---
title: "Azure Data Lake Store Storm 성능 조정 지침 | Microsoft Docs"
description: "Azure Data Lake Store Storm 성능 조정 지침"
services: data-lake-store
documentationcenter: 
author: stewu
manager: amitkul
editor: stewu
ms.assetid: ebde7b9f-2e51-4d43-b7ab-566417221335
ms.service: data-lake-store
ms.devlang: na
ms.topic: article
ms.tgt_pltfrm: na
ms.workload: big-data
ms.date: 12/19/2016
ms.author: stewu
ms.openlocfilehash: 1dfa93643f45a96ded3fd022aa8b1c71d487acb4
ms.sourcegitcommit: f537befafb079256fba0529ee554c034d73f36b0
ms.translationtype: MT
ms.contentlocale: ko-KR
ms.lasthandoff: 07/11/2017
---
# <a name="performance-tuning-guidance-for-storm-on-hdinsight-and-azure-data-lake-store"></a><span data-ttu-id="28d86-103">HDInsight의 Storm 및 Azure Data Lake Store에 대한 성능 조정 지침</span><span class="sxs-lookup"><span data-stu-id="28d86-103">Performance tuning guidance for Storm on HDInsight and Azure Data Lake Store</span></span>

<span data-ttu-id="28d86-104">Azure Storm 토폴로지의 성능을 조정할 때 고려해야 하는 요소를 이해합니다.</span><span class="sxs-lookup"><span data-stu-id="28d86-104">Understand the factors that should be considered when you tune the performance of an Azure Storm topology.</span></span> <span data-ttu-id="28d86-105">예를 들어, Spout 및 Bolt(작업이 I/O 또는 메모리 집약적인지에 따름)에서 수행한 작업의 특징을 이해하는 것이 중요합니다.</span><span class="sxs-lookup"><span data-stu-id="28d86-105">For example, it's important to understand the characteristics of the work done by the spouts and the bolts (whether the work is I/O or memory intensive).</span></span> <span data-ttu-id="28d86-106">이 문서에서는 다양한 성능 조정 지침, 일반적인 문제 해결 등을 다룹니다.</span><span class="sxs-lookup"><span data-stu-id="28d86-106">This article covers a range of performance tuning guidelines, including troubleshooting common issues.</span></span>

## <a name="prerequisites"></a><span data-ttu-id="28d86-107">필수 조건</span><span class="sxs-lookup"><span data-stu-id="28d86-107">Prerequisites</span></span>

* <span data-ttu-id="28d86-108">**Azure 구독**.</span><span class="sxs-lookup"><span data-stu-id="28d86-108">**An Azure subscription**.</span></span> <span data-ttu-id="28d86-109">[Azure 무료 평가판](https://azure.microsoft.com/pricing/free-trial/)을 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="28d86-109">See [Get Azure free trial](https://azure.microsoft.com/pricing/free-trial/).</span></span>
* <span data-ttu-id="28d86-110">**Azure 데이터 레이크 저장소 계정**.</span><span class="sxs-lookup"><span data-stu-id="28d86-110">**An Azure Data Lake Store account**.</span></span> <span data-ttu-id="28d86-111">만드는 방법에 대한 지침은 [Azure Data Lake Store 시작](data-lake-store-get-started-portal.md)을 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="28d86-111">For instructions on how to create one, see [Get started with Azure Data Lake Store](data-lake-store-get-started-portal.md).</span></span>
* <span data-ttu-id="28d86-112">Data Lake Store 계정에 액세스하는 **Azure HDInsight 클러스터**입니다.</span><span class="sxs-lookup"><span data-stu-id="28d86-112">**An Azure HDInsight cluster** with access to a Data Lake Store account.</span></span> <span data-ttu-id="28d86-113">[Data Lake Store가 있는 HDInsight 클러스터 만들기](data-lake-store-hdinsight-hadoop-use-portal.md)를 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="28d86-113">See [Create an HDInsight cluster with Data Lake Store](data-lake-store-hdinsight-hadoop-use-portal.md).</span></span> <span data-ttu-id="28d86-114">클러스터에 대한 원격 데스크톱을 사용하도록 설정해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="28d86-114">Make sure you enable Remote Desktop for the cluster.</span></span>
* <span data-ttu-id="28d86-115">**Data Lake Store에서 실행 중인 Storm 클러스터**</span><span class="sxs-lookup"><span data-stu-id="28d86-115">**Running a Storm cluster on Data Lake Store**.</span></span> <span data-ttu-id="28d86-116">자세한 내용은 [HDInsight의 Storm](https://docs.microsoft.com/en-us/azure/hdinsight/hdinsight-storm-overview)을 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="28d86-116">For more information, see [Storm on HDInsight](https://docs.microsoft.com/en-us/azure/hdinsight/hdinsight-storm-overview).</span></span>
* <span data-ttu-id="28d86-117">**Data Lake Store 성능 조정 지침**</span><span class="sxs-lookup"><span data-stu-id="28d86-117">**Performance tuning guidelines on Data Lake Store**.</span></span>  <span data-ttu-id="28d86-118">일반적인 성능 개념은 [Data Lake Store 성능 조정 지침](https://docs.microsoft.com/en-us/azure/data-lake-store/data-lake-store-performance-tuning-guidance)을 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="28d86-118">For general performance concepts, see [Data Lake Store Performance Tuning Guidance](https://docs.microsoft.com/en-us/azure/data-lake-store/data-lake-store-performance-tuning-guidance).</span></span>  

## <a name="tune-the-parallelism-of-the-topology"></a><span data-ttu-id="28d86-119">토폴로지의 병렬 처리 조정</span><span class="sxs-lookup"><span data-stu-id="28d86-119">Tune the parallelism of the topology</span></span>

<span data-ttu-id="28d86-120">Data Lake Store와의 I/O 동시성을 늘리면 성능을 개설할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="28d86-120">You might be able to improve performance by increasing the concurrency of the I/O to and from Data Lake Store.</span></span> <span data-ttu-id="28d86-121">Storm 토폴로지에는 병렬 처리를 결정하는 일련의 구성이 포함되어 있습니다.</span><span class="sxs-lookup"><span data-stu-id="28d86-121">A Storm topology has a set of configurations that determine the parallelism:</span></span>
* <span data-ttu-id="28d86-122">작업자 프로세스 수(작업자는 VM 간에 균일하게 분산됨).</span><span class="sxs-lookup"><span data-stu-id="28d86-122">Number of worker processes (the workers are evenly distributed across the VMs).</span></span>
* <span data-ttu-id="28d86-123">Spout 실행기 인스턴스 수</span><span class="sxs-lookup"><span data-stu-id="28d86-123">Number of spout executor instances.</span></span>
* <span data-ttu-id="28d86-124">Bolt 실행기 인스턴스 수</span><span class="sxs-lookup"><span data-stu-id="28d86-124">Number of bolt executor instances.</span></span>
* <span data-ttu-id="28d86-125">Spout 태스크 수</span><span class="sxs-lookup"><span data-stu-id="28d86-125">Number of spout tasks.</span></span>
* <span data-ttu-id="28d86-126">Bolt 태스크 수</span><span class="sxs-lookup"><span data-stu-id="28d86-126">Number of bolt tasks.</span></span>

<span data-ttu-id="28d86-127">예를 들어, VM 4개와 작업자 프로세스 4개, Spout 실행기 32개, Spout 태스크 32개, Bolt 실행기 256개, Bolt 태스크 512개가 있는 클러스터에는 다음 항목을 고려합니다.</span><span class="sxs-lookup"><span data-stu-id="28d86-127">For example, on a cluster with 4 VMs and 4 worker processes, 32 spout executors and 32 spout tasks, and 256 bolt executors and 512 bolt tasks, consider the following:</span></span>

<span data-ttu-id="28d86-128">작업자 노드인 각 감독자에는 단일 작업자 JVM(Java 가상 컴퓨터) 프로세스가 있습니다.</span><span class="sxs-lookup"><span data-stu-id="28d86-128">Each supervisor, which is a worker node, has a single worker Java virtual machine (JVM) process.</span></span> <span data-ttu-id="28d86-129">이 JVM 프로세스는 4개의 Spout 스레드 및 64개의 Bolt 스레드를 관리합니다.</span><span class="sxs-lookup"><span data-stu-id="28d86-129">This JVM process manages 4 spout threads and 64 bolt threads.</span></span> <span data-ttu-id="28d86-130">각 스레드 내에서 태스크를 순차적으로 실행합니다.</span><span class="sxs-lookup"><span data-stu-id="28d86-130">Within each thread, tasks are run sequentially.</span></span> <span data-ttu-id="28d86-131">이전 구성을 사용하는 각 Spout 스레드에는 1개의 태스크가 있고 각 Bolt 스레드에는 2개의 태스크가 있습니다.</span><span class="sxs-lookup"><span data-stu-id="28d86-131">With the preceding configuration, each spout thread has 1 task, and each bolt thread has 2 tasks.</span></span>

<span data-ttu-id="28d86-132">Storm에는 다양한 구성 요소가 관련되어 있으며 여기서는 이 구성 요소가 사용자의 병렬 처리 수준에 어떻게 영향을 주는지 살펴봅니다.</span><span class="sxs-lookup"><span data-stu-id="28d86-132">In Storm, here are the various components involved, and how they affect the level of parallelism you have:</span></span>
* <span data-ttu-id="28d86-133">작업을 제출 및 관리하는 데 헤드 노드(Storm에서 Nimbus라고 함)가 사용됩니다.</span><span class="sxs-lookup"><span data-stu-id="28d86-133">The head node (called Nimbus in Storm) is used to submit and manage jobs.</span></span> <span data-ttu-id="28d86-134">이러한 노드는 병렬 처리 수준에 영향을 주지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="28d86-134">These nodes have no impact on the degree of parallelism.</span></span>
* <span data-ttu-id="28d86-135">감독자 노드</span><span class="sxs-lookup"><span data-stu-id="28d86-135">The supervisor nodes.</span></span> <span data-ttu-id="28d86-136">HDInsight에서는 작업자 노드 Azure VM에 해당합니다.</span><span class="sxs-lookup"><span data-stu-id="28d86-136">In HDInsight, this corresponds to a worker node Azure VM.</span></span>
* <span data-ttu-id="28d86-137">작업자 태스크는 VM에서 실행 중인 Storm 프로세스입니다.</span><span class="sxs-lookup"><span data-stu-id="28d86-137">The worker tasks are Storm processes running in the VMs.</span></span> <span data-ttu-id="28d86-138">각 작업자 태스크는 JVM 인스턴스에 해당합니다.</span><span class="sxs-lookup"><span data-stu-id="28d86-138">Each worker task corresponds to a JVM instance.</span></span> <span data-ttu-id="28d86-139">Storm은 사용자가 지정한 작업자 프로세스 수를 작업자 노드에 최대한 균등하게 배포합니다.</span><span class="sxs-lookup"><span data-stu-id="28d86-139">Storm distributes the number of worker processes you specify to the worker nodes as evenly as possible.</span></span>
* <span data-ttu-id="28d86-140">Spout 및 Bolt 실행기 인스턴스</span><span class="sxs-lookup"><span data-stu-id="28d86-140">Spout and bolt executor instances.</span></span> <span data-ttu-id="28d86-141">각 실행기 인스턴스는 작업자(JVM) 내에서 실행 중인 스레드에 해당합니다.</span><span class="sxs-lookup"><span data-stu-id="28d86-141">Each executor instance corresponds to a thread running within the workers (JVMs).</span></span>
* <span data-ttu-id="28d86-142">Storm 태스크</span><span class="sxs-lookup"><span data-stu-id="28d86-142">Storm tasks.</span></span> <span data-ttu-id="28d86-143">이러한 각 스레드가 실행되는 논리적 태스크입니다.</span><span class="sxs-lookup"><span data-stu-id="28d86-143">These are logical tasks that each of these threads run.</span></span> <span data-ttu-id="28d86-144">병렬 처리 수준은 변경되지 않으므로 실행기당 여러 태스크가 필요한지 평가해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="28d86-144">This does not change the level of parallelism, so you should evaluate if you need multiple tasks per executor or not.</span></span>

### <a name="get-the-best-performance-from-data-lake-store"></a><span data-ttu-id="28d86-145">Data Lake Store에서 최상의 성능 얻기</span><span class="sxs-lookup"><span data-stu-id="28d86-145">Get the best performance from Data Lake Store</span></span>

<span data-ttu-id="28d86-146">Data Lake Store를 사용할 때 다음을 수행하는 경우 최상의 성능을 얻을 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="28d86-146">When working with Data Lake Store, you get the best performance if you do the following:</span></span>
* <span data-ttu-id="28d86-147">작은 크기의 추가 항목을 보다 큰 크기로 병합합니다(이상적으로 4MB).</span><span class="sxs-lookup"><span data-stu-id="28d86-147">Coalesce your small appends into larger sizes (ideally 4 MB).</span></span>
* <span data-ttu-id="28d86-148">가능한 동시 요청을 많이 수행.</span><span class="sxs-lookup"><span data-stu-id="28d86-148">Do as many concurrent requests as you can.</span></span> <span data-ttu-id="28d86-149">각 Bolt 스레드는 읽기 차단 작업을 수행하므로 코어당 8-12개 스레드 범위 내에서 수행하려고 합니다.</span><span class="sxs-lookup"><span data-stu-id="28d86-149">Because each bolt thread is doing blocking reads, you want to have somewhere in the range of 8-12 threads per core.</span></span> <span data-ttu-id="28d86-150">그러면 NIC 및 CPU를 잘 활용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="28d86-150">This keeps the NIC and the CPU well utilized.</span></span> <span data-ttu-id="28d86-151">VM 크기가 크면 더 많은 동시 요청이 가능합니다.</span><span class="sxs-lookup"><span data-stu-id="28d86-151">A larger VM enables more concurrent requests.</span></span>  

### <a name="example-topology"></a><span data-ttu-id="28d86-152">예제 토폴로지</span><span class="sxs-lookup"><span data-stu-id="28d86-152">Example topology</span></span>

<span data-ttu-id="28d86-153">D13v2 Azure VM과 함께 8개의 작업자 노드 클러스터가 있다고 가정해 보겠습니다.</span><span class="sxs-lookup"><span data-stu-id="28d86-153">Let’s assume you have an 8 worker node cluster with a D13v2 Azure VM.</span></span> <span data-ttu-id="28d86-154">이 VM에는 8개의 코어가 있으므로 8개의 작업자 노드에는 총 64개의 코어가 있습니다.</span><span class="sxs-lookup"><span data-stu-id="28d86-154">This VM has 8 cores, so among the 8 worker nodes, you have 64 total cores.</span></span>

<span data-ttu-id="28d86-155">코어당 8개의 Bolt 스레드를 수행한다고 가정해 보겠습니다.</span><span class="sxs-lookup"><span data-stu-id="28d86-155">Let’s say we do 8 bolt threads per core.</span></span> <span data-ttu-id="28d86-156">64개의 코어가 제공되므로 총 512개의 Bolt 실행기 인스턴스(즉, 스레드)가 필요합니다.</span><span class="sxs-lookup"><span data-stu-id="28d86-156">Given 64 cores, that means we want 512 total bolt executor instances (that is, threads).</span></span> <span data-ttu-id="28d86-157">이 경우 VM당 JVM 1개로 시작하고 JVM 내에서 스레드 동시성을 주로 사용하여 동시성을 달성한다고 가정해 보겠습니다.</span><span class="sxs-lookup"><span data-stu-id="28d86-157">In this case, let’s say we start with one JVM per VM, and mainly use the thread concurrency within the JVM to achieve concurrency.</span></span> <span data-ttu-id="28d86-158">즉, 8개의 작업자 태스크(Azure VM당 하나)와 512개의 Bolt 실행기가 필요합니다.</span><span class="sxs-lookup"><span data-stu-id="28d86-158">That means we need 8 worker tasks (one per Azure VM), and 512 bolt executors.</span></span> <span data-ttu-id="28d86-159">이 구성이 정해지면 Storm이 작업자를 작업자 노드(감독자 노드라고도 함) 간에 균등하게 배포하려고 시도하고 각 작업자 노드에 1개의 JVM을 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="28d86-159">Given this configuration, Storm tries to distribute the workers evenly across worker nodes (also known as supervisor nodes), giving each worker node 1 JVM.</span></span> <span data-ttu-id="28d86-160">이제 감독자 내에서 Storm은 실행기를 감독자 간에 균등하게 배포하려고 시도하여 각 감독자(즉, JVM)에 8개의 스레드를 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="28d86-160">Now within the supervisors, Storm tries to distribute the executors evenly between supervisors, giving each supervisor (that is, JVM) 8 threads each.</span></span>

## <a name="tune-additional-parameters"></a><span data-ttu-id="28d86-161">추가 매개 변수 조정</span><span class="sxs-lookup"><span data-stu-id="28d86-161">Tune additional parameters</span></span>
<span data-ttu-id="28d86-162">기본 토폴로지를 만든 후에는 매개 변수를 수정할 것인지 고려할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="28d86-162">After you have the basic topology, you can consider whether you want to tweak any of the parameters:</span></span>
* <span data-ttu-id="28d86-163">**작업자 노드당 JVM 수**</span><span class="sxs-lookup"><span data-stu-id="28d86-163">**Number of JVMs per worker node.**</span></span> <span data-ttu-id="28d86-164">메모리 내에 호스트하는 큰 데이터 구조(예: 조회 테이블)가 있는 경우 각 JVM에는 별도 복사본이 필요합니다.</span><span class="sxs-lookup"><span data-stu-id="28d86-164">If you have a large data structure (for example, a lookup table) that you host in memory, each JVM requires a separate copy.</span></span> <span data-ttu-id="28d86-165">또는 JVM을 적게 설정한 경우 여러 스레드에 걸쳐 데이터 구조를 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="28d86-165">Alternatively, you can use the data structure across many threads if you have fewer JVMs.</span></span> <span data-ttu-id="28d86-166">Bolt I/O의 경우, JVM 수는 해당 JVM 간에 추가된 스레드 수와 큰 차이가 없습니다.</span><span class="sxs-lookup"><span data-stu-id="28d86-166">For the bolt’s I/O, the number of JVMs does not make as much of a difference as the number of threads added across those JVMs.</span></span> <span data-ttu-id="28d86-167">간소화하기 위해 작업자당 하나의 JVM이 있는 것이 좋습니다.</span><span class="sxs-lookup"><span data-stu-id="28d86-167">For simplicity, it's a good idea to have one JVM per worker.</span></span> <span data-ttu-id="28d86-168">하지만 Bolt에서 수행한 작업이나 필요한 응용 프로그램 프로세스에 따라 이 번호를 변경해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="28d86-168">Depending on what your bolt is doing or what application processing you require, though, you may need to change this number.</span></span>
* <span data-ttu-id="28d86-169">**Spout 실행자 수**</span><span class="sxs-lookup"><span data-stu-id="28d86-169">**Number of spout executors.**</span></span> <span data-ttu-id="28d86-170">이전 예제에서 Data Lake Store에 대한 쓰기에 Bolt를 사용하기 때문에 Spout 수는 Bolt 성능과 직접 관련이 없습니다.</span><span class="sxs-lookup"><span data-stu-id="28d86-170">Because the preceding example uses bolts for writing to Data Lake Store, the number of spouts is not directly relevant to the bolt performance.</span></span> <span data-ttu-id="28d86-171">하지만 Spout에서 발생하는 처리 또는 I/O 양에 따라 최적의 성능을 얻기 위해 Spout을 조정하는 것이 좋습니다.</span><span class="sxs-lookup"><span data-stu-id="28d86-171">However, depending on the amount of processing or I/O happening in the spout, it's a good idea to tune the spouts for best performance.</span></span> <span data-ttu-id="28d86-172">Bolt를 사용할 수 있는 충분한 Spout이 있는지 확인합니다.</span><span class="sxs-lookup"><span data-stu-id="28d86-172">Ensure that you have enough spouts to be able to keep the bolts busy.</span></span> <span data-ttu-id="28d86-173">Spout의 출력 속도는 Bolt의 처리량과 일치해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="28d86-173">The output rates of the spouts should match the throughput of the bolts.</span></span> <span data-ttu-id="28d86-174">실제 구성은 Spout에 따라 달라집니다.</span><span class="sxs-lookup"><span data-stu-id="28d86-174">The actual configuration depends on the spout.</span></span>
* <span data-ttu-id="28d86-175">**태스크 수**</span><span class="sxs-lookup"><span data-stu-id="28d86-175">**Number of tasks.**</span></span> <span data-ttu-id="28d86-176">각 Bolt는 단일 스레드로 실행됩니다.</span><span class="sxs-lookup"><span data-stu-id="28d86-176">Each bolt runs as a single thread.</span></span> <span data-ttu-id="28d86-177">Bolt당 추가 태스크는 어떠한 동시성도 제공하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="28d86-177">Additional tasks per bolt don't provide any additional concurrency.</span></span> <span data-ttu-id="28d86-178">이익이 되는 경우는 튜플을 승인하는 프로세스가 Bolt 실행 시간의 상당 부분을 차지하는 경우 뿐입니다.</span><span class="sxs-lookup"><span data-stu-id="28d86-178">The only time they are of benefit is if your process of acknowledging the tuple takes a large proportion of your bolt execution time.</span></span> <span data-ttu-id="28d86-179">Bolt에서 승인을 보내기 전에 많은 튜플을 추가에 그룹화하는 것이 좋습니다.</span><span class="sxs-lookup"><span data-stu-id="28d86-179">It's a good idea to group many tuples into a larger append before you send an acknowledgement from the bolt.</span></span> <span data-ttu-id="28d86-180">즉, 대부분의 경우에 여러 태스크에는 추가적인 이점이 없습니다.</span><span class="sxs-lookup"><span data-stu-id="28d86-180">So, in most cases, multiple tasks provide no additional benefit.</span></span>
* <span data-ttu-id="28d86-181">**로컬 또는 순서 섞기 그룹화**</span><span class="sxs-lookup"><span data-stu-id="28d86-181">**Local or shuffle grouping.**</span></span> <span data-ttu-id="28d86-182">이 설정을 사용하면 동일한 작업자 프로세스 내에서 튜플이 Bolt로 전송됩니다.</span><span class="sxs-lookup"><span data-stu-id="28d86-182">When this setting is enabled, tuples are sent to bolts within the same worker process.</span></span> <span data-ttu-id="28d86-183">그러면 프로세스 간 통신과 네트워크 호출이 줄어듭니다.</span><span class="sxs-lookup"><span data-stu-id="28d86-183">This reduces inter-process communication and network calls.</span></span> <span data-ttu-id="28d86-184">대부분의 토폴로지에 사용하는 것이 좋습니다.</span><span class="sxs-lookup"><span data-stu-id="28d86-184">This is recommended for most topologies.</span></span>

<span data-ttu-id="28d86-185">이 기본 시나리오는 시작 지점으로 사용하는 것이 좋습니다.</span><span class="sxs-lookup"><span data-stu-id="28d86-185">This basic scenario is a good starting point.</span></span> <span data-ttu-id="28d86-186">최적의 성능을 얻기 위해 이전 매개 변수를 조정하여 소유한 데이터를 테스트합니다.</span><span class="sxs-lookup"><span data-stu-id="28d86-186">Test with your own data to tweak the preceding parameters to achieve optimal performance.</span></span>

## <a name="tune-the-spout"></a><span data-ttu-id="28d86-187">Spout 조정</span><span class="sxs-lookup"><span data-stu-id="28d86-187">Tune the spout</span></span>

<span data-ttu-id="28d86-188">Spout를 조정하도록 다음 설정을 수정할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="28d86-188">You can modify the following settings to tune the spout.</span></span>

- <span data-ttu-id="28d86-189">**튜플 시간 초과: topology.message.timeout.secs**</span><span class="sxs-lookup"><span data-stu-id="28d86-189">**Tuple timeout: topology.message.timeout.secs**.</span></span> <span data-ttu-id="28d86-190">이 설정은 실패로 간주되기 전에 메시지가 승인을 완료 및 수신하는 데 걸리는 시간을 결정합니다.</span><span class="sxs-lookup"><span data-stu-id="28d86-190">This setting determines the amount of time a message takes to complete, and receive acknowledgement, before it is considered failed.</span></span>

- <span data-ttu-id="28d86-191">**작업자 프로세스당 최대 메모리: worker.childopts**</span><span class="sxs-lookup"><span data-stu-id="28d86-191">**Max memory per worker process: worker.childopts**.</span></span> <span data-ttu-id="28d86-192">이 설정을 통해 Java 작업자에 대해 추가 명령줄 매개 변수를 지정할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="28d86-192">This setting lets you specify additional command-line parameters to the Java workers.</span></span> <span data-ttu-id="28d86-193">여기서 가장 일반적으로 사용된 설정은 XmX이며 JVM 힙에 할당된 최대 메모리를 결정합니다.</span><span class="sxs-lookup"><span data-stu-id="28d86-193">The most commonly used setting here is XmX, which determines the maximum memory allocated to a JVM’s heap.</span></span>

- <span data-ttu-id="28d86-194">**보류 중인 최대 Spout: topology.max.spout.pending**</span><span class="sxs-lookup"><span data-stu-id="28d86-194">**Max spout pending: topology.max.spout.pending**.</span></span> <span data-ttu-id="28d86-195">이 설정은 언제든지 Spout 스레드당 처리할 수 있는(토폴로지의 모든 노드에서 아직 승인되지 않은) 튜플 수를 결정합니다.</span><span class="sxs-lookup"><span data-stu-id="28d86-195">This setting determines the number of tuples that can in be flight (not yet acknowledged at all nodes in the topology) per spout thread at any time.</span></span>

 <span data-ttu-id="28d86-196">수행할 수 있는 적절한 계산은 각 튜플의 크기를 예상하는 것입니다.</span><span class="sxs-lookup"><span data-stu-id="28d86-196">A good calculation to do is to estimate the size of each of your tuples.</span></span> <span data-ttu-id="28d86-197">그런 다음 한 개의 Spout 스레드에 지정된 메모리 양을 파악합니다.</span><span class="sxs-lookup"><span data-stu-id="28d86-197">Then figure out how much memory one spout thread has.</span></span> <span data-ttu-id="28d86-198">스레드에 할당된 총 메모리를 이 값으로 나누어 보류 중인 최대 Spout 매개 변수에 대한 상한을 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="28d86-198">The total memory allocated to a thread, divided by this value, should give you the upper bound for the max spout pending parameter.</span></span>

## <a name="tune-the-bolt"></a><span data-ttu-id="28d86-199">Bolt 조정</span><span class="sxs-lookup"><span data-stu-id="28d86-199">Tune the bolt</span></span>
<span data-ttu-id="28d86-200">Data Lake Store에 기록할 경우 크기 동기화 정책(클라이언트 쪽에서 버퍼)을 4MB로 설정합니다.</span><span class="sxs-lookup"><span data-stu-id="28d86-200">When you're writing to Data Lake Store, set a size sync policy (buffer on the client side) to 4 MB.</span></span> <span data-ttu-id="28d86-201">그러면 버퍼 크기가 이 값일 때만 플러시 또는 hsync()가 수행됩니다.</span><span class="sxs-lookup"><span data-stu-id="28d86-201">A flushing or hsync() is then performed only when the buffer size is the at this value.</span></span> <span data-ttu-id="28d86-202">사용자가 hsync()를 명시적 수행하지 않으면 작업자 VM의 Data Lake Store 드라이버는 이 버퍼링을 자동으로 수행합니다.</span><span class="sxs-lookup"><span data-stu-id="28d86-202">The Data Lake Store driver on the worker VM automatically does this buffering, unless you explicitly perform an hsync().</span></span>

<span data-ttu-id="28d86-203">기본 Data Lake Store Storm Bolt에는 이 매개 변수를 조정하는 데 사용할 수 있는 크기 동기화 정책 매개 변수(fileBufferSize)가 포함됩니다.</span><span class="sxs-lookup"><span data-stu-id="28d86-203">The default Data Lake Store Storm bolt has a size sync policy parameter (fileBufferSize) that can be used to tune this parameter.</span></span>

<span data-ttu-id="28d86-204">I/O 집약적인 토폴로지에서 각 Bolt 스레드는 자체 파일에 기록하고 파일 회전 정책(fileRotationSize)을 설정하는 것이 좋습니다.</span><span class="sxs-lookup"><span data-stu-id="28d86-204">In I/O-intensive topologies, it's a good idea to have each bolt thread write to its own file, and to set a file rotation policy (fileRotationSize).</span></span> <span data-ttu-id="28d86-205">파일이 특정 크기에 도달하면 스트림이 자동으로 플러시되며 새 파일이 기록됩니다.</span><span class="sxs-lookup"><span data-stu-id="28d86-205">When the file reaches a certain size, the stream is automatically flushed and a new file is written to.</span></span> <span data-ttu-id="28d86-206">회전에 권장되는 파일 크기는 1GB입니다.</span><span class="sxs-lookup"><span data-stu-id="28d86-206">The recommended file size for rotation is 1 GB.</span></span>

### <a name="handle-tuple-data"></a><span data-ttu-id="28d86-207">튜플 데이터 처리</span><span class="sxs-lookup"><span data-stu-id="28d86-207">Handle tuple data</span></span>

<span data-ttu-id="28d86-208">Storm에서 Spout는 튜플이 Bolt에 의해 명시적으로 승인될 때까지 튜플을 계속 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="28d86-208">In Storm, a spout holds on to a tuple until it is explicitly acknowledged by the bolt.</span></span> <span data-ttu-id="28d86-209">튜플을 Bolt에서 읽었지만 아직 승인되지 않은 경우 Spout는 Data Lake Store 백 엔드에 유지되지 않을 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="28d86-209">If a tuple has been read by the bolt but has not been acknowledged yet, the spout might not have persisted into Data Lake Store back end.</span></span> <span data-ttu-id="28d86-210">튜플이 승인된 후에 Spout에서 Bolt의 지속성을 보장할 수 있고 읽어 오는 원본이 무엇이든지 원본 데이터를 삭제할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="28d86-210">After a tuple is acknowledged, the spout can be guaranteed persistence by the bolt, and can then delete the source data from whatever source it is reading from.</span></span>  

<span data-ttu-id="28d86-211">최상의 Data Lake Store 성능을 위해 Bolt가 4MB의 튜플 데이터를 버퍼링합니다.</span><span class="sxs-lookup"><span data-stu-id="28d86-211">For best performance on Data Lake Store, have the bolt buffer 4 MB of tuple data.</span></span> <span data-ttu-id="28d86-212">그런 다음 Data Lake Store 백 엔드에 하나의 4MB 쓰기로 작성합니다.</span><span class="sxs-lookup"><span data-stu-id="28d86-212">Then write to the Data Lake Store back end as one 4-MB write.</span></span> <span data-ttu-id="28d86-213">hflush()를 호출하여 저장소에 데이터를 성공적으로 기록한 후에 Bolt가 데이터를 Spout으로 다시 승인할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="28d86-213">After the data has been successfully written to the store (by calling hflush()), the bolt can acknowledge the data back to the spout.</span></span> <span data-ttu-id="28d86-214">여기에 제공된 Bolt 예제에서 이 작업을 수행합니다.</span><span class="sxs-lookup"><span data-stu-id="28d86-214">This is what the example bolt supplied here does.</span></span> <span data-ttu-id="28d86-215">또한 hflush() 호출을 수행하고 튜플을 승인하기 전에 많은 수의 튜플을 보유하는 것도 가능합니다.</span><span class="sxs-lookup"><span data-stu-id="28d86-215">It is also acceptable to hold a larger number of tuples before the hflush() call is made and the tuples acknowledged.</span></span> <span data-ttu-id="28d86-216">하지만 이 경우 Spout이 보유해야 하는 진행 중인 튜플 수가 증가하므로 JVM당 필요한 메모리 양이 늘어납니다.</span><span class="sxs-lookup"><span data-stu-id="28d86-216">However, this increases the number of tuples in flight that the spout needs to hold, and therefore increases the amount of memory required per JVM.</span></span>

> [!NOTE]
<span data-ttu-id="28d86-217">응용 프로그램에는 기타 성능 이외의 이유로 더욱 자주(4MB 미만의 데이터 크기로) 튜플을 승인하도록 요청해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="28d86-217">Applications might have a requirement to acknowledge tuples more frequently (at data sizes less than 4 MB) for other non-performance reasons.</span></span> <span data-ttu-id="28d86-218">그러나 저장소 백 엔드에 대한 I/O 처리량에 영향을 줄 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="28d86-218">However, that might affect the I/O throughput to the storage back end.</span></span> <span data-ttu-id="28d86-219">Bolt의 I/O 성능에 대해 이러한 균형 유지를 신중하게 평가합니다.</span><span class="sxs-lookup"><span data-stu-id="28d86-219">Carefully weigh this tradeoff against the bolt’s I/O performance.</span></span>

<span data-ttu-id="28d86-220">들어오는 튜플 비율이 높지 않으므로 4MB 버퍼를 채우는 데 시간이 오래 걸리고 다음과 같은 방법으로 이를 완화하는 것을 고려합니다.</span><span class="sxs-lookup"><span data-stu-id="28d86-220">If the incoming rate of tuples is not high, so the 4-MB buffer takes a long time to fill, consider mitigating this by:</span></span>
* <span data-ttu-id="28d86-221">Bolt 수를 줄이면 채울 버퍼 수가 줄어듭니다.</span><span class="sxs-lookup"><span data-stu-id="28d86-221">Reducing the number of bolts, so there are fewer buffers to fill.</span></span>
* <span data-ttu-id="28d86-222">시간 기반 또는 개수 기반 정책을 사용할 경우 x 플러시 또는 y 밀리초마다 hflush()가 트리거되고 지금까지 누적된 튜플이 다시 승인됩니다.</span><span class="sxs-lookup"><span data-stu-id="28d86-222">Having a time-based or count-based policy, where an hflush() is triggered every x flushes or every y milliseconds, and the tuples accumulated so far are acknowledged back.</span></span>

<span data-ttu-id="28d86-223">이 경우 처리량은 낮지만 이벤트 속도가 느리고 최대 처리량이 최대 목표는 아닙니다.</span><span class="sxs-lookup"><span data-stu-id="28d86-223">Note that the throughput in this case is lower, but with a slow rate of events, maximum throughput is not the biggest objective anyway.</span></span> <span data-ttu-id="28d86-224">이러한 완화를 통해 튜플을 저장소에 흘려 보내는 데 걸리는 총 시간을 줄일 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="28d86-224">These mitigations help you reduce the total time that it takes for a tuple to flow through to the store.</span></span> <span data-ttu-id="28d86-225">이벤트 비율이 낮은 실시간 파이프라인을 사용하려는 경우 문제가 될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="28d86-225">This might matter if you want a real-time pipeline even with a low event rate.</span></span> <span data-ttu-id="28d86-226">또한 들어오는 튜플 비율이 낮은 경우 버퍼링 또는 처리 중에 튜플이 시간 초과되지 않도록 topology.message.timeout_secs 매개 변수를 조정해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="28d86-226">Also note that if your incoming tuple rate is low, you should adjust the topology.message.timeout_secs parameter, so the tuples don’t time out while they are getting buffered or processed.</span></span>

## <a name="monitor-your-topology-in-storm"></a><span data-ttu-id="28d86-227">Storm에서 토폴로지 모니터링</span><span class="sxs-lookup"><span data-stu-id="28d86-227">Monitor your topology in Storm</span></span>  
<span data-ttu-id="28d86-228">토폴로지를 실행하는 동안 Storm 사용자 인터페이스에서 모니터링할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="28d86-228">While your topology is running, you can monitor it in the Storm user interface.</span></span> <span data-ttu-id="28d86-229">확인할 주요 매개 변수는 다음과 같습니다.</span><span class="sxs-lookup"><span data-stu-id="28d86-229">Here are the main parameters to look at:</span></span>

* <span data-ttu-id="28d86-230">**총 프로세스 실행 대기 시간**</span><span class="sxs-lookup"><span data-stu-id="28d86-230">**Total process execution latency.**</span></span> <span data-ttu-id="28d86-231">1개의 튜플이 Spout에 의해 보내지는 데 소요되어 Bolt에 의해 처리되고 승인되는 평균 시간입니다.</span><span class="sxs-lookup"><span data-stu-id="28d86-231">This is the average time one tuple takes to be emitted by the spout, processed by the bolt, and acknowledged.</span></span>

* <span data-ttu-id="28d86-232">**총 Bolt 프로세스 대기 시간**</span><span class="sxs-lookup"><span data-stu-id="28d86-232">**Total bolt process latency.**</span></span> <span data-ttu-id="28d86-233">승인을 받기까지 Bolt에서 튜플에 소요된 평균 시간입니다.</span><span class="sxs-lookup"><span data-stu-id="28d86-233">This is the average time spent by the tuple at the bolt until it receives an acknowledgement.</span></span>

* <span data-ttu-id="28d86-234">**총 Bolt 실행 대기 시간**</span><span class="sxs-lookup"><span data-stu-id="28d86-234">**Total bolt execute latency.**</span></span> <span data-ttu-id="28d86-235">실행 메서드에서 Bolt에 소요된 평균 시간입니다.</span><span class="sxs-lookup"><span data-stu-id="28d86-235">This is the average time spent by the bolt in the execute method.</span></span>

* <span data-ttu-id="28d86-236">**오류 수**</span><span class="sxs-lookup"><span data-stu-id="28d86-236">**Number of failures.**</span></span> <span data-ttu-id="28d86-237">시간이 초과되기 전에 완전히 처리되지 않은 튜플 수를 나타냅니다.</span><span class="sxs-lookup"><span data-stu-id="28d86-237">This refers to the number of tuples that failed to be fully processed before they timed out.</span></span>

* <span data-ttu-id="28d86-238">**용량**</span><span class="sxs-lookup"><span data-stu-id="28d86-238">**Capacity.**</span></span> <span data-ttu-id="28d86-239">시스템이 얼마나 사용 중인지를 측정한 값입니다.</span><span class="sxs-lookup"><span data-stu-id="28d86-239">This is a measure of how busy your system is.</span></span> <span data-ttu-id="28d86-240">1이면 Bolt가 가장 빠르게 작동 중입니다.</span><span class="sxs-lookup"><span data-stu-id="28d86-240">If this number is 1, your bolts are working as fast as they can.</span></span> <span data-ttu-id="28d86-241">1 미만이면 병렬 처리를 늘립니다.</span><span class="sxs-lookup"><span data-stu-id="28d86-241">If it is less than 1, increase the parallelism.</span></span> <span data-ttu-id="28d86-242">1보다 크면 병렬 처리를 줄입니다.</span><span class="sxs-lookup"><span data-stu-id="28d86-242">If it is greater than 1, reduce the parallelism.</span></span>

## <a name="troubleshoot-common-problems"></a><span data-ttu-id="28d86-243">일반적인 문제 해결</span><span class="sxs-lookup"><span data-stu-id="28d86-243">Troubleshoot common problems</span></span>
<span data-ttu-id="28d86-244">일반적인 문제 해결 시나리오는 다음과 같습니다.</span><span class="sxs-lookup"><span data-stu-id="28d86-244">Here are a few common troubleshooting scenarios.</span></span>
* <span data-ttu-id="28d86-245">**많은 튜플의 시간이 초과되었습니다.**</span><span class="sxs-lookup"><span data-stu-id="28d86-245">**Many tuples are timing out.**</span></span> <span data-ttu-id="28d86-246">토폴로지에서 각 노드를 확인하여 병목 현상이 발생한 위치를 확인합니다.</span><span class="sxs-lookup"><span data-stu-id="28d86-246">Look at each node in the topology to determine where the bottleneck is.</span></span> <span data-ttu-id="28d86-247">가장 일반적인 원인은 Bolt가 Spout을 따라갈 수 없기 때문입니다.</span><span class="sxs-lookup"><span data-stu-id="28d86-247">The most common reason for this is that the bolts are not able to keep up with the spouts.</span></span> <span data-ttu-id="28d86-248">이렇게 하면 튜플이 처리될 때까지 대기하는 동안 내부 버퍼를 방해합니다.</span><span class="sxs-lookup"><span data-stu-id="28d86-248">This leads to tuples clogging the internal buffers while waiting to be processed.</span></span> <span data-ttu-id="28d86-249">시간 초과 값을 늘리거나 보류 중인 최대 Spout을 줄이세요.</span><span class="sxs-lookup"><span data-stu-id="28d86-249">Consider increasing the timeout value or decreasing the max spout pending.</span></span>

* <span data-ttu-id="28d86-250">**총 프로세스 실행 대기 시간이 길지만 Bolt 프로세스 대기 시간이 짧습니다.**</span><span class="sxs-lookup"><span data-stu-id="28d86-250">**There is a high total process execution latency, but a low bolt process latency.**</span></span> <span data-ttu-id="28d86-251">이런 경우 튜플이 충분히 빨리 승인되지 않을 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="28d86-251">In this case, it is possible that the tuples are not being acknowledged fast enough.</span></span> <span data-ttu-id="28d86-252">acknowledger 수가 충분한지 확인하세요.</span><span class="sxs-lookup"><span data-stu-id="28d86-252">Check that there are a sufficient number of acknowledgers.</span></span> <span data-ttu-id="28d86-253">Bolt가 처리를 시작하기 전에 큐에서 너무 오래 대기 중인 것도 원인이 될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="28d86-253">Another possibility is that they are waiting in the queue for too long before the bolts start processing them.</span></span> <span data-ttu-id="28d86-254">보류 중인 최대 Spout을 줄이세요.</span><span class="sxs-lookup"><span data-stu-id="28d86-254">Decrease the max spout pending.</span></span>

* <span data-ttu-id="28d86-255">**Bolt 실행 대기 시간이 깁니다.**</span><span class="sxs-lookup"><span data-stu-id="28d86-255">**There is a high bolt execute latency.**</span></span> <span data-ttu-id="28d86-256">Bolt의 execute() 메서드에 시간이 너무 오래 소요되기 때문입니다.</span><span class="sxs-lookup"><span data-stu-id="28d86-256">This means that the execute() method of your bolt is taking too long.</span></span> <span data-ttu-id="28d86-257">코드를 최적화하고 쓰기 크기 및 플러시 동작을 확인하세요.</span><span class="sxs-lookup"><span data-stu-id="28d86-257">Optimize the code, or look at write sizes and flush behavior.</span></span>

### <a name="data-lake-store-throttling"></a><span data-ttu-id="28d86-258">Data Lake Store 제한</span><span class="sxs-lookup"><span data-stu-id="28d86-258">Data Lake Store throttling</span></span>
<span data-ttu-id="28d86-259">Data Lake Store에서 제공하는 대역폭 한계에 도달한 경우 태스크 오류가 표시됩니다.</span><span class="sxs-lookup"><span data-stu-id="28d86-259">If you hit the limits of bandwidth provided by Data Lake Store, you might see task failures.</span></span> <span data-ttu-id="28d86-260">제한 오류에 대한 태스크 로그를 확인합니다.</span><span class="sxs-lookup"><span data-stu-id="28d86-260">Check task logs for throttling errors.</span></span> <span data-ttu-id="28d86-261">컨테이너 크기를 늘려 병렬 처리를 줄일 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="28d86-261">You can decrease the parallelism by increasing container size.</span></span>    

<span data-ttu-id="28d86-262">제한 여부를 확인하려면 클라이언트 쪽에서 디버그 로깅을 사용하도록 설정합니다.</span><span class="sxs-lookup"><span data-stu-id="28d86-262">To check if you are getting throttled, enable the debug logging on the client side:</span></span>

1. <span data-ttu-id="28d86-263">**Ambari** > **Storm** > **Config** > **고급 storm-worker-log4j**에서 **&lt;root level="info"&gt;**를 **&lt;root level=”debug”&gt;**로 변경합니다.</span><span class="sxs-lookup"><span data-stu-id="28d86-263">In **Ambari** > **Storm** > **Config** > **Advanced storm-worker-log4j**, change **&lt;root level="info"&gt;** to **&lt;root level=”debug”&gt;**.</span></span> <span data-ttu-id="28d86-264">구성을 적용하려면 모든 노드/서비스를 다시 시작합니다.</span><span class="sxs-lookup"><span data-stu-id="28d86-264">Restart all the nodes/service for the configuration to take effect.</span></span>
2. <span data-ttu-id="28d86-265">작업자 노드의 storm 토폴로지 로그에서 Data Lake Store 제한 예외를 모니터링합니다(/var/log/storm/worker-artifacts/&lt;TopologyName&gt;/&lt;port&gt;/worker.log 아래).</span><span class="sxs-lookup"><span data-stu-id="28d86-265">Monitor the Storm topology logs on worker nodes (under /var/log/storm/worker-artifacts/&lt;TopologyName&gt;/&lt;port&gt;/worker.log) for Data Lake Store throttling exceptions.</span></span>

## <a name="next-steps"></a><span data-ttu-id="28d86-266">다음 단계</span><span class="sxs-lookup"><span data-stu-id="28d86-266">Next steps</span></span>
<span data-ttu-id="28d86-267">Storm의 추가 성능 조정은 이 [블로그](https://blogs.msdn.microsoft.com/shanyu/2015/05/14/performance-tuning-for-hdinsight-storm-and-microsoft-azure-eventhubs/)를 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="28d86-267">Additional performance tuning for Storm can be referenced in [this blog](https://blogs.msdn.microsoft.com/shanyu/2015/05/14/performance-tuning-for-hdinsight-storm-and-microsoft-azure-eventhubs/).</span></span>

<span data-ttu-id="28d86-268">추가 예제를 실행하려면 [GitHub에서 이 항목](https://github.com/hdinsight/storm-performance-automation)을 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="28d86-268">For an additional example to run, see [this one on GitHub](https://github.com/hdinsight/storm-performance-automation).</span></span>
