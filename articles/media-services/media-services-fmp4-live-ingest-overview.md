---
title: "aaaAzure 미디어 서비스 라이브 조각난된 MP4 수집 사양 | Microsoft Docs"
description: "이 사양은 hello 프로토콜 및 조각난된 MP4 기반 라이브 스트리밍 수집 Azure 미디어 서비스에 대 한 형식을 설명합니다. Azure 미디어 서비스 toostream 라이브 이벤트를 사용할 수 있으며 hello 클라우드 플랫폼으로 Azure를 사용 하 여 실시간에서 콘텐츠 브로드캐스트 수 있습니다. 이 문서에서는 매우 중복되고 강력한 라이브 수집 메커니즘을 구축하는 모범 사례도 다룹니다."
services: media-services
documentationcenter: 
author: cenkdin
manager: cfowler
editor: 
ms.assetid: 43fac263-a5ea-44af-8dd5-cc88e423b4de
ms.service: media-services
ms.workload: media
ms.tgt_pltfrm: na
ms.devlang: na
ms.topic: article
ms.date: 06/29/2017
ms.author: cenkd;juliako
ms.openlocfilehash: 0c191f8d6c5a595621feaba0e571fb984b666f34
ms.sourcegitcommit: 523283cc1b3c37c428e77850964dc1c33742c5f0
ms.translationtype: MT
ms.contentlocale: ko-KR
ms.lasthandoff: 10/06/2017
---
# <a name="azure-media-services-fragmented-mp4-live-ingest-specification"></a><span data-ttu-id="aa5f6-105">Azure Media Services 조각화된 MP4 라이브 수집 사양</span><span class="sxs-lookup"><span data-stu-id="aa5f6-105">Azure Media Services fragmented MP4 live ingest specification</span></span>
<span data-ttu-id="aa5f6-106">이 사양은 hello 프로토콜 및 조각난된 MP4 기반 라이브 스트리밍 수집 Azure 미디어 서비스에 대 한 형식을 설명합니다.</span><span class="sxs-lookup"><span data-stu-id="aa5f6-106">This specification describes hello protocol and format for fragmented MP4-based live streaming ingestion for Azure Media Services.</span></span> <span data-ttu-id="aa5f6-107">미디어 서비스 라이브 스트리밍 서비스로 고객 toostream 라이브 이벤트를 사용 하 고 hello 클라우드 플랫폼으로 Azure를 사용 하 여 실시간에서 콘텐츠 브로드캐스트할 수를 제공 합니다.</span><span class="sxs-lookup"><span data-stu-id="aa5f6-107">Media Services provides a live streaming service that customers can use toostream live events and broadcast content in real time by using Azure as hello cloud platform.</span></span> <span data-ttu-id="aa5f6-108">이 문서에서는 매우 중복되고 강력한 라이브 수집 메커니즘을 구축하는 모범 사례도 다룹니다.</span><span class="sxs-lookup"><span data-stu-id="aa5f6-108">This document also discusses best practices for building highly redundant and robust live ingest mechanisms.</span></span>

## <a name="1-conformance-notation"></a><span data-ttu-id="aa5f6-109">1. 적합성 표기</span><span class="sxs-lookup"><span data-stu-id="aa5f6-109">1. Conformance notation</span></span>
<span data-ttu-id="aa5f6-110">"권장", "가능", 및이 문서의 "OPTIONAL"는 해야만에 설명 된 대로 해석 toobe는 hello 키워드 "해야," "하지 않아야," "REQUIRED,", "은 NOT", "해서는 안" 되어서는 안, "입니다.</span><span class="sxs-lookup"><span data-stu-id="aa5f6-110">hello key words "MUST," "MUST NOT," "REQUIRED," "SHALL," "SHALL NOT," "SHOULD," "SHOULD NOT," "RECOMMENDED," "MAY," and "OPTIONAL" in this document are toobe interpreted as they are described in RFC 2119.</span></span>

## <a name="2-service-diagram"></a><span data-ttu-id="aa5f6-111">2. 서비스 다이어그램</span><span class="sxs-lookup"><span data-stu-id="aa5f6-111">2. Service diagram</span></span>
<span data-ttu-id="aa5f6-112">hello 다음 그림에 hello의 상위 수준 아키텍처 hello 라이브 스트리밍 미디어 서비스의 서비스:</span><span class="sxs-lookup"><span data-stu-id="aa5f6-112">hello following diagram shows hello high-level architecture of hello live streaming service in Media Services:</span></span>

1. <span data-ttu-id="aa5f6-113">라이브 인코더 hello Azure Media Services SDK를 통해 생성 되 고 사용자를 프로 비전 하는 라이브 피드 toochannels를 푸시합니다.</span><span class="sxs-lookup"><span data-stu-id="aa5f6-113">A live encoder pushes live feeds toochannels that are created and provisioned via hello Azure Media Services SDK.</span></span>
2. <span data-ttu-id="aa5f6-114">채널, 프로그램 및 스트리밍 끝점에서 미디어 서비스 핸들 모든 hello 라이브 스트리밍 기능을 수집, 형식 지정, DVR, 보안, 확장성 및 중복성 클라우드입니다.</span><span class="sxs-lookup"><span data-stu-id="aa5f6-114">Channels, programs, and streaming endpoints in Media Services handle all hello live streaming functionalities, including ingest, formatting, cloud DVR, security, scalability, and redundancy.</span></span>
3. <span data-ttu-id="aa5f6-115">필요에 따라 고객 toodeploy hello 스트리밍 끝점 및 hello 클라이언트 끝점 사이의 프로그램 Azure 콘텐츠 배달 네트워크 계층을 선택할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="aa5f6-115">Optionally, customers can choose toodeploy an Azure Content Delivery Network layer between hello streaming endpoint and hello client endpoints.</span></span>
4. <span data-ttu-id="aa5f6-116">클라이언트 hello HTTP 적응 스트리밍 프로토콜을 사용 하 여 스트리밍 끝점에서에서 끝점 스트림.</span><span class="sxs-lookup"><span data-stu-id="aa5f6-116">Client endpoints stream from hello streaming endpoint by using HTTP Adaptive Streaming protocols.</span></span> <span data-ttu-id="aa5f6-117">예로 Microsoft 부드러운 스트리밍, HTTP를 통한 동적 적응 스트리밍(DASH 또는 MPEG-DASH) 및 Apple HLS(HTTP 라이브 스트리밍)가 있습니다.</span><span class="sxs-lookup"><span data-stu-id="aa5f6-117">Examples include Microsoft Smooth Streaming, Dynamic Adaptive Streaming over HTTP (DASH, or MPEG-DASH), and Apple HTTP Live Streaming (HLS).</span></span>

![수집 흐름][image1]

## <a name="3-bitstream-format--iso-14496-12-fragmented-mp4"></a><span data-ttu-id="aa5f6-119">3. 비트스트림 형식 - ISO 14496-12 조각화된 MP4</span><span class="sxs-lookup"><span data-stu-id="aa5f6-119">3. Bitstream format – ISO 14496-12 fragmented MP4</span></span>
<span data-ttu-id="aa5f6-120">hello 통신 형식 수집 라이브 스트리밍에 대 한 설명에서이 문서는 [14496-12]를 기반 합니다.</span><span class="sxs-lookup"><span data-stu-id="aa5f6-120">hello wire format for live streaming ingest discussed in this document is based on [ISO-14496-12].</span></span> <span data-ttu-id="aa5f6-121">주문형 비디오 파일 및 라이브 스트리밍 수집 모두에 대한 조각화된 MP4 형식 및 확장에 대한 자세한 내용은 [[MS-SSTR]](http://msdn.microsoft.com/library/ff469518.aspx)을 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="aa5f6-121">For a detailed explanation of fragmented MP4 format and extensions both for video-on-demand files and live streaming ingestion, see [[MS-SSTR]](http://msdn.microsoft.com/library/ff469518.aspx).</span></span>

### <a name="live-ingest-format-definitions"></a><span data-ttu-id="aa5f6-122">라이브 수집 형식 정의</span><span class="sxs-lookup"><span data-stu-id="aa5f6-122">Live ingest format definitions</span></span>
<span data-ttu-id="aa5f6-123">hello 다음 목록은 toolive 적용 되는 정의가 Azure 미디어 서비스에 수집 하는 특수 형식.</span><span class="sxs-lookup"><span data-stu-id="aa5f6-123">hello following list describes special format definitions that apply toolive ingest into Azure Media Services:</span></span>

1. <span data-ttu-id="aa5f6-124">hello **ftyp**, **서버 매니페스트 상자 라이브**, 및 **moov** 상자 (HTTP POST) 각 요청과 함께 보내야 합니다.</span><span class="sxs-lookup"><span data-stu-id="aa5f6-124">hello **ftyp**, **Live Server Manifest Box**, and **moov** boxes MUST be sent with each request (HTTP POST).</span></span> <span data-ttu-id="aa5f6-125">Hello 스트림의 hello 시작 부분에서 이러한 상자 전송 되어야 하 고 수집 하는 언제 든 지 hello 인코더 tooresume 스트림에 다시 연결 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="aa5f6-125">These boxes MUST be sent at hello beginning of hello stream and any time hello encoder must reconnect tooresume stream ingest.</span></span> <span data-ttu-id="aa5f6-126">자세한 내용은 [1]의 섹션 6을 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="aa5f6-126">For more information, see Section 6 in [1].</span></span>
2. <span data-ttu-id="aa5f6-127">[1]의 섹션 3.3.2는 라이브 수집용 **StreamManifestBox**라는 옵션 상자를 설명합니다.</span><span class="sxs-lookup"><span data-stu-id="aa5f6-127">Section 3.3.2 in [1] defines an optional box called **StreamManifestBox** for live ingest.</span></span> <span data-ttu-id="aa5f6-128">Toohello hello Azure 부하 분산 장치 라우팅 논리를 인해이 상자를 사용 하는 사용 되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="aa5f6-128">Due toohello routing logic of hello Azure load balancer, using this box is deprecated.</span></span> <span data-ttu-id="aa5f6-129">hello 상자 미디어 서비스에 수집 시 표시 되지 않아야 합니다.</span><span class="sxs-lookup"><span data-stu-id="aa5f6-129">hello box SHOULD NOT be present when ingesting into Media Services.</span></span> <span data-ttu-id="aa5f6-130">이 상자가 표시되는 경우 Media Services는 자동으로 이를 무시합니다.</span><span class="sxs-lookup"><span data-stu-id="aa5f6-130">If this box is present, Media Services silently ignores it.</span></span>
3. <span data-ttu-id="aa5f6-131">hello **TrackFragmentExtendedHeaderBox** 상자에 [1] 3.2.3.2에 정의 된 각 조각에 대 한 있어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="aa5f6-131">hello **TrackFragmentExtendedHeaderBox** box defined in 3.2.3.2 in [1] MUST be present for each fragment.</span></span>
4. <span data-ttu-id="aa5f6-132">버전 2의 hello **TrackFragmentExtendedHeaderBox** 상자에는 여러 데이터 센터에서 동일한 Url이 있는 미디어 세그먼트를 사용 하는 toogenerate 되어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="aa5f6-132">Version 2 of hello **TrackFragmentExtendedHeaderBox** box SHOULD be used toogenerate media segments that have identical URLs in multiple datacenters.</span></span> <span data-ttu-id="aa5f6-133">hello 조각 인덱스 필드 인덱스 기반 스트리밍 형식 Apple HLS 등의 데이터 센터 간 장애 조치에는 REQUIRED 및 인덱스 기반 MPEG DASH는입니다.</span><span class="sxs-lookup"><span data-stu-id="aa5f6-133">hello fragment index field is REQUIRED for cross-datacenter failover of index-based streaming formats such as Apple HLS and index-based MPEG-DASH.</span></span> <span data-ttu-id="aa5f6-134">tooenable 데이터 센터 간 장애 조치 hello 조각 인덱스 여러 인코더에서 동기화 해야 하 고 인코더 다시 시작 또는 오류 간에 각 연속 미디어 조각에 대 한 1 씩 증가 합니다.</span><span class="sxs-lookup"><span data-stu-id="aa5f6-134">tooenable cross-datacenter failover, hello fragment index MUST be synced across multiple encoders and be increased by 1 for each successive media fragment, even across encoder restarts or failures.</span></span>
5. <span data-ttu-id="aa5f6-135">섹션 3.3.6 [1] 정의 라는 상자 **MovieFragmentRandomAccessBox** (**mfra**) 라이브 수집 tooindicate 스트림의 끝 (EOS) toohello 채널의 hello 끝에 전송 될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="aa5f6-135">Section 3.3.6 in [1] defines a box called **MovieFragmentRandomAccessBox** (**mfra**) that MAY be sent at hello end of live ingestion tooindicate end-of-stream (EOS) toohello channel.</span></span> <span data-ttu-id="aa5f6-136">기한 toohello EOS를 사용 하는 더 이상 hello 미디어 서비스의 논리를 수집 **mfra** 라이브 수집 보내지 않아야에 대 한 상자입니다.</span><span class="sxs-lookup"><span data-stu-id="aa5f6-136">Due toohello ingest logic of Media Services, using EOS is deprecated, and hello **mfra** box for live ingestion SHOULD NOT be sent.</span></span> <span data-ttu-id="aa5f6-137">전송한 경우 Media Services는 자동으로 이를 무시합니다.</span><span class="sxs-lookup"><span data-stu-id="aa5f6-137">If sent, Media Services silently ignores it.</span></span> <span data-ttu-id="aa5f6-138">tooreset hello 상태의 hello 지점 수집, 사용 하는 것이 좋습니다 [채널 재설정](https://docs.microsoft.com/rest/api/media/operations/channel#reset_channels)합니다.</span><span class="sxs-lookup"><span data-stu-id="aa5f6-138">tooreset hello state of hello ingest point, we recommend that you use [Channel Reset](https://docs.microsoft.com/rest/api/media/operations/channel#reset_channels).</span></span> <span data-ttu-id="aa5f6-139">사용 하는 것이 좋습니다 [프로그램 중지](https://msdn.microsoft.com/library/azure/dn783463.aspx#stop_programs) tooend 프레젠테이션 및 스트림 합니다.</span><span class="sxs-lookup"><span data-stu-id="aa5f6-139">We also recommend that you use [Program Stop](https://msdn.microsoft.com/library/azure/dn783463.aspx#stop_programs) tooend a presentation and stream.</span></span>
6. <span data-ttu-id="aa5f6-140">hello MP4 조각 시간을 일정 해야 hello 클라이언트 매니페스트 tooreduce hello 크기입니다.</span><span class="sxs-lookup"><span data-stu-id="aa5f6-140">hello MP4 fragment duration SHOULD be constant, tooreduce hello size of hello client manifests.</span></span> <span data-ttu-id="aa5f6-141">상수 MP4 조각 기간에는 반복 태그의 hello 사용을 통해 클라이언트 다운로드 추론 향상 됩니다.</span><span class="sxs-lookup"><span data-stu-id="aa5f6-141">A constant MP4 fragment duration also improves client download heuristics through hello use of repeat tags.</span></span> <span data-ttu-id="aa5f6-142">hello 기간 정수가 아닌 프레임 속도 대 한 toocompensate를 변동 될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="aa5f6-142">hello duration MAY fluctuate toocompensate for non-integer frame rates.</span></span>
7. <span data-ttu-id="aa5f6-143">hello MP4 조각 기간 약 2-6 초 사이 여야 합니다.</span><span class="sxs-lookup"><span data-stu-id="aa5f6-143">hello MP4 fragment duration SHOULD be between approximately 2 and 6 seconds.</span></span>
8. <span data-ttu-id="aa5f6-144">MP4 조각 타임스탬프 및 인덱스(**TrackFragmentExtendedHeaderBox** `fragment_ absolute_ time` 및 `fragment_index`)는 오름차순으로 도착해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="aa5f6-144">MP4 fragment timestamps and indexes (**TrackFragmentExtendedHeaderBox** `fragment_ absolute_ time` and `fragment_index`) SHOULD arrive in increasing order.</span></span> <span data-ttu-id="aa5f6-145">미디어 서비스 탄력적 tooduplicate 조각 이지만, toohello 미디어 타임 라인에 따라 기능 tooreorder 조각 제한적입니다.</span><span class="sxs-lookup"><span data-stu-id="aa5f6-145">Although Media Services is resilient tooduplicate fragments, it has limited ability tooreorder fragments according toohello media timeline.</span></span>

## <a name="4-protocol-format--http"></a><span data-ttu-id="aa5f6-146">4. 프로토콜 형식 – HTTP</span><span class="sxs-lookup"><span data-stu-id="aa5f6-146">4. Protocol format – HTTP</span></span>
<span data-ttu-id="aa5f6-147">ISO 조각난 MP4 기반 라이브 미디어 서비스는 표준 장기 실행 HTTP POST 요청 tootransmit 인코딩된 미디어 데이터 조각난된 MP4 형식 toohello 서비스에서 패키지에서 사용 하 여 수집 합니다.</span><span class="sxs-lookup"><span data-stu-id="aa5f6-147">ISO fragmented MP4-based live ingest for Media Services uses a standard long-running HTTP POST request tootransmit encoded media data that is packaged in fragmented MP4 format toohello service.</span></span> <span data-ttu-id="aa5f6-148">각 HTTP POST 보냅니다 전체 조각난 MP4 bitstream ("stream") 헤더 상자와 hello 시작 부분에서 시작 (**ftyp**, **서버 매니페스트 상자 라이브**, 및 **moov** 상자) 조각 시퀀스를 계속 하 고 (**moof** 및 **인식 되지** 상자).</span><span class="sxs-lookup"><span data-stu-id="aa5f6-148">Each HTTP POST sends a complete fragmented MP4 bitstream ("stream"), starting from hello beginning with header boxes (**ftyp**, **Live Server Manifest Box**, and **moov** boxes), and continuing with a sequence of fragments (**moof** and **mdat** boxes).</span></span> <span data-ttu-id="aa5f6-149">Hello HTTP POST 요청에 대 한 URL 구문에 대 한 섹션을 참조 9.2 [1]입니다.</span><span class="sxs-lookup"><span data-stu-id="aa5f6-149">For URL syntax for hello HTTP POST request, see section 9.2 in [1].</span></span> <span data-ttu-id="aa5f6-150">Hello 게시 URL의 예는.</span><span class="sxs-lookup"><span data-stu-id="aa5f6-150">An example of hello POST URL is:</span></span> 

    http://customer.channel.mediaservices.windows.net/ingest.isml/streams(720p)

### <a name="requirements"></a><span data-ttu-id="aa5f6-151">요구 사항</span><span class="sxs-lookup"><span data-stu-id="aa5f6-151">Requirements</span></span>
<span data-ttu-id="aa5f6-152">Hello 자세한 요구 사항은 다음과 같습니다.</span><span class="sxs-lookup"><span data-stu-id="aa5f6-152">Here are hello detailed requirements:</span></span>

1. <span data-ttu-id="aa5f6-153">hello 인코더 시작할지은 빈 HTTP POST 요청을 전송 하 여 브로드캐스팅 hello "body" (콘텐츠 길이가 0)를 사용 하 여 hello 동일한 수집 URL입니다.</span><span class="sxs-lookup"><span data-stu-id="aa5f6-153">hello encoder SHOULD start hello broadcast by sending an HTTP POST request with an empty “body” (zero content length) by using hello same ingestion URL.</span></span> <span data-ttu-id="aa5f6-154">이 hello 라이브 수집 끝점 유효 하며 인증이 또는 필요한 기타 조건 있을 경우 신속 하 게 감지 하는 hello 인코더를 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="aa5f6-154">This can help hello encoder quickly detect whether hello live ingestion endpoint is valid, and if there are any authentication or other conditions required.</span></span> <span data-ttu-id="aa5f6-155">각 HTTP 프로토콜 hello 서버 없습니다 다시 보낼 HTTP 응답 hello hello POST 본문을 포함 하는 전체 요청을 받을 때까지 합니다.</span><span class="sxs-lookup"><span data-stu-id="aa5f6-155">Per HTTP protocol, hello server can't send back an HTTP response until hello entire request, including hello POST body, is received.</span></span> <span data-ttu-id="aa5f6-156">이 단계에서는 hello 인코더 하지 않고 라이브 이벤트의 hello 장기 실행 특성을 지정 된 아닐 수 있습니다 수 toodetect 오류 모든 hello 데이터를 보내기 완료 될 때까지.</span><span class="sxs-lookup"><span data-stu-id="aa5f6-156">Given hello long-running nature of a live event, without this step, hello encoder might not be able toodetect any error until it finishes sending all hello data.</span></span>
2. <span data-ttu-id="aa5f6-157">hello 인코더 (1)로 인해 오류 또는 인증 문제를 처리 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="aa5f6-157">hello encoder MUST handle any errors or authentication challenges because of (1).</span></span> <span data-ttu-id="aa5f6-158">(1)이(가) 200 응답에 성공하면 계속합니다.</span><span class="sxs-lookup"><span data-stu-id="aa5f6-158">If (1) succeeds with a 200 response, continue.</span></span>
3. <span data-ttu-id="aa5f6-159">hello 인코더 hello 조각난 MP4 스트림을 사용 하 여 새 HTTP POST 요청을 시작 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="aa5f6-159">hello encoder MUST start a new HTTP POST request with hello fragmented MP4 stream.</span></span> <span data-ttu-id="aa5f6-160">hello 페이로드 hello 헤더 상자 뒤에 조각의로 시작 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="aa5f6-160">hello payload MUST start with hello header boxes, followed by fragments.</span></span> <span data-ttu-id="aa5f6-161">해당 hello 참고 **ftyp**, **서버 매니페스트 상자 라이브**, 및 **moov** hello 인코더 때문에 다시 연결 해야 하는 경우에이 순서에 따라이 상자 각 요청과 함께 전송 해야 hello 이전 요청에는 이전 toohello hello 스트림 끝에 종료 되었습니다.</span><span class="sxs-lookup"><span data-stu-id="aa5f6-161">Note that hello **ftyp**, **Live Server Manifest Box**, and **moov** boxes (in this order) MUST be sent with each request, even if hello encoder must reconnect because hello previous request was terminated prior toohello end of hello stream.</span></span> 
4. <span data-ttu-id="aa5f6-162">hello 인코더는 청크 분할된 전송 업로드에 대 한 인코딩을 사용 하 여, 불가능 한 toopredict hello 전체의 콘텐츠 길이 hello 있기 때문에 라이브 이벤트 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="aa5f6-162">hello encoder MUST use chunked transfer encoding for uploading, because it’s impossible toopredict hello entire content length of hello live event.</span></span>
5. <span data-ttu-id="aa5f6-163">Hello 마지막 조각의 보낸 후 hello 이벤트를 움직일 때 hello 인코더 hello 청크 분할 전송 인코딩 (대부분 HTTP 클라이언트 스택에 것을 자동으로 처리) 하는 메시지 시퀀스를 정상적으로 종료 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="aa5f6-163">When hello event is over, after sending hello last fragment, hello encoder MUST gracefully end hello chunked transfer encoding message sequence (most HTTP client stacks handle it automatically).</span></span> <span data-ttu-id="aa5f6-164">hello 인코더는 hello 서비스 tooreturn hello 최종 응답 코드에 대 한 대기 하 고 hello 연결을 종료 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="aa5f6-164">hello encoder MUST wait for hello service tooreturn hello final response code, and then terminate hello connection.</span></span> 
6. <span data-ttu-id="aa5f6-165">hello를 사용 하는 hello 인코더 해서는 안 `Events()` 를 미디어 서비스 라이브 수집에 대 한 9.2에 [1]에 설명 된 대로 명사.</span><span class="sxs-lookup"><span data-stu-id="aa5f6-165">hello encoder MUST NOT use hello `Events()` noun as described in 9.2 in [1] for live ingestion into Media Services.</span></span>
7. <span data-ttu-id="aa5f6-166">Hello HTTP POST 요청을 종료 하거나 시간 초과 hello 스트림의 TCP 오류 이전 toohello 끝과 hello 인코더 새 연결을 사용 하 여 새 POST 요청을 실행 하며 수행 하는 경우에 앞의 요구 사항을 hello 합니다.</span><span class="sxs-lookup"><span data-stu-id="aa5f6-166">If hello HTTP POST request terminates or times out with a TCP error prior toohello end of hello stream, hello encoder MUST issue a new POST request by using a new connection, and follow hello preceding requirements.</span></span> <span data-ttu-id="aa5f6-167">또한 hello 인코더 hello hello 스트림의 각 추적에 대 한 이전 두 MP4 조각을 다시 전송 하 고 hello 미디어 타임 라인에서 불연속성을 도입 하지 않고 다시 시작 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="aa5f6-167">Additionally, hello encoder MUST resend hello previous two MP4 fragments for each track in hello stream, and resume without introducing a discontinuity in hello media timeline.</span></span> <span data-ttu-id="aa5f6-168">각 추적에 대 한 마지막 두 개의 MP4 조각을 hello를 다시 보내는 등 어떤 데이터도 손실 되는지 확인 합니다.</span><span class="sxs-lookup"><span data-stu-id="aa5f6-168">Resending hello last two MP4 fragments for each track ensures that there is no data loss.</span></span> <span data-ttu-id="aa5f6-169">즉, 스트림을 오디오와 비디오 트랙을 포함 하는 경우 POST 요청을 현재 hello 오류가 발생 하면 hello 인코더 다시 연결 해야 하 고 resend hello 오디오 트랙에 대 한 이전에 성공적으로 전송 된, 마지막 두 개의 조각을 hello와 hello 마지막 두 개의 조각을 대 한 hello 비디오 트랙을 이전에 성공적으로 전송 된, 데이터 손실도 없고 tooensure입니다.</span><span class="sxs-lookup"><span data-stu-id="aa5f6-169">In other words, if a stream contains both an audio and a video track, and hello current POST request fails, hello encoder must reconnect and resend hello last two fragments for hello audio track, which were previously successfully sent, and hello last two fragments for hello video track, which were previously successfully sent, tooensure that there is no data loss.</span></span> <span data-ttu-id="aa5f6-170">hello 인코더 다시 연결 하는 경우 다시 보내기 미디어 조각의 "앞 으로" 버퍼를 유지 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="aa5f6-170">hello encoder MUST maintain a “forward” buffer of media fragments, which it resends when it reconnects.</span></span>

## <a name="5-timescale"></a><span data-ttu-id="aa5f6-171">5. 시간 간격</span><span class="sxs-lookup"><span data-stu-id="aa5f6-171">5. Timescale</span></span>
<span data-ttu-id="aa5f6-172">[[MS SSTR] ](https://msdn.microsoft.com/library/ff469518.aspx) hello 사용법에 대 한 시간 간격을 **SmoothStreamingMedia** (단원 2.2.2.1) **StreamElement** (단원 2.2.2.3) **StreamFragmentElement**(2.2.2.6 섹션) 및 **LiveSMIL** (2.2.7.3.1 섹션).</span><span class="sxs-lookup"><span data-stu-id="aa5f6-172">[[MS-SSTR]](https://msdn.microsoft.com/library/ff469518.aspx) describes hello usage of timescale for **SmoothStreamingMedia** (Section 2.2.2.1), **StreamElement** (Section 2.2.2.3), **StreamFragmentElement** (Section 2.2.2.6), and **LiveSMIL** (Section 2.2.7.3.1).</span></span> <span data-ttu-id="aa5f6-173">Hello 시간 간격 값 없으면 hello 사용 되는 기본값이 10000000 (10 MHz)입니다.</span><span class="sxs-lookup"><span data-stu-id="aa5f6-173">If hello timescale value is not present, hello default value used is 10,000,000 (10 MHz).</span></span> <span data-ttu-id="aa5f6-174">대부분의 인코더 구현에서는이 기본값을 사용할 hello 부드러운 스트리밍 형식 지정 다른 시간 간격 값의 사용을 차단 하지 않습니다, 하지만 값 (10 MHz) toogenerate 부드러운 스트리밍 데이터를 수집 합니다.</span><span class="sxs-lookup"><span data-stu-id="aa5f6-174">Although hello Smooth Streaming format specification doesn’t block usage of other timescale values, most encoder implementations use this default value (10 MHz) toogenerate Smooth Streaming ingest data.</span></span> <span data-ttu-id="aa5f6-175">기한 toohello [Azure 미디어 동적 패키징](media-services-dynamic-packaging-overview.md) 기능, 권장 오디오 스트림에 대 한 비디오 스트림 및 44.1 k h z 또는 48.1 KHz 90 KHz 표시줄을 사용 합니다.</span><span class="sxs-lookup"><span data-stu-id="aa5f6-175">Due toohello [Azure Media Dynamic Packaging](media-services-dynamic-packaging-overview.md) feature, we recommend that you use a 90-KHz timescale for video streams and 44.1 KHz or 48.1 KHz for audio streams.</span></span> <span data-ttu-id="aa5f6-176">다양 한 스트림에 사용 되는 서로 다른 시간 간격 값, hello 스트림 수준 시간 간격을 전송 되어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="aa5f6-176">If different timescale values are used for different streams, hello stream-level timescale MUST be sent.</span></span> <span data-ttu-id="aa5f6-177">자세한 내용은 [[MS-SSTR]](https://msdn.microsoft.com/library/ff469518.aspx)을 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="aa5f6-177">For more information, see [[MS-SSTR]](https://msdn.microsoft.com/library/ff469518.aspx).</span></span>     

## <a name="6-definition-of-stream"></a><span data-ttu-id="aa5f6-178">6. “스트림”의 정의</span><span class="sxs-lookup"><span data-stu-id="aa5f6-178">6. Definition of “stream”</span></span>
<span data-ttu-id="aa5f6-179">스트림이 hello 기본 단위 연산의 실시간 프레젠테이션을 작성에 대 한 라이브 수집 스트리밍 장애 조치 및 중복성 시나리오를 처리 합니다.</span><span class="sxs-lookup"><span data-stu-id="aa5f6-179">Stream is hello basic unit of operation in live ingestion for composing live presentations, handling streaming failover, and redundancy scenarios.</span></span> <span data-ttu-id="aa5f6-180">스트림은 단일 트랙 또는 여러 트랙을 포함할 수 있는 하나의 고유한 조각화된 MP4 비트스트림으로 정의됩니다.</span><span class="sxs-lookup"><span data-stu-id="aa5f6-180">Stream is defined as one unique, fragmented MP4 bitstream that might contain a single track or multiple tracks.</span></span> <span data-ttu-id="aa5f6-181">전체 라이브 프레젠테이션의 hello 라이브 인코더의 hello 구성에 따라 하나 이상의 스트림을 포함 될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="aa5f6-181">A full live presentation might contain one or more streams, depending on hello configuration of hello live encoders.</span></span> <span data-ttu-id="aa5f6-182">예제 따르는 hello 프레젠테이션을 전체 라이브 스트림을 toocompose를 사용 하 여 다양 한 옵션을 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="aa5f6-182">hello following examples illustrate various options of using streams toocompose a full live presentation.</span></span>

<span data-ttu-id="aa5f6-183">**예제:**</span><span class="sxs-lookup"><span data-stu-id="aa5f6-183">**Example:**</span></span> 

<span data-ttu-id="aa5f6-184">고객이 toocreate hello 오디오/비디오 비트 전송률 다음을 포함 하는 라이브 스트리밍 프레젠테이션은:</span><span class="sxs-lookup"><span data-stu-id="aa5f6-184">A customer wants toocreate a live streaming presentation that includes hello following audio/video bitrates:</span></span>

<span data-ttu-id="aa5f6-185">비디오 - 3000kbps, 1500kbps, 750kbps</span><span class="sxs-lookup"><span data-stu-id="aa5f6-185">Video – 3000 kbps, 1500 kbps, 750 kbps</span></span>

<span data-ttu-id="aa5f6-186">오디오 - 128kbps</span><span class="sxs-lookup"><span data-stu-id="aa5f6-186">Audio – 128 kbps</span></span>

### <a name="option-1-all-tracks-in-one-stream"></a><span data-ttu-id="aa5f6-187">옵션 1: 모든 트랙을 하나의 스트림에</span><span class="sxs-lookup"><span data-stu-id="aa5f6-187">Option 1: All tracks in one stream</span></span>
<span data-ttu-id="aa5f6-188">이 옵션에서는 단일 인코더가 모든 오디오/비디오 트랙을 생성한 다음 하나의 조각화된 MP4 비트스트림으로 번들화합니다.</span><span class="sxs-lookup"><span data-stu-id="aa5f6-188">In this option, a single encoder generates all audio/video tracks, and then bundles them into one fragmented MP4 bitstream.</span></span> <span data-ttu-id="aa5f6-189">hello 조각난 MP4 bitstream 단일 HTTP POST 연결을 통해 전송 됩니다.</span><span class="sxs-lookup"><span data-stu-id="aa5f6-189">hello fragmented MP4 bitstream is then sent via a single HTTP POST connection.</span></span> <span data-ttu-id="aa5f6-190">이 예제에서는 이 라이브 프레젠테이션에 스트림이 하나만 존재합니다.</span><span class="sxs-lookup"><span data-stu-id="aa5f6-190">In this example, there is only one stream for this live presentation.</span></span>

![스트림 - 한 트랙][image2]

### <a name="option-2-each-track-in-a-separate-stream"></a><span data-ttu-id="aa5f6-192">옵션 2: 각각의 트랙을 별도의 스트림에</span><span class="sxs-lookup"><span data-stu-id="aa5f6-192">Option 2: Each track in a separate stream</span></span>
<span data-ttu-id="aa5f6-193">이 옵션에서는 hello 인코더 각 MP4 조각 bitstream에 한 트랙을 넣고 별도 HTTP 연결을 통해 모든 hello 스트림 게시 됩니다.</span><span class="sxs-lookup"><span data-stu-id="aa5f6-193">In this option, hello encoder puts one track into each fragment MP4 bitstream, and then posts all of hello streams over separate HTTP connections.</span></span> <span data-ttu-id="aa5f6-194">이는 하나 이상의 인코더로 수행할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="aa5f6-194">This can be done with one encoder or with multiple encoders.</span></span> <span data-ttu-id="aa5f6-195">hello 라이브 수집 4 개의 스트림 구성 처럼이 라이브 프레젠테이션의 볼 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="aa5f6-195">hello live ingestion sees this live presentation as composed of four streams.</span></span>

![스트림 - 별도 트랙][image3]

### <a name="option-3-bundle-audio-track-with-hello-lowest-bitrate-video-track-into-one-stream"></a><span data-ttu-id="aa5f6-197">옵션 3: 하나의 스트림으로 오디오 트랙 hello 가장 낮은 비트 전송률 비디오 트랙으로 번들</span><span class="sxs-lookup"><span data-stu-id="aa5f6-197">Option 3: Bundle audio track with hello lowest bitrate video track into one stream</span></span>
<span data-ttu-id="aa5f6-198">이 옵션을 hello 고객이 toobundle hello 오디오 MP4 조각 하나의 bitstream에서 가장 낮은 비트 전송률 비디오 트랙 hello와 추적 및 leave hello 별개의 스트림으로 다른 두 개의 비디오 트랙을 선택 합니다.</span><span class="sxs-lookup"><span data-stu-id="aa5f6-198">In this option, hello customer chooses toobundle hello audio track with hello lowest-bitrate video track in one fragment MP4 bitstream, and leave hello other two video tracks as separate streams.</span></span> 

![스트림 - 오디오 및 비디오 트랙][image4]

### <a name="summary"></a><span data-ttu-id="aa5f6-200">요약</span><span class="sxs-lookup"><span data-stu-id="aa5f6-200">Summary</span></span>
<span data-ttu-id="aa5f6-201">이는 이 예제에서 가능한 모든 수집 옵션의 완벽한 목록은 아닙니다.</span><span class="sxs-lookup"><span data-stu-id="aa5f6-201">This is not an exhaustive list of all possible ingestion options for this example.</span></span> <span data-ttu-id="aa5f6-202">사실상 어떤 트랙을 스트림에 그룹화하는 것은 라이브 수집에서 지원됩니다.</span><span class="sxs-lookup"><span data-stu-id="aa5f6-202">As a matter of fact, any grouping of tracks into streams is supported by live ingestion.</span></span> <span data-ttu-id="aa5f6-203">고객 및 인코더 공급 업체는 엔지니어링 복잡성, 인코더 용량 및 중복성과 장애 조치 고려 사항에 따라 고유한 구현을 선택할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="aa5f6-203">Customers and encoder vendors can choose their own implementations based on engineering complexity, encoder capacity, and redundancy and failover considerations.</span></span> <span data-ttu-id="aa5f6-204">그러나 대부분의 경우, 즉 전체 라이브 프레젠테이션의 hello에 대 한 오디오 트랙을 하나만 있습니다.</span><span class="sxs-lookup"><span data-stu-id="aa5f6-204">However, in most cases, there is only one audio track for hello entire live presentation.</span></span> <span data-ttu-id="aa5f6-205">따라서의 중요 한 tooensure hello healthiness hello의 hello 오디오 트랙을 포함 하는 스트림을 수집 합니다. Hello 오디오 트랙 (옵션 2)에서 같이 자체 스트림에 배치 하거나 (옵션 3)에서 같이 hello 비트 전송률이 가장 낮은 비디오 트랙으로 번들이 고려 종종 발생 합니다.</span><span class="sxs-lookup"><span data-stu-id="aa5f6-205">So, it’s important tooensure hello healthiness of hello ingest stream that contains hello audio track. This consideration often results in putting hello audio track in its own stream (as in Option 2) or bundling it with hello lowest-bitrate video track (as in Option 3).</span></span> <span data-ttu-id="aa5f6-206">또한, 더 나은 중복과 내결함성을 위해 보내는 hello 두 개의 스트림 (중복 오디오 트랙으로 옵션 2)에 동일한 오디오 트랙 또는 번들 hello 오디오 트랙 (옵션 3 시에 번들로 묶이는 오디오와 hello 비트 전송률이 가장 낮은 비디오 트랙의 두 개 이상 있는 최소 두 개의 비디오 스트림)이 가장 좋습니다에 대 한 라이브 미디어 서비스에 수집 합니다.</span><span class="sxs-lookup"><span data-stu-id="aa5f6-206">Also, for better redundancy and fault tolerance, sending hello same audio track in two different streams (Option 2 with redundant audio tracks) or bundling hello audio track with at least two of hello lowest-bitrate video tracks (Option 3 with audio bundled in at least two video streams) is highly recommended for live ingest into Media Services.</span></span>

## <a name="7-service-failover"></a><span data-ttu-id="aa5f6-207">7. 서비스 장애 조치(failover)</span><span class="sxs-lookup"><span data-stu-id="aa5f6-207">7. Service failover</span></span>
<span data-ttu-id="aa5f6-208">라이브 스트리밍을의 hello 특성을 지정한 좋은 장애 조치 지원을 hello hello 서비스 가용성 보장 중요 합니다.</span><span class="sxs-lookup"><span data-stu-id="aa5f6-208">Given hello nature of live streaming, good failover support is critical for ensuring hello availability of hello service.</span></span> <span data-ttu-id="aa5f6-209">미디어 서비스 다양 한 유형의 실패, 네트워크 오류, 서버 오류 및 저장소 문제를 포함 하 여 디자인 된 toohandle 됩니다.</span><span class="sxs-lookup"><span data-stu-id="aa5f6-209">Media Services is designed toohandle various types of failures, including network errors, server errors, and storage issues.</span></span> <span data-ttu-id="aa5f6-210">Hello 라이브 인코더에서에서 적절 한 장애 조치 논리와 함께 사용할 경우 고객 hello 클라우드에서 항상 신뢰할 수 있는 라이브 스트리밍 서비스로 달성할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="aa5f6-210">When used in conjunction with proper failover logic from hello live encoder side, customers can achieve a highly reliable live streaming service from hello cloud.</span></span>

<span data-ttu-id="aa5f6-211">이 섹션에서는 서비스 장애 조치(failover) 시나리오를 설명합니다.</span><span class="sxs-lookup"><span data-stu-id="aa5f6-211">In this section, we discuss service failover scenarios.</span></span> <span data-ttu-id="aa5f6-212">네트워크 오류로 하기도 hello 오류 hello 서비스 내에서 어딘가에 발생이 경우 합니다.</span><span class="sxs-lookup"><span data-stu-id="aa5f6-212">In this case, hello failure happens somewhere within hello service, and it manifests itself as a network error.</span></span> <span data-ttu-id="aa5f6-213">다음은 서비스 장애를 처리 하기 위한 hello 인코더 구현에 대 한 몇 가지 권장 사항입니다.</span><span class="sxs-lookup"><span data-stu-id="aa5f6-213">Here are some recommendations for hello encoder implementation for handling service failover:</span></span>

1. <span data-ttu-id="aa5f6-214">Hello TCP 연결을 설정 하는 데 10 초 제한 시간을 사용 합니다.</span><span class="sxs-lookup"><span data-stu-id="aa5f6-214">Use a 10-second timeout for establishing hello TCP connection.</span></span> <span data-ttu-id="aa5f6-215">Hello 작업을 중단 하는 시도 tooestablish hello 연결 10 초 보다 더 오래 걸리면, 다시 시도 하십시오.</span><span class="sxs-lookup"><span data-stu-id="aa5f6-215">If an attempt tooestablish hello connection takes longer than 10 seconds, abort hello operation and try again.</span></span> 
2. <span data-ttu-id="aa5f6-216">Hello HTTP 요청 메시지 청크를 보내기 위한 짧은 제한 시간을 사용 합니다.</span><span class="sxs-lookup"><span data-stu-id="aa5f6-216">Use a short timeout for sending hello HTTP request message chunks.</span></span> <span data-ttu-id="aa5f6-217">N 초 hello 대상 MP4 조각 지속 시간을 사용 하는 경우 사용 하 여 N과 2 N 초 간의 전송 시간 초과 예를 들어 6 초 hello MP4 조각 기간을 사용 하는 경우 6 too12 초 제한 시간을 사용 합니다.</span><span class="sxs-lookup"><span data-stu-id="aa5f6-217">If hello target MP4 fragment duration is N seconds, use a send timeout between N and 2 N seconds; for example, if hello MP4 fragment duration is 6 seconds, use a timeout of 6 too12 seconds.</span></span> <span data-ttu-id="aa5f6-218">시간 초과가 발생 하는 경우 재설정 hello 연결, 새 연결 열기 및 resume 스트림 hello 새 연결에 대해 수집 합니다.</span><span class="sxs-lookup"><span data-stu-id="aa5f6-218">If a timeout occurs, reset hello connection, open a new connection, and resume stream ingest on hello new connection.</span></span> 
3. <span data-ttu-id="aa5f6-219">Hello 마지막 두 개의 조각이 각 추적에 대 한 완전히 및 성공적으로 보낸 toohello 서비스를 포함 하는 롤링 버퍼를 유지 합니다.</span><span class="sxs-lookup"><span data-stu-id="aa5f6-219">Maintain a rolling buffer that has hello last two fragments for each track that were successfully and completely sent toohello service.</span></span>  <span data-ttu-id="aa5f6-220">스트림에 대 한 HTTP POST 요청 hello 종료 되거나 제한 시간이 초과 이전 toohello hello 스트림 끝을 하는 경우 새 연결을 열거나 및 다른 HTTP POST 요청을 시작, hello 스트림 헤더를 다시 보낼, 각 추적에 대 한 마지막 두 조각의 hello를 다시 보냅니다 및 다시 시작 없이 hello 스트림 hello 미디어 타임 라인에서 불연속성을 소개 합니다.</span><span class="sxs-lookup"><span data-stu-id="aa5f6-220">If hello HTTP POST request for a stream is terminated or times out prior toohello end of hello stream, open a new connection and begin another HTTP POST request, resend hello stream headers, resend hello last two fragments for each track, and resume hello stream without introducing a discontinuity in hello media timeline.</span></span> <span data-ttu-id="aa5f6-221">이렇게 하면 hello 데이터 손실 가능성이 줄어듭니다.</span><span class="sxs-lookup"><span data-stu-id="aa5f6-221">This reduces hello chance of data loss.</span></span>
4. <span data-ttu-id="aa5f6-222">해당 hello 인코더 hello 재시도 tooestablish 연결 수를 제한 하거나 스트리밍 TCP 오류가 발생 한 후 다시 시작 하지 않는 것이 좋습니다.</span><span class="sxs-lookup"><span data-stu-id="aa5f6-222">We recommend that hello encoder does NOT limit hello number of retries tooestablish a connection or resume streaming after a TCP error occurs.</span></span>
5. <span data-ttu-id="aa5f6-223">TCP 오류 후:</span><span class="sxs-lookup"><span data-stu-id="aa5f6-223">After a TCP error:</span></span>
  
    <span data-ttu-id="aa5f6-224">a.</span><span class="sxs-lookup"><span data-stu-id="aa5f6-224">a.</span></span> <span data-ttu-id="aa5f6-225">현재 연결 hello 해야 닫히고 새 HTTP POST 요청에 대 한 새 연결을 만들어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="aa5f6-225">hello current connection MUST be closed, and a new connection MUST be created for a new HTTP POST request.</span></span>

    <span data-ttu-id="aa5f6-226">b.</span><span class="sxs-lookup"><span data-stu-id="aa5f6-226">b.</span></span> <span data-ttu-id="aa5f6-227">새 HTTP POST URL 해야 하는 hello hello 초기 게시 URL hello와 동일 합니다.</span><span class="sxs-lookup"><span data-stu-id="aa5f6-227">hello new HTTP POST URL MUST be hello same as hello initial POST URL.</span></span>
  
    <span data-ttu-id="aa5f6-228">c.</span><span class="sxs-lookup"><span data-stu-id="aa5f6-228">c.</span></span> <span data-ttu-id="aa5f6-229">hello 새 HTTP POST 헤더를 포함 해야 스트림 (**ftyp**, **서버 매니페스트 상자 라이브**, 및 **moov** 상자) 하는 동일한 toohello 스트림 헤더 hello에 POST를 초기 합니다.</span><span class="sxs-lookup"><span data-stu-id="aa5f6-229">hello new HTTP POST MUST include stream headers (**ftyp**, **Live Server Manifest Box**, and **moov** boxes) that are identical toohello stream headers in hello initial POST.</span></span>
  
    <span data-ttu-id="aa5f6-230">d.</span><span class="sxs-lookup"><span data-stu-id="aa5f6-230">d.</span></span> <span data-ttu-id="aa5f6-231">각 추적에 대 한 전송 hello 마지막 두 개의 조각이 다시 보내야, 및 스트리밍 불연속성 hello 미디어 타임 라인에는 위험 없이 재개 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="aa5f6-231">hello last two fragments sent for each track must be resent, and streaming must resume without introducing a discontinuity in hello media timeline.</span></span> <span data-ttu-id="aa5f6-232">hello MP4 조각 타임 스탬프 HTTP POST 요청 간에 계속 해 서 증가 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="aa5f6-232">hello MP4 fragment timestamps must increase continuously, even across HTTP POST requests.</span></span>
6. <span data-ttu-id="aa5f6-233">hello 인코더 hello MP4 조각 작업 기간에 비례하여 속도로 데이터는 전송 되지 않을 경우 hello HTTP POST 요청을 종료 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="aa5f6-233">hello encoder SHOULD terminate hello HTTP POST request if data is not being sent at a rate commensurate with hello MP4 fragment duration.</span></span>  <span data-ttu-id="aa5f6-234">데이터를 보내지 않습니다 하는 HTTP POST 요청은 서비스 업데이트의 hello 이벤트의 hello 인코더에서 신속 하 게 연결 끊기에서 미디어 서비스를 방지할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="aa5f6-234">An HTTP POST request that does not send data can prevent Media Services from quickly disconnecting from hello encoder in hello event of a service update.</span></span> <span data-ttu-id="aa5f6-235">이러한 이유로 hello에 대 한 HTTP POST 스파스 (광고 신호)를 추적 해야 단기 hello 스파스 조각 전송 되는 즉시 종료 합니다.</span><span class="sxs-lookup"><span data-stu-id="aa5f6-235">For this reason, hello HTTP POST for sparse (ad signal) tracks SHOULD be short-lived, terminating as soon as hello sparse fragment is sent.</span></span>

## <a name="8-encoder-failover"></a><span data-ttu-id="aa5f6-236">8. 인코더 장애 조치(failover)</span><span class="sxs-lookup"><span data-stu-id="aa5f6-236">8. Encoder failover</span></span>
<span data-ttu-id="aa5f6-237">인코더 장애 조치는 hello 두 번째 종류의 종단 간 라이브 스트리밍 배달에 대 한 toobe 해결 해야 하는 장애 조치 시나리오입니다.</span><span class="sxs-lookup"><span data-stu-id="aa5f6-237">Encoder failover is hello second type of failover scenario that needs toobe addressed for end-to-end live streaming delivery.</span></span> <span data-ttu-id="aa5f6-238">이 시나리오에서는 hello 인코더 쪽 hello 오류 조건이 발생합니다.</span><span class="sxs-lookup"><span data-stu-id="aa5f6-238">In this scenario, hello error condition occurs on hello encoder side.</span></span> 

![인코더 장애 조치(failover)][image5]

<span data-ttu-id="aa5f6-240">hello 기대 다음 인코더 장애 조치 하는 경우 hello 라이브 수집 끝점에서 적용 됩니다.</span><span class="sxs-lookup"><span data-stu-id="aa5f6-240">hello following expectations apply from hello live ingestion endpoint when encoder failover happens:</span></span>

1. <span data-ttu-id="aa5f6-241">새 인코더 인스턴스 만들어야 toocontinue 스트리밍 그림과 같이 hello (3000 k에 파선이 있는 비디오에 대 한 스트림) 합니다.</span><span class="sxs-lookup"><span data-stu-id="aa5f6-241">A new encoder instance SHOULD be created toocontinue streaming, as illustrated in hello diagram (Stream for 3000k video, with dashed line).</span></span>
2. <span data-ttu-id="aa5f6-242">hello 새 인코더 해야 사용 하 여 hello 동일한 URL을 HTTP POST 요청으로 hello 인스턴스 실패 했습니다.</span><span class="sxs-lookup"><span data-stu-id="aa5f6-242">hello new encoder MUST use hello same URL for HTTP POST requests as hello failed instance.</span></span>
3. <span data-ttu-id="aa5f6-243">hello 새 인코더의 POST 요청에 포함 되어야 hello 실패 한 인스턴스 hello으로 MP4 헤더 상자 조각화 동일 합니다.</span><span class="sxs-lookup"><span data-stu-id="aa5f6-243">hello new encoder’s POST request MUST include hello same fragmented MP4 header boxes as hello failed instance.</span></span>
4. <span data-ttu-id="aa5f6-244">hello 동일한 라이브 프레젠테이션의 toogenerate 동기화 정렬 된 조각 경계와 오디오/비디오 샘플에 대 한 hello 새 인코더 실행 중인 다른 모든 인코더와 제대로 동기화 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="aa5f6-244">hello new encoder MUST be properly synced with all other running encoders for hello same live presentation toogenerate synced audio/video samples with aligned fragment boundaries.</span></span>
5. <span data-ttu-id="aa5f6-245">hello 새 스트림이 hello 이전 스트림을 사용 하 여 의미는 동일 해야 합니다. 및 hello 헤더 및 조각 수준에서 사용이 가능 합니다.</span><span class="sxs-lookup"><span data-stu-id="aa5f6-245">hello new stream MUST be semantically equivalent with hello previous stream, and interchangeable at hello header and fragment levels.</span></span>
6. <span data-ttu-id="aa5f6-246">새 인코더 hello toominimize 데이터 손실을 시도해 보십시오.</span><span class="sxs-lookup"><span data-stu-id="aa5f6-246">hello new encoder SHOULD try toominimize data loss.</span></span> <span data-ttu-id="aa5f6-247">hello `fragment_absolute_time` 및 `fragment_index` hello 지점 hello 인코더 마지막 중지 위치에서 미디어 조각을 증가 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="aa5f6-247">hello `fragment_absolute_time` and `fragment_index` of media fragments SHOULD increase from hello point where hello encoder last stopped.</span></span> <span data-ttu-id="aa5f6-248">hello `fragment_absolute_time` 및 `fragment_index` 는 지속적으로 증가 해야 하지만 것이 허용 가능한 toointroduce 불연속성, 필요한 경우.</span><span class="sxs-lookup"><span data-stu-id="aa5f6-248">hello `fragment_absolute_time` and `fragment_index` SHOULD increase in a continuous manner, but it is permissible toointroduce a discontinuity, if necessary.</span></span> <span data-ttu-id="aa5f6-249">미디어 서비스는 hello 미디어 타임 라인에서 toointroduce 불연속 보다 조각을 다시 보내는 등의 hello 측에 더 나은 tooerr 되기 때문 수신 및 처리 하 고, 이미에 조각의 무시 합니다.</span><span class="sxs-lookup"><span data-stu-id="aa5f6-249">Media Services ignores fragments that it has already received and processed, so it's better tooerr on hello side of resending fragments than toointroduce discontinuities in hello media timeline.</span></span> 

## <a name="9-encoder-redundancy"></a><span data-ttu-id="aa5f6-250">9. 인코더 중복성</span><span class="sxs-lookup"><span data-stu-id="aa5f6-250">9. Encoder redundancy</span></span>
<span data-ttu-id="aa5f6-251">중요 한 라이브 있는지 요구 더 높은 가용성 및 환경의 품질 것이 좋습니다 데이터 손실 없이 활성-활성 중복 인코더 tooachieve 원활한 장애 조치를 사용 하는 이벤트입니다.</span><span class="sxs-lookup"><span data-stu-id="aa5f6-251">For certain critical live events that demand even higher availability and quality of experience, we recommended that you use active-active redundant encoders tooachieve seamless failover with no data loss.</span></span>

![인코더 중복성][image6]

<span data-ttu-id="aa5f6-253">이 다이어그램에 볼 수 있듯이, 인코더의 두 그룹 푸시 각 스트림에의 두 복사본이 동시에 hello 라이브 서비스입니다.</span><span class="sxs-lookup"><span data-stu-id="aa5f6-253">As illustrated in this diagram, two groups of encoders push two copies of each stream simultaneously into hello live service.</span></span> <span data-ttu-id="aa5f6-254">이 설정은 Media Services가 중복된 조각을 스트림 ID와 조각 타임스탬프에 따라 필터링할 수 있기 때문에 지원됩니다.</span><span class="sxs-lookup"><span data-stu-id="aa5f6-254">This setup is supported because Media Services can filter out duplicate fragments based on stream ID and fragment timestamp.</span></span> <span data-ttu-id="aa5f6-255">결과 라이브 스트림을 hello 및 보관 파일이 hello 두 소스의 hello 최상의 가능한 집계 하는 모든 hello 스트림의 단일 복사본입니다.</span><span class="sxs-lookup"><span data-stu-id="aa5f6-255">hello resulting live stream and archive is a single copy of all hello streams that is hello best possible aggregation from hello two sources.</span></span> <span data-ttu-id="aa5f6-256">예를 들어 가상 극단적인 경우에는 하나의 인코더 (없어도 toobe hello 동일한 하나)으로 특정 시점에 실행 각 스트림에 대해 hello hello 서비스에서 라이브 스트림을 결과 연속 데이터 손실 없이 합니다.</span><span class="sxs-lookup"><span data-stu-id="aa5f6-256">For example, in a hypothetical extreme case, as long as there is one encoder (it doesn’t have toobe hello same one) running at any given point in time for each stream, hello resulting live stream from hello service is continuous without data loss.</span></span> 

<span data-ttu-id="aa5f6-257">이 시나리오에 대 한 hello 요구 사항 거의 동일 hello "인코더 장애 조치" 경우에서 hello 요구 사항으로 hello, 인코더의 두 번째 집합 hello hello에서 실행 되는 hello 예외와 동일한 기본 인코더 hello 된 표준 시간입니다.</span><span class="sxs-lookup"><span data-stu-id="aa5f6-257">hello requirements for this scenario are almost hello same as hello requirements in hello "Encoder failover" case, with hello exception that hello second set of encoders are running at hello same time as hello primary encoders.</span></span>

## <a name="10-service-redundancy"></a><span data-ttu-id="aa5f6-258">10. 서비스 중복성</span><span class="sxs-lookup"><span data-stu-id="aa5f6-258">10. Service redundancy</span></span>
<span data-ttu-id="aa5f6-259">경우에 따라 중복성이 뛰어나고 글로벌 배포에 대 한 지역 간 백업 toohandle 국가별 재해를 있어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="aa5f6-259">For highly redundant global distribution, sometimes you must have cross-region backup toohandle regional disasters.</span></span> <span data-ttu-id="aa5f6-260">Hello "인코더 중복" 토폴로지를 확장 고객이 선택할 수 toohave 중복 서비스 배포 인코더의 두 번째 집합 hello와 연결 된 다른 지역에 있습니다.</span><span class="sxs-lookup"><span data-stu-id="aa5f6-260">Expanding on hello “Encoder redundancy” topology, customers can choose toohave a redundant service deployment in a different region that's connected with hello second set of encoders.</span></span> <span data-ttu-id="aa5f6-261">또한 고객 작업 수 콘텐츠 배달 네트워크 공급자 toodeploy hello 두 서비스 배포 tooseamlessly 경로 클라이언트 트래픽 앞에 전역 트래픽 관리자를 사용 합니다.</span><span class="sxs-lookup"><span data-stu-id="aa5f6-261">Customers also can work with a Content Delivery Network provider toodeploy a Global Traffic Manager in front of hello two service deployments tooseamlessly route client traffic.</span></span> <span data-ttu-id="aa5f6-262">hello hello 인코더에 대 한 요건은 hello "인코더 중복" 대/소문자 hello와 동일 합니다.</span><span class="sxs-lookup"><span data-stu-id="aa5f6-262">hello requirements for hello encoders are hello same as hello “Encoder redundancy” case.</span></span> <span data-ttu-id="aa5f6-263">hello만 예외는 hello 두 번째 집합이 인코더 요구 toobe 다른 tooa 실시간 가리키고 수집 끝점입니다.</span><span class="sxs-lookup"><span data-stu-id="aa5f6-263">hello only exception is that hello second set of encoders needs toobe pointed tooa different live ingest endpoint.</span></span> <span data-ttu-id="aa5f6-264">hello 다음 그림에이 설치:</span><span class="sxs-lookup"><span data-stu-id="aa5f6-264">hello following diagram shows this setup:</span></span>

![서비스 중복성][image7]

## <a name="11-special-types-of-ingestion-formats"></a><span data-ttu-id="aa5f6-266">11. 수집 형식의 특수한 유형</span><span class="sxs-lookup"><span data-stu-id="aa5f6-266">11. Special types of ingestion formats</span></span>
<span data-ttu-id="aa5f6-267">이 섹션에는 특정 시나리오에 맞춰 디자인된 toohandle 있는 라이브 수집 형식의 특별 한 형식을 설명 합니다.</span><span class="sxs-lookup"><span data-stu-id="aa5f6-267">This section discusses special types of live ingestion formats that are designed toohandle specific scenarios.</span></span>

### <a name="sparse-track"></a><span data-ttu-id="aa5f6-268">스파스 트랙</span><span class="sxs-lookup"><span data-stu-id="aa5f6-268">Sparse track</span></span>
<span data-ttu-id="aa5f6-269">리치 클라이언트 시각적 효과를 라이브 스트리밍 프레젠테이션의 서비스를 제공 하 종종 필요한 tootransmit 시간 동기화 이벤트 또는 hello 주 미디어 데이터와는 별도로에 신호를 보냅니다.</span><span class="sxs-lookup"><span data-stu-id="aa5f6-269">When delivering a live streaming presentation with a rich client experience, often it's necessary tootransmit time-synced events or signals in-band with hello main media data.</span></span> <span data-ttu-id="aa5f6-270">동적 라이브 광고 삽입이 하나의 예입니다.</span><span class="sxs-lookup"><span data-stu-id="aa5f6-270">An example of this is dynamic live ad insertion.</span></span> <span data-ttu-id="aa5f6-271">이벤트 신호 보내기의 이 유형은 스파스 특성 때문에 일반적인 오디오/비디오 스트리밍과 다릅니다.</span><span class="sxs-lookup"><span data-stu-id="aa5f6-271">This type of event signaling is different from regular audio/video streaming because of its sparse nature.</span></span> <span data-ttu-id="aa5f6-272">데이터 일반적으로 계속 해 서 발생 하지 않는 및 hello 간격은 하드 toopredict 수 신호 hello 즉,</span><span class="sxs-lookup"><span data-stu-id="aa5f6-272">In other words, hello signaling data usually does not happen continuously, and hello interval can be hard toopredict.</span></span> <span data-ttu-id="aa5f6-273">스파스 트랙의 hello 개념은 설계 된 tooingest 브로드캐스트 밴드 신호 데이터.</span><span class="sxs-lookup"><span data-stu-id="aa5f6-273">hello concept of sparse track was designed tooingest and broadcast in-band signaling data.</span></span>

<span data-ttu-id="aa5f6-274">hello 다음 단계는 스파스 트랙을 수집 하는 방법에 대 한 권장된 구현.</span><span class="sxs-lookup"><span data-stu-id="aa5f6-274">hello following steps are a recommended implementation for ingesting sparse track:</span></span>

1. <span data-ttu-id="aa5f6-275">오디오/비디오 트랙 없이 스파스 트랙만 포함하는 별도의 조각화된 MP4 비트스트림을 생성합니다.</span><span class="sxs-lookup"><span data-stu-id="aa5f6-275">Create a separate fragmented MP4 bitstream that contains only sparse tracks, without audio/video tracks.</span></span>
2. <span data-ttu-id="aa5f6-276">Hello에 **서버 매니페스트 상자 라이브** hello를 사용 하 여에 정의 된 대로 섹션 6에 [1]의 *parentTrackName* hello 부모 트랙의 매개 변수 toospecify hello 이름입니다. 자세한 내용은 [1]의 섹션 4.2.1.2.1.2를 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="aa5f6-276">In hello **Live Server Manifest Box** as defined in Section 6 in [1], use hello *parentTrackName* parameter toospecify hello name of hello parent track. For more information, see section 4.2.1.2.1.2 in [1].</span></span>
3. <span data-ttu-id="aa5f6-277">Hello에 **서버 매니페스트 상자 라이브**, **manifestOutput** 너무 설정 되어 있어야**true**합니다.</span><span class="sxs-lookup"><span data-stu-id="aa5f6-277">In hello **Live Server Manifest Box**, **manifestOutput** MUST be set too**true**.</span></span>
4. <span data-ttu-id="aa5f6-278">이벤트 신호를 보내는 hello의 hello 스파스 특성에 지정 된 경우 hello 다음을 좋습니다.</span><span class="sxs-lookup"><span data-stu-id="aa5f6-278">Given hello sparse nature of hello signaling event, we recommended hello following:</span></span>
   
    <span data-ttu-id="aa5f6-279">a.</span><span class="sxs-lookup"><span data-stu-id="aa5f6-279">a.</span></span> <span data-ttu-id="aa5f6-280">Hello 라이브 이벤트의 hello 맨 hello 인코더 hello 클라이언트 매니페스트에 hello 서비스 tooregister hello 스파스 트랙 수 있는 toohello 서비스 hello 초기 헤더 상자를 보냅니다.</span><span class="sxs-lookup"><span data-stu-id="aa5f6-280">At hello beginning of hello live event, hello encoder sends hello initial header boxes toohello service, which allows hello service tooregister hello sparse track in hello client manifest.</span></span>
   
    <span data-ttu-id="aa5f6-281">b.</span><span class="sxs-lookup"><span data-stu-id="aa5f6-281">b.</span></span> <span data-ttu-id="aa5f6-282">데이터가 전송 되지 않으므로 때 hello 인코더 hello HTTP POST 요청을 종료 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="aa5f6-282">hello encoder SHOULD terminate hello HTTP POST request when data is not being sent.</span></span> <span data-ttu-id="aa5f6-283">데이터를 보내지 않는 장기 실행 HTTP POST 서비스 업데이트 또는 서버 재부팅 hello 이벤트의 hello 인코더에서 신속 하 게 연결 끊기에서 미디어 서비스를 방지할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="aa5f6-283">A long-running HTTP POST that does not send data can prevent Media Services from quickly disconnecting from hello encoder in hello event of a service update or server reboot.</span></span> <span data-ttu-id="aa5f6-284">이러한 경우 hello 미디어 서버 hello 소켓에서 수신 작업에서 일시적으로 차단 됩니다.</span><span class="sxs-lookup"><span data-stu-id="aa5f6-284">In these cases, hello media server is temporarily blocked in a receive operation on hello socket.</span></span>
   
    <span data-ttu-id="aa5f6-285">c.</span><span class="sxs-lookup"><span data-stu-id="aa5f6-285">c.</span></span> <span data-ttu-id="aa5f6-286">데이터를 신호 없는 경우 사용할 수 없는 hello 시간 동안 hello 인코더 hello HTTP POST 요청을 닫아야 합니다.</span><span class="sxs-lookup"><span data-stu-id="aa5f6-286">During hello time when signaling data is not available, hello encoder SHOULD close hello HTTP POST request.</span></span> <span data-ttu-id="aa5f6-287">Hello POST 요청이 활성 상태인 동안 hello 인코더 데이터를 보내야 합니다.</span><span class="sxs-lookup"><span data-stu-id="aa5f6-287">While hello POST request is active, hello encoder SHOULD send data.</span></span>

    <span data-ttu-id="aa5f6-288">d.</span><span class="sxs-lookup"><span data-stu-id="aa5f6-288">d.</span></span> <span data-ttu-id="aa5f6-289">스파스 조각을 보낼 때 hello 인코더 사용 가능한 경우 명시적 콘텐츠 길이 헤더를 설정할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="aa5f6-289">When sending sparse fragments, hello encoder can set an explicit content-length header, if it’s available.</span></span>

    <span data-ttu-id="aa5f6-290">e.</span><span class="sxs-lookup"><span data-stu-id="aa5f6-290">e.</span></span> <span data-ttu-id="aa5f6-291">새 연결 된 스파스 조각을 보낼 때 hello 인코더 뒤에 새 조각을 hello hello 헤더 상자에서 보내기 시작 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="aa5f6-291">When sending sparse fragments with a new connection, hello encoder SHOULD start sending from hello header boxes, followed by hello new fragments.</span></span> <span data-ttu-id="aa5f6-292">사이, 발생 하는 장애 조치의 경우 이것이 hello 새 스파스 연결 하기 전에 hello 스파스 트랙 찾을 수 없습니다. 설정 된 tooa 새 서버 되 고 있습니다.</span><span class="sxs-lookup"><span data-stu-id="aa5f6-292">This is for cases in which failover happens in-between, and hello new sparse connection is being established tooa new server that has not seen hello sparse track before.</span></span>

    <span data-ttu-id="aa5f6-293">f.</span><span class="sxs-lookup"><span data-stu-id="aa5f6-293">f.</span></span> <span data-ttu-id="aa5f6-294">hello 스파스 트랙 조각 hello 해당 부모 트랙 조각 값을 같거나 더 큰 타임 스탬프 값이 사용 가능한 toohello 클라이언트 만들어질 때 사용할 수 있는 toohello 클라이언트 됩니다.</span><span class="sxs-lookup"><span data-stu-id="aa5f6-294">hello sparse track fragment becomes available toohello client when hello corresponding parent track fragment that has an equal or larger timestamp value is made available toohello client.</span></span> <span data-ttu-id="aa5f6-295">예를 들어 hello 스파스 조각에는 t의 타임 스탬프 = 1000, 하는 hello 클라이언트 "비디오" ("비디오" hello 부모 트랙 이름 라고 가정함) 조각 1000 타임 스탬프 또는 beyond, 다운로드할 수를 표시 한 후 hello 스파스 조각 t 것으로 예상 = 1000입니다.</span><span class="sxs-lookup"><span data-stu-id="aa5f6-295">For example, if hello sparse fragment has a timestamp of t=1000, it is expected that after hello client sees "video" (assuming hello parent track name is "video") fragment timestamp 1000 or beyond, it can download hello sparse fragment t=1000.</span></span> <span data-ttu-id="aa5f6-296">실제 신호 hello는 지정 된 용도 대 한 hello 프레젠테이션 타임 라인에서 다른 위치에 대해 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="aa5f6-296">Note that hello actual signal could be used for a different position in hello presentation timeline for its designated purpose.</span></span> <span data-ttu-id="aa5f6-297">이 예제에서는 t의 스파스 조각 hello 가능한의 = 1000의 위치를 몇 초 후에 광고를 삽입 하는 데 사용 되는 XML 페이로드는 나중에 있습니다.</span><span class="sxs-lookup"><span data-stu-id="aa5f6-297">In this example, it’s possible that hello sparse fragment of t=1000 has an XML payload, which is for inserting an ad in a position that’s a few seconds later.</span></span>

    <span data-ttu-id="aa5f6-298">g.</span><span class="sxs-lookup"><span data-stu-id="aa5f6-298">g.</span></span> <span data-ttu-id="aa5f6-299">스파스 트랙 조각의 hello 페이로드 hello 시나리오에 따라 서로 다른 형식 (예: XML, 텍스트 또는 이진) 될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="aa5f6-299">hello payload of sparse track fragments can be in different formats (such as XML, text, or binary), depending on hello scenario.</span></span>

### <a name="redundant-audio-track"></a><span data-ttu-id="aa5f6-300">중복 오디오 트랙</span><span class="sxs-lookup"><span data-stu-id="aa5f6-300">Redundant audio track</span></span>
<span data-ttu-id="aa5f6-301">일반적인 HTTP 적응 스트리밍 시나리오 (예: 부드러운 스트리밍 또는 대시) 종종, 즉 hello 전체 프레젠테이션에서 오디오 트랙을 하나만 있습니다.</span><span class="sxs-lookup"><span data-stu-id="aa5f6-301">In a typical HTTP adaptive streaming scenario (for example, Smooth Streaming or DASH), often, there's only one audio track in hello entire presentation.</span></span> <span data-ttu-id="aa5f6-302">오류 조건에에서 클라이언트 toochoose hello에 대 한 여러 품질 수준이 있는 비디오 트랙 달리 hello 오디오 트랙 hello hello 오디오 트랙을 포함 하는 hello 스트림의 수집 중단 된 단일 실패 지점이 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="aa5f6-302">Unlike video tracks, which have multiple quality levels for hello client toochoose from in error conditions, hello audio track can be a single point of failure if hello ingestion of hello stream that contains hello audio track is broken.</span></span> 

<span data-ttu-id="aa5f6-303">이 문제를 미디어 서비스 지원 toosolve 라이브 중복 오디오 트랙의 수집 합니다.</span><span class="sxs-lookup"><span data-stu-id="aa5f6-303">toosolve this problem, Media Services supports live ingestion of redundant audio tracks.</span></span> <span data-ttu-id="aa5f6-304">hello 개념은 해당 hello 동일한 오디오 트랙 다양 한 스트림에 여러 번 보낼 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="aa5f6-304">hello idea is that hello same audio track can be sent multiple times in different streams.</span></span> <span data-ttu-id="aa5f6-305">Hello 서비스만 등록 hello 오디오 트랙 한 번 hello 클라이언트 매니페스트에 있지만 사용할 수 있습니다 중복 오디오 트랙으로 백업 hello 주 오디오 트랙에 문제가 오디오 조각을 검색에 대 한 합니다.</span><span class="sxs-lookup"><span data-stu-id="aa5f6-305">Although hello service only registers hello audio track once in hello client manifest, it can use redundant audio tracks as backups for retrieving audio fragments if hello primary audio track has issues.</span></span> <span data-ttu-id="aa5f6-306">중복 오디오 트랙 tooingest hello 인코더를 해야합니다.</span><span class="sxs-lookup"><span data-stu-id="aa5f6-306">tooingest redundant audio tracks, hello encoder needs to:</span></span>

1. <span data-ttu-id="aa5f6-307">여러 조각 MP4 bitstreams에에서 동일한 오디오 트랙 hello를 만듭니다.</span><span class="sxs-lookup"><span data-stu-id="aa5f6-307">Create hello same audio track in multiple fragment MP4 bitstreams.</span></span> <span data-ttu-id="aa5f6-308">hello 중복 오디오 트랙 의미론적으로 동일 해야, hello로 동일 타임 스탬프를 조각화 하 고 hello 헤더 및 조각 수준에서 서로 바꿔 사용할 합니다.</span><span class="sxs-lookup"><span data-stu-id="aa5f6-308">hello redundant audio tracks MUST be semantically equivalent, with hello same fragment timestamps, and be interchangeable at hello header and fragment levels.</span></span>
2. <span data-ttu-id="aa5f6-309">해당 hello "오디오" 항목을 확인 hello에 라이브 서버 매니페스트 ([1] 섹션 6)은 hello 동일 중복 오디오 트랙에 대 한 합니다.</span><span class="sxs-lookup"><span data-stu-id="aa5f6-309">Ensure that hello “audio” entry in hello Live Server Manifest (Section 6 in [1]) is hello same for all redundant audio tracks.</span></span>

<span data-ttu-id="aa5f6-310">구현은 다음 hello 중복 오디오 트랙에 대 한 것이 좋습니다.</span><span class="sxs-lookup"><span data-stu-id="aa5f6-310">hello following implementation is recommended for redundant audio tracks:</span></span>

1. <span data-ttu-id="aa5f6-311">하나의 스트림에서 자체적으로 고유한 각 오디오 트랙을 전송합니다.</span><span class="sxs-lookup"><span data-stu-id="aa5f6-311">Send each unique audio track in a stream by itself.</span></span> <span data-ttu-id="aa5f6-312">또한 이러한 오디오 트랙 스트림의 여기서 두 번째 스트림의 hello와 다른 hello에서 먼저 hello HTTP POST URL에서에서 hello 식별자로만 각각에 대해 중복 스트림을 보낼: {프로토콜}:// {서버 주소} / {지점 path}/Streams({identifier}) 게시 합니다.</span><span class="sxs-lookup"><span data-stu-id="aa5f6-312">Also, send a redundant stream for each of these audio track streams, where hello second stream differs from hello first only by hello identifier in hello HTTP POST URL: {protocol}://{server address}/{publishing point path}/Streams({identifier}).</span></span>
2. <span data-ttu-id="aa5f6-313">별도 스트림을 toosend hello 두 개의 가장 낮은 비디오 비트 전송률을 사용 합니다.</span><span class="sxs-lookup"><span data-stu-id="aa5f6-313">Use separate streams toosend hello two lowest video bitrates.</span></span> <span data-ttu-id="aa5f6-314">이 스트림 각각은 각 고유한 오디오 트랙 각각의 복사본도 포함해야 합니다. 예를 들어, 여러 언어가 지원되는 경우 이 스트림은 각 언어에 대한 오디오 트랙을 포함해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="aa5f6-314">Each of these streams SHOULD also contain a copy of each unique audio track. For example, when multiple languages are supported, these streams SHOULD contain audio tracks for each language.</span></span>
3. <span data-ttu-id="aa5f6-315">별도 서버 (인코더) 인스턴스 tooencode를 사용 하 고에 언급 된 hello 중복 스트림 (1) 및 (2)를 보냅니다.</span><span class="sxs-lookup"><span data-stu-id="aa5f6-315">Use separate server (encoder) instances tooencode and send hello redundant streams mentioned in (1) and (2).</span></span> 

## <a name="media-services-learning-paths"></a><span data-ttu-id="aa5f6-316">미디어 서비스 학습 경로</span><span class="sxs-lookup"><span data-stu-id="aa5f6-316">Media Services learning paths</span></span>
[!INCLUDE [media-services-learning-paths-include](../../includes/media-services-learning-paths-include.md)]

## <a name="provide-feedback"></a><span data-ttu-id="aa5f6-317">피드백 제공</span><span class="sxs-lookup"><span data-stu-id="aa5f6-317">Provide feedback</span></span>
[!INCLUDE [media-services-user-voice-include](../../includes/media-services-user-voice-include.md)]

[image1]: ./media/media-services-fmp4-live-ingest-overview/media-services-image1.png
[image2]: ./media/media-services-fmp4-live-ingest-overview/media-services-image2.png
[image3]: ./media/media-services-fmp4-live-ingest-overview/media-services-image3.png
[image4]: ./media/media-services-fmp4-live-ingest-overview/media-services-image4.png
[image5]: ./media/media-services-fmp4-live-ingest-overview/media-services-image5.png
[image6]: ./media/media-services-fmp4-live-ingest-overview/media-services-image6.png
[image7]: ./media/media-services-fmp4-live-ingest-overview/media-services-image7.png
