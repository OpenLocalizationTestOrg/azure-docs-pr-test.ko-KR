---
title: "웹 API 및 REST API를 커넥터로 만들기 - Azure Logic Apps | Microsoft Docs"
description: "Azure Logic Apps와 시스템을 통합하기 위해 워크플로에서 API, 서비스 또는 시스템을 호출하는 웹 API 및 REST API를 만듭니다."
keywords: "웹 API, REST API, 커넥터, 워크플로, 시스템 통합"
services: logic-apps
author: jeffhollan
manager: anneta
editor: 
documentationcenter: 
ms.assetid: bd229179-7199-4aab-bae0-1baf072c7659
ms.service: logic-apps
ms.workload: integration
ms.tgt_pltfrm: na
ms.devlang: na
ms.topic: article
ms.date: 5/26/2017
ms.author: LADocs; jehollan
ms.openlocfilehash: 4ae98804aced23c0261c1d58721cb18d8152c6f1
ms.sourcegitcommit: f537befafb079256fba0529ee554c034d73f36b0
ms.translationtype: MT
ms.contentlocale: ko-KR
ms.lasthandoff: 07/11/2017
---
# <a name="create-custom-apis-as-connectors-for-logic-apps"></a><span data-ttu-id="96e29-104">사용자 지정 API를 논리 앱용 커넥터로 만들기</span><span class="sxs-lookup"><span data-stu-id="96e29-104">Create custom APIs as connectors for logic apps</span></span>

<span data-ttu-id="96e29-105">Azure Logic Apps는 논리 앱 워크플로에서 사용할 수 있는[100개 이상의 기본 제공 커넥터](../connectors/apis-list.md)를 제공하지만, 커넥터로 사용할 수 없는 API, 시스템 및 서비스를 호출하는 것이 좋을 수도 있습니다.</span><span class="sxs-lookup"><span data-stu-id="96e29-105">Although Azure Logic Apps offers [100+ built-in connectors](../connectors/apis-list.md) that you can use in logic app workflows, you might want to call APIs, systems, and services that aren't available as connectors.</span></span> <span data-ttu-id="96e29-106">논리 앱에서 사용할 동작과 트리거를 제공하는 사용자 지정 API는 직접 만들 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="96e29-106">You can create your own custom APIs that provide actions and triggers to use in logic apps.</span></span> <span data-ttu-id="96e29-107">논리 앱에서 커넥터로 사용할 API를 직접 만들려는 다른 이유는 다음가 같습니다.</span><span class="sxs-lookup"><span data-stu-id="96e29-107">Here are other reasons why you might want to create your own APIs to use as connectors in logic apps:</span></span>

* <span data-ttu-id="96e29-108">현재의 시스템 통합 및 데이터 통합 워크플로를 확장합니다.</span><span class="sxs-lookup"><span data-stu-id="96e29-108">Extend your current system integration and data integration workflows.</span></span>
* <span data-ttu-id="96e29-109">고객이 서비스를 사용하여 전문적이거나 개인적인 작업을 관리할 수 있도록 지원합니다.</span><span class="sxs-lookup"><span data-stu-id="96e29-109">Help customers use your service to manage professional or personal tasks.</span></span>
* <span data-ttu-id="96e29-110">서비스에 대한 범위, 검색 기능 및 사용을 확장합니다.</span><span class="sxs-lookup"><span data-stu-id="96e29-110">Expand the reach, discoverability, and use for your service.</span></span>

<span data-ttu-id="96e29-111">기본적으로 커넥터는 플러그형 인터페이스에 대한 REST, 문서에 대한 [Swagger 메타데이터 형식](http://swagger.io/specification/) 및 JSON(데이터 교환 형식)을 사용하는 웹 API입니다.</span><span class="sxs-lookup"><span data-stu-id="96e29-111">Basically, connectors are web APIs that use REST for pluggable interfaces, [Swagger metadata format](http://swagger.io/specification/) for documentation, and JSON as their data exchange format.</span></span> <span data-ttu-id="96e29-112">커넥터는 HTTP 끝점을 통해 통신하는 REST API이므로 .NET, Java 또는 Node.js와 같은 언어를 사용하여 커넥터를 빌드할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="96e29-112">Because connectors are REST APIs that communicate through HTTP endpoints, you can use any language, like .NET, Java, or Node.js, for building connectors.</span></span> <span data-ttu-id="96e29-113">API 호스팅을 위한 가장 쉽고, 확장성 있는, 최상의 방법 중 하나를 제공하는 PaaS(Platform-as-a-Service) 제품인 [Azure App Service](../app-service/app-service-value-prop-what-is.md)에서 API를 호스팅할 수도 있습니다.</span><span class="sxs-lookup"><span data-stu-id="96e29-113">You can also host your APIs on [Azure App Service](../app-service/app-service-value-prop-what-is.md), a platform-as-a-service (PaaS) offering that provides one of the best, easiest, and most scalable ways for API hosting.</span></span> 

<span data-ttu-id="96e29-114">사용자 지정 API가 논리 앱에서 작동하려면 API가 논리 앱 워크플로에서 특정 작업을 수행하는 [*동작*](./logic-apps-what-are-logic-apps.md#logic-app-concepts)을 제공할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="96e29-114">For custom APIs to work with logic apps, your API can provide [*actions*](./logic-apps-what-are-logic-apps.md#logic-app-concepts) that perform specific tasks in logic app workflows.</span></span> <span data-ttu-id="96e29-115">또한 API는 [*트리거*](./logic-apps-what-are-logic-apps.md#logic-app-concepts)의 역할을 수행하여 새 데이터 또는 이벤트가 지정된 조건을 충족할 때 논리 앱 워크플로를 시작할 수도 있습니다.</span><span class="sxs-lookup"><span data-stu-id="96e29-115">Your API can also act as a [*trigger*](./logic-apps-what-are-logic-apps.md#logic-app-concepts) that starts a logic app workflow when new data or an event meets a specified condition.</span></span> <span data-ttu-id="96e29-116">이 항목에서는 API에서 제공할 동작에 따라 API에서 동작과 트리거를 빌드할 때 따라야 하는 일반적인 패턴에 대해 설명합니다.</span><span class="sxs-lookup"><span data-stu-id="96e29-116">This topic describes common patterns that you can follow for building actions and triggers in your API, based on the behavior that you want your API to provide.</span></span>

> [!TIP] 
> <span data-ttu-id="96e29-117">API를 [웹앱](../app-service-web/app-service-web-overview.md)으로 배포할 수 있지만 [API 앱](../app-service-api/app-service-api-apps-why-best-platform.md)으로 배포하는 것이 좋습니다. 이렇게 하면 클라우드에서 API를 빌드, 호스팅 및 사용할 때 작업을 더 쉽게 수행할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="96e29-117">Although you can deploy your APIs as [web apps](../app-service-web/app-service-web-overview.md), consider deploying your APIs as [API apps](../app-service-api/app-service-api-apps-why-best-platform.md), which can make your job easier when you build, host, and consume APIs in the cloud and on premises.</span></span> <span data-ttu-id="96e29-118">API에서 코드를 변경할 필요가 없이 API 앱에 코드를 배포하기만 하면 됩니다.</span><span class="sxs-lookup"><span data-stu-id="96e29-118">You don't have to change any code in your APIs -- just deploy your code to an API app.</span></span> <span data-ttu-id="96e29-119">[ASP.NET](../app-service-api/app-service-api-dotnet-get-started.md), [Java](../app-service-api/app-service-api-java-api-app.md) 또는 [Node.js](../app-service-api/app-service-api-nodejs-api-app.md)로 만든 API 앱을 빌드하는 방법에 대해 알아보세요.</span><span class="sxs-lookup"><span data-stu-id="96e29-119">Learn how to [build API apps created with ASP.NET](../app-service-api/app-service-api-dotnet-get-started.md), [Java](../app-service-api/app-service-api-java-api-app.md), or [Node.js](../app-service-api/app-service-api-nodejs-api-app.md).</span></span> 
>
> <span data-ttu-id="96e29-120">논리 앱용으로 빌드된 API 앱 샘플은 [Azure Logic Apps GitHub 리포지토리](http://github.com/logicappsio) 또는 [블로그](http://aka.ms/logicappsblog)를 방문하세요.</span><span class="sxs-lookup"><span data-stu-id="96e29-120">For API App samples built for logic apps, visit the [Azure Logic Apps GitHub repository](http://github.com/logicappsio) or [blog](http://aka.ms/logicappsblog).</span></span>

## <a name="helpful-tools"></a><span data-ttu-id="96e29-121">유용한 도구</span><span class="sxs-lookup"><span data-stu-id="96e29-121">Helpful tools</span></span>

<span data-ttu-id="96e29-122">API 작업 및 매개 변수를 설명하는 [Swagger 문서](http://swagger.io/specification/)도 API에 있으면 사용자 지정 API가 논리 앱에서 가장 잘 작동합니다.</span><span class="sxs-lookup"><span data-stu-id="96e29-122">A custom API works best with logic apps when the API also has a [Swagger document](http://swagger.io/specification/) that describes the API's operations and parameters.</span></span>
<span data-ttu-id="96e29-123">많은 라이브러리(예: [Swashbuckle](https://github.com/domaindrivendev/Swashbuckle))에서 Swagger 파일을 자동으로 생성할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="96e29-123">Many libraries, like [Swashbuckle](https://github.com/domaindrivendev/Swashbuckle), can automatically generate the Swagger file for you.</span></span> <span data-ttu-id="96e29-124">또한 Swagger 파일에 표시 이름, 속성 형식 등에 주석을 달려면 [TRex](https://github.com/nihaue/TRex)를 사용하여 Swagger 파일이 논리 앱에서 잘 작동하도록 할 수도 있습니다.</span><span class="sxs-lookup"><span data-stu-id="96e29-124">To annotate the Swagger file for display names, property types, and so on, you can also use [TRex](https://github.com/nihaue/TRex) so that your Swagger file works well with logic apps.</span></span>

<a name="actions"></a>

## <a name="action-patterns"></a><span data-ttu-id="96e29-125">동작 패턴</span><span class="sxs-lookup"><span data-stu-id="96e29-125">Action patterns</span></span>

<span data-ttu-id="96e29-126">논리 앱에서 작업을 수행하려면 사용자 지정 API에서 [*동작*](./logic-apps-what-are-logic-apps.md#logic-app-concepts)을 제공해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="96e29-126">For logic apps to perform tasks, your custom API should provide [*actions*](./logic-apps-what-are-logic-apps.md#logic-app-concepts).</span></span> <span data-ttu-id="96e29-127">API 작업 각각은 동작에 맵핑됩니다.</span><span class="sxs-lookup"><span data-stu-id="96e29-127">Each operation in your API maps to an action.</span></span> <span data-ttu-id="96e29-128">기본 동작은 HTTP 요청을 받아들이고 HTTP 응답을 반환하는 컨트롤러입니다.</span><span class="sxs-lookup"><span data-stu-id="96e29-128">A basic action is a controller that accepts HTTP requests and returns HTTP responses.</span></span> <span data-ttu-id="96e29-129">예를 들어 논리 앱은 웹앱 또는 API 앱에 HTTP 요청을 보냅니다.</span><span class="sxs-lookup"><span data-stu-id="96e29-129">So for example, a logic app sends an HTTP request to your web app or API app.</span></span> <span data-ttu-id="96e29-130">그런 다음 앱은 논리 앱에서 처리할 수 있는 내용과 함께 HTTP 응답을 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="96e29-130">Your app then returns an HTTP response, along with content that the logic app can process.</span></span>

<span data-ttu-id="96e29-131">표준 동작의 경우 API에 HTTP 요청 메서드를 작성하고 해당 메서드를 Swagger 파일에 설명할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="96e29-131">For a standard action, you can write an HTTP request method in your API and describe that method in a Swagger file.</span></span> <span data-ttu-id="96e29-132">그런 다음 [HTTP 동작](../connectors/connectors-native-http.md) 또는 [HTTP + Swagger](../connectors/connectors-native-http-swagger.md) 동작을 사용하여 API를 직접 호출할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="96e29-132">You can then call your API directly with an [HTTP action](../connectors/connectors-native-http.md) or an [HTTP + Swagger](../connectors/connectors-native-http-swagger.md) action.</span></span> <span data-ttu-id="96e29-133">기본적으로 응답은 [요청 시간 제한](./logic-apps-limits-and-config.md) 내에 반환되어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="96e29-133">By default, responses must be returned within the [request timeout limit](./logic-apps-limits-and-config.md).</span></span> 

![표준 동작 패턴](./media/logic-apps-create-api-app/standard-action.png)

<span data-ttu-id="96e29-135"><a name="pattern-overview"></a> API에서 장기 실행 작업을 완료하는 동안 논리 앱이 대기하도록 하려면 API가 이 항목에서 설명하는 [비동기 폴링 패턴](#async-pattern) 또는 [비동기 웹후크 패턴](#webhook-actions)을 따르면 됩니다.</span><span class="sxs-lookup"><span data-stu-id="96e29-135"><a name="pattern-overview"></a> To make a logic app wait while your API finishes longer-running tasks, your API can follow the [asynchronous polling pattern](#async-pattern) or the [asynchronous webhook pattern](#webhook-actions) described in this topic.</span></span> <span data-ttu-id="96e29-136">이러한 패턴의 특이한 동작을 시각화할 수 있도록 유추하기 위해 빵집에서 사용자 지정 케이크 주문을 처리하는 프로세스를 가정해 봅니다.</span><span class="sxs-lookup"><span data-stu-id="96e29-136">For an analogy that helps you visualize these patterns' different behaviors, imagine the process for ordering a custom cake from a bakery.</span></span> <span data-ttu-id="96e29-137">폴링 패턴은 케이크가 준비되었는지 여부를 확인하기 위해 20분마다 고객이 빵집에 전화하는 동작을 미러링합니다.</span><span class="sxs-lookup"><span data-stu-id="96e29-137">The polling pattern mirrors the behavior where you call the bakery every 20 minutes to check whether the cake is ready.</span></span> <span data-ttu-id="96e29-138">웹후크 패턴은 케이크가 준비되었을 때 고객에게 전화를 걸도록 하기 위해 빵집에서 고객의 전화 번호를 요구하는 동작을 미러링합니다.</span><span class="sxs-lookup"><span data-stu-id="96e29-138">The webhook pattern mirrors the behavior where the bakery asks you for your phone number so they can call you when the cake is ready.</span></span>

<span data-ttu-id="96e29-139">샘플은 [Logic Apps GitHub 리포지토리](https://github.com/logicappsio)를 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="96e29-139">For samples, visit the [Logic Apps GitHub repository](https://github.com/logicappsio).</span></span> <span data-ttu-id="96e29-140">또한 [동작 사용량 측정](logic-apps-pricing.md)에 대해서도 자세히 알아보세요.</span><span class="sxs-lookup"><span data-stu-id="96e29-140">Also, learn more about [usage metering for actions](logic-apps-pricing.md).</span></span>

<a name="async-pattern"></a>

### <a name="perform-long-running-tasks-with-the-polling-action-pattern"></a><span data-ttu-id="96e29-141">폴링 동작 패턴으로 장기 실행 작업 수행</span><span class="sxs-lookup"><span data-stu-id="96e29-141">Perform long-running tasks with the polling action pattern</span></span>

<span data-ttu-id="96e29-142">API에서 [요청 시간 제한](./logic-apps-limits-and-config.md)보다 더 오래 실행될 수 있는 작업을 수행하도록 하려면 비동기 폴링 패턴을 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="96e29-142">To have your API perform tasks that could run longer than the [request timeout limit](./logic-apps-limits-and-config.md), you can use the asynchronous polling pattern.</span></span> <span data-ttu-id="96e29-143">이 패턴에서는 API가 별도의 스레드에서 작동하지만 Logic Apps 엔진에 대한 활성 연결을 유지합니다.</span><span class="sxs-lookup"><span data-stu-id="96e29-143">This pattern has your API do work in a separate thread, but keep an active connection to the Logic Apps engine.</span></span> <span data-ttu-id="96e29-144">이렇게 하면 API에서 작업을 완료하기 전에 논리 앱에서 시간 초과하지 않거나 워크플로의 다음 단계로 계속 진행합니다.</span><span class="sxs-lookup"><span data-stu-id="96e29-144">That way, the logic app does not time out or continue with the next step in the workflow before your API finishes working.</span></span>

<span data-ttu-id="96e29-145">다음은 일반적인 패턴입니다.</span><span class="sxs-lookup"><span data-stu-id="96e29-145">Here's the general pattern:</span></span>

1. <span data-ttu-id="96e29-146">엔진에서 API가 요청을 수락하고 작업을 시작했는지 확인합니다.</span><span class="sxs-lookup"><span data-stu-id="96e29-146">Make sure that the engine knows that your API accepted the request and started working.</span></span>
2. <span data-ttu-id="96e29-147">엔진에서 작업 상태에 대한 후속 요청을 하면 API에서 작업을 완료할 때 엔진에 알립니다.</span><span class="sxs-lookup"><span data-stu-id="96e29-147">When the engine makes subsequent requests for job status, let the engine know when your API finishes the task.</span></span>
3. <span data-ttu-id="96e29-148">논리 앱 워크플로를 계속할 수 있도록 관련 데이터를 엔진에 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="96e29-148">Return relevant data to the engine so that the logic app workflow can continue.</span></span>

<span data-ttu-id="96e29-149"><a name="bakery-polling-action"></a> 이제 폴링 패턴에 앞서의 빵집 유추를 적용하고, 빵집에 전화를 걸어 배달용 사용자 지정 케이크를 주문한다고 가정합니다.</span><span class="sxs-lookup"><span data-stu-id="96e29-149"><a name="bakery-polling-action"></a> Now apply the previous bakery analogy to the polling pattern, and imagine that you call a bakery and order a custom cake for delivery.</span></span> <span data-ttu-id="96e29-150">케이크를 만드는 과정에 시간이 걸리고, 빵집에서 케이크를 만드는 동안은 빵집의 전화를 기다리지 않으려고 합니다.</span><span class="sxs-lookup"><span data-stu-id="96e29-150">The process for making the cake takes time, and you don't want to wait on the phone while the bakery works on the cake.</span></span> <span data-ttu-id="96e29-151">빵집에서 주문을 확인하고 케이크 상태에 대해 20분마다 고객에게 전화를 겁니다.</span><span class="sxs-lookup"><span data-stu-id="96e29-151">The bakery confirms your order and has you call every 20 minutes for the cake's status.</span></span> <span data-ttu-id="96e29-152">20분이 지나면 빵집에 전화를 걸지만, 케이크가 아직 완성되지 않았고 20분 후에 고객이 다시 전화해야 한다고 알려줍니다.</span><span class="sxs-lookup"><span data-stu-id="96e29-152">After 20 minutes pass, you call the bakery, but they tell you that your cake isn't done and that you should call in another 20 minutes.</span></span> <span data-ttu-id="96e29-153">이 앞뒤 과정은 고객이 전화할 때까지 계속되며, 빵집에서는 주문이 준비되어 케이크를 배달한다고 알려줍니다.</span><span class="sxs-lookup"><span data-stu-id="96e29-153">This back-and-forth process continues until you call, and the bakery tells you that your order is ready and delivers your cake.</span></span> 

<span data-ttu-id="96e29-154">이제 폴링 패턴을 다시 매핑해 보겠습니다.</span><span class="sxs-lookup"><span data-stu-id="96e29-154">So let's map this polling pattern back.</span></span> <span data-ttu-id="96e29-155">빵집은 사용자 지정 API를 나타내고, 케이크를 주문한 고객은 Logic Apps 엔진을 나타냅니다.</span><span class="sxs-lookup"><span data-stu-id="96e29-155">The bakery represents your custom API, while you, the cake customer, represent the Logic Apps engine.</span></span> <span data-ttu-id="96e29-156">엔진에서 요청을 통해 API를 호출하면, API는 요청을 확인하고 엔진에서 작업 상태를 확인할 수 있는 간격으로 응답합니다.</span><span class="sxs-lookup"><span data-stu-id="96e29-156">When the engine calls your API with a request, your API confirms the request and responds with the time interval when the engine can check job status.</span></span> <span data-ttu-id="96e29-157">API에서 작업을 완료했다고 응답하고 논리 앱에 데이터를 반환할 때까지 엔진에서는 작업 상태를 계속 확인한 다음 워크플로를 계속 진행합니다.</span><span class="sxs-lookup"><span data-stu-id="96e29-157">The engine continues checking job status until your API responds that the job is done and returns data to your logic app, which then continues workflow.</span></span> 

![폴링 동작 패턴](./media/logic-apps-create-api-app/custom-api-async-action-pattern.png)

<span data-ttu-id="96e29-159">API의 관점에서 설명하는 API의 구체적인 수행 단계는 다음과 같습니다.</span><span class="sxs-lookup"><span data-stu-id="96e29-159">Here are the specific steps for your API to follow, described from the API's perspective:</span></span>

1. <span data-ttu-id="96e29-160">API에서 작업을 시작하라는 HTTP 요청을 받으면 이 단계의 뒷부분에서 설명하는 `location` 헤더가 있는 HTTP `202 ACCEPTED` 응답을 즉시 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="96e29-160">When your API gets an HTTP request to start work, immediately return an HTTP `202 ACCEPTED` response with the `location` header described later in this step.</span></span> <span data-ttu-id="96e29-161">Logic Apps 엔진에서는 이 응답을 통해 API가 요청을 받고 요청 페이로드(데이터 입력)를 수락하여 현재 처리 중임을 확인할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="96e29-161">This response lets the Logic Apps engine know that your API got the request, accepted the request payload (data input), and is now processing.</span></span> 
   
   <span data-ttu-id="96e29-162">`202 ACCEPTED` 응답에는 다음과 같은 헤더가 포함되어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="96e29-162">The `202 ACCEPTED` response should include these headers:</span></span>
   
   * <span data-ttu-id="96e29-163">*필수*: Logic Apps 엔진이 API의 작업 상태를 확인할 수 있는 URL의 절대 경로를 지정하는 `location` 헤더</span><span class="sxs-lookup"><span data-stu-id="96e29-163">*Required*: A `location` header that specifies the absolute path to a URL where the Logic Apps engine can check your API's job status</span></span>

   * <span data-ttu-id="96e29-164">*선택*: 작업 상태에 대해 `location` URL을 확인하기 전에 엔진에서 대기해야 하는 시간(초)을 지정하는 `retry-after` 헤더</span><span class="sxs-lookup"><span data-stu-id="96e29-164">*Optional*: A `retry-after` header that specifies the number of seconds that the engine should wait before checking the `location` URL for job status.</span></span> 

     <span data-ttu-id="96e29-165">기본적으로 엔진은 매 20초마다 확인합니다.</span><span class="sxs-lookup"><span data-stu-id="96e29-165">By default, the engine checks every 20 seconds.</span></span> <span data-ttu-id="96e29-166">다른 간격을 지정하려면 `retry-after` 헤더와 다음 폴링까지의 시간(초)을 포함합니다.</span><span class="sxs-lookup"><span data-stu-id="96e29-166">To specify a different interval, include the `retry-after` header and the number of seconds until the next poll.</span></span>

2. <span data-ttu-id="96e29-167">지정된 시간이 지나면 Logic Apps 엔진에서 `location` URL을 폴링하여 작업 상태를 확인합니다.</span><span class="sxs-lookup"><span data-stu-id="96e29-167">After the specified time passes, the Logic Apps engine polls the `location` URL to check job status.</span></span> <span data-ttu-id="96e29-168">API는 이러한 검사를 수행하고 다음과 같은 응답을 반환해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="96e29-168">Your API should perform these checks and return these responses:</span></span>
   
   * <span data-ttu-id="96e29-169">작업이 완료되면 응답 페이로드(다음 단계에 대한 입력)와 함께 HTTP `200 OK` 응답을 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="96e29-169">If the job is done, return an HTTP `200 OK` response, along with the response payload (input for the next step).</span></span>

   * <span data-ttu-id="96e29-170">작업이 아직 처리 중인 경우 원래 응답과 동일한 헤더가 포함된 다른 HTTP `202 ACCEPTED` 응답을 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="96e29-170">If the job is still processing, return another HTTP `202 ACCEPTED` response, but with the same headers as the original response.</span></span>

<span data-ttu-id="96e29-171">API가 이 패턴을 따르는 경우 작업 상태를 계속 확인하기 위해 논리 앱 워크플로 정의에서 어떤 작업도 수행할 필요가 없습니다.</span><span class="sxs-lookup"><span data-stu-id="96e29-171">When your API follows this pattern, you don't have to do anything in the logic app workflow definition to continue checking job status.</span></span> <span data-ttu-id="96e29-172">엔진이 HTTP `202 ACCEPTED` 응답과 유효한 `location` 헤더를 가져오면 비동기 패턴을 고려하여 API에서 202가 아닌 응답을 반환할 때까지 엔진에서 `location` 헤더를 확인합니다.</span><span class="sxs-lookup"><span data-stu-id="96e29-172">When the engine gets an HTTP `202 ACCEPTED` response and a valid `location` header, the engine respects the asynchronous pattern and checks the `location` header until your API returns a non-202 response.</span></span>

> [!TIP]
> <span data-ttu-id="96e29-173">비동기 패턴 예제는 [GitHub의 비동기 컨트롤러 응답 샘플](https://github.com/logicappsio/LogicAppsAsyncResponseSample)(영문)을 검토하세요.</span><span class="sxs-lookup"><span data-stu-id="96e29-173">For an example asynchronous pattern, review this [asynchronous controller response sample in GitHub](https://github.com/logicappsio/LogicAppsAsyncResponseSample).</span></span>

<a name="webhook-actions"></a>

### <a name="perform-long-running-tasks-with-the-webhook-action-pattern"></a><span data-ttu-id="96e29-174">웹후크 동작 패턴으로 장기 실행 작업 수행</span><span class="sxs-lookup"><span data-stu-id="96e29-174">Perform long-running tasks with the webhook action pattern</span></span>

<span data-ttu-id="96e29-175">대안으로 장기 실행 작업과 비동기 처리에 대해 웹후크 패턴을 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="96e29-175">As an alternative, you can use the webhook pattern for long-running tasks and asynchronous processing.</span></span> <span data-ttu-id="96e29-176">이 패턴에는 논리 앱이 일시 중지되고 워크플로를 계속하기 전에 API로부터 "콜백"할 때까지 기다립니다.</span><span class="sxs-lookup"><span data-stu-id="96e29-176">This pattern has the logic app pause and wait for a "callback" from your API to finish processing before continuing workflow.</span></span> <span data-ttu-id="96e29-177">이 콜백은 이벤트 발생 시 URL에 메시지를 보내는 HTTP POST입니다.</span><span class="sxs-lookup"><span data-stu-id="96e29-177">This callback is an HTTP POST that sends a message to a URL when an event happens.</span></span> 

<span data-ttu-id="96e29-178"><a name="bakery-webhook-action"></a> 이제 웹후크 패턴에 앞서의 빵집 유추를 적용하고, 빵집에 전화를 걸어 배달용 사용자 지정 케이크를 주문한다고 가정합니다.</span><span class="sxs-lookup"><span data-stu-id="96e29-178"><a name="bakery-webhook-action"></a> Now apply the previous bakery analogy to the webhook pattern, and imagine that you call a bakery and order a custom cake for delivery.</span></span> <span data-ttu-id="96e29-179">케이크를 만드는 과정에 시간이 걸리고, 빵집에서 케이크를 만드는 동안은 빵집의 전화를 기다리지 않으려고 합니다.</span><span class="sxs-lookup"><span data-stu-id="96e29-179">The process for making the cake takes time, and you don't want to wait on the phone while the bakery works on the cake.</span></span> <span data-ttu-id="96e29-180">빵집에서 주문을 확인하지만, 이번에는 케이크가 완성되었을 때 빵집에서 전화할 수 있도록 고객이 자신의 전화 번호를 빵집에 알려줍니다.</span><span class="sxs-lookup"><span data-stu-id="96e29-180">The bakery confirms your order, but this time, you give them your phone number so they can call you when the cake is done.</span></span> <span data-ttu-id="96e29-181">이번에는 주문이 준비되어 케이크를 배달할 때 빵집에서 고객에게 알려줍니다.</span><span class="sxs-lookup"><span data-stu-id="96e29-181">This time, the bakery tells you when your order is ready and delivers your cake.</span></span>

<span data-ttu-id="96e29-182">이 웹후크 패턴을 다시 매핑하는 경우 빵집은 사용자 지정 API를 나타내고, 케이크를 주문한 고객은 Logic Apps 엔진을 나타냅니다.</span><span class="sxs-lookup"><span data-stu-id="96e29-182">When we map this webhook pattern back, the bakery represents your custom API, while you, the cake customer, represent the Logic Apps engine.</span></span> <span data-ttu-id="96e29-183">엔진에서 요청을 통해 API를 호출하고 "콜백" URL을 포함합니다.</span><span class="sxs-lookup"><span data-stu-id="96e29-183">The engine calls your API with a request and includes a "callback" URL.</span></span>
<span data-ttu-id="96e29-184">작업이 완료되면 API에서 URL을 사용하여 엔진에 알리고, 논리 앱에 데이터를 반환하고, 워크플로를 계속 진행합니다.</span><span class="sxs-lookup"><span data-stu-id="96e29-184">When the job is done, your API uses the URL to notify the engine and return data to your logic app, which then continues workflow.</span></span> 

<span data-ttu-id="96e29-185">이 패턴의 경우 컨트롤러에 두 개의 끝점(`subscribe` 및 `unsubscribe`)을 설정합니다.</span><span class="sxs-lookup"><span data-stu-id="96e29-185">For this pattern, set up two endpoints on your controller: `subscribe` and `unsubscribe`</span></span>

*  <span data-ttu-id="96e29-186">`subscribe` 끝점: 실행이 워크플로의 API 동작에 도달하면 Logic Apps 엔진에서 `subscribe` 끝점을 호출합니다.</span><span class="sxs-lookup"><span data-stu-id="96e29-186">`subscribe` endpoint: When execution reaches your API's action in the workflow, the Logic Apps engine calls the `subscribe` endpoint.</span></span> <span data-ttu-id="96e29-187">이 단계에서는 논리 앱이 API에서 저장하는 콜백 URL을 만든 다음, 작업이 완료될 때 API로부터 콜백을 기다립니다.</span><span class="sxs-lookup"><span data-stu-id="96e29-187">This step causes the logic app to create a callback URL that your API stores and then wait for the callback from your API when work is complete.</span></span> <span data-ttu-id="96e29-188">그런 다음 API에서 URL에 대한 HTTP POST를 통해 콜백하고 반환된 모든 내용과 헤더를 논리 앱에 대한 입력으로 전달합니다.</span><span class="sxs-lookup"><span data-stu-id="96e29-188">Your API then calls back with an HTTP POST to the URL and passes any returned content and headers as input to the logic app.</span></span>

* <span data-ttu-id="96e29-189">`unsubscribe` 끝점: 논리 앱이 실행 취소되면 Logic Apps 엔진에서 `unsubscribe` 끝점을 호출합니다.</span><span class="sxs-lookup"><span data-stu-id="96e29-189">`unsubscribe` endpoint: If the logic app run is canceled, the Logic Apps engine calls the `unsubscribe` endpoint.</span></span> <span data-ttu-id="96e29-190">그런 다음 API에서 콜백 URL을 등록 취소하고 필요에 따라 모든 프로세스를 중지할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="96e29-190">Your API can then unregister the callback URL and stop any processes as necessary.</span></span>

![웹후크 동작 패턴](./media/logic-apps-create-api-app/custom-api-webhook-action-pattern.png)

> [!NOTE]
> <span data-ttu-id="96e29-192">현재 Logic App Designer는 Swagger를 통한 웹후크 끝점 검색을 지원하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="96e29-192">Currently, the Logic App Designer doesn't support discovering webhook endpoints through Swagger.</span></span> <span data-ttu-id="96e29-193">따라서 이 패턴의 경우 [**웹후크** 동작](../connectors/connectors-native-webhook.md)을 추가하고 요청에 대한 URL, 헤더 및 본문을 지정해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="96e29-193">So for this pattern, you have to add a [**Webhook** action](../connectors/connectors-native-webhook.md) and specify the URL, headers, and body for your request.</span></span> <span data-ttu-id="96e29-194">[워크플로 작업 및 트리거](logic-apps-workflow-actions-triggers.md#api-connection-webhook-action)도 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="96e29-194">See also [Workflow actions and triggers](logic-apps-workflow-actions-triggers.md#api-connection-webhook-action).</span></span> <span data-ttu-id="96e29-195">콜백 URL을 전달하려면 필요에 따라 이전 필드 중 하나에서 `@listCallbackUrl()` 워크플로 함수를 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="96e29-195">To pass in the callback URL, you can use the `@listCallbackUrl()` workflow function in any of the previous fields as necessary.</span></span>

> [!TIP]
> <span data-ttu-id="96e29-196">웹후크 패턴 예제는 [GitHub의 웹후크 트리거 샘플](https://github.com/logicappsio/LogicAppTriggersExample/blob/master/LogicAppTriggers/Controllers/WebhookTriggerController.cs)(영문)을 검토하세요.</span><span class="sxs-lookup"><span data-stu-id="96e29-196">For an example webhook pattern, review this [webhook trigger sample in GitHub](https://github.com/logicappsio/LogicAppTriggersExample/blob/master/LogicAppTriggers/Controllers/WebhookTriggerController.cs).</span></span>

<a name="triggers"></a>

## <a name="trigger-patterns"></a><span data-ttu-id="96e29-197">트리거 패턴</span><span class="sxs-lookup"><span data-stu-id="96e29-197">Trigger patterns</span></span>

<span data-ttu-id="96e29-198">사용자 지정 API는 [*트리거*](./logic-apps-what-are-logic-apps.md#logic-app-concepts)의 역할을 수행하여 새 데이터 또는 이벤트가 지정된 조건을 충족할 때 논리 앱을 시작할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="96e29-198">Your custom API can act as a [*trigger*](./logic-apps-what-are-logic-apps.md#logic-app-concepts) that starts a logic app when new data or an event meets a specified condition.</span></span> <span data-ttu-id="96e29-199">이 트리거는 서비스 끝점에서 새 데이터 또는 이벤트를 정기적으로 확인하거나 대기 및 수신 대기할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="96e29-199">This trigger can either check regularly, or wait and listen, for new data or events at your service endpoint.</span></span> <span data-ttu-id="96e29-200">새 데이터 또는 이벤트가 지정된 조건을 충족하면 트리거가 시작되고 해당 트리거를 수신하는 논리 앱이 시작됩니다.</span><span class="sxs-lookup"><span data-stu-id="96e29-200">If new data or an event meets the specified condition, the trigger fires and starts the logic app, which is listening to that trigger.</span></span> <span data-ttu-id="96e29-201">이러한 방식으로 논리 앱을 시작하려면 API에서 [*폴링 트리거*](#polling-triggers) 또는 [*웹후크 트리거*](#webhook-triggers) 패턴을 따르면 됩니다.</span><span class="sxs-lookup"><span data-stu-id="96e29-201">To start logic apps this way, your API can follow the [*polling trigger*](#polling-triggers) or the [*webhook trigger*](#webhook-triggers) pattern.</span></span> <span data-ttu-id="96e29-202">이러한 패턴은 [폴링 동작](#async-pattern) 및 [웹후크 동작](#webhook-actions)의 해당 패턴과 비슷합니다.</span><span class="sxs-lookup"><span data-stu-id="96e29-202">These patterns are similar to their counterparts for [polling actions](#async-pattern) and [webhook actions](#webhook-actions).</span></span> <span data-ttu-id="96e29-203">또한 [트리거 사용량 측정](logic-apps-pricing.md)에 대해서도 자세히 알아보세요.</span><span class="sxs-lookup"><span data-stu-id="96e29-203">Also, learn more about [usage metering for triggers](logic-apps-pricing.md).</span></span>

<a name="polling-triggers"></a>

### <a name="check-for-new-data-or-events-regularly-with-the-polling-trigger-pattern"></a><span data-ttu-id="96e29-204">폴링 트리거 패턴으로 정기적인 새 데이터 또는 이벤트 확인</span><span class="sxs-lookup"><span data-stu-id="96e29-204">Check for new data or events regularly with the polling trigger pattern</span></span>

<span data-ttu-id="96e29-205">*폴링 트리거*는 이 항목의 앞부분에서 설명한 [폴링 동작](#async-pattern)과 매우 비슷하게 작동합니다.</span><span class="sxs-lookup"><span data-stu-id="96e29-205">A *polling trigger* acts much like the [polling action](#async-pattern) previously described in this topic.</span></span> <span data-ttu-id="96e29-206">Logic Apps 엔진에서는 새 데이터 또는 이벤트에 대한 트리거 끝점을 정기적으로 호출하고 확인합니다.</span><span class="sxs-lookup"><span data-stu-id="96e29-206">The Logic Apps engine periodically calls and checks the trigger endpoint for new data or events.</span></span> <span data-ttu-id="96e29-207">엔진에서 지정된 조건을 충족하는 새 데이터 또는 이벤트를 발견하면 트리거가 실행됩니다.</span><span class="sxs-lookup"><span data-stu-id="96e29-207">If the engine finds new data or an event that meets your specified condition, the trigger fires.</span></span> <span data-ttu-id="96e29-208">그런 다음 엔진에서 데이터를 입력으로 처리하는 논리 앱 인스턴스를 만듭니다.</span><span class="sxs-lookup"><span data-stu-id="96e29-208">Then, the engine creates a logic app instance that processes the data as input.</span></span> 

![폴링 트리거 패턴](./media/logic-apps-create-api-app/custom-api-polling-trigger-pattern.png)

> [!NOTE]
> <span data-ttu-id="96e29-210">논리 앱 인스턴스를 만들지 않은 경우에도 각 폴링 요청은 동작 실행으로 간주됩니다.</span><span class="sxs-lookup"><span data-stu-id="96e29-210">Each polling request counts as an action execution, even when no logic app instance is created.</span></span> <span data-ttu-id="96e29-211">동일한 데이터를 여러 번 처리하지 않도록 방지하려면 트리거에서 이미 읽고 논리 앱에 전달된 데이터를 정리해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="96e29-211">To prevent processing the same data multiple times, your trigger should clean up data that was already read and passed to the logic app.</span></span>

<span data-ttu-id="96e29-212">API의 관점에서 설명하는 폴링 트리거의 구체적인 단계는 다음과 같습니다.</span><span class="sxs-lookup"><span data-stu-id="96e29-212">Here are specific steps for a polling trigger, described from the API's perspective:</span></span>

| <span data-ttu-id="96e29-213">새 데이터 또는 이벤트가 있습니까?</span><span class="sxs-lookup"><span data-stu-id="96e29-213">Found new data or event?</span></span>  | <span data-ttu-id="96e29-214">API 응답</span><span class="sxs-lookup"><span data-stu-id="96e29-214">API response</span></span> | 
| ------------------------- | ------------ |
| <span data-ttu-id="96e29-215">있음</span><span class="sxs-lookup"><span data-stu-id="96e29-215">Found</span></span> | <span data-ttu-id="96e29-216">응답 페이로드(다음 단계의 입력)와 함께 HTTP `200 OK` 상태를 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="96e29-216">Return an HTTP `200 OK` status with the response payload (input for next step).</span></span> <br/><span data-ttu-id="96e29-217">이 응답은 논리 앱 인스턴스를 만들고 워크플로를 시작합니다.</span><span class="sxs-lookup"><span data-stu-id="96e29-217">This response creates a logic app instance and starts the workflow.</span></span> |
| <span data-ttu-id="96e29-218">찾을 수 없음</span><span class="sxs-lookup"><span data-stu-id="96e29-218">Not found</span></span> | <span data-ttu-id="96e29-219">`location` 헤더 및 `retry-after` 헤더와 함께 HTTP `202 ACCEPTED` 상태를 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="96e29-219">Return an HTTP `202 ACCEPTED` status with a `location` header and a `retry-after` header.</span></span> <br/><span data-ttu-id="96e29-220">트리거의 경우 `location` 헤더에 `triggerState` 쿼리 매개 변수(일반적으로 "timestamp")도 있어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="96e29-220">For triggers, the `location` header should also contain a `triggerState` query parameter, which is usually a "timestamp."</span></span> <span data-ttu-id="96e29-221">API에서는 이 식별자를 사용하여 논리 앱이 트리거된 마지막 시간을 추적할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="96e29-221">Your API can use this identifier to track the last time that the logic app was triggered.</span></span> |

<span data-ttu-id="96e29-222">예를 들어 새 파일에 대한 서비스를 정기적으로 확인하려면 다음과 같은 동작을 포함하는 폴링 트리거를 빌드할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="96e29-222">For example, to periodically check your service for new files, you might build a polling trigger that has these behaviors:</span></span>

| <span data-ttu-id="96e29-223">요청에 `triggerState`가 있습니까?</span><span class="sxs-lookup"><span data-stu-id="96e29-223">Request includes `triggerState`?</span></span> | <span data-ttu-id="96e29-224">API 응답</span><span class="sxs-lookup"><span data-stu-id="96e29-224">API response</span></span> |
| -------------------------------- | -------------|
| <span data-ttu-id="96e29-225">아니요</span><span class="sxs-lookup"><span data-stu-id="96e29-225">No</span></span> | <span data-ttu-id="96e29-226">HTTP `202 ACCEPTED` 상태 및 현재 시간으로 설정된 `triggerState`와 15초로 설정된 `retry-after` 간격이 포함된 `location` 헤더를 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="96e29-226">Return an HTTP `202 ACCEPTED` status plus a `location` header with `triggerState` set to the current time and the `retry-after` interval to 15 seconds.</span></span> |
| <span data-ttu-id="96e29-227">예</span><span class="sxs-lookup"><span data-stu-id="96e29-227">Yes</span></span> | <span data-ttu-id="96e29-228">`triggerState`에 대한 `DateTime` 이후에 추가된 파일에 대한 서비스를 확인합니다.</span><span class="sxs-lookup"><span data-stu-id="96e29-228">Check your service for files added after the `DateTime` for `triggerState`.</span></span> |

| <span data-ttu-id="96e29-229">검색된 파일의 수</span><span class="sxs-lookup"><span data-stu-id="96e29-229">Number of files found</span></span> | <span data-ttu-id="96e29-230">API 응답</span><span class="sxs-lookup"><span data-stu-id="96e29-230">API response</span></span> |
| --------------------- | -------------|
| <span data-ttu-id="96e29-231">단일 파일</span><span class="sxs-lookup"><span data-stu-id="96e29-231">Single file</span></span> | <span data-ttu-id="96e29-232">HTTP `200 OK` 상태와 콘텐츠 페이로드를 반환하고, `triggerState`를 반환된 파일에 대한 `DateTime`으로 업데이트하고, `retry-after` 간격을 15초로 설정합니다.</span><span class="sxs-lookup"><span data-stu-id="96e29-232">Return an HTTP `200 OK` status and the content payload, update `triggerState` to the `DateTime` for the returned file, and set `retry-after` interval to 15 seconds.</span></span> |
| <span data-ttu-id="96e29-233">여러 파일</span><span class="sxs-lookup"><span data-stu-id="96e29-233">Multiple files</span></span> | <span data-ttu-id="96e29-234">한 번에 파일 하나씩 및 HTTP `200 OK` 상태를 반환하고, `triggerState`를 업데이트하고, `retry-after` 간격을 0초로 설정합니다.</span><span class="sxs-lookup"><span data-stu-id="96e29-234">Return one file at a time and an HTTP `200 OK` status, update `triggerState`, and set the `retry-after` interval to 0 seconds.</span></span> </br><span data-ttu-id="96e29-235">이러한 단계를 통해 더 많은 데이터를 사용할 수 있고 엔진이 `location` 헤더의 URL에서 데이터를 즉시 요청해야 한다고 엔진에 알립니다.</span><span class="sxs-lookup"><span data-stu-id="96e29-235">These steps let the engine know that more data is available, and that the engine should immediately request the data from the URL in the `location` header.</span></span> |
| <span data-ttu-id="96e29-236">파일 없음</span><span class="sxs-lookup"><span data-stu-id="96e29-236">No files</span></span> | <span data-ttu-id="96e29-237">HTTP `202 ACCEPTED` 상태를 반환하고, `triggerState`를 변경하지 않고, `retry-after` 간격을 15초로 설정합니다.</span><span class="sxs-lookup"><span data-stu-id="96e29-237">Return an HTTP `202 ACCEPTED` status, don't change `triggerState`, and set the `retry-after` interval to 15 seconds.</span></span> |

> [!TIP]
> <span data-ttu-id="96e29-238">폴링 트리거 패턴 예제는 [GitHub의 폴 트리거 컨트롤러 샘플](https://github.com/logicappsio/LogicAppTriggersExample/blob/master/LogicAppTriggers/Controllers/PollTriggerController.cs)(영문)을 검토하세요.</span><span class="sxs-lookup"><span data-stu-id="96e29-238">For an example polling trigger pattern, review this [poll trigger controller sample in GitHub](https://github.com/logicappsio/LogicAppTriggersExample/blob/master/LogicAppTriggers/Controllers/PollTriggerController.cs).</span></span>

<a name="webhook-triggers"></a>

### <a name="wait-and-listen-for-new-data-or-events-with-the-webhook-trigger-pattern"></a><span data-ttu-id="96e29-239">웹후크 트리거 패턴으로 새 데이터 또는 이벤트 대기 및 수신 대기</span><span class="sxs-lookup"><span data-stu-id="96e29-239">Wait and listen for new data or events with the webhook trigger pattern</span></span>

<span data-ttu-id="96e29-240">웹후크 트리거는 서비스 끝점에서 새 데이터 또는 이벤트를 대기하고 수신 대기하는 *푸시 트리거*입니다.</span><span class="sxs-lookup"><span data-stu-id="96e29-240">A webhook trigger is a *push trigger* that waits and listens for new data or events at your service endpoint.</span></span> <span data-ttu-id="96e29-241">새 데이터 또는 이벤트가 지정된 조건을 충족하면 트리거가 실행되고, 논리 앱 인스턴스가 만들어지고, 데이터가 입력으로 처리됩니다.</span><span class="sxs-lookup"><span data-stu-id="96e29-241">If new data or an event meets the specified condition, the trigger fires and creates a logic app instance, which then processes the data as input.</span></span>
<span data-ttu-id="96e29-242">웹후크 트리거는 이 항목의 앞부분에서 설명한 [웹후크 동작](#webhook-actions)과 매우 비슷하게 작동하며 `subscribe` 및 `unsubscribe` 끝점으로 설정됩니다.</span><span class="sxs-lookup"><span data-stu-id="96e29-242">Webhook triggers act much like the [webhook actions](#webhook-actions) previously described in this topic, and are set up with `subscribe` and `unsubscribe` endpoints.</span></span> 

* <span data-ttu-id="96e29-243">`subscribe` 끝점: 논리 앱에 웹후크 트리거를 추가하고 저장하면 Logic Apps 엔진에서 `subscribe` 끝점을 호출합니다.</span><span class="sxs-lookup"><span data-stu-id="96e29-243">`subscribe` endpoint: When you add and save a webhook trigger in your logic app, the Logic Apps engine calls the `subscribe` endpoint.</span></span> <span data-ttu-id="96e29-244">이 단계에서는 논리 앱이 API에서 저장하는 콜백 URL을 만듭니다.</span><span class="sxs-lookup"><span data-stu-id="96e29-244">This step causes the logic app to create a callback URL that your API stores.</span></span> <span data-ttu-id="96e29-245">지정된 조건을 충족하는 새 데이터 또는 이벤트가 있으면 API에서 URL에 대한 HTTP POST를 통해 콜백합니다.</span><span class="sxs-lookup"><span data-stu-id="96e29-245">When there's new data or an event that meets the specified condition, your API calls back with an HTTP POST to the URL.</span></span> <span data-ttu-id="96e29-246">콘텐츠 페이로드와 헤더는 입력으로 논리 앱에 전달됩니다.</span><span class="sxs-lookup"><span data-stu-id="96e29-246">The content payload and headers pass as input to the logic app.</span></span>

* <span data-ttu-id="96e29-247">`unsubscribe` 끝점: 웹후크 트리거 또는 전체 논리 앱이 삭제되면 Logic Apps 엔진에서 `unsubscribe` 끝점을 호출합니다.</span><span class="sxs-lookup"><span data-stu-id="96e29-247">`unsubscribe` endpoint: If the webhook trigger or entire logic app is deleted, the Logic Apps engine calls the `unsubscribe` endpoint.</span></span> <span data-ttu-id="96e29-248">그런 다음 API에서 콜백 URL을 등록 취소하고 필요에 따라 모든 프로세스를 중지할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="96e29-248">Your API can then unregister the callback URL and stop any processes as necessary.</span></span>

![웹후크 트리거 패턴](./media/logic-apps-create-api-app/custom-api-webhook-trigger-pattern.png)

> [!NOTE]
> <span data-ttu-id="96e29-250">현재 Logic App Designer는 Swagger를 통한 웹후크 끝점 검색을 지원하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="96e29-250">Currently, the Logic App Designer doesn't support discovering webhook endpoints through Swagger.</span></span> <span data-ttu-id="96e29-251">따라서 이 패턴의 경우 [**웹후크** 트리거](../connectors/connectors-native-webhook.md)를 추가하고 요청에 대한 URL, 헤더 및 본문을 지정해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="96e29-251">So for this pattern, you have to add a [**Webhook** trigger](../connectors/connectors-native-webhook.md) and specify the URL, headers, and body for your request.</span></span> <span data-ttu-id="96e29-252">[HTTPWebhook 트리거](logic-apps-workflow-actions-triggers.md#httpwebhook-trigger)도 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="96e29-252">See also [HTTPWebhook trigger](logic-apps-workflow-actions-triggers.md#httpwebhook-trigger).</span></span> <span data-ttu-id="96e29-253">콜백 URL을 전달하려면 필요에 따라 이전 필드 중 하나에서 `@listCallbackUrl()` 워크플로 함수를 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="96e29-253">To pass in the callback URL, you can use the `@listCallbackUrl()` workflow function in any of the previous fields as necessary.</span></span>
>
> <span data-ttu-id="96e29-254">동일한 데이터를 여러 번 처리하지 않도록 방지하려면 트리거에서 이미 읽고 논리 앱에 전달된 데이터를 정리해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="96e29-254">To prevent processing the same data multiple times, your trigger should clean up data that was already read and passed to the logic app.</span></span>

> [!TIP]
> <span data-ttu-id="96e29-255">웹후크 패턴 예제는 [GitHub의 웹후크 트리거 컨트롤러 샘플](https://github.com/logicappsio/LogicAppTriggersExample/blob/master/LogicAppTriggers/Controllers/WebhookTriggerController.cs)(영문)을 검토하세요.</span><span class="sxs-lookup"><span data-stu-id="96e29-255">For an example webhook pattern, review this [webhook trigger controller sample in GitHub](https://github.com/logicappsio/LogicAppTriggersExample/blob/master/LogicAppTriggers/Controllers/WebhookTriggerController.cs).</span></span>

## <a name="deploy-call-and-secure-custom-apis"></a><span data-ttu-id="96e29-256">사용자 지정 API 배포, 호출 및 보호</span><span class="sxs-lookup"><span data-stu-id="96e29-256">Deploy, call, and secure custom APIs</span></span>

<span data-ttu-id="96e29-257">사용자 지정 API를 만든 후 배포를 위한 API를 설정하여 안전하게 호출할 수 있도록 합니다.</span><span class="sxs-lookup"><span data-stu-id="96e29-257">After creating your custom APIs, set up your APIs for deployment so you can call them securely.</span></span> <span data-ttu-id="96e29-258">[논리 앱에 대한 사용자 지정 API를 배포, 호출 및 보안](./logic-apps-custom-hosted-api.md)하는 방법에 대해 알아보세요.</span><span class="sxs-lookup"><span data-stu-id="96e29-258">Learn how to [deploy, call, and secure custom APIs for logic apps](./logic-apps-custom-hosted-api.md).</span></span>

## <a name="publish-custom-apis-to-azure"></a><span data-ttu-id="96e29-259">Azure에 사용자 지정 API 게시</span><span class="sxs-lookup"><span data-stu-id="96e29-259">Publish custom APIs to Azure</span></span>

<span data-ttu-id="96e29-260">사용자 지정 API를 Azure에서 공용으로 사용할 수 있게 하려면 [Microsoft Azure Certified 프로그램](https://azure.microsoft.com/marketplace/programs/certified/logic-apps/)에 추천을 제출해 주세요.</span><span class="sxs-lookup"><span data-stu-id="96e29-260">To make your custom APIs available for public use in Azure, submit your nominations to the [Microsoft Azure Certified program](https://azure.microsoft.com/marketplace/programs/certified/logic-apps/).</span></span>

## <a name="get-help"></a><span data-ttu-id="96e29-261">도움말 보기</span><span class="sxs-lookup"><span data-stu-id="96e29-261">Get help</span></span>

<span data-ttu-id="96e29-262">사용자 지정 API에 대한 구체적인 지원은 [customapishelp@microsoft.com](mailto:customapishelp@microsoft.com)에 문의해 주세요.</span><span class="sxs-lookup"><span data-stu-id="96e29-262">For specific help with custom APIs, contact [customapishelp@microsoft.com](mailto:customapishelp@microsoft.com).</span></span>

<span data-ttu-id="96e29-263">질문하고, 질문에 답변하고, 다른 Azure Logic Apps 사용자가 어떤 일을 하는지 확인하려면 [Azure Logic Apps 포럼](https://social.msdn.microsoft.com/Forums/en-US/home?forum=azurelogicapps)을 방문하세요.</span><span class="sxs-lookup"><span data-stu-id="96e29-263">To ask questions, answer questions, and see what other Azure Logic Apps users are doing, visit the [Azure Logic Apps forum](https://social.msdn.microsoft.com/Forums/en-US/home?forum=azurelogicapps).</span></span>

<span data-ttu-id="96e29-264">Logic Apps 및 커넥터 개선에 도움을 주려면 [Logic Apps 사용자 의견 사이트](http://aka.ms/logicapps-wish)에서 투표하고 아이디어를 제출하세요.</span><span class="sxs-lookup"><span data-stu-id="96e29-264">To help improve Logic Apps and connectors, vote on or submit ideas at the [Logic Apps user feedback site](http://aka.ms/logicapps-wish).</span></span> 

## <a name="next-steps"></a><span data-ttu-id="96e29-265">다음 단계</span><span class="sxs-lookup"><span data-stu-id="96e29-265">Next steps</span></span>

* [<span data-ttu-id="96e29-266">동작 및 트리거에 대한 사용량 측정</span><span class="sxs-lookup"><span data-stu-id="96e29-266">Usage metering for actions and triggers</span></span>](logic-apps-pricing.md)
* [<span data-ttu-id="96e29-267">콘텐츠 형식 처리</span><span class="sxs-lookup"><span data-stu-id="96e29-267">Handle content types</span></span>](./logic-apps-content-type.md)
* [<span data-ttu-id="96e29-268">오류 및 예외 처리</span><span class="sxs-lookup"><span data-stu-id="96e29-268">Handle errors and exceptions</span></span>](./logic-apps-exception-handling.md)
* [<span data-ttu-id="96e29-269">논리 앱에 대한 보안 액세스</span><span class="sxs-lookup"><span data-stu-id="96e29-269">Secure access to your logic apps</span></span>](./logic-apps-securing-a-logic-app.md)
* [<span data-ttu-id="96e29-270">HTTP 끝점을 통해 논리 앱 호출, 트리거 또는 중첩</span><span class="sxs-lookup"><span data-stu-id="96e29-270">Call, trigger, or nest logic apps with HTTP endpoints</span></span>](./logic-apps-http-endpoint.md)