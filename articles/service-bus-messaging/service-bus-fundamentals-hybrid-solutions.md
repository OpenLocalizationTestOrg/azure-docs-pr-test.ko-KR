---
title: "Azure 서비스 버스 기본 정보 aaaOverview | Microsoft Docs"
description: "소개 toousing 서비스 버스 tooconnect Azure 응용 프로그램 tooother 소프트웨어."
services: service-bus-messaging
documentationcenter: .net
author: sethmanheim
manager: timlt
editor: 
ms.assetid: 12654cdd-82ab-4b95-b56f-08a5a8bbc6f9
ms.service: service-bus-messaging
ms.workload: na
ms.tgt_pltfrm: na
ms.devlang: na
ms.topic: get-started-article
ms.date: 06/15/2017
ms.author: sethm
ms.openlocfilehash: 1abd5cf310ef06ba35e1e2489a7c0a07e1797736
ms.sourcegitcommit: 523283cc1b3c37c428e77850964dc1c33742c5f0
ms.translationtype: MT
ms.contentlocale: ko-KR
ms.lasthandoff: 10/06/2017
---
# <a name="azure-service-bus"></a><span data-ttu-id="3e49c-103">Azure Service Bus</span><span class="sxs-lookup"><span data-stu-id="3e49c-103">Azure Service Bus</span></span>

<span data-ttu-id="3e49c-104">응용 프로그램 또는 서비스 hello 클라우드 또는 온-프레미스를 실행 하는지 여부를 다른 응용 프로그램 또는 서비스와 함께 toointeract 자주 필요 합니다.</span><span class="sxs-lookup"><span data-stu-id="3e49c-104">Whether an application or service runs in hello cloud or on premises, it often needs toointeract with other applications or services.</span></span> <span data-ttu-id="3e49c-105">tooprovide 광범위 하 게 유용한 방법은 toodo이, Microsoft Azure 서비스 버스에서 제공 합니다.</span><span class="sxs-lookup"><span data-stu-id="3e49c-105">tooprovide a broadly useful way toodo this, Microsoft Azure offers Service Bus.</span></span> <span data-ttu-id="3e49c-106">이 문서에서는이 기술, 정의 및 toouse는 이유를 설명 하는 것입니다.</span><span class="sxs-lookup"><span data-stu-id="3e49c-106">This article looks at this technology, describing what it is and why you might want toouse it.</span></span>

## <a name="service-bus-fundamentals"></a><span data-ttu-id="3e49c-107">서비스 버스 기본 사항</span><span class="sxs-lookup"><span data-stu-id="3e49c-107">Service Bus fundamentals</span></span>

<span data-ttu-id="3e49c-108">각 상황에 따라 다른 스타일의 통신이 요청됩니다.</span><span class="sxs-lookup"><span data-stu-id="3e49c-108">Different situations call for different styles of communication.</span></span> <span data-ttu-id="3e49c-109">경우에 따라 응용 프로그램 단순 큐를 통해 메시지를 주고받을 수 있도록이 hello 좋습니다.</span><span class="sxs-lookup"><span data-stu-id="3e49c-109">Sometimes, letting applications send and receive messages through a simple queue is hello best solution.</span></span> <span data-ttu-id="3e49c-110">다른 상황에서는 일반적인 큐로 충분하지 않고 게시 및 구독 메커니즘을 사용한 큐가 더 효율적입니다.</span><span class="sxs-lookup"><span data-stu-id="3e49c-110">In other situations, an ordinary queue isn't enough; a queue with a publish-and-subscribe mechanism is better.</span></span> <span data-ttu-id="3e49c-111">응용 프로그램 간의 연결만 필요하고 큐가 필요하지 않은 경우도 있습니다.</span><span class="sxs-lookup"><span data-stu-id="3e49c-111">In some cases, all that's needed is a connection between applications, and queues are not required.</span></span> <span data-ttu-id="3e49c-112">서비스 버스 여러 가지 방법으로 응용 프로그램 toointeract를 사용 하면 모든 세 가지 옵션을 제공 합니다.</span><span class="sxs-lookup"><span data-stu-id="3e49c-112">Service Bus provides all three options, enabling your applications toointeract in several different ways.</span></span>

<span data-ttu-id="3e49c-113">서비스 버스는 hello 서비스에 여러 사용자가 공유 되는 것을 의미 하는 다중 테 넌 트 클라우드 서비스입니다.</span><span class="sxs-lookup"><span data-stu-id="3e49c-113">Service Bus is a multi-tenant cloud service, which means that hello service is shared by multiple users.</span></span> <span data-ttu-id="3e49c-114">응용 프로그램 개발자와 같은 각 사용자 생성 한 *네임 스페이스*, 한 다음 해당 네임 스페이스 내에서 필요한 hello 통신 메커니즘을 정의 합니다.</span><span class="sxs-lookup"><span data-stu-id="3e49c-114">Each user, such as an application developer, creates a *namespace*, then defines hello communication mechanisms needed within that namespace.</span></span> <span data-ttu-id="3e49c-115">그림 1에서는 이 아키텍처는 모양을 보여줍니다.</span><span class="sxs-lookup"><span data-stu-id="3e49c-115">Figure 1 shows how this architecture looks.</span></span>

![][1]

<span data-ttu-id="3e49c-116">**그림 1: 서비스 버스 hello 클라우드를 통해 응용 프로그램을 연결 하기 위한 다중 테 넌 트 서비스를 제공 합니다.**</span><span class="sxs-lookup"><span data-stu-id="3e49c-116">**Figure 1: Service Bus provides a multi-tenant service for connecting applications through hello cloud.**</span></span>

<span data-ttu-id="3e49c-117">네임스페이스 내에서 각각 다른 방식으로 응용 프로그램을 연결하는 세 가지 통신 메커니즘 인스턴스를 하나 이상 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="3e49c-117">Within a namespace, you can use one or more instances of three different communication mechanisms, each of which connects applications in a different way.</span></span> <span data-ttu-id="3e49c-118">hello 선택할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="3e49c-118">hello choices are:</span></span>

* <span data-ttu-id="3e49c-119">*큐*- 단방향 통신을 허용합니다.</span><span class="sxs-lookup"><span data-stu-id="3e49c-119">*Queues*, which allow one-directional communication.</span></span> <span data-ttu-id="3e49c-120">각 큐는 수신될 때까지 전송된 메시지를 저장하는 중간자( *브로커*라고도 함) 역할을 합니다.</span><span class="sxs-lookup"><span data-stu-id="3e49c-120">Each queue acts as an intermediary (sometimes called a *broker*) that stores sent messages until they are received.</span></span> <span data-ttu-id="3e49c-121">단일 수신자가 각 메시지를 수신합니다.</span><span class="sxs-lookup"><span data-stu-id="3e49c-121">Each message is received by a single recipient.</span></span>
* <span data-ttu-id="3e49c-122">*토픽* - *구독*을 사용하여 단방향 통신 기능을 제공합니다. 토픽 하나에 구독이 여러 개 포함될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="3e49c-122">*Topics*, which provide one-directional communication using *subscriptions*-a single topic can have multiple subscriptions.</span></span> <span data-ttu-id="3e49c-123">큐와 같은 항목 브로커 역할을, 하지만 각 구독은 특정 조건과 일치 하는 필터 tooreceive만 메시지를 선택적으로 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="3e49c-123">Like a queue, a topic acts as a broker, but each subscription can optionally use a filter tooreceive only messages that match specific criteria.</span></span>
* <span data-ttu-id="3e49c-124">*릴레이*- 양방향 통신을 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="3e49c-124">*Relays*, which provide bi-directional communication.</span></span> <span data-ttu-id="3e49c-125">큐 및 토픽과 달리 릴레이는 처리 중인 메시지를 저장하지 않으며, 브로커 역할을 하지 않고</span><span class="sxs-lookup"><span data-stu-id="3e49c-125">Unlike queues and topics, a relay doesn't store in-flight messages; it's not a broker.</span></span> <span data-ttu-id="3e49c-126">대신, 전달에 toohello 대상 응용 프로그램에 있습니다.</span><span class="sxs-lookup"><span data-stu-id="3e49c-126">Instead, it just passes them on toohello destination application.</span></span>

<span data-ttu-id="3e49c-127">큐, 토픽 또는 릴레이를 만들 때 이름을 지정합니다.</span><span class="sxs-lookup"><span data-stu-id="3e49c-127">When you create a queue, topic, or relay, you give it a name.</span></span> <span data-ttu-id="3e49c-128">이 이름은 네임 스페이스를 호출한 경우 모든 함께 hello 개체에 대 한 고유 식별자를 만듭니다.</span><span class="sxs-lookup"><span data-stu-id="3e49c-128">Combined with whatever you called your namespace, this name creates a unique identifier for hello object.</span></span> <span data-ttu-id="3e49c-129">응용 프로그램 이름 tooService 버스,이 제공 합니다. 다음 해당 큐, 항목 또는 릴레이 toocommunicate를 사용 하 여 서로 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="3e49c-129">Applications can provide this name tooService Bus, then use that queue, topic, or relay toocommunicate with one another.</span></span> 

<span data-ttu-id="3e49c-130">toouse hello 릴레이 시나리오에서 이러한 개체를 Windows 응용 프로그램 Windows Communication Foundation (WCF)를 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="3e49c-130">toouse any of these objects in hello relay scenario, Windows applications can use Windows Communication Foundation (WCF).</span></span> <span data-ttu-id="3e49c-131">이 서비스는 [WCF 릴레이](../service-bus-relay/relay-what-is-it.md)라고 합니다.</span><span class="sxs-lookup"><span data-stu-id="3e49c-131">This service is known as [WCF Relay](../service-bus-relay/relay-what-is-it.md).</span></span> <span data-ttu-id="3e49c-132">큐와 토픽의 경우 Windows 응용 프로그램이 서비스 버스로 정의된 메시지 API를 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="3e49c-132">For queues and topics, Windows applications can use Service Bus-defined messaging APIs.</span></span> <span data-ttu-id="3e49c-133">toomake 비 Windows 응용 프로그램에서 쉽게 toouse 개체를 이러한, Microsoft는 Java, Node.js, 및 다른 언어에 대 한 Sdk를 제공 합니다.</span><span class="sxs-lookup"><span data-stu-id="3e49c-133">toomake these objects easier toouse from non-Windows applications, Microsoft provides SDKs for Java, Node.js, and other languages.</span></span> <span data-ttu-id="3e49c-134">HTTP를 통해 [REST API](/rest/api/servicebus/)를 사용하여 큐 및 토픽에 액세스할 수도 있습니다.</span><span class="sxs-lookup"><span data-stu-id="3e49c-134">You can also access queues and topics using [REST APIs](/rest/api/servicebus/) over HTTP(s).</span></span> 

<span data-ttu-id="3e49c-135">Hello 클라우드에서 실행 되는 자체 않더라도 서비스 버스 toounderstand 반드시 (즉, Microsoft의 Azure 데이터 센터에서), 응용 프로그램을 사용 하는 원격 실행할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="3e49c-135">It's important toounderstand that even though Service Bus itself runs in hello cloud (that is, in Microsoft's Azure datacenters), applications that use it can run anywhere.</span></span> <span data-ttu-id="3e49c-136">예를 들어 Azure 또는 자체 데이터 센터 내에서 실행 되는 응용 프로그램에서 실행 중인 서비스 버스 tooconnect 응용 프로그램을 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="3e49c-136">You can use Service Bus tooconnect applications running on Azure, for example, or applications running inside your own datacenter.</span></span> <span data-ttu-id="3e49c-137">사용할 수 있습니다도 tooconnect 또는 Azure에서 실행 중인 응용 프로그램는 온-프레미스 응용 프로그램 또는 태블릿 및 휴대폰과 클라우드 플랫폼입니다.</span><span class="sxs-lookup"><span data-stu-id="3e49c-137">You can also use it tooconnect an application running on Azure or another cloud platform with an on-premises application or with tablets and phones.</span></span> <span data-ttu-id="3e49c-138">가능한 tooconnect 가구 어플라이언스, 센서, 및 기타 장치 tooa 중앙 응용 프로그램 또는 다른 tooone 않습니다.</span><span class="sxs-lookup"><span data-stu-id="3e49c-138">It's even possible tooconnect household appliances, sensors, and other devices tooa central application or tooone other.</span></span> <span data-ttu-id="3e49c-139">서비스 버스는 거의 모든 위치에서 액세스할 수 있는 hello 클라우드에서 통신 메커니즘입니다.</span><span class="sxs-lookup"><span data-stu-id="3e49c-139">Service Bus is a communication mechanism in hello cloud that's accessible from pretty much anywhere.</span></span> <span data-ttu-id="3e49c-140">방법 사용 하면 응용 프로그램 어떤 toodo 필요에 따라 다릅니다.</span><span class="sxs-lookup"><span data-stu-id="3e49c-140">How you use it depends on what your applications need toodo.</span></span>

## <a name="queues"></a><span data-ttu-id="3e49c-141">큐</span><span class="sxs-lookup"><span data-stu-id="3e49c-141">Queues</span></span>

<span data-ttu-id="3e49c-142">서비스 버스 큐를 사용 하 여 tooconnect 두 응용 프로그램을 결정 했다고 가정 합니다.</span><span class="sxs-lookup"><span data-stu-id="3e49c-142">Suppose you decide tooconnect two applications using a Service Bus queue.</span></span> <span data-ttu-id="3e49c-143">그림 2에서는 이 상황을 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="3e49c-143">Figure 2 illustrates this situation.</span></span>

![][2]

<span data-ttu-id="3e49c-144">**그림 2: 서비스 버스 큐는 단방향 비동기 큐를 제공합니다.**</span><span class="sxs-lookup"><span data-stu-id="3e49c-144">**Figure 2: Service Bus queues provide one-way asynchronous queuing.**</span></span>

<span data-ttu-id="3e49c-145">hello 과정은 간단: 보내는 메시지 tooa 서비스 버스 큐 및 수신자가이 나중에 해당 메시지를 선택 합니다.</span><span class="sxs-lookup"><span data-stu-id="3e49c-145">hello process is simple: A sender sends a message tooa Service Bus queue, and a receiver picks up that message at some later time.</span></span> <span data-ttu-id="3e49c-146">센서가 메시지를 서비스 버스 큐로 보내면 수신기가 나중에 해당 메시지를 확인합니다.</span><span class="sxs-lookup"><span data-stu-id="3e49c-146">A queue can have just a single receiver, as Figure 2 shows.</span></span> <span data-ttu-id="3e49c-147">Hello에서 여러 응용 프로그램을 읽을 수 또는 동일한 큐입니다.</span><span class="sxs-lookup"><span data-stu-id="3e49c-147">Or, multiple applications can read from hello same queue.</span></span> <span data-ttu-id="3e49c-148">Hello 후자의 경우, 각 메시지는 하나의 수신기에서 읽습니다.</span><span class="sxs-lookup"><span data-stu-id="3e49c-148">In hello latter situation, each message is read by just one receiver.</span></span> <span data-ttu-id="3e49c-149">멀티캐스트 서비스의 경우 대신 주제를 사용해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="3e49c-149">For a multi-cast service, you should use a topic instead.</span></span>

<span data-ttu-id="3e49c-150">각 메시지는 각각 키/값 쌍인 속성 집합과 메시지 페이로드의 두 부분으로 이루어져 있습니다.</span><span class="sxs-lookup"><span data-stu-id="3e49c-150">Each message has two parts: a set of properties, each a key/value pair, and a message payload.</span></span> <span data-ttu-id="3e49c-151">hello 페이로드는 이진, 텍스트 또는 XML에도 될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="3e49c-151">hello payload can be binary, text, or even XML.</span></span> <span data-ttu-id="3e49c-152">사용 하는 방법 toodo를 시도 하는 응용 프로그램에 따라 달라 집니다.</span><span class="sxs-lookup"><span data-stu-id="3e49c-152">How they're used depends on what an application is trying toodo.</span></span> <span data-ttu-id="3e49c-153">최근 판매에 대 한 메시지를 보내는 응용 프로그램 수 hello 속성을 포함 하는 예를 들어 **판매자 "Ava" =** 및 **크기 = 10000**합니다.</span><span class="sxs-lookup"><span data-stu-id="3e49c-153">For example, an application sending a message about a recent sale might include hello properties **Seller="Ava"** and **Amount=10000**.</span></span> <span data-ttu-id="3e49c-154">hello 메시지 본문 hello 판매 서명 된 계약의 스캔 한 이미지가 포함 될 수도 있습니다, 없는 경우를 빈 상태로 유지.</span><span class="sxs-lookup"><span data-stu-id="3e49c-154">hello message body might contain a scanned image of hello sale's signed contract or, if there isn't one, remain empty.</span></span>

<span data-ttu-id="3e49c-155">수신기는 두 가지 방법으로 서비스 버스 큐에서 메시지를 읽을 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="3e49c-155">A receiver can read a message from a Service Bus queue in two different ways.</span></span> <span data-ttu-id="3e49c-156">라는 첫 번째 옵션을 hello  *[ReceiveAndDelete](/dotnet/api/microsoft.servicebus.messaging.receivemode)*hello 큐에서 메시지를 제거 하 고 즉시 삭제 합니다.</span><span class="sxs-lookup"><span data-stu-id="3e49c-156">hello first option, called *[ReceiveAndDelete](/dotnet/api/microsoft.servicebus.messaging.receivemode)*, removes a message from hello queue and immediately deletes it.</span></span> <span data-ttu-id="3e49c-157">이 옵션은 간단 하지만 hello 메시지 처리를 완료 하기 전에 hello 수신기가 충돌 하는 경우 hello 메시지가 손실 됩니다.</span><span class="sxs-lookup"><span data-stu-id="3e49c-157">This option is simple, but if hello receiver crashes before it finishes processing hello message, hello message is lost.</span></span> <span data-ttu-id="3e49c-158">Hello 큐에서 제거 되었으므로를 다른 수신기 없음 액세스할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="3e49c-158">Because it's been removed from hello queue, no other receiver can access it.</span></span> 

<span data-ttu-id="3e49c-159">두 번째 옵션 hello  *[PeekLock](/dotnet/api/microsoft.servicebus.messaging.receivemode)*, toohelp이 문제가 발생할 것입니다.</span><span class="sxs-lookup"><span data-stu-id="3e49c-159">hello second option, *[PeekLock](/dotnet/api/microsoft.servicebus.messaging.receivemode)*, is meant toohelp with this problem.</span></span> <span data-ttu-id="3e49c-160">마찬가지로 **ReceiveAndDelete**, **PeekLock** 읽기 hello 큐에서 메시지를 제거 합니다.</span><span class="sxs-lookup"><span data-stu-id="3e49c-160">Like **ReceiveAndDelete**, a **PeekLock** read removes a message from hello queue.</span></span> <span data-ttu-id="3e49c-161">그러나 hello 메시지를 삭제 되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="3e49c-161">It doesn't delete hello message, however.</span></span> <span data-ttu-id="3e49c-162">대신, 보이지 않는 tooother 수신기를 만드는 hello 메시지를 잠급니다 다음 세 가지 이벤트 중 하나가 될 때까지 대기 합니다.</span><span class="sxs-lookup"><span data-stu-id="3e49c-162">Instead, it locks hello message, making it invisible tooother receivers, then waits for one of three events:</span></span>

* <span data-ttu-id="3e49c-163">수신기 프로세스 hello 메시지를 성공적으로 hello, 호출 [complete ()](/dotnet/api/microsoft.servicebus.messaging.brokeredmessage#Microsoft_ServiceBus_Messaging_BrokeredMessage_Complete), hello 큐 hello 메시지를 삭제 합니다.</span><span class="sxs-lookup"><span data-stu-id="3e49c-163">If hello receiver processes hello message successfully, it calls [Complete()](/dotnet/api/microsoft.servicebus.messaging.brokeredmessage#Microsoft_ServiceBus_Messaging_BrokeredMessage_Complete), and hello queue deletes hello message.</span></span> 
* <span data-ttu-id="3e49c-164">Hello 수신기가 hello 메시지를 성공적으로 처리할 수 없다고를 결정 하는 경우 호출 [Abandon()](/dotnet/api/microsoft.servicebus.messaging.brokeredmessage#Microsoft_ServiceBus_Messaging_BrokeredMessage_Abandon)합니다.</span><span class="sxs-lookup"><span data-stu-id="3e49c-164">If hello receiver decides that it can't process hello message successfully, it calls [Abandon()](/dotnet/api/microsoft.servicebus.messaging.brokeredmessage#Microsoft_ServiceBus_Messaging_BrokeredMessage_Abandon).</span></span> <span data-ttu-id="3e49c-165">그런 다음 hello 큐 hello 잠금은 hello 메시지에서 제거 하 고 사용할 수 있는 tooother 수신기를 만듭니다.</span><span class="sxs-lookup"><span data-stu-id="3e49c-165">hello queue then removes hello lock from hello message and makes it available tooother receivers.</span></span>
* <span data-ttu-id="3e49c-166">Hello 수신기에서는 이러한 메서드의 둘 다에서 구성 가능한 일정 기간 (기본적으로 60 초), hello 큐 hello 수신기 못한 가정 합니다.</span><span class="sxs-lookup"><span data-stu-id="3e49c-166">If hello receiver calls neither of these methods within a configurable period of time (by default, 60 seconds), hello queue assumes hello receiver has failed.</span></span> <span data-ttu-id="3e49c-167">이 경우 것 처럼 동작 hello 수신기 호출한 **중단**, hello 메시지 사용할 수 있는 tooother 수신기 만들기.</span><span class="sxs-lookup"><span data-stu-id="3e49c-167">In this case, it behaves as if hello receiver had called **Abandon**, making hello message available tooother receivers.</span></span>

<span data-ttu-id="3e49c-168">여기에 발생할 수 있는 결과 표시: hello 동일한 메시지 배달 될 수 있다는 두 번 tootwo 아마도 다른 수신기입니다.</span><span class="sxs-lookup"><span data-stu-id="3e49c-168">Notice what can happen here: hello same message might be delivered twice, perhaps tootwo different receivers.</span></span> <span data-ttu-id="3e49c-169">Service Bus 큐를 사용하는 응용 프로그램은 이 이벤트에 대비해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="3e49c-169">Applications using Service Bus queues must be prepared for this event.</span></span> <span data-ttu-id="3e49c-170">toomake 쉽게 중복 감지, 각 메시지에는 고유한 [MessageID](/dotnet/api/microsoft.servicebus.messaging.brokeredmessage#Microsoft_ServiceBus_Messaging_BrokeredMessage_MessageId) 큐에서 읽은 hello 메시지 횟수에 관계 없이 동일한 기본적으로 hello 상태를 유지 하는 속성입니다.</span><span class="sxs-lookup"><span data-stu-id="3e49c-170">toomake duplicate detection easier, each message has a unique [MessageID](/dotnet/api/microsoft.servicebus.messaging.brokeredmessage#Microsoft_ServiceBus_Messaging_BrokeredMessage_MessageId) property that by default stays hello same no matter how many times hello message is read from a queue.</span></span> 

<span data-ttu-id="3e49c-171">큐는 다양한 상황에서 유용합니다.</span><span class="sxs-lookup"><span data-stu-id="3e49c-171">Queues are useful in quite a few situations.</span></span> <span data-ttu-id="3e49c-172">응용 프로그램 toocommunicate 있도록 hello에서 모두 실행 하지 않는 경우에 동일한 시간, 일괄 처리 및 모바일 응용 프로그램에서 매우 편리에 있다는 것입니다.</span><span class="sxs-lookup"><span data-stu-id="3e49c-172">They enable applications toocommunicate even when both aren't running at hello same time, something that's especially handy with batch and mobile applications.</span></span> <span data-ttu-id="3e49c-173">여러 수신기가 있는 큐는 전송된 메시지가 이러한 수신기에 분산되므로 자동 부하 분산 기능도 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="3e49c-173">A queue with multiple receivers also provides automatic load balancing, since sent messages are spread across these receivers.</span></span>

## <a name="topics"></a><span data-ttu-id="3e49c-174">토픽</span><span class="sxs-lookup"><span data-stu-id="3e49c-174">Topics</span></span>

<span data-ttu-id="3e49c-175">유용한 멤버인, 큐 없는 경우도 hello 적합 한 솔루션입니다.</span><span class="sxs-lookup"><span data-stu-id="3e49c-175">Useful as they are, queues aren't always hello right solution.</span></span> <span data-ttu-id="3e49c-176">때로는 서비스 버스 토픽이 더 효율적입니다.</span><span class="sxs-lookup"><span data-stu-id="3e49c-176">Sometimes, Service Bus topics are better.</span></span> <span data-ttu-id="3e49c-177">그림 3에서는 이 아이디어를 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="3e49c-177">Figure 3 illustrates this idea.</span></span>

![][3]

<span data-ttu-id="3e49c-178">**그림 3: 등록 응용 프로그램을 지정 하는 hello 필터에 따라, 일부를 받을 수 또는 모든 hello 메시지가 전송 tooa 서비스 버스 항목입니다.**</span><span class="sxs-lookup"><span data-stu-id="3e49c-178">**Figure 3: Based on hello filter a subscribing application specifies, it can receive some or all hello messages sent tooa Service Bus topic.**</span></span>

<span data-ttu-id="3e49c-179">A *항목* 여러 방법으로 tooa 큐에 있는 것과 비슷합니다.</span><span class="sxs-lookup"><span data-stu-id="3e49c-179">A *topic* is similar in many ways tooa queue.</span></span> <span data-ttu-id="3e49c-180">보낸 사람 tooa 부분 hello에 메시지를 전송 tooa 큐 메시지를 전송할 때와 동일한 큐와 마찬가지로 이러한 메시지 모양을 hello 같은 방식으로 합니다.</span><span class="sxs-lookup"><span data-stu-id="3e49c-180">Senders submit messages tooa topic in hello same way that they submit messages tooa queue, and those messages look hello same as with queues.</span></span> <span data-ttu-id="3e49c-181">hello 차이점은 각 수신 응용 프로그램 toocreate을 사용 하는 항목 자체 *구독* 정의 하 여 한 *필터*합니다.</span><span class="sxs-lookup"><span data-stu-id="3e49c-181">hello difference is that topics enable each receiving application toocreate its own *subscription* by defining a *filter*.</span></span> <span data-ttu-id="3e49c-182">구독자는 다음 해당 필터와 일치 하는 hello 메시지만 표시 합니다.</span><span class="sxs-lookup"><span data-stu-id="3e49c-182">A subscriber then sees only hello messages that match that filter.</span></span> <span data-ttu-id="3e49c-183">예를 들어 그림 3에서는 각각 고유한 필터가 있는 세 명의 구독자가 포함된 토픽과 보낸 사람을 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="3e49c-183">For example, Figure 3 shows a sender and a topic with three subscribers, each with its own filter:</span></span>

* <span data-ttu-id="3e49c-184">구독자 1 hello 속성을 포함 하는 메시지만 받습니다 *판매자 "Ava" =*합니다.</span><span class="sxs-lookup"><span data-stu-id="3e49c-184">Subscriber 1 receives only messages that contain hello property *Seller="Ava"*.</span></span>
* <span data-ttu-id="3e49c-185">Hello 속성을 포함 하는 메시지를 수신 하는 구독자 2 *판매자 "Ruby" =* 포함 및/또는 *양* 100, 000 보다 큰 값으로 속성입니다.</span><span class="sxs-lookup"><span data-stu-id="3e49c-185">Subscriber 2 receives messages that contain hello property *Seller="Ruby"* and/or contain an *Amount* property whose value is greater than 100,000.</span></span> <span data-ttu-id="3e49c-186">아마도 Ruby 되므로 hello 영업 관리자가 자신의 판매와는 누가 관계 없이 모든 큰 판매 toosee 만들려고 합니다.</span><span class="sxs-lookup"><span data-stu-id="3e49c-186">Perhaps Ruby is hello sales manager, so she wants toosee both her own sales and all large sales regardless of who makes them.</span></span>
* <span data-ttu-id="3e49c-187">3 구독자가 해당 필터를 너무 설정*True*, 모든 메시지를 수신 했음을 의미 합니다.</span><span class="sxs-lookup"><span data-stu-id="3e49c-187">Subscriber 3 has set its filter too*True*, which means that it receives all messages.</span></span> <span data-ttu-id="3e49c-188">예를 들어이 응용 프로그램 감사 내역을 유지 관리 해야 할 수 있습니다 및 따라서 필요한 toosee 모든 hello 메시지입니다.</span><span class="sxs-lookup"><span data-stu-id="3e49c-188">For example, this application might be responsible for maintaining an audit trail and therefore it needs toosee all hello messages.</span></span>

<span data-ttu-id="3e49c-189">큐와 구독자 tooa 항목 중 하나를 사용 하 여 메시지를 읽이 있는 [ReceiveAndDelete 또는 PeekLock](/dotnet/api/microsoft.servicebus.messaging.receivemode)합니다.</span><span class="sxs-lookup"><span data-stu-id="3e49c-189">As with queues, subscribers tooa topic can read messages using either [ReceiveAndDelete or PeekLock](/dotnet/api/microsoft.servicebus.messaging.receivemode).</span></span> <span data-ttu-id="3e49c-190">그러나 큐와 달리 단일 메시지 전송 tooa 항목 여러 구독에서 받을 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="3e49c-190">Unlike queues, however, a single message sent tooa topic can be received by multiple subscriptions.</span></span> <span data-ttu-id="3e49c-191">일반적으로 이라는이 방법을 사용 *게시 및 구독* (또는 *pub/sub*), 여러 응용 프로그램이 hello에 관심이 때마다 유용 같은 메시지입니다.</span><span class="sxs-lookup"><span data-stu-id="3e49c-191">This approach, commonly called *publish and subscribe* (or *pub/sub*), is useful whenever multiple applications are interested in hello same messages.</span></span> <span data-ttu-id="3e49c-192">Hello 오른쪽 필터를 정의 하 여 각 구독자 필요 하다 고 toosee hello 메시지 스트림의 hello 부분만 활용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="3e49c-192">By defining hello right filter, each subscriber can tap into just hello part of hello message stream that it needs toosee.</span></span>

## <a name="relays"></a><span data-ttu-id="3e49c-193">릴레이</span><span class="sxs-lookup"><span data-stu-id="3e49c-193">Relays</span></span>

<span data-ttu-id="3e49c-194">큐와 토픽은 둘 다 브로커를 통해 단방향 비동기 통신을 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="3e49c-194">Both queues and topics provide one-way asynchronous communication through a broker.</span></span> <span data-ttu-id="3e49c-195">트래픽이 한 방향으로만 진행되며, 보낸 사람과 받는 사람 간에 직접 연결이 없습니다.</span><span class="sxs-lookup"><span data-stu-id="3e49c-195">Traffic flows in just one direction, and there's no direct connection between senders and receivers.</span></span> <span data-ttu-id="3e49c-196">그러나 이런 연결을 원하지 않는 경우 어떻게 해야 할까요?</span><span class="sxs-lookup"><span data-stu-id="3e49c-196">But what if you don't want this connection?</span></span> <span data-ttu-id="3e49c-197">응용 프로그램을 가정 필요 tooboth 보내고 메시지를 받을 또는 아마도 서로 직접 링크를 원하는 및 broker toostore 메시지 필요 하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="3e49c-197">Suppose your applications need tooboth send and receive messages, or perhaps you want a direct link between them and you don't need a broker toostore messages.</span></span> <span data-ttu-id="3e49c-198">이와 같은 tooaddress 시나리오에서 서비스 버스를 제공 *릴레이*그림 4, 합니다.</span><span class="sxs-lookup"><span data-stu-id="3e49c-198">tooaddress scenarios such as this, Service Bus provides *relays*, as Figure 4 shows.</span></span>

![][4]

<span data-ttu-id="3e49c-199">**그림 4: 서비스 버스 릴레이는 응용 프로그램 간에 양방향 동기 통신을 제공합니다.**</span><span class="sxs-lookup"><span data-stu-id="3e49c-199">**Figure 4: Service Bus relay provides synchronous, two-way communication between applications.**</span></span>

<span data-ttu-id="3e49c-200">hello 릴레이 대 한 명확한 질문 tooask 이것이: 왜 사용 하나?</span><span class="sxs-lookup"><span data-stu-id="3e49c-200">hello obvious question tooask about relays is this: why would I use one?</span></span> <span data-ttu-id="3e49c-201">큐 필요 없음, 경우에 직접 상호 작용 뿐 아니라 클라우드 서비스를 통해 통신 하는 응용 프로그램을 만드는 이유? hello 대답이 통하게 직접 수 있도록 생각 보다 어렵습니다.</span><span class="sxs-lookup"><span data-stu-id="3e49c-201">Even if I don't need queues, why make applications communicate via a cloud service rather than just interact directly? hello answer is that talking directly can be harder than you might think.</span></span>

<span data-ttu-id="3e49c-202">Tooconnect 두 온-프레미스 응용 프로그램을 가정해 기업 데이터 센터 내에서 둘 다 실행 합니다.</span><span class="sxs-lookup"><span data-stu-id="3e49c-202">Suppose you want tooconnect two on-premises applications, both running inside corporate datacenters.</span></span> <span data-ttu-id="3e49c-203">각 응용 프로그램은 방화벽 뒤에 있고, 각 데이터 센터에서 NAT(Network Address Translation)를 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="3e49c-203">Each of these applications sits behind a firewall, and each datacenter probably uses network address translation (NAT).</span></span> <span data-ttu-id="3e49c-204">각 응용 프로그램에서 실행 되는 hello 컴퓨터를 의미 하는 몇 가지 포트 및 NAT 제외한 모든 들어오는 데이터 hello 방화벽 블록 외부 hello 데이터 센터에서 직접 도달할 수 있는 고정된 IP 주소를 없는 합니다.</span><span class="sxs-lookup"><span data-stu-id="3e49c-204">hello firewall blocks incoming data on all but a few ports, and NAT implies that hello machine each application is running on doesn't have a fixed IP address that you can reach directly from outside hello datacenter.</span></span> <span data-ttu-id="3e49c-205">몇 가지 추가 도움 없이 hello를 통해 이러한 응용 프로그램 연결 공용 인터넷 문제가 될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="3e49c-205">Without some extra help, connecting these applications over hello public internet is problematic.</span></span>

<span data-ttu-id="3e49c-206">Azure 서비스 버스 릴레이는 도움이 됩니다.</span><span class="sxs-lookup"><span data-stu-id="3e49c-206">A Service Bus relay can help.</span></span> <span data-ttu-id="3e49c-207">각 응용 프로그램에 대 한 릴레이 통해 양방향으로 toocommunicate 서비스 버스에 대 한 아웃 바운드 TCP 연결을 설정 후 열어 둡니다.</span><span class="sxs-lookup"><span data-stu-id="3e49c-207">toocommunicate bi-directionally through a relay, each application establishes an outbound TCP connection with Service Bus, then keeps it open.</span></span> <span data-ttu-id="3e49c-208">Hello 두 응용 프로그램 간의 모든 통신이 이러한 연결을 통해 이동 합니다.</span><span class="sxs-lookup"><span data-stu-id="3e49c-208">All communication between hello two applications travels over these connections.</span></span> <span data-ttu-id="3e49c-209">각 연결 때문에에서 hello 데이터 센터 내 hello 방화벽 허용 들어오는 트래픽을 tooeach 응용 프로그램이 새 포트를 열지 않고 합니다.</span><span class="sxs-lookup"><span data-stu-id="3e49c-209">Because each connection was established from inside hello datacenter, hello firewall allows incoming traffic tooeach application without opening new ports.</span></span> <span data-ttu-id="3e49c-210">이 방법은 hello 클라우드의 hello 통신 전체에서 각 응용 프로그램에는 일관성 있는 끝점이 hello NAT 문제를 가져옵니다.</span><span class="sxs-lookup"><span data-stu-id="3e49c-210">This approach also gets around hello NAT problem, because each application has a consistent endpoint in hello cloud throughout hello communication.</span></span> <span data-ttu-id="3e49c-211">Hello 릴레이 통해 데이터를 교환 하 여 hello 응용 프로그램은 그렇지 않은 경우 통신 어렵게 만드는 hello 문제를 방지할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="3e49c-211">By exchanging data through hello relay, hello applications can avoid hello problems that would otherwise make communication difficult.</span></span> 

<span data-ttu-id="3e49c-212">서비스 버스 릴레이 toouse, 응용 프로그램이 Windows Communication Foundation (WCF) hello를 사용 합니다.</span><span class="sxs-lookup"><span data-stu-id="3e49c-212">toouse Service Bus relays, applications rely on hello Windows Communication Foundation (WCF).</span></span> <span data-ttu-id="3e49c-213">서비스 버스 릴레이 통해 Windows 응용 프로그램 toointeract에 대 한 간단 하 게 확인 하는 WCF 바인딩을 제공 합니다.</span><span class="sxs-lookup"><span data-stu-id="3e49c-213">Service Bus provides WCF bindings that make it straightforward for Windows applications toointeract via relays.</span></span> <span data-ttu-id="3e49c-214">이미 WCF를 사용 하는 응용 프로그램 일반적으로 이러한 바인딩 중 하나를 지정 다음 이야기 tooeach 릴레이 통해 다른 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="3e49c-214">Applications that already use WCF can typically specify one of these bindings, then talk tooeach other through a relay.</span></span> <span data-ttu-id="3e49c-215">그러나 큐 및 토픽과 달리 Windows가 아닌 응용 프로그램에서 릴레이를 사용할 수는 있지만 이 경우 약간의 프로그래밍이 필요하며 표준 라이브러리가 제공되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="3e49c-215">Unlike queues and topics, however, using relays from non-Windows applications, while possible, requires some programming effort; no standard libraries are provided.</span></span>

<span data-ttu-id="3e49c-216">큐 및 토픽과 달리 응용 프로그램에서 명시적으로 릴레이를 만들지는 않습니다.</span><span class="sxs-lookup"><span data-stu-id="3e49c-216">Unlike queues and topics, applications don't explicitly create relays.</span></span> <span data-ttu-id="3e49c-217">대신 서비스 버스에 TCP 연결을 설정 하는 tooreceive 메시지 하지 않고자 한다면 하는 응용 프로그램, 릴레이 자동으로 만들어집니다.</span><span class="sxs-lookup"><span data-stu-id="3e49c-217">Instead, when an application that wishes tooreceive messages establishes a TCP connection with Service Bus, a relay is created automatically.</span></span> <span data-ttu-id="3e49c-218">Hello 연결을 삭제 하는 경우에 hello 릴레이 삭제 됩니다.</span><span class="sxs-lookup"><span data-stu-id="3e49c-218">When hello connection is dropped, hello relay is deleted.</span></span> <span data-ttu-id="3e49c-219">특정 수신기를 서비스 버스에서 만든 응용 프로그램 toofind hello 릴레이 tooenable 이름으로 응용 프로그램 toolocate 수 있도록 하는 레지스트리 특정 릴레이 제공 합니다.</span><span class="sxs-lookup"><span data-stu-id="3e49c-219">tooenable an application toofind hello relay created by a specific listener, Service Bus provides a registry that enables applications toolocate a specific relay by name.</span></span>

<span data-ttu-id="3e49c-220">응용 프로그램 간의 직접 통신 해야 하는 경우 릴레이 hello 오른쪽 솔루션입니다.</span><span class="sxs-lookup"><span data-stu-id="3e49c-220">Relays are hello right solution when you need direct communication between applications.</span></span> <span data-ttu-id="3e49c-221">온-프레미스 데이터 센터에서 실행되는 항공편 예약 시스템을 체크 인 키오스크, 모바일 장치 및 기타 컴퓨터에서 액세스할 수 있어야 하는 경우를 예로 들어 보겠습니다.</span><span class="sxs-lookup"><span data-stu-id="3e49c-221">For example, consider an airline reservation system running in an on-premises datacenter that must be accessed from check-in kiosks, mobile devices, and other computers.</span></span> <span data-ttu-id="3e49c-222">이러한 모든 시스템에서 실행 중인 응용 프로그램 hello 클라우드 toocommunicate에서 서비스 버스 릴레이 의존 수 때마다 실행 될 수도 있습니다.</span><span class="sxs-lookup"><span data-stu-id="3e49c-222">Applications running on all these systems could rely on Service Bus relays in hello cloud toocommunicate, wherever they might be running.</span></span>

## <a name="summary"></a><span data-ttu-id="3e49c-223">요약</span><span class="sxs-lookup"><span data-stu-id="3e49c-223">Summary</span></span>

<span data-ttu-id="3e49c-224">전체 솔루션을 작성의 일부 항상 있었지만 응용 프로그램에 연결 및 응용 프로그램 및 서비스 toocommunicate 서로 해야 하는 시나리오의 hello 범위 tooincrease 설정 되어 더 많은 응용 프로그램 및 장치에 연결 된 toohello로 인터넷 합니다.</span><span class="sxs-lookup"><span data-stu-id="3e49c-224">Connecting applications has always been part of building complete solutions, and hello range of scenarios that require applications and services toocommunicate with each other is set tooincrease as more applications and devices are connected toohello internet.</span></span> <span data-ttu-id="3e49c-225">클라우드 기반 기술인 큐, 항목 및 릴레이 통해 통신을 얻기 위해을 제공 하 여 서비스 버스 목표로 toomake이 필수 기능은 쉽게 tooimplement 보다 광범위 하 게 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="3e49c-225">By providing cloud-based technologies for achieving communication through queues, topics, and relays, Service Bus aims toomake this essential function easier tooimplement and more broadly available.</span></span>

## <a name="next-steps"></a><span data-ttu-id="3e49c-226">다음 단계</span><span class="sxs-lookup"><span data-stu-id="3e49c-226">Next steps</span></span>

<span data-ttu-id="3e49c-227">Azure 서비스 버스의 hello 기본 사항 학습 한, 했으므로 이러한 링크 toolearn 자세한 수행 합니다.</span><span class="sxs-lookup"><span data-stu-id="3e49c-227">Now that you've learned hello fundamentals of Azure Service Bus, follow these links toolearn more.</span></span>

* <span data-ttu-id="3e49c-228">어떻게 toouse [서비스 버스 큐](service-bus-dotnet-get-started-with-queues.md)</span><span class="sxs-lookup"><span data-stu-id="3e49c-228">How toouse [Service Bus queues](service-bus-dotnet-get-started-with-queues.md)</span></span>
* <span data-ttu-id="3e49c-229">어떻게 toouse [서비스 버스 주제](service-bus-dotnet-how-to-use-topics-subscriptions.md)</span><span class="sxs-lookup"><span data-stu-id="3e49c-229">How toouse [Service Bus topics](service-bus-dotnet-how-to-use-topics-subscriptions.md)</span></span>
* <span data-ttu-id="3e49c-230">어떻게 toouse [서비스 버스 릴레이](../service-bus-relay/service-bus-dotnet-how-to-use-relay.md)</span><span class="sxs-lookup"><span data-stu-id="3e49c-230">How toouse [Service Bus relay](../service-bus-relay/service-bus-dotnet-how-to-use-relay.md)</span></span>
* [<span data-ttu-id="3e49c-231">서비스 버스 샘플</span><span class="sxs-lookup"><span data-stu-id="3e49c-231">Service Bus samples</span></span>](service-bus-samples.md)

[1]: ./media/service-bus-fundamentals-hybrid-solutions/SvcBus_01_architecture.png
[2]: ./media/service-bus-fundamentals-hybrid-solutions/SvcBus_02_queues.png
[3]: ./media/service-bus-fundamentals-hybrid-solutions/SvcBus_03_topicsandsubscriptions.png
[4]: ./media/service-bus-fundamentals-hybrid-solutions/SvcBus_04_relay.png
