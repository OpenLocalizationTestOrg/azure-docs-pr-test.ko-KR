---
title: "Azure 서비스 버스를 사용 하 여 성능을 향상 시키기 위한 aaaBest 사례 | Microsoft Docs"
description: "교환할 때 서비스 버스 toooptimize 성능 toouse 메시지를 조정 하는 방법을 설명 합니다."
services: service-bus-messaging
documentationcenter: na
author: sethmanheim
manager: timlt
editor: 
ms.assetid: e756c15d-31fc-45c0-8df4-0bca0da10bb2
ms.service: service-bus-messaging
ms.devlang: na
ms.topic: article
ms.tgt_pltfrm: na
ms.workload: na
ms.date: 05/10/2017
ms.author: sethm
ms.openlocfilehash: 52764d227757cbb11246675878933f21685817f1
ms.sourcegitcommit: 523283cc1b3c37c428e77850964dc1c33742c5f0
ms.translationtype: MT
ms.contentlocale: ko-KR
ms.lasthandoff: 10/06/2017
---
# <a name="best-practices-for-performance-improvements-using-service-bus-messaging"></a><span data-ttu-id="782f4-103">Service Bus 메시징을 사용한 성능 향상의 모범 사례</span><span class="sxs-lookup"><span data-stu-id="782f4-103">Best Practices for performance improvements using Service Bus Messaging</span></span>

<span data-ttu-id="782f4-104">이 문서에서는 설명 방법을 toouse [Azure 서비스 버스 메시징](https://azure.microsoft.com/services/service-bus/) toooptimize 성능을 교환할 때 메시지를 조정 합니다.</span><span class="sxs-lookup"><span data-stu-id="782f4-104">This article describes how toouse [Azure Service Bus messaging](https://azure.microsoft.com/services/service-bus/) toooptimize performance when exchanging brokered messages.</span></span> <span data-ttu-id="782f4-105">이 항목의 첫 번째 부분 hello hello toohelp 증가 성능이 제공 되는 서로 다른 메커니즘을 설명 합니다.</span><span class="sxs-lookup"><span data-stu-id="782f4-105">hello first part of this topic describes hello different mechanisms that are offered toohelp increase performance.</span></span> <span data-ttu-id="782f4-106">두 번째 부분은 hello 방법을 제공할 수 있는 방식으로 서비스 버스 toouse hello 지정된 된 시나리오에서 성능을 최대화 하에 지침을 제공 합니다.</span><span class="sxs-lookup"><span data-stu-id="782f4-106">hello second part provides guidance on how toouse Service Bus in a way that can offer hello best performance in a given scenario.</span></span>

<span data-ttu-id="782f4-107">이 항목 전반 hello 라는 용어 "클라이언트" 서비스 버스에 액세스 하는 tooany 엔터티를 나타냅니다.</span><span class="sxs-lookup"><span data-stu-id="782f4-107">Throughout this topic, hello term "client" refers tooany entity that accesses Service Bus.</span></span> <span data-ttu-id="782f4-108">클라이언트는 발신자 또는 수신자의 hello 역할을 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="782f4-108">A client can take hello role of a sender or a receiver.</span></span> <span data-ttu-id="782f4-109">"sender" hello 용어 메시지 tooa 서비스 버스 큐 또는 항목을 전송 하는 서비스 버스 큐 또는 항목 클라이언트에 사용 됩니다.</span><span class="sxs-lookup"><span data-stu-id="782f4-109">hello term "sender" is used for a Service Bus queue or topic client that sends messages tooa Service Bus queue or topic.</span></span> <span data-ttu-id="782f4-110">hello "수신자" 이라는 용어는 tooa 서비스 버스 큐 또는 구독 클라이언트를 서비스 버스 큐 또는 구독에서 메시지를 수신 합니다.</span><span class="sxs-lookup"><span data-stu-id="782f4-110">hello term "receiver" refers tooa Service Bus queue or subscription client that receives messages from a Service Bus queue or subscription.</span></span>

<span data-ttu-id="782f4-111">이 섹션에서는 서비스 버스 toohelp 성능을 높이기를 사용 하는 몇 가지 개념을 소개 합니다.</span><span class="sxs-lookup"><span data-stu-id="782f4-111">These sections introduce several concepts that Service Bus uses toohelp boost performance.</span></span>

## <a name="protocols"></a><span data-ttu-id="782f4-112">프로토콜</span><span class="sxs-lookup"><span data-stu-id="782f4-112">Protocols</span></span>
<span data-ttu-id="782f4-113">서비스 버스 클라이언트 toosend 있으며 특정 프로토콜 중 하나를 통해 메시지를 수신 합니다.</span><span class="sxs-lookup"><span data-stu-id="782f4-113">Service Bus enables clients toosend and receive messages via one of three protocols:</span></span>

1. <span data-ttu-id="782f4-114">AMQP(고급 메시지 큐 프로토콜)</span><span class="sxs-lookup"><span data-stu-id="782f4-114">Advanced Message Queuing Protocol (AMQP)</span></span>
2. <span data-ttu-id="782f4-115">SBMP(Service Bus 메시징 프로토콜)</span><span class="sxs-lookup"><span data-stu-id="782f4-115">Service Bus Messaging Protocol (SBMP)</span></span>
3. <span data-ttu-id="782f4-116">HTTP</span><span class="sxs-lookup"><span data-stu-id="782f4-116">HTTP</span></span>

<span data-ttu-id="782f4-117">AMQP 및 SBMP는 hello 메시징 팩터리 존재 hello 연결 tooService 버스 유지 하기 때문에 더 효율적입니다.</span><span class="sxs-lookup"><span data-stu-id="782f4-117">AMQP and SBMP are more efficient, because they maintain hello connection tooService Bus as long as hello messaging factory exists.</span></span> <span data-ttu-id="782f4-118">또한 일괄 처리와 프리페치도 구현합니다.</span><span class="sxs-lookup"><span data-stu-id="782f4-118">It also implements batching and prefetching.</span></span> <span data-ttu-id="782f4-119">명시적으로 언급 하지 않는 한이 항목의 모든 콘텐츠는 AMQP 또는 SBMP hello 사용을 가정 합니다.</span><span class="sxs-lookup"><span data-stu-id="782f4-119">Unless explicitly mentioned, all content in this topic assumes hello use of AMQP or SBMP.</span></span>

## <a name="reusing-factories-and-clients"></a><span data-ttu-id="782f4-120">팩터리 및 클라이언트 다시 사용</span><span class="sxs-lookup"><span data-stu-id="782f4-120">Reusing factories and clients</span></span>
<span data-ttu-id="782f4-121">[QueueClient][QueueClient] 또는 [MessageSender][MessageSender]와 같은 Service Bus 클라이언트 개체는 내부 연결 관리도 제공하는 [MessagingFactory][MessagingFactory] 개체를 통해 만듭니다.</span><span class="sxs-lookup"><span data-stu-id="782f4-121">Service Bus client objects, such as [QueueClient][QueueClient] or [MessageSender][MessageSender], are created through a [MessagingFactory][MessagingFactory] object, which also provides internal management of connections.</span></span> <span data-ttu-id="782f4-122">메시징 팩터리 나 큐, 항목 및 구독 클라이언트는 메시지를 보내고 다음 다시 작성 hello 다음 메시지를 보낼 때 후 닫기 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="782f4-122">You should not close messaging factories or queue, topic, and subscription clients after you send a message, and then re-create them when you send hello next message.</span></span> <span data-ttu-id="782f4-123">Hello 팩터리를 다시 만들 때 새 연결이 설정 되 및 hello 연결 toohello 서비스 버스 서비스를 삭제 하는 메시징 팩터리를 닫으면 합니다.</span><span class="sxs-lookup"><span data-stu-id="782f4-123">Closing a messaging factory deletes hello connection toohello Service Bus service, and a new connection is established when recreating hello factory.</span></span> <span data-ttu-id="782f4-124">여러 작업에 대 한 개체 연결이 다시 사용 하 여 방지할 수 있습니다는 비용이 많이 드는 작업 hello 같은 팩터리 및 클라이언트를 설정 합니다.</span><span class="sxs-lookup"><span data-stu-id="782f4-124">Establishing a connection is an expensive operation that you can avoid by re-using hello same factory and client objects for multiple operations.</span></span> <span data-ttu-id="782f4-125">Hello를 안전 하 게 사용할 수 있습니다 [QueueClient] [ QueueClient] 동시 비동기 작업 및 다중 스레드에서 메시지를 보내기 위한 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="782f4-125">You can safely use hello [QueueClient][QueueClient] object for sending messages from concurrent asynchronous operations and multiple threads.</span></span> 

## <a name="concurrent-operations"></a><span data-ttu-id="782f4-126">동시 작업</span><span class="sxs-lookup"><span data-stu-id="782f4-126">Concurrent operations</span></span>
<span data-ttu-id="782f4-127">작업(보내기, 받기, 삭제 등) 수행은 다소 시간이 걸립니다.</span><span class="sxs-lookup"><span data-stu-id="782f4-127">Performing an operation (send, receive, delete, etc.) takes some time.</span></span> <span data-ttu-id="782f4-128">이 시간 hello 요청과 hello 회신의 추가 toohello 대기 시간에 서비스 버스 서비스 hello 하 여 hello hello 작업 처리를 포함합니다.</span><span class="sxs-lookup"><span data-stu-id="782f4-128">This time includes hello processing of hello operation by hello Service Bus service in addition toohello latency of hello request and hello reply.</span></span> <span data-ttu-id="782f4-129">시간당 작업 tooincrease hello 번호 작업이 동시에 실행 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="782f4-129">tooincrease hello number of operations per time, operations must execute concurrently.</span></span> <span data-ttu-id="782f4-130">이 작업은 다양한 방법으로 수행할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="782f4-130">You can do this in several different ways:</span></span>

* <span data-ttu-id="782f4-131">**비동기 작업**: hello 클라이언트는 비동기 작업을 수행 하 여 작업을 예약 합니다.</span><span class="sxs-lookup"><span data-stu-id="782f4-131">**Asynchronous operations**: hello client schedules operations by performing asynchronous operations.</span></span> <span data-ttu-id="782f4-132">hello 이전 요청을 완료 하기 전에 hello 다음 요청이 시작 됩니다.</span><span class="sxs-lookup"><span data-stu-id="782f4-132">hello next request is started before hello previous request is completed.</span></span> <span data-ttu-id="782f4-133">hello 다음은 비동기 보내기 작업의 예입니다.</span><span class="sxs-lookup"><span data-stu-id="782f4-133">hello following is an example of an asynchronous send operation:</span></span>
  
 ```csharp
  BrokeredMessage m1 = new BrokeredMessage(body);
  BrokeredMessage m2 = new BrokeredMessage(body);
  
  Task send1 = queueClient.SendAsync(m1).ContinueWith((t) => 
    {
      Console.WriteLine("Sent message #1");
    });
  Task send2 = queueClient.SendAsync(m2).ContinueWith((t) => 
    {
      Console.WriteLine("Sent message #2");
    });
  Task.WaitAll(send1, send2);
  Console.WriteLine("All messages sent");
  ```
  
  <span data-ttu-id="782f4-134">다음은 비동기 수신 작업의 예제입니다.</span><span class="sxs-lookup"><span data-stu-id="782f4-134">This is an example of an asynchronous receive operation:</span></span>
  
  ```csharp
  Task receive1 = queueClient.ReceiveAsync().ContinueWith(ProcessReceivedMessage);
  Task receive2 = queueClient.ReceiveAsync().ContinueWith(ProcessReceivedMessage);
  
  Task.WaitAll(receive1, receive2);
  Console.WriteLine("All messages received");
  
  async void ProcessReceivedMessage(Task<BrokeredMessage> t)
  {
    BrokeredMessage m = t.Result;
    Console.WriteLine("{0} received", m.Label);
    await m.CompleteAsync();
    Console.WriteLine("{0} complete", m.Label);
  }
  ```
* <span data-ttu-id="782f4-135">**여러 팩터리**:에 의해 만들어진 모든 클라이언트 (보낸 사람 더하기 tooreceivers) hello 같은 팩터리 공유 하나의 TCP 연결 합니다.</span><span class="sxs-lookup"><span data-stu-id="782f4-135">**Multiple factories**: all clients (senders in addition tooreceivers) that are created by hello same factory share one TCP connection.</span></span> <span data-ttu-id="782f4-136">hello 최대 메시지 처리량이 TCP 연결을 통과할 수 있는 작업의 hello 수로 제한 됩니다.</span><span class="sxs-lookup"><span data-stu-id="782f4-136">hello maximum message throughput is limited by hello number of operations that can go through this TCP connection.</span></span> <span data-ttu-id="782f4-137">단일 팩터리를 통해 얻을 수 있는 hello 처리량 TCP 왕복 시간 및 메시지 크기를 크게 달라 집니다.</span><span class="sxs-lookup"><span data-stu-id="782f4-137">hello throughput that can be obtained with a single factory varies greatly with TCP round-trip times and message size.</span></span> <span data-ttu-id="782f4-138">처리량 속도 더 tooobtain, 여러 메시징 팩터리를 사용 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="782f4-138">tooobtain higher throughput rates, you should use multiple messaging factories.</span></span>

## <a name="receive-mode"></a><span data-ttu-id="782f4-139">수신 모드</span><span class="sxs-lookup"><span data-stu-id="782f4-139">Receive mode</span></span>
<span data-ttu-id="782f4-140">큐 또는 구독 클라이언트를 만들 때 *보기-잠금* 또는 *수신 및 삭제* 중에서 수신 모드를 지정할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="782f4-140">When creating a queue or subscription client, you can specify a receive mode: *Peek-lock* or *Receive and Delete*.</span></span> <span data-ttu-id="782f4-141">hello 기본 수신 모드는 [PeekLock][PeekLock]합니다.</span><span class="sxs-lookup"><span data-stu-id="782f4-141">hello default receive mode is [PeekLock][PeekLock].</span></span> <span data-ttu-id="782f4-142">이 모드에서 작업할 때 클라이언트 hello 메시지를 보냅니다 요청 tooreceive 서비스 버스에서.</span><span class="sxs-lookup"><span data-stu-id="782f4-142">When operating in this mode, hello client sends a request tooreceive a message from Service Bus.</span></span> <span data-ttu-id="782f4-143">Hello 클라이언트 hello 메시지를 받은 경우 요청 toocomplete hello 메시지를 보냅니다.</span><span class="sxs-lookup"><span data-stu-id="782f4-143">After hello client has received hello message, it sends a request toocomplete hello message.</span></span>

<span data-ttu-id="782f4-144">Hello 설정 수신 모드 너무[ReceiveAndDelete][ReceiveAndDelete], 두 단계가 단일 요청에 결합 됩니다.</span><span class="sxs-lookup"><span data-stu-id="782f4-144">When setting hello receive mode too[ReceiveAndDelete][ReceiveAndDelete], both steps are combined in a single request.</span></span> <span data-ttu-id="782f4-145">작업의 전체 번호가 hello 줄어들고 hello를 향상 시킬 수 있습니다이 전반적인 메시지 처리량입니다.</span><span class="sxs-lookup"><span data-stu-id="782f4-145">This reduces hello overall number of operations, and can improve hello overall message throughput.</span></span> <span data-ttu-id="782f4-146">메시지가 손실의 위험 hello에 성능상의 이점이 제공 됩니다.</span><span class="sxs-lookup"><span data-stu-id="782f4-146">This performance gain comes at hello risk of losing messages.</span></span>

<span data-ttu-id="782f4-147">서비스 버스는 수신 및 삭제 작업에 대한 트랜잭션을 지원하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="782f4-147">Service Bus does not support transactions for receive-and-delete operations.</span></span> <span data-ttu-id="782f4-148">또한 미리 보기-잠금 의미 체계는 어떤 hello에 클라이언트가 원하는 toodefer 모든 시나리오에 필요 하거나 [배달 못 한 편지](service-bus-dead-letter-queues.md) 메시지입니다.</span><span class="sxs-lookup"><span data-stu-id="782f4-148">In addition, peek-lock semantics are required for any scenarios in which hello client wants toodefer or [dead-letter](service-bus-dead-letter-queues.md) a message.</span></span>

## <a name="client-side-batching"></a><span data-ttu-id="782f4-149">클라이언트 쪽 일괄 처리</span><span class="sxs-lookup"><span data-stu-id="782f4-149">Client-side batching</span></span>
<span data-ttu-id="782f4-150">큐 또는 항목 클라이언트 toodelay hello 메시지 보내기를 일정 기간에 대 한 클라이언트 쪽 일괄 처리 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="782f4-150">Client-side batching enables a queue or topic client toodelay hello sending of a message for a certain period of time.</span></span> <span data-ttu-id="782f4-151">클라이언트 hello이 시간 동안 추가 메시지를 보내면, 단일 일괄 처리의 hello 메시지를 전송 합니다.</span><span class="sxs-lookup"><span data-stu-id="782f4-151">If hello client sends additional messages during this time period, it transmits hello messages in a single batch.</span></span> <span data-ttu-id="782f4-152">클라이언트 쪽 일괄 처리 큐 또는 구독 클라이언트 toobatch로 인해 여러 **완료** 단일 요청으로 요청 합니다.</span><span class="sxs-lookup"><span data-stu-id="782f4-152">Client-side batching also causes a queue or subscription client toobatch multiple **Complete** requests into a single request.</span></span> <span data-ttu-id="782f4-153">일괄 처리는 비동기 **전송** 및 **완료** 작업에만 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="782f4-153">Batching is only available for asynchronous **Send** and **Complete** operations.</span></span> <span data-ttu-id="782f4-154">동기 작업 toohello 서비스 버스 서비스를 즉시 전송 됩니다.</span><span class="sxs-lookup"><span data-stu-id="782f4-154">Synchronous operations are immediately sent toohello Service Bus service.</span></span> <span data-ttu-id="782f4-155">일괄 처리는 보기 또는 수신 작업에 대해 발생하지 않으며 클라이언트 전반에서도 발생하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="782f4-155">Batching does not occur for peek or receive operations, nor does batching occur across clients.</span></span>

<span data-ttu-id="782f4-156">기본적으로 클라이언트는 20ms의 배치 간격을 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="782f4-156">By default, a client uses a batch interval of 20ms.</span></span> <span data-ttu-id="782f4-157">Hello 설정 하 여 hello 일괄 처리 간격을 변경할 수 있습니다 [BatchFlushInterval] [ BatchFlushInterval] 속성을 만들기 전에 hello 메시징 팩터리입니다.</span><span class="sxs-lookup"><span data-stu-id="782f4-157">You can change hello batch interval by setting hello [BatchFlushInterval][BatchFlushInterval] property before creating hello messaging factory.</span></span> <span data-ttu-id="782f4-158">이 설정은이 이 팩터리에서 만든 모든 클라이언트에 영향을 줍니다.</span><span class="sxs-lookup"><span data-stu-id="782f4-158">This setting affects all clients that are created by this factory.</span></span>

<span data-ttu-id="782f4-159">hello 설정 toodisable 일괄 처리, [BatchFlushInterval] [ BatchFlushInterval] 속성 너무**TimeSpan.Zero**합니다.</span><span class="sxs-lookup"><span data-stu-id="782f4-159">toodisable batching, set hello [BatchFlushInterval][BatchFlushInterval] property too**TimeSpan.Zero**.</span></span> <span data-ttu-id="782f4-160">예:</span><span class="sxs-lookup"><span data-stu-id="782f4-160">For example:</span></span>

```csharp
MessagingFactorySettings mfs = new MessagingFactorySettings();
mfs.TokenProvider = tokenProvider;
mfs.NetMessagingTransportSettings.BatchFlushInterval = TimeSpan.FromSeconds(0.05);
MessagingFactory messagingFactory = MessagingFactory.Create(namespaceUri, mfs);
```

<span data-ttu-id="782f4-161">일괄 처리 hello 청구 가능한 메시징 작업 수에 영향을 주지 않습니다 되며 hello 서비스 버스 클라이언트 프로토콜에 대해서만 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="782f4-161">Batching does not affect hello number of billable messaging operations, and is available only for hello Service Bus client protocol.</span></span> <span data-ttu-id="782f4-162">HTTP 프로토콜 hello 일괄 처리를 지원 하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="782f4-162">hello HTTP protocol does not support batching.</span></span>

## <a name="batching-store-access"></a><span data-ttu-id="782f4-163">저장소 액세스 일괄 처리</span><span class="sxs-lookup"><span data-stu-id="782f4-163">Batching store access</span></span>
<span data-ttu-id="782f4-164">큐, 항목 또는 구독의 tooincrease hello 처리량, tooits 내부 저장소에 쓸 때 서비스 버스 여러 개의 메시지 일괄 처리.</span><span class="sxs-lookup"><span data-stu-id="782f4-164">tooincrease hello throughput of a queue, topic, or subscription, Service Bus batches multiple messages when it writes tooits internal store.</span></span> <span data-ttu-id="782f4-165">큐 또는 항목에서 활성화 hello 저장소로의 메시지 쓰기가 일괄 처리할 됩니다.</span><span class="sxs-lookup"><span data-stu-id="782f4-165">If enabled on a queue or topic, writing messages into hello store will be batched.</span></span> <span data-ttu-id="782f4-166">큐 또는 구독에서 활성화 hello 저장소에서 메시지를 삭제 일괄 처리할 됩니다.</span><span class="sxs-lookup"><span data-stu-id="782f4-166">If enabled on a queue or subscription, deleting messages from hello store will be batched.</span></span> <span data-ttu-id="782f4-167">엔터티에 대 한 일괄 처리 방식된 저장소 액세스를 사용 하는 경우 서비스 버스 too20ms 구성 하 여 해당 엔터티에 대 한 저장소 쓰기 작업을 지연 됩니다.</span><span class="sxs-lookup"><span data-stu-id="782f4-167">If batched store access is enabled for an entity, Service Bus delays a store write operation regarding that entity by up too20ms.</span></span> <span data-ttu-id="782f4-168">이 간격 동안 발생 하는 추가 저장소 작업 toohello 일괄 처리에 추가 됩니다.</span><span class="sxs-lookup"><span data-stu-id="782f4-168">Additional store operations that occur during this interval are added toohello batch.</span></span> <span data-ttu-id="782f4-169">일괄 처리된 저장소 액세스는 **전송** 및 **완료** 작업에만 영향을 주고 수신 작업은 영향을 받지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="782f4-169">Batched store access only affects **Send** and **Complete** operations; receive operations are not affected.</span></span> <span data-ttu-id="782f4-170">일괄 처리된 저장소 액세스는 엔터티의 속성입니다.</span><span class="sxs-lookup"><span data-stu-id="782f4-170">Batched store access is a property on an entity.</span></span> <span data-ttu-id="782f4-171">일괄 처리는 일괄 처리된 저장소 액세스가 가능한 모든 엔터티에서 발생합니다.</span><span class="sxs-lookup"><span data-stu-id="782f4-171">Batching occurs across all entities that enable batched store access.</span></span>

<span data-ttu-id="782f4-172">새 큐, 토픽 또는 구독을 만들면 기본적으로 일괄 처리된 저장소 액세스가 사용하도록 설정됩니다.</span><span class="sxs-lookup"><span data-stu-id="782f4-172">When creating a new queue, topic or subscription, batched store access is enabled by default.</span></span> <span data-ttu-id="782f4-173">toodisable 일괄 저장소 액세스, 집합 hello [EnableBatchedOperations] [ EnableBatchedOperations] 속성 너무**false** hello 엔터티를 만들기 전에 합니다.</span><span class="sxs-lookup"><span data-stu-id="782f4-173">toodisable batched store access, set hello [EnableBatchedOperations][EnableBatchedOperations] property too**false** before creating hello entity.</span></span> <span data-ttu-id="782f4-174">예:</span><span class="sxs-lookup"><span data-stu-id="782f4-174">For example:</span></span>

```csharp
QueueDescription qd = new QueueDescription();
qd.EnableBatchedOperations = false;
Queue q = namespaceManager.CreateQueue(qd);
```

<span data-ttu-id="782f4-175">일괄 처리 방식된 저장소 액세스 hello 청구 가능한 메시징 작업 수에 영향을 주지 않습니다 되며, 큐, 항목 또는 구독의 속성입니다.</span><span class="sxs-lookup"><span data-stu-id="782f4-175">Batched store access does not affect hello number of billable messaging operations, and is a property of a queue, topic, or subscription.</span></span> <span data-ttu-id="782f4-176">Hello 독립적일 수신 하는 클라이언트 및 서비스 버스 서비스 hello 간에 사용 되는 모드와 hello 프로토콜입니다.</span><span class="sxs-lookup"><span data-stu-id="782f4-176">It is independent of hello receive mode and hello protocol that is used between a client and hello Service Bus service.</span></span>

## <a name="prefetching"></a><span data-ttu-id="782f4-177">프리페치</span><span class="sxs-lookup"><span data-stu-id="782f4-177">Prefetching</span></span>
<span data-ttu-id="782f4-178">프리페치는 수신 작업을 수행할 때 hello 큐 또는 구독 클라이언트 tooload 추가 서비스에서 메시지를 hello 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="782f4-178">Prefetching enables hello queue or subscription client tooload additional messages from hello service when it performs a receive operation.</span></span> <span data-ttu-id="782f4-179">hello 클라이언트는 로컬 캐시에서 이러한 메시지를 저장합니다.</span><span class="sxs-lookup"><span data-stu-id="782f4-179">hello client stores these messages in a local cache.</span></span> <span data-ttu-id="782f4-180">hello 캐시의 hello 크기 hello 따라 사용자가 [QueueClient.PrefetchCount] [ QueueClient.PrefetchCount] 또는 [SubscriptionClient.PrefetchCount] [ SubscriptionClient.PrefetchCount] 속성입니다.</span><span class="sxs-lookup"><span data-stu-id="782f4-180">hello size of hello cache is determined by hello [QueueClient.PrefetchCount][QueueClient.PrefetchCount] or [SubscriptionClient.PrefetchCount][SubscriptionClient.PrefetchCount] properties.</span></span> <span data-ttu-id="782f4-181">프리페치를 사용할 수 있는 각 클라이언트는 각각의 캐시를 유지합니다.</span><span class="sxs-lookup"><span data-stu-id="782f4-181">Each client that enables prefetching maintains its own cache.</span></span> <span data-ttu-id="782f4-182">캐시는 클라이언트 사이에서 공유되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="782f4-182">A cache is not shared across clients.</span></span> <span data-ttu-id="782f4-183">Hello 클라이언트가 수신 작업을 시작 하는 경우 해당 캐시가 비어 hello 서비스는 메시지의 일괄 처리를 전송 합니다.</span><span class="sxs-lookup"><span data-stu-id="782f4-183">If hello client initiates a receive operation and its cache is empty, hello service transmits a batch of messages.</span></span> <span data-ttu-id="782f4-184">hello hello 일괄 처리 크기는 hello 크기 hello 캐시 또는 256KB 이면 중 더 작은 값입니다.</span><span class="sxs-lookup"><span data-stu-id="782f4-184">hello size of hello batch equals hello size of hello cache or 256 KB, whichever is smaller.</span></span> <span data-ttu-id="782f4-185">수신 작업을 시작 하는 hello 클라이언트 hello 캐시에 메시지를 포함 하는 경우 hello 캐시에서 hello 메시지를 가져옵니다.</span><span class="sxs-lookup"><span data-stu-id="782f4-185">If hello client initiates a receive operation and hello cache contains a message, hello message is taken from hello cache.</span></span>

<span data-ttu-id="782f4-186">때 메시지를 프리페치 hello 서비스 잠금이 hello 프리페치된 메시지입니다.</span><span class="sxs-lookup"><span data-stu-id="782f4-186">When a message is prefetched, hello service locks hello prefetched message.</span></span> <span data-ttu-id="782f4-187">이 작업을 수행 하 여 다른 수신기가 hello 프리페치된 메시지를 받을 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="782f4-187">By doing this, hello prefetched message cannot be received by a different receiver.</span></span> <span data-ttu-id="782f4-188">Hello 수신기를 완료할 수 없으면 hello 메시지 hello 잠금이 만료 되기 전에 사용할 수 있는 tooother 수신기 hello 메시지에 있게 됩니다.</span><span class="sxs-lookup"><span data-stu-id="782f4-188">If hello receiver cannot complete hello message before hello lock expires, hello message becomes available tooother receivers.</span></span> <span data-ttu-id="782f4-189">사전 인출 hello hello 메시지 사본을 hello 캐시에 남아 있습니다.</span><span class="sxs-lookup"><span data-stu-id="782f4-189">hello prefetched copy of hello message remains in hello cache.</span></span> <span data-ttu-id="782f4-190">hello hello를 사용 하는 수신기 만료 캐시 된 복사본에서 해당 메시지 toocomplete 읽으려고 할 때 예외를 수신 합니다.</span><span class="sxs-lookup"><span data-stu-id="782f4-190">hello receiver that consumes hello expired cached copy will receive an exception when it tries toocomplete that message.</span></span> <span data-ttu-id="782f4-191">기본적으로 hello 메시지 잠금은 60 초 후에 만료 됩니다.</span><span class="sxs-lookup"><span data-stu-id="782f4-191">By default, hello message lock expires after 60 seconds.</span></span> <span data-ttu-id="782f4-192">이 값은 확장된 too5 분 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="782f4-192">This value can be extended too5 minutes.</span></span> <span data-ttu-id="782f4-193">만료 된 메시지의 tooprevent hello 소비, hello 캐시 크기가 항상 보다 작아야 hello hello 잠금 시간 제한 간격 내 클라이언트에서 사용할 수 있는 메시지 수입니다.</span><span class="sxs-lookup"><span data-stu-id="782f4-193">tooprevent hello consumption of expired messages, hello cache size should always be smaller than hello number of messages that can be consumed by a client within hello lock time-out interval.</span></span>

<span data-ttu-id="782f4-194">좋은 값을 60 초 hello 기본 잠금 만료를 사용할 경우 [SubscriptionClient.PrefetchCount] [ SubscriptionClient.PrefetchCount] 최대 20 회 hello 처리는 모든 hello 팩터리 수신자의 속도입니다.</span><span class="sxs-lookup"><span data-stu-id="782f4-194">When using hello default lock expiration of 60 seconds, a good value for [SubscriptionClient.PrefetchCount][SubscriptionClient.PrefetchCount] is 20 times hello maximum processing rates of all receivers of hello factory.</span></span> <span data-ttu-id="782f4-195">예를 들어 팩터리가 수신자 3 개 및 각 수신자는 초당 too10 메시지를 처리할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="782f4-195">For example, a factory creates 3 receivers, and each receiver can process up too10 messages per second.</span></span> <span data-ttu-id="782f4-196">hello 프리페치 수는 20 X 3 X 10 = 600을 넘지 않아야 합니다.</span><span class="sxs-lookup"><span data-stu-id="782f4-196">hello prefetch count should not exceed 20 X 3 X 10 = 600.</span></span> <span data-ttu-id="782f4-197">기본적으로 [QueueClient.PrefetchCount] [ QueueClient.PrefetchCount] hello 서비스에서 추가 메시지를 가져오지는 즉 집합 too0 됩니다.</span><span class="sxs-lookup"><span data-stu-id="782f4-197">By default, [QueueClient.PrefetchCount][QueueClient.PrefetchCount] is set too0, which means that no additional messages are fetched from hello service.</span></span>

<span data-ttu-id="782f4-198">증가 hello 메시지 작업 또는 왕복 전체 번호가 감소 하므로 큐 또는 구독에 대 한 전반적인 처리량 hello 메시지를 프리페치 합니다.</span><span class="sxs-lookup"><span data-stu-id="782f4-198">Prefetching messages increases hello overall throughput for a queue or subscription because it reduces hello overall number of message operations, or round trips.</span></span> <span data-ttu-id="782f4-199">그러나 Hello 첫 번째 메시지를 인출 합니다. 더 오래 걸립니다 (인해 증가 toohello 메시지 크기).</span><span class="sxs-lookup"><span data-stu-id="782f4-199">Fetching hello first message, however, will take longer (due toohello increased message size).</span></span> <span data-ttu-id="782f4-200">프리페치된 메시지를 받는 속도가 더 빠를 수 hello 클라이언트가 이미 다운로드 된 이러한 메시지입니다.</span><span class="sxs-lookup"><span data-stu-id="782f4-200">Receiving prefetched messages will be faster because these messages have already been downloaded by hello client.</span></span>

<span data-ttu-id="782f4-201">메시지의 hello 활성 시간 (TTL) 속성이 hello 서버 hello 메시지 toohello 클라이언트 전송 hello 시 hello 서버에 의해 확인 됩니다.</span><span class="sxs-lookup"><span data-stu-id="782f4-201">hello time-to-live (TTL) property of a message is checked by hello server at hello time hello server sends hello message toohello client.</span></span> <span data-ttu-id="782f4-202">hello 클라이언트 hello 메시지를 받을 때 hello 메시지의 TTL 속성을 확인 하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="782f4-202">hello client does not check hello message’s TTL property when hello message is received.</span></span> <span data-ttu-id="782f4-203">대신, hello 클라이언트 hello 메시지를 캐시 하는 동안 hello 메시지의 TTL이 경과 하는 경우에 hello 메시지를 받을 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="782f4-203">Instead, hello message can be received even if hello message’s TTL has passed while hello message was cached by hello client.</span></span>

<span data-ttu-id="782f4-204">프리페치 hello 청구 가능한 메시징 작업 수에 영향을 주지 않습니다 되며 hello 서비스 버스 클라이언트 프로토콜에 대해서만 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="782f4-204">Prefetching does not affect hello number of billable messaging operations, and is available only for hello Service Bus client protocol.</span></span> <span data-ttu-id="782f4-205">HTTP 프로토콜 hello 프리페치를 지원 하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="782f4-205">hello HTTP protocol does not support prefetching.</span></span> <span data-ttu-id="782f4-206">프리페치는 동기 및 비동기 수신 작업에 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="782f4-206">Prefetching is available for both synchronous and asynchronous receive operations.</span></span>

## <a name="express-queues-and-topics"></a><span data-ttu-id="782f4-207">명시적 큐 및 토픽</span><span class="sxs-lookup"><span data-stu-id="782f4-207">Express queues and topics</span></span>

<span data-ttu-id="782f4-208">Express 엔터티는 높은 처리량 및 대기 시간 단축된 시나리오를 사용 하도록 설정 하 고 hello 표준 메시징 계층 에서만 지원 됩니다.</span><span class="sxs-lookup"><span data-stu-id="782f4-208">Express entities enable high throughput and reduced latency scenarios, and are supported only in hello Standard messaging tier.</span></span> <span data-ttu-id="782f4-209">만든 엔터티 [Premium 네임 스페이스](service-bus-premium-messaging.md) hello express 옵션을 지원 하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="782f4-209">Entities created in [Premium namespaces](service-bus-premium-messaging.md) do not support hello express option.</span></span> <span data-ttu-id="782f4-210">Express 엔터티 사용 tooa 큐 또는 항목에는 메시지를 보내는 경우 hello 메시지는 되지 즉시 hello 메시징 저장소에 저장 합니다.</span><span class="sxs-lookup"><span data-stu-id="782f4-210">With express entities, if a message is sent tooa queue or topic, hello message is not immediately stored in hello messaging store.</span></span> <span data-ttu-id="782f4-211">대신 메모리에 캐시됩니다.</span><span class="sxs-lookup"><span data-stu-id="782f4-211">Instead, it is cached in memory.</span></span> <span data-ttu-id="782f4-212">여러 시간 (초)에 대 한 hello 큐에 메시지가 남아 있으면 tooan 중단 인해 손실 로부터 보호할 toostable 저장소, 자동으로 기록 됩니다.</span><span class="sxs-lookup"><span data-stu-id="782f4-212">If a message remains in hello queue for more than a few seconds, it is automatically written toostable storage, thus protecting it against loss due tooan outage.</span></span> <span data-ttu-id="782f4-213">메모리 캐시로 hello 메시지 처리량이 증가 및 없습니다 액세스 toostable 있기 때문에 대기 시간이 단축 작성 hello 시간 hello 메시지 저장소에 전송 됩니다.</span><span class="sxs-lookup"><span data-stu-id="782f4-213">Writing hello message into a memory cache increases throughput and reduces latency because there is no access toostable storage at hello time hello message is sent.</span></span> <span data-ttu-id="782f4-214">몇 초 내에 사용 되는 메시지는 메시지 저장소 toohello를 기록 되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="782f4-214">Messages that are consumed within a few seconds are not written toohello messaging store.</span></span> <span data-ttu-id="782f4-215">다음 예제는 hello express 항목을 만듭니다.</span><span class="sxs-lookup"><span data-stu-id="782f4-215">hello following example creates an express topic.</span></span>

```csharp
TopicDescription td = new TopicDescription(TopicName);
td.EnableExpress = true;
namespaceManager.CreateTopic(td);
```

<span data-ttu-id="782f4-216">Hello 보낸 사람에 게 서비스 버스를 강제할 수 손실 되지 않아야 하는 중요 한 정보를 포함 하는 메시지를 보내면 tooan express 엔터티로 tooimmediately 영구 hello 설정 하 여 hello 메시지 toostable 저장소 [ForcePersistence] [ ForcePersistence] 속성 너무**true**합니다.</span><span class="sxs-lookup"><span data-stu-id="782f4-216">If a message containing critical information that must not be lost is sent tooan express entity, hello sender can force Service Bus tooimmediately persist hello message toostable storage by setting hello [ForcePersistence][ForcePersistence] property too**true**.</span></span>

> [!NOTE]
> <span data-ttu-id="782f4-217">기본 엔터티는 트랜잭션을 지원하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="782f4-217">Express entities do not support transactions.</span></span>

## <a name="use-of-partitioned-queues-or-topics"></a><span data-ttu-id="782f4-218">분할된 큐 또는 토픽 사용</span><span class="sxs-lookup"><span data-stu-id="782f4-218">Use of partitioned queues or topics</span></span>
<span data-ttu-id="782f4-219">내부적으로 사용 하 여 서비스 버스 같은 노드 및 메시징 저장소 tooprocess hello 및 메시징 엔터티 (큐 또는 항목)에 대 한 모든 메시지를 저장 합니다.</span><span class="sxs-lookup"><span data-stu-id="782f4-219">Internally, Service Bus uses hello same node and messaging store tooprocess and store all messages for a messaging entity (queue or topic).</span></span> <span data-ttu-id="782f4-220">분할 된 큐 또는 항목 hello에 다른 손 여러 노드 및 메시징 저장소에서 배포 됩니다.</span><span class="sxs-lookup"><span data-stu-id="782f4-220">A partitioned queue or topic, on hello other hand, is distributed across multiple nodes and messaging stores.</span></span> <span data-ttu-id="782f4-221">분할된 큐와 토픽은 일반 큐 및 토픽보다 높은 처리량뿐만 아니라 뛰어난 가용성을 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="782f4-221">Partitioned queues and topics not only yield a higher throughput than regular queues and topics, they also exhibit superior availability.</span></span> <span data-ttu-id="782f4-222">toocreate 분할된 된 엔터티 집합 hello [EnablePartitioning] [ EnablePartitioning] 속성 너무**true**hello 다음 예제에에서 나온 것 처럼 합니다.</span><span class="sxs-lookup"><span data-stu-id="782f4-222">toocreate a partitioned entity, set hello [EnablePartitioning][EnablePartitioning] property too**true**, as shown in hello following example.</span></span> <span data-ttu-id="782f4-223">분할된 엔터티에 대한 자세한 내용은 [분할된 메시징 엔터티][Partitioned messaging entities]를 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="782f4-223">For more information about partitioned entities, see [Partitioned messaging entities][Partitioned messaging entities].</span></span>

```csharp
// Create partitioned queue.
QueueDescription qd = new QueueDescription(QueueName);
qd.EnablePartitioning = true;
namespaceManager.CreateQueue(qd);
```

## <a name="use-of-multiple-queues"></a><span data-ttu-id="782f4-224">여러 큐 사용</span><span class="sxs-lookup"><span data-stu-id="782f4-224">Use of multiple queues</span></span>

<span data-ttu-id="782f4-225">분할 된 큐 또는 항목 또는 hello 예상 단일 분할 된 큐 또는 항목에서 부하를 처리할 수 없는 가능한 toouse 없는 경우에 여러 메시징 엔터티를 사용 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="782f4-225">If it is not possible toouse a partitioned queue or topic, or hello expected load cannot be handled by a single partitioned queue or topic, you must use multiple messaging entities.</span></span> <span data-ttu-id="782f4-226">여러 엔터티를 사용할 때 각 엔터티에 대해 전용된 클라이언트를 만들고, 사용 하는 대신 동일한 hello 모든 엔터티에 대 한 클라이언트입니다.</span><span class="sxs-lookup"><span data-stu-id="782f4-226">When using multiple entities, create a dedicated client for each entity, instead of using hello same client for all entities.</span></span>

## <a name="development-and-testing-features"></a><span data-ttu-id="782f4-227">개발 및 테스트 기능</span><span class="sxs-lookup"><span data-stu-id="782f4-227">Development and testing features</span></span>

<span data-ttu-id="782f4-228">Service Bus에는 특별히 **프로덕션 구성에서 사용해서는 안 되는** 개발에 사용되는 한 가지 기능이 있습니다. [TopicDescription.EnableFilteringMessagesBeforePublishing][]</span><span class="sxs-lookup"><span data-stu-id="782f4-228">Service Bus has one feature that is used specifically for development which **should never be used in production configurations**: [TopicDescription.EnableFilteringMessagesBeforePublishing][].</span></span>

<span data-ttu-id="782f4-229">새 규칙 또는 필터 toohello 항목을 추가 하는 경우 사용할 수 있습니다 [TopicDescription.EnableFilteringMessagesBeforePublishing][] 새 필터 식을 hello tooverify 예상 대로 작동 합니다.</span><span class="sxs-lookup"><span data-stu-id="782f4-229">When new rules or filters are added toohello topic, you can use [TopicDescription.EnableFilteringMessagesBeforePublishing][] tooverify that hello new filter expression is working as expected.</span></span>

## <a name="scenarios"></a><span data-ttu-id="782f4-230">시나리오</span><span class="sxs-lookup"><span data-stu-id="782f4-230">Scenarios</span></span>
<span data-ttu-id="782f4-231">hello 다음 섹션에서는 일반적인 메시징 시나리오에 설명 하 고 기본 설정 hello 서비스 버스 설정을 설명 합니다.</span><span class="sxs-lookup"><span data-stu-id="782f4-231">hello following sections describe typical messaging scenarios and outline hello preferred Service Bus settings.</span></span> <span data-ttu-id="782f4-232">처리량 속도는 적음(초당 1개 메시지 미만), 보통(초당 1개 메시지 이상, 초당 100개 메시지 미만), 높음(초당 100개 메시지 이상)으로 분류됩니다.</span><span class="sxs-lookup"><span data-stu-id="782f4-232">Throughput rates are classified as small (less than 1 message/second), moderate (1 message/second or greater but less than 100 messages/second) and high (100 messages/second or greater).</span></span> <span data-ttu-id="782f4-233">hello 클라이언트 수가으로 분류 됩니다 (5 개 더 적은) 보통 (5 개 보다 많이 미만 이지만 또는 같은 too20), 및 대형 (둘 이상의 20).</span><span class="sxs-lookup"><span data-stu-id="782f4-233">hello number of clients are classified as small (5 or fewer), moderate (more than 5 but less than or equal too20), and large (more than 20).</span></span>

### <a name="high-throughput-queue"></a><span data-ttu-id="782f4-234">처리량이 높은 큐</span><span class="sxs-lookup"><span data-stu-id="782f4-234">High-throughput queue</span></span>
<span data-ttu-id="782f4-235">목표: 단일 큐의 hello 처리량을 최대화 합니다.</span><span class="sxs-lookup"><span data-stu-id="782f4-235">Goal: Maximize hello throughput of a single queue.</span></span> <span data-ttu-id="782f4-236">발신자와 수신자의 hello 수는 적습니다.</span><span class="sxs-lookup"><span data-stu-id="782f4-236">hello number of senders and receivers is small.</span></span>

* <span data-ttu-id="782f4-237">성능 및 가용성 향상을 위해 분할된 큐를 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="782f4-237">Use a partitioned queue for improved performance and availability.</span></span>
* <span data-ttu-id="782f4-238">전반적인 tooincrease hello hello 큐로 전송 속도, 여러 메시지 팩터리 toocreate 보낸 사람을 사용 합니다.</span><span class="sxs-lookup"><span data-stu-id="782f4-238">tooincrease hello overall send rate into hello queue, use multiple message factories toocreate senders.</span></span> <span data-ttu-id="782f4-239">각 발신기에 대해 비동기 작업이나 여러 스레드를 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="782f4-239">For each sender, use asynchronous operations or multiple threads.</span></span>
* <span data-ttu-id="782f4-240">전반적인 tooincrease hello hello 큐에서 수신 속도, 여러 메시지 팩터리 toocreate 수신기를 사용 합니다.</span><span class="sxs-lookup"><span data-stu-id="782f4-240">tooincrease hello overall receive rate from hello queue, use multiple message factories toocreate receivers.</span></span>
* <span data-ttu-id="782f4-241">클라이언트 쪽 일괄 처리의 비동기 작업 tootake 장점은 사용 합니다.</span><span class="sxs-lookup"><span data-stu-id="782f4-241">Use asynchronous operations tootake advantage of client-side batching.</span></span>
* <span data-ttu-id="782f4-242">서비스 버스 클라이언트 프로토콜 전송 간격 too50ms tooreduce hello 수 일괄 처리 하는 hello를 설정 합니다.</span><span class="sxs-lookup"><span data-stu-id="782f4-242">Set hello batching interval too50ms tooreduce hello number of Service Bus client protocol transmissions.</span></span> <span data-ttu-id="782f4-243">여러 발신자를 사용 하는 hello 간격 too100ms 일괄 처리를 늘립니다.</span><span class="sxs-lookup"><span data-stu-id="782f4-243">If multiple senders are used, increase hello batching interval too100ms.</span></span>
* <span data-ttu-id="782f4-244">일괄 처리된 저장소 액세스는 사용하도록 설정한 상태로 둡니다.</span><span class="sxs-lookup"><span data-stu-id="782f4-244">Leave batched store access enabled.</span></span> <span data-ttu-id="782f4-245">전반적인 hello 증가 속도는 메시지 hello 큐에 쓸 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="782f4-245">This increases hello overall rate at which messages can be written into hello queue.</span></span>
* <span data-ttu-id="782f4-246">모든 팩터리 수신자의 최대 처리 속도 hello hello 프리페치 개수 too20 시간을 설정 합니다.</span><span class="sxs-lookup"><span data-stu-id="782f4-246">Set hello prefetch count too20 times hello maximum processing rates of all receivers of a factory.</span></span> <span data-ttu-id="782f4-247">이렇게 하면 서비스 버스 클라이언트 프로토콜 전송 hello 수가 줄어듭니다.</span><span class="sxs-lookup"><span data-stu-id="782f4-247">This reduces hello number of Service Bus client protocol transmissions.</span></span>

### <a name="multiple-high-throughput-queues"></a><span data-ttu-id="782f4-248">처리량이 높은 복수 큐</span><span class="sxs-lookup"><span data-stu-id="782f4-248">Multiple high-throughput queues</span></span>
<span data-ttu-id="782f4-249">목표: 여러 큐의 전체 처리량을 극대화합니다.</span><span class="sxs-lookup"><span data-stu-id="782f4-249">Goal: Maximize overall throughput of multiple queues.</span></span> <span data-ttu-id="782f4-250">개별 큐의 hello 처리량은 보통 또는 높음입니다.</span><span class="sxs-lookup"><span data-stu-id="782f4-250">hello throughput of an individual queue is moderate or high.</span></span>

<span data-ttu-id="782f4-251">tooobtain 여러 큐에서 최대 처리량을 hello 설정을 사용 하 여 단일 큐의 toomaximize hello 처리량을 설명합니다.</span><span class="sxs-lookup"><span data-stu-id="782f4-251">tooobtain maximum throughput across multiple queues, use hello settings outlined toomaximize hello throughput of a single queue.</span></span> <span data-ttu-id="782f4-252">또한 다른 큐에서 송신 또는 수신 하는 서로 다른 여러 팩터리 toocreate 클라이언트를 사용 합니다.</span><span class="sxs-lookup"><span data-stu-id="782f4-252">In addition, use different factories toocreate clients that send or receive from different queues.</span></span>

### <a name="low-latency-queue"></a><span data-ttu-id="782f4-253">대기 시간이 짧은 큐</span><span class="sxs-lookup"><span data-stu-id="782f4-253">Low latency queue</span></span>
<span data-ttu-id="782f4-254">목표: 큐 또는 토픽의 종단간 대기 시간을 최소화합니다.</span><span class="sxs-lookup"><span data-stu-id="782f4-254">Goal: Minimize end-to-end latency of a queue or topic.</span></span> <span data-ttu-id="782f4-255">발신자와 수신자의 hello 수는 적습니다.</span><span class="sxs-lookup"><span data-stu-id="782f4-255">hello number of senders and receivers is small.</span></span> <span data-ttu-id="782f4-256">hello 큐의 hello 처리량은 낮음 또는 보통입니다.</span><span class="sxs-lookup"><span data-stu-id="782f4-256">hello throughput of hello queue is small or moderate.</span></span>

* <span data-ttu-id="782f4-257">가용성 향상을 위해 분할된 큐를 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="782f4-257">Use a partitioned queue for improved availability.</span></span>
* <span data-ttu-id="782f4-258">클라이언트 쪽 일괄 처리를 사용하지 않도록 설정합니다.</span><span class="sxs-lookup"><span data-stu-id="782f4-258">Disable client-side batching.</span></span> <span data-ttu-id="782f4-259">클라이언트 hello 메시지를 즉시 보냅니다.</span><span class="sxs-lookup"><span data-stu-id="782f4-259">hello client immediately sends a message.</span></span>
* <span data-ttu-id="782f4-260">일괄 처리된 저장소 액세스를 사용하지 않도록 설정합니다.</span><span class="sxs-lookup"><span data-stu-id="782f4-260">Disable batched store access.</span></span> <span data-ttu-id="782f4-261">hello 서비스는 hello 메시지 toohello 저장소를 즉시 씁니다.</span><span class="sxs-lookup"><span data-stu-id="782f4-261">hello service immediately writes hello message toohello store.</span></span>
* <span data-ttu-id="782f4-262">단일 클라이언트를 사용 하는 경우 hello 프리페치 개수 too20 hello 처리 속도 hello 수신기를 설정 합니다.</span><span class="sxs-lookup"><span data-stu-id="782f4-262">If using a single client, set hello prefetch count too20 times hello processing rate of hello receiver.</span></span> <span data-ttu-id="782f4-263">동일한 hello hello에는 큐에 여러 메시지가 도착 하는 경우 시간, 서비스 버스 클라이언트 프로토콜 hello hello에 모두 전송 동시 합니다.</span><span class="sxs-lookup"><span data-stu-id="782f4-263">If multiple messages arrive at hello queue at hello same time, hello Service Bus client protocol transmits them all at hello same time.</span></span> <span data-ttu-id="782f4-264">Hello 클라이언트 hello 다음 메시지를 받으면 해당 메시지 hello 로컬 캐시에 이미입니다.</span><span class="sxs-lookup"><span data-stu-id="782f4-264">When hello client receives hello next message, that message is already in hello local cache.</span></span> <span data-ttu-id="782f4-265">hello 캐시는 작아야 합니다.</span><span class="sxs-lookup"><span data-stu-id="782f4-265">hello cache should be small.</span></span>
* <span data-ttu-id="782f4-266">여러 클라이언트를 사용 하는 경우 프리페치 개수 too0 hello를 설정 합니다.</span><span class="sxs-lookup"><span data-stu-id="782f4-266">If using multiple clients, set hello prefetch count too0.</span></span> <span data-ttu-id="782f4-267">이 작업을 수행 하 여 hello 두 번째 클라이언트가 첫 번째 클라이언트 hello 아직 hello 첫 번째 메시지를 처리 하는 동안 hello 두 번째 메시지를 받을 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="782f4-267">By doing this, hello second client can receive hello second message while hello first client is still processing hello first message.</span></span>

### <a name="queue-with-a-large-number-of-senders"></a><span data-ttu-id="782f4-268">발신기 수가 많은 큐</span><span class="sxs-lookup"><span data-stu-id="782f4-268">Queue with a large number of senders</span></span>
<span data-ttu-id="782f4-269">목표: 발신기 수가 많은 큐 또는 토픽의 처리량 극대화</span><span class="sxs-lookup"><span data-stu-id="782f4-269">Goal: Maximize throughput of a queue or topic with a large number of senders.</span></span> <span data-ttu-id="782f4-270">각 발신기는 보통 속도의 메시지를 전송합니다.</span><span class="sxs-lookup"><span data-stu-id="782f4-270">Each sender sends messages with a moderate rate.</span></span> <span data-ttu-id="782f4-271">수신자의 hello 수는 적습니다.</span><span class="sxs-lookup"><span data-stu-id="782f4-271">hello number of receivers is small.</span></span>

<span data-ttu-id="782f4-272">Too1000 동시 연결 tooa 메시징 엔터티를 사용 하면 서비스 버스 (5000 또는 AMQP를 사용 하 여).</span><span class="sxs-lookup"><span data-stu-id="782f4-272">Service Bus enables up too1000 concurrent connections tooa messaging entity (or 5000 using AMQP).</span></span> <span data-ttu-id="782f4-273">이 제한을 hello 네임 스페이스 수준에서 적용 하 고 큐/항목/구독은 네임 스페이스 당 동시 연결 hello 제한으로 제한 됩니다.</span><span class="sxs-lookup"><span data-stu-id="782f4-273">This limit is enforced at hello namespace level, and queues/topics/subscriptions are capped by hello limit of concurrent connections per namespace.</span></span> <span data-ttu-id="782f4-274">큐의 경우 이 숫자는 발신기와 수신기 사이에 공유됩니다.</span><span class="sxs-lookup"><span data-stu-id="782f4-274">For queues, this number is shared between senders and receivers.</span></span> <span data-ttu-id="782f4-275">모든 연결 허용-보낸 사람에 대 한 증명이 hello 큐를 항목 및 단일 구독으로 바꿔야 합니다.</span><span class="sxs-lookup"><span data-stu-id="782f4-275">If all 1000 connections are required for senders, you should replace hello queue with a topic and a single subscription.</span></span> <span data-ttu-id="782f4-276">항목은 hello 구독 수신자의 추가 1000 동시 연결을 허용 하는 반면 too1000 발신자의 동시 연결을 허용 합니다.</span><span class="sxs-lookup"><span data-stu-id="782f4-276">A topic accepts up too1000 concurrent connections from senders, whereas hello subscription accepts an additional 1000 concurrent connections from receivers.</span></span> <span data-ttu-id="782f4-277">1000 개 이상 동시 발신자 필요한 경우 보낸 사람 hello 메시지 toohello HTTP 통해 서비스 버스 프로토콜 보내야 합니다.</span><span class="sxs-lookup"><span data-stu-id="782f4-277">If more than 1000 concurrent senders are required, hello senders should send messages toohello Service Bus protocol via HTTP.</span></span>

<span data-ttu-id="782f4-278">toomaximize 처리량 다음 hello지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="782f4-278">toomaximize throughput, do hello following:</span></span>

* <span data-ttu-id="782f4-279">성능 및 가용성 향상을 위해 분할된 큐를 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="782f4-279">Use a partitioned queue for improved performance and availability.</span></span>
* <span data-ttu-id="782f4-280">각 발신기가 다른 프로세스에 상주하는 경우 프로세스당 하나의 팩터리만 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="782f4-280">If each sender resides in a different process, use only a single factory per process.</span></span>
* <span data-ttu-id="782f4-281">클라이언트 쪽 일괄 처리의 비동기 작업 tootake 장점은 사용 합니다.</span><span class="sxs-lookup"><span data-stu-id="782f4-281">Use asynchronous operations tootake advantage of client-side batching.</span></span>
* <span data-ttu-id="782f4-282">Hello 기본 일괄 처리 간격 20ms tooreduce hello 서비스 버스 클라이언트 프로토콜 전송 수를 사용 합니다.</span><span class="sxs-lookup"><span data-stu-id="782f4-282">Use hello default batching interval of 20ms tooreduce hello number of Service Bus client protocol transmissions.</span></span>
* <span data-ttu-id="782f4-283">일괄 처리된 저장소 액세스는 사용하도록 설정한 상태로 둡니다.</span><span class="sxs-lookup"><span data-stu-id="782f4-283">Leave batched store access enabled.</span></span> <span data-ttu-id="782f4-284">전반적인 hello 증가 속도는 메시지 hello 큐 또는 항목에 쓸 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="782f4-284">This increases hello overall rate at which messages can be written into hello queue or topic.</span></span>
* <span data-ttu-id="782f4-285">모든 팩터리 수신자의 최대 처리 속도 hello hello 프리페치 개수 too20 시간을 설정 합니다.</span><span class="sxs-lookup"><span data-stu-id="782f4-285">Set hello prefetch count too20 times hello maximum processing rates of all receivers of a factory.</span></span> <span data-ttu-id="782f4-286">이렇게 하면 서비스 버스 클라이언트 프로토콜 전송 hello 수가 줄어듭니다.</span><span class="sxs-lookup"><span data-stu-id="782f4-286">This reduces hello number of Service Bus client protocol transmissions.</span></span>

### <a name="queue-with-a-large-number-of-receivers"></a><span data-ttu-id="782f4-287">수신기 수가 많은 큐</span><span class="sxs-lookup"><span data-stu-id="782f4-287">Queue with a large number of receivers</span></span>
<span data-ttu-id="782f4-288">목표: hello 최대화 수신 큐 또는 구독 수신자 수가 많은을 비율입니다.</span><span class="sxs-lookup"><span data-stu-id="782f4-288">Goal: Maximize hello receive rate of a queue or subscription with a large number of receivers.</span></span> <span data-ttu-id="782f4-289">각 수신자는 보통 속도로 메시지를 받습니다.</span><span class="sxs-lookup"><span data-stu-id="782f4-289">Each receiver receives messages at a moderate rate.</span></span> <span data-ttu-id="782f4-290">보낸 사람 hello 수는 적습니다.</span><span class="sxs-lookup"><span data-stu-id="782f4-290">hello number of senders is small.</span></span>

<span data-ttu-id="782f4-291">서비스 버스 too1000 동시 연결 tooan 엔터티를 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="782f4-291">Service Bus enables up too1000 concurrent connections tooan entity.</span></span> <span data-ttu-id="782f4-292">큐에 1000 개 이상의 수신기 필요한 hello 큐를 항목 및 여러 구독으로 바꿔야 합니다.</span><span class="sxs-lookup"><span data-stu-id="782f4-292">If a queue requires more than 1000 receivers, you should replace hello queue with a topic and multiple subscriptions.</span></span> <span data-ttu-id="782f4-293">각 구독 too1000 동시 연결을 지원할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="782f4-293">Each subscription can support up too1000 concurrent connections.</span></span> <span data-ttu-id="782f4-294">또한 수신기 hello 큐 hello HTTP 프로토콜을 통해 액세스할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="782f4-294">Alternatively, receivers can access hello queue via hello HTTP protocol.</span></span>

<span data-ttu-id="782f4-295">toomaximize 처리량 다음 hello지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="782f4-295">toomaximize throughput, do hello following:</span></span>

* <span data-ttu-id="782f4-296">성능 및 가용성 향상을 위해 분할된 큐를 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="782f4-296">Use a partitioned queue for improved performance and availability.</span></span>
* <span data-ttu-id="782f4-297">각 수신기가 다른 프로세스에 상주하는 경우 프로세스당 하나의 팩터리만 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="782f4-297">If each receiver resides in a different process, use only a single factory per process.</span></span>
* <span data-ttu-id="782f4-298">수신기는 동기 또는 비동기 작업을 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="782f4-298">Receivers can use synchronous or asynchronous operations.</span></span> <span data-ttu-id="782f4-299">Hello 보통 지정한 수신 개별 수신자의 속도 때 Complete 요청의 클라이언트 쪽 일괄 처리 수신자 처리량에 영향을 주지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="782f4-299">Given hello moderate receive rate of an individual receiver, client-side batching of a Complete request does not affect receiver throughput.</span></span>
* <span data-ttu-id="782f4-300">일괄 처리된 저장소 액세스는 사용하도록 설정한 상태로 둡니다.</span><span class="sxs-lookup"><span data-stu-id="782f4-300">Leave batched store access enabled.</span></span> <span data-ttu-id="782f4-301">이렇게 하면 hello 줄어듭니다 hello 엔터티의 전체 부하가 합니다.</span><span class="sxs-lookup"><span data-stu-id="782f4-301">This reduces hello overall load of hello entity.</span></span> <span data-ttu-id="782f4-302">Hello 감소 전체적 비율을 메시지 hello 큐 또는 항목에 쓸 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="782f4-302">It also reduces hello overall rate at which messages can be written into hello queue or topic.</span></span>
* <span data-ttu-id="782f4-303">Hello 프리페치 개수 tooa 작은 값을 설정 (예: PrefetchCount = 10).</span><span class="sxs-lookup"><span data-stu-id="782f4-303">Set hello prefetch count tooa small value (for example, PrefetchCount = 10).</span></span> <span data-ttu-id="782f4-304">이렇게 하면 발신기에 많은 수의 메시지가 캐시된 동안 수신기가 유휴 상태가 되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="782f4-304">This prevents receivers from being idle while other receivers have large numbers of messages cached.</span></span>

### <a name="topic-with-a-small-number-of-subscriptions"></a><span data-ttu-id="782f4-305">구독 수가 적은 토픽</span><span class="sxs-lookup"><span data-stu-id="782f4-305">Topic with a small number of subscriptions</span></span>
<span data-ttu-id="782f4-306">목표: 구독 수가 적은 항목의 hello 처리량을 최대화 합니다.</span><span class="sxs-lookup"><span data-stu-id="782f4-306">Goal: Maximize hello throughput of a topic with a small number of subscriptions.</span></span> <span data-ttu-id="782f4-307">메시지가 hello 결합을 의미 하는 여러 구독에서 수신 되 수신 속도가 모든 구독에 대해 hello 송신 속도 보다 더 높습니다.</span><span class="sxs-lookup"><span data-stu-id="782f4-307">A message is received by many subscriptions, which means hello combined receive rate over all subscriptions is larger than hello send rate.</span></span> <span data-ttu-id="782f4-308">보낸 사람 hello 수는 적습니다.</span><span class="sxs-lookup"><span data-stu-id="782f4-308">hello number of senders is small.</span></span> <span data-ttu-id="782f4-309">구독 당 수신자 hello 수는 적습니다.</span><span class="sxs-lookup"><span data-stu-id="782f4-309">hello number of receivers per subscription is small.</span></span>

<span data-ttu-id="782f4-310">toomaximize 처리량 다음 hello지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="782f4-310">toomaximize throughput, do hello following:</span></span>

* <span data-ttu-id="782f4-311">성능 및 가용성 향상을 위해 분할된 토픽을 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="782f4-311">Use a partitioned topic for improved performance and availability.</span></span>
* <span data-ttu-id="782f4-312">전반적인 tooincrease hello hello 항목에 전송 속도, 여러 메시지 팩터리 toocreate 보낸 사람을 사용 합니다.</span><span class="sxs-lookup"><span data-stu-id="782f4-312">tooincrease hello overall send rate into hello topic, use multiple message factories toocreate senders.</span></span> <span data-ttu-id="782f4-313">각 발신기에 대해 비동기 작업이나 여러 스레드를 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="782f4-313">For each sender, use asynchronous operations or multiple threads.</span></span>
* <span data-ttu-id="782f4-314">전반적인 tooincrease hello 구독에서 수신 속도, 여러 메시지 팩터리 toocreate 수신기를 사용 합니다.</span><span class="sxs-lookup"><span data-stu-id="782f4-314">tooincrease hello overall receive rate from a subscription, use multiple message factories toocreate receivers.</span></span> <span data-ttu-id="782f4-315">각 수신기에 대해 비동기 작업이나 여러 스레드를 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="782f4-315">For each receiver, use asynchronous operations or multiple threads.</span></span>
* <span data-ttu-id="782f4-316">클라이언트 쪽 일괄 처리의 비동기 작업 tootake 장점은 사용 합니다.</span><span class="sxs-lookup"><span data-stu-id="782f4-316">Use asynchronous operations tootake advantage of client-side batching.</span></span>
* <span data-ttu-id="782f4-317">Hello 기본 일괄 처리 간격 20ms tooreduce hello 서비스 버스 클라이언트 프로토콜 전송 수를 사용 합니다.</span><span class="sxs-lookup"><span data-stu-id="782f4-317">Use hello default batching interval of 20ms tooreduce hello number of Service Bus client protocol transmissions.</span></span>
* <span data-ttu-id="782f4-318">일괄 처리된 저장소 액세스는 사용하도록 설정한 상태로 둡니다.</span><span class="sxs-lookup"><span data-stu-id="782f4-318">Leave batched store access enabled.</span></span> <span data-ttu-id="782f4-319">전반적인 hello 증가 속도는 메시지 hello 항목에 쓸 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="782f4-319">This increases hello overall rate at which messages can be written into hello topic.</span></span>
* <span data-ttu-id="782f4-320">모든 팩터리 수신자의 최대 처리 속도 hello hello 프리페치 개수 too20 시간을 설정 합니다.</span><span class="sxs-lookup"><span data-stu-id="782f4-320">Set hello prefetch count too20 times hello maximum processing rates of all receivers of a factory.</span></span> <span data-ttu-id="782f4-321">이렇게 하면 서비스 버스 클라이언트 프로토콜 전송 hello 수가 줄어듭니다.</span><span class="sxs-lookup"><span data-stu-id="782f4-321">This reduces hello number of Service Bus client protocol transmissions.</span></span>

### <a name="topic-with-a-large-number-of-subscriptions"></a><span data-ttu-id="782f4-322">구독 수가 많은 토픽</span><span class="sxs-lookup"><span data-stu-id="782f4-322">Topic with a large number of subscriptions</span></span>
<span data-ttu-id="782f4-323">목표: 구독 수가 많은 항목의 hello 처리량을 최대화 합니다.</span><span class="sxs-lookup"><span data-stu-id="782f4-323">Goal: Maximize hello throughput of a topic with a large number of subscriptions.</span></span> <span data-ttu-id="782f4-324">메시지가 hello 결합을 의미 하는 여러 구독에서 수신 되 수신 모든 구독에 대해 속도 hello 전송 속도 보다 훨씬 큽니다.</span><span class="sxs-lookup"><span data-stu-id="782f4-324">A message is received by many subscriptions, which means hello combined receive rate over all subscriptions is much larger than hello send rate.</span></span> <span data-ttu-id="782f4-325">보낸 사람 hello 수는 적습니다.</span><span class="sxs-lookup"><span data-stu-id="782f4-325">hello number of senders is small.</span></span> <span data-ttu-id="782f4-326">구독 당 수신자 hello 수는 적습니다.</span><span class="sxs-lookup"><span data-stu-id="782f4-326">hello number of receivers per subscription is small.</span></span>

<span data-ttu-id="782f4-327">구독 수가 많은 주제는 일반적으로 모든 메시지는 라우트된 tooall 구독 하는 경우 전반적인 처리량이 낮아집니다를 노출 합니다.</span><span class="sxs-lookup"><span data-stu-id="782f4-327">Topics with a large number of subscriptions typically expose a low overall throughput if all messages are routed tooall subscriptions.</span></span> <span data-ttu-id="782f4-328">이 hello 팩트 각 메시지를 여러 번 수신 및 저장 동일 항목에 포함 된 모든 메시지와 모든 구독 hello에 저장 됩니다.</span><span class="sxs-lookup"><span data-stu-id="782f4-328">This is caused by hello fact that each message is received many times, and all messages that are contained in a topic and all its subscriptions are stored in hello same store.</span></span> <span data-ttu-id="782f4-329">발신자 수가 hello 및 구독 당 수신자 수 작습니다 간주 됩니다.</span><span class="sxs-lookup"><span data-stu-id="782f4-329">It is assumed that hello number of senders and number of receivers per subscription is small.</span></span> <span data-ttu-id="782f4-330">서비스 버스 too2, 항목당 000 구독을 지원합니다.</span><span class="sxs-lookup"><span data-stu-id="782f4-330">Service Bus supports up too2,000 subscriptions per topic.</span></span>

<span data-ttu-id="782f4-331">toomaximize 처리량 다음 hello지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="782f4-331">toomaximize throughput, do hello following:</span></span>

* <span data-ttu-id="782f4-332">성능 및 가용성 향상을 위해 분할된 토픽을 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="782f4-332">Use a partitioned topic for improved performance and availability.</span></span>
* <span data-ttu-id="782f4-333">클라이언트 쪽 일괄 처리의 비동기 작업 tootake 장점은 사용 합니다.</span><span class="sxs-lookup"><span data-stu-id="782f4-333">Use asynchronous operations tootake advantage of client-side batching.</span></span>
* <span data-ttu-id="782f4-334">Hello 기본 일괄 처리 간격 20ms tooreduce hello 서비스 버스 클라이언트 프로토콜 전송 수를 사용 합니다.</span><span class="sxs-lookup"><span data-stu-id="782f4-334">Use hello default batching interval of 20ms tooreduce hello number of Service Bus client protocol transmissions.</span></span>
* <span data-ttu-id="782f4-335">일괄 처리된 저장소 액세스는 사용하도록 설정한 상태로 둡니다.</span><span class="sxs-lookup"><span data-stu-id="782f4-335">Leave batched store access enabled.</span></span> <span data-ttu-id="782f4-336">전반적인 hello 증가 속도는 메시지 hello 항목에 쓸 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="782f4-336">This increases hello overall rate at which messages can be written into hello topic.</span></span>
* <span data-ttu-id="782f4-337">Hello 프리페치 개수 too20 번 hello 예상 수신 속도 (초)에서으로 설정 합니다.</span><span class="sxs-lookup"><span data-stu-id="782f4-337">Set hello prefetch count too20 times hello expected receive rate in seconds.</span></span> <span data-ttu-id="782f4-338">이렇게 하면 서비스 버스 클라이언트 프로토콜 전송 hello 수가 줄어듭니다.</span><span class="sxs-lookup"><span data-stu-id="782f4-338">This reduces hello number of Service Bus client protocol transmissions.</span></span>

## <a name="next-steps"></a><span data-ttu-id="782f4-339">다음 단계</span><span class="sxs-lookup"><span data-stu-id="782f4-339">Next steps</span></span>
<span data-ttu-id="782f4-340">서비스 버스 성능 최적화에 대 한 더 toolearn 참조 [메시징 엔터티 분할][Partitioned messaging entities]합니다.</span><span class="sxs-lookup"><span data-stu-id="782f4-340">toolearn more about optimizing Service Bus performance, see [Partitioned messaging entities][Partitioned messaging entities].</span></span>

[QueueClient]: /dotnet/api/microsoft.servicebus.messaging.queueclient
[MessageSender]: /dotnet/api/microsoft.servicebus.messaging.messagesender
[MessagingFactory]: /dotnet/api/microsoft.servicebus.messaging.messagingfactory
[PeekLock]: /dotnet/api/microsoft.servicebus.messaging.receivemode
[ReceiveAndDelete]: /dotnet/api/microsoft.servicebus.messaging.receivemode
[BatchFlushInterval]: /dotnet/api/microsoft.servicebus.messaging.netmessagingtransportsettings.batchflushinterval#Microsoft_ServiceBus_Messaging_NetMessagingTransportSettings_BatchFlushInterval
[EnableBatchedOperations]: /dotnet/api/microsoft.servicebus.messaging.queuedescription.enablebatchedoperations#Microsoft_ServiceBus_Messaging_QueueDescription_EnableBatchedOperations
[QueueClient.PrefetchCount]: /dotnet/api/microsoft.servicebus.messaging.queueclient.prefetchcount#Microsoft_ServiceBus_Messaging_QueueClient_PrefetchCount
[SubscriptionClient.PrefetchCount]: /dotnet/api/microsoft.servicebus.messaging.subscriptionclient.prefetchcount#Microsoft_ServiceBus_Messaging_SubscriptionClient_PrefetchCount
[ForcePersistence]: /dotnet/api/microsoft.servicebus.messaging.brokeredmessage.forcepersistence#Microsoft_ServiceBus_Messaging_BrokeredMessage_ForcePersistence
[EnablePartitioning]: /dotnet/api/microsoft.servicebus.messaging.queuedescription.enablepartitioning#Microsoft_ServiceBus_Messaging_QueueDescription_EnablePartitioning
[Partitioned messaging entities]: service-bus-partitioning.md
[TopicDescription.EnableFilteringMessagesBeforePublishing]: /dotnet/api/microsoft.servicebus.messaging.topicdescription.enablefilteringmessagesbeforepublishing#Microsoft_ServiceBus_Messaging_TopicDescription_EnableFilteringMessagesBeforePublishing
