---
title: "Azure Service Bus를 사용하여 성능을 향상하는 모범 사례 | Microsoft Docs"
description: "broker 저장 메시지를 교환할 때 Azure Service Bus를 사용하여 성능을 최적화하는 방법에 대해 설명합니다."
services: service-bus-messaging
documentationcenter: na
author: sethmanheim
manager: timlt
editor: 
ms.assetid: e756c15d-31fc-45c0-8df4-0bca0da10bb2
ms.service: service-bus-messaging
ms.devlang: na
ms.topic: article
ms.tgt_pltfrm: na
ms.workload: na
ms.date: 05/10/2017
ms.author: sethm
ms.openlocfilehash: e6a0e480f7748f12f5e566cf4059b5b2c4242c09
ms.sourcegitcommit: f537befafb079256fba0529ee554c034d73f36b0
ms.translationtype: MT
ms.contentlocale: ko-KR
ms.lasthandoff: 07/11/2017
---
# <a name="best-practices-for-performance-improvements-using-service-bus-messaging"></a><span data-ttu-id="d1679-103">Service Bus 메시징을 사용한 성능 향상의 모범 사례</span><span class="sxs-lookup"><span data-stu-id="d1679-103">Best Practices for performance improvements using Service Bus Messaging</span></span>

<span data-ttu-id="d1679-104">이 문서에서는 조정된 메시지를 교환할 때 [Azure Service Bus 메시징](https://azure.microsoft.com/services/service-bus/)을 사용하여 성능을 최적화하는 방법을 설명합니다.</span><span class="sxs-lookup"><span data-stu-id="d1679-104">This article describes how to use [Azure Service Bus messaging](https://azure.microsoft.com/services/service-bus/) to optimize performance when exchanging brokered messages.</span></span> <span data-ttu-id="d1679-105">이 항목의 첫 번째 부분에서는 성능 향상을 위해 제공되는 다양한 메커니즘에 대해 설명합니다.</span><span class="sxs-lookup"><span data-stu-id="d1679-105">The first part of this topic describes the different mechanisms that are offered to help increase performance.</span></span> <span data-ttu-id="d1679-106">두 번째 부분은 특정 시나리오에서 최고의 성능을 제공하는 방식으로 서비스 버스를 사용하는 방법에 대해 안내합니다.</span><span class="sxs-lookup"><span data-stu-id="d1679-106">The second part provides guidance on how to use Service Bus in a way that can offer the best performance in a given scenario.</span></span>

<span data-ttu-id="d1679-107">이 항목 전반적으로 "클라이언트"라는 용어는 Service Bus에 액세스하는 모든 엔터티를 가리킵니다.</span><span class="sxs-lookup"><span data-stu-id="d1679-107">Throughout this topic, the term "client" refers to any entity that accesses Service Bus.</span></span> <span data-ttu-id="d1679-108">클라이언트는 발신기 또는 수신기의 역할을 수행할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="d1679-108">A client can take the role of a sender or a receiver.</span></span> <span data-ttu-id="d1679-109">"발신기"라는 용어는 메시지를 Service Bus 큐 또는 토픽에 보내는 Service Bus 큐 또는 토픽 클라이언트에 사용됩니다.</span><span class="sxs-lookup"><span data-stu-id="d1679-109">The term "sender" is used for a Service Bus queue or topic client that sends messages to a Service Bus queue or topic.</span></span> <span data-ttu-id="d1679-110">"수신기"라는 용어는 Service Bus 큐 또는 구독에서 메시지를 수신하는 Service Bus 큐 또는 구독 클라이언트를 가리킵니다.</span><span class="sxs-lookup"><span data-stu-id="d1679-110">The term "receiver" refers to a Service Bus queue or subscription client that receives messages from a Service Bus queue or subscription.</span></span>

<span data-ttu-id="d1679-111">다음 섹션에서는 서비스 버스가 성능 향상을 위해 사용하는 몇 가지 개념에 대해 소개합니다.</span><span class="sxs-lookup"><span data-stu-id="d1679-111">These sections introduce several concepts that Service Bus uses to help boost performance.</span></span>

## <a name="protocols"></a><span data-ttu-id="d1679-112">프로토콜</span><span class="sxs-lookup"><span data-stu-id="d1679-112">Protocols</span></span>
<span data-ttu-id="d1679-113">Service Bus를 사용하면 클라이언트에서 세 가지 프로토콜 중 하나를 통해 메시지를 보내고 받을 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="d1679-113">Service Bus enables clients to send and receive messages via one of three protocols:</span></span>

1. <span data-ttu-id="d1679-114">AMQP(고급 메시지 큐 프로토콜)</span><span class="sxs-lookup"><span data-stu-id="d1679-114">Advanced Message Queuing Protocol (AMQP)</span></span>
2. <span data-ttu-id="d1679-115">SBMP(Service Bus 메시징 프로토콜)</span><span class="sxs-lookup"><span data-stu-id="d1679-115">Service Bus Messaging Protocol (SBMP)</span></span>
3. <span data-ttu-id="d1679-116">http</span><span class="sxs-lookup"><span data-stu-id="d1679-116">HTTP</span></span>

<span data-ttu-id="d1679-117">AMQP와 SBMP는 메시징 팩터리가 존재하는 한 Service Bus에 대한 연결을 유지하기 때문에 둘 다 보다 효율적입니다.</span><span class="sxs-lookup"><span data-stu-id="d1679-117">AMQP and SBMP are more efficient, because they maintain the connection to Service Bus as long as the messaging factory exists.</span></span> <span data-ttu-id="d1679-118">또한 일괄 처리와 프리페치도 구현합니다.</span><span class="sxs-lookup"><span data-stu-id="d1679-118">It also implements batching and prefetching.</span></span> <span data-ttu-id="d1679-119">명시적으로 언급하지 않는 한 이 항목의 모든 내용에서는 AMQP 또는 SBMP를 사용하는 것으로 가정합니다.</span><span class="sxs-lookup"><span data-stu-id="d1679-119">Unless explicitly mentioned, all content in this topic assumes the use of AMQP or SBMP.</span></span>

## <a name="reusing-factories-and-clients"></a><span data-ttu-id="d1679-120">팩터리 및 클라이언트 다시 사용</span><span class="sxs-lookup"><span data-stu-id="d1679-120">Reusing factories and clients</span></span>
<span data-ttu-id="d1679-121">[QueueClient][QueueClient] 또는 [MessageSender][MessageSender]와 같은 Service Bus 클라이언트 개체는 내부 연결 관리도 제공하는 [MessagingFactory][MessagingFactory] 개체를 통해 만듭니다.</span><span class="sxs-lookup"><span data-stu-id="d1679-121">Service Bus client objects, such as [QueueClient][QueueClient] or [MessageSender][MessageSender], are created through a [MessagingFactory][MessagingFactory] object, which also provides internal management of connections.</span></span> <span data-ttu-id="d1679-122">메시지를 보낸 다음 메시징 팩터리 또는 큐, 토픽, 구독 클라이언트를 닫은 후 다음 메시지를 보낼 때 이러한 메시징 팩터리 또는 큐, 토픽, 구독 클라이언트를 다시 만들지 않아야 합니다.</span><span class="sxs-lookup"><span data-stu-id="d1679-122">You should not close messaging factories or queue, topic, and subscription clients after you send a message, and then re-create them when you send the next message.</span></span> <span data-ttu-id="d1679-123">메시징 팩터리를 닫을 경우 서비스 버스 서비스에 대한 연결이 삭제되고 팩터리를 다시 만들면 새 연결이 구축됩니다.</span><span class="sxs-lookup"><span data-stu-id="d1679-123">Closing a messaging factory deletes the connection to the Service Bus service, and a new connection is established when recreating the factory.</span></span> <span data-ttu-id="d1679-124">여러 작업에 대해 동일한 팩터리와 클라이언트 개체를 다시 사용하면 많은 비용이 드는 연결 작업을 하지 않아도 됩니다.</span><span class="sxs-lookup"><span data-stu-id="d1679-124">Establishing a connection is an expensive operation that you can avoid by re-using the same factory and client objects for multiple operations.</span></span> <span data-ttu-id="d1679-125">동시 비동기 작업 및 다중 스레드에서 메시지를 보내기 위해 [QueueClient][QueueClient] 개체를 안전하게 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="d1679-125">You can safely use the [QueueClient][QueueClient] object for sending messages from concurrent asynchronous operations and multiple threads.</span></span> 

## <a name="concurrent-operations"></a><span data-ttu-id="d1679-126">동시 작업</span><span class="sxs-lookup"><span data-stu-id="d1679-126">Concurrent operations</span></span>
<span data-ttu-id="d1679-127">작업(보내기, 받기, 삭제 등) 수행은 다소 시간이 걸립니다.</span><span class="sxs-lookup"><span data-stu-id="d1679-127">Performing an operation (send, receive, delete, etc.) takes some time.</span></span> <span data-ttu-id="d1679-128">이 시간에는 요청 및 응답 지연 시간과 서비스 버스 서비스의 작업 처리가 포함됩니다.</span><span class="sxs-lookup"><span data-stu-id="d1679-128">This time includes the processing of the operation by the Service Bus service in addition to the latency of the request and the reply.</span></span> <span data-ttu-id="d1679-129">시간당 작업 수를 늘리려면 작업이 동시에 실행되어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="d1679-129">To increase the number of operations per time, operations must execute concurrently.</span></span> <span data-ttu-id="d1679-130">이 작업은 다양한 방법으로 수행할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="d1679-130">You can do this in several different ways:</span></span>

* <span data-ttu-id="d1679-131">**비동기 작업**: 클라이언트가 비동기 작업을 수행하여 작업을 예약합니다.</span><span class="sxs-lookup"><span data-stu-id="d1679-131">**Asynchronous operations**: the client schedules operations by performing asynchronous operations.</span></span> <span data-ttu-id="d1679-132">이전 요청이 완료되기 전에 다음 요청이 시작됩니다.</span><span class="sxs-lookup"><span data-stu-id="d1679-132">The next request is started before the previous request is completed.</span></span> <span data-ttu-id="d1679-133">다음은 비동기 전송 작업의 예제입니다.</span><span class="sxs-lookup"><span data-stu-id="d1679-133">The following is an example of an asynchronous send operation:</span></span>
  
 ```csharp
  BrokeredMessage m1 = new BrokeredMessage(body);
  BrokeredMessage m2 = new BrokeredMessage(body);
  
  Task send1 = queueClient.SendAsync(m1).ContinueWith((t) => 
    {
      Console.WriteLine("Sent message #1");
    });
  Task send2 = queueClient.SendAsync(m2).ContinueWith((t) => 
    {
      Console.WriteLine("Sent message #2");
    });
  Task.WaitAll(send1, send2);
  Console.WriteLine("All messages sent");
  ```
  
  <span data-ttu-id="d1679-134">다음은 비동기 수신 작업의 예제입니다.</span><span class="sxs-lookup"><span data-stu-id="d1679-134">This is an example of an asynchronous receive operation:</span></span>
  
  ```csharp
  Task receive1 = queueClient.ReceiveAsync().ContinueWith(ProcessReceivedMessage);
  Task receive2 = queueClient.ReceiveAsync().ContinueWith(ProcessReceivedMessage);
  
  Task.WaitAll(receive1, receive2);
  Console.WriteLine("All messages received");
  
  async void ProcessReceivedMessage(Task<BrokeredMessage> t)
  {
    BrokeredMessage m = t.Result;
    Console.WriteLine("{0} received", m.Label);
    await m.CompleteAsync();
    Console.WriteLine("{0} complete", m.Label);
  }
  ```
* <span data-ttu-id="d1679-135">**복수 팩터리**: 동일한 팩터리에서 만든 모든 클라이언트(발신기 및 수신기)가 하나의 TCP 연결을 공유합니다.</span><span class="sxs-lookup"><span data-stu-id="d1679-135">**Multiple factories**: all clients (senders in addition to receivers) that are created by the same factory share one TCP connection.</span></span> <span data-ttu-id="d1679-136">최대 메시지 처리량은 이 TCO 연결을 통과할 수 있는 작업의 수로 제한됩니다.</span><span class="sxs-lookup"><span data-stu-id="d1679-136">The maximum message throughput is limited by the number of operations that can go through this TCP connection.</span></span> <span data-ttu-id="d1679-137">단일 팩터리로 얻을 수 있는 처리량은 TCP 왕복 시간과 메시지 크기에 따라 크게 달라집니다.</span><span class="sxs-lookup"><span data-stu-id="d1679-137">The throughput that can be obtained with a single factory varies greatly with TCP round-trip times and message size.</span></span> <span data-ttu-id="d1679-138">더 높은 처리량 속도를 얻으려면 여러 메시징 팩터리를 사용해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="d1679-138">To obtain higher throughput rates, you should use multiple messaging factories.</span></span>

## <a name="receive-mode"></a><span data-ttu-id="d1679-139">수신 모드</span><span class="sxs-lookup"><span data-stu-id="d1679-139">Receive mode</span></span>
<span data-ttu-id="d1679-140">큐 또는 구독 클라이언트를 만들 때 *보기-잠금* 또는 *수신 및 삭제* 중에서 수신 모드를 지정할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="d1679-140">When creating a queue or subscription client, you can specify a receive mode: *Peek-lock* or *Receive and Delete*.</span></span> <span data-ttu-id="d1679-141">기본 수신 모드는 [PeekLock][PeekLock]입니다.</span><span class="sxs-lookup"><span data-stu-id="d1679-141">The default receive mode is [PeekLock][PeekLock].</span></span> <span data-ttu-id="d1679-142">이 모드에서 작동하는 경우 클라이언트가 서비스 버스에서 메시지를 수신하기 위한 요청을 보냅니다.</span><span class="sxs-lookup"><span data-stu-id="d1679-142">When operating in this mode, the client sends a request to receive a message from Service Bus.</span></span> <span data-ttu-id="d1679-143">클라이언트가 메시지를 받으면 메시지를 완료하기 위한 요청을 보냅니다.</span><span class="sxs-lookup"><span data-stu-id="d1679-143">After the client has received the message, it sends a request to complete the message.</span></span>

<span data-ttu-id="d1679-144">수신 모드를 [ReceiveAndDelete][ReceiveAndDelete]로 설정하는 경우 두 단계가 단일 요청으로 결합됩니다.</span><span class="sxs-lookup"><span data-stu-id="d1679-144">When setting the receive mode to [ReceiveAndDelete][ReceiveAndDelete], both steps are combined in a single request.</span></span> <span data-ttu-id="d1679-145">그러면 전체 작업 수가 줄어들고 전체 메시지 처리량을 향상할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="d1679-145">This reduces the overall number of operations, and can improve the overall message throughput.</span></span> <span data-ttu-id="d1679-146">이와 같이 성능이 향상되지만 메시지 손실의 위험이 있습니다.</span><span class="sxs-lookup"><span data-stu-id="d1679-146">This performance gain comes at the risk of losing messages.</span></span>

<span data-ttu-id="d1679-147">서비스 버스는 수신 및 삭제 작업에 대한 트랜잭션을 지원하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="d1679-147">Service Bus does not support transactions for receive-and-delete operations.</span></span> <span data-ttu-id="d1679-148">또한 클라이언트가 메시지를 연기하거나 [배달 못 한](service-bus-dead-letter-queues.md) 시나리오에서는 보기-잠금 의미 체계가 필요합니다.</span><span class="sxs-lookup"><span data-stu-id="d1679-148">In addition, peek-lock semantics are required for any scenarios in which the client wants to defer or [dead-letter](service-bus-dead-letter-queues.md) a message.</span></span>

## <a name="client-side-batching"></a><span data-ttu-id="d1679-149">클라이언트 쪽 일괄 처리</span><span class="sxs-lookup"><span data-stu-id="d1679-149">Client-side batching</span></span>
<span data-ttu-id="d1679-150">클라이언트 쪽 일괄 처리에서는 큐 또는 토픽 클라이언트가 일정 시간 동안 메시지 전송을 연기할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="d1679-150">Client-side batching enables a queue or topic client to delay the sending of a message for a certain period of time.</span></span> <span data-ttu-id="d1679-151">클라이언트가 이 기간 동안 추가 메시지를 보내면 메시지를 단일 배치로 전송합니다.</span><span class="sxs-lookup"><span data-stu-id="d1679-151">If the client sends additional messages during this time period, it transmits the messages in a single batch.</span></span> <span data-ttu-id="d1679-152">또한 클라이언트 쪽 일괄 처리에서는 또한 큐 또는 구독 클라이언트가 여러 **완료** 요청을 단일 요청으로 일괄 처리합니다.</span><span class="sxs-lookup"><span data-stu-id="d1679-152">Client-side batching also causes a queue or subscription client to batch multiple **Complete** requests into a single request.</span></span> <span data-ttu-id="d1679-153">일괄 처리는 비동기 **전송** 및 **완료** 작업에만 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="d1679-153">Batching is only available for asynchronous **Send** and **Complete** operations.</span></span> <span data-ttu-id="d1679-154">동기 작업은 서비스 버스 서비스에 즉시 보내집니다.</span><span class="sxs-lookup"><span data-stu-id="d1679-154">Synchronous operations are immediately sent to the Service Bus service.</span></span> <span data-ttu-id="d1679-155">일괄 처리는 보기 또는 수신 작업에 대해 발생하지 않으며 클라이언트 전반에서도 발생하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="d1679-155">Batching does not occur for peek or receive operations, nor does batching occur across clients.</span></span>

<span data-ttu-id="d1679-156">기본적으로 클라이언트는 20ms의 배치 간격을 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="d1679-156">By default, a client uses a batch interval of 20ms.</span></span> <span data-ttu-id="d1679-157">메시지 팩터리를 만들기 전에 [BatchFlushInterval][BatchFlushInterval] 속성을 설정하여 배치 간격을 변경할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="d1679-157">You can change the batch interval by setting the [BatchFlushInterval][BatchFlushInterval] property before creating the messaging factory.</span></span> <span data-ttu-id="d1679-158">이 설정은이 이 팩터리에서 만든 모든 클라이언트에 영향을 줍니다.</span><span class="sxs-lookup"><span data-stu-id="d1679-158">This setting affects all clients that are created by this factory.</span></span>

<span data-ttu-id="d1679-159">일괄 처리를 사용하지 않도록 설정하려면 [BatchFlushInterval][BatchFlushInterval] 속성을 **TimeSpan.Zero**로 설정합니다.</span><span class="sxs-lookup"><span data-stu-id="d1679-159">To disable batching, set the [BatchFlushInterval][BatchFlushInterval] property to **TimeSpan.Zero**.</span></span> <span data-ttu-id="d1679-160">예:</span><span class="sxs-lookup"><span data-stu-id="d1679-160">For example:</span></span>

```csharp
MessagingFactorySettings mfs = new MessagingFactorySettings();
mfs.TokenProvider = tokenProvider;
mfs.NetMessagingTransportSettings.BatchFlushInterval = TimeSpan.FromSeconds(0.05);
MessagingFactory messagingFactory = MessagingFactory.Create(namespaceUri, mfs);
```

<span data-ttu-id="d1679-161">일괄 처리는 청구 가능 메시징 작업의 수에 영향을 주지 않으며 서비스 버스 클라이언트 프로토콜에 대해서만 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="d1679-161">Batching does not affect the number of billable messaging operations, and is available only for the Service Bus client protocol.</span></span> <span data-ttu-id="d1679-162">HTTP 프로토콜은 일괄 처리를 지원하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="d1679-162">The HTTP protocol does not support batching.</span></span>

## <a name="batching-store-access"></a><span data-ttu-id="d1679-163">저장소 액세스 일괄 처리</span><span class="sxs-lookup"><span data-stu-id="d1679-163">Batching store access</span></span>
<span data-ttu-id="d1679-164">큐, 토픽 또는 구독의 처리량을 높이기 위해 Service Bus는 내부 저장소에 쓸 때 여러 메시지를 일괄 처리합니다.</span><span class="sxs-lookup"><span data-stu-id="d1679-164">To increase the throughput of a queue, topic, or subscription, Service Bus batches multiple messages when it writes to its internal store.</span></span> <span data-ttu-id="d1679-165">큐 또는 토픽에 설정된 경우 저장소에 메시지를 쓰는 작업이 일괄 처리됩니다.</span><span class="sxs-lookup"><span data-stu-id="d1679-165">If enabled on a queue or topic, writing messages into the store will be batched.</span></span> <span data-ttu-id="d1679-166">큐 또는 구독에 설정된 경우 저장소에서 메시지를 삭제하는 작업이 일괄 처리됩니다.</span><span class="sxs-lookup"><span data-stu-id="d1679-166">If enabled on a queue or subscription, deleting messages from the store will be batched.</span></span> <span data-ttu-id="d1679-167">엔터티에 대해 일괄 처리된 저장소 액세스를 사용할 경우 서비스 버스는 해당 엔터티와 관련된 저장소 쓰기 작업을 최대 20ms까지 지연합니다.</span><span class="sxs-lookup"><span data-stu-id="d1679-167">If batched store access is enabled for an entity, Service Bus delays a store write operation regarding that entity by up to 20ms.</span></span> <span data-ttu-id="d1679-168">이 간격 동안 발생하는 추가 저장소 작업은 배치에 추가됩니다.</span><span class="sxs-lookup"><span data-stu-id="d1679-168">Additional store operations that occur during this interval are added to the batch.</span></span> <span data-ttu-id="d1679-169">일괄 처리된 저장소 액세스는 **전송** 및 **완료** 작업에만 영향을 주고 수신 작업은 영향을 받지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="d1679-169">Batched store access only affects **Send** and **Complete** operations; receive operations are not affected.</span></span> <span data-ttu-id="d1679-170">일괄 처리된 저장소 액세스는 엔터티의 속성입니다.</span><span class="sxs-lookup"><span data-stu-id="d1679-170">Batched store access is a property on an entity.</span></span> <span data-ttu-id="d1679-171">일괄 처리는 일괄 처리된 저장소 액세스가 가능한 모든 엔터티에서 발생합니다.</span><span class="sxs-lookup"><span data-stu-id="d1679-171">Batching occurs across all entities that enable batched store access.</span></span>

<span data-ttu-id="d1679-172">새 큐, 토픽 또는 구독을 만들면 기본적으로 일괄 처리된 저장소 액세스가 사용하도록 설정됩니다.</span><span class="sxs-lookup"><span data-stu-id="d1679-172">When creating a new queue, topic or subscription, batched store access is enabled by default.</span></span> <span data-ttu-id="d1679-173">일괄 처리된 저장소 액세스를 사용하지 않으려면 엔터티를 만들기 전에 [EnableBatchedOperations][EnableBatchedOperations] 속성을 **false**로 설정합니다.</span><span class="sxs-lookup"><span data-stu-id="d1679-173">To disable batched store access, set the [EnableBatchedOperations][EnableBatchedOperations] property to **false** before creating the entity.</span></span> <span data-ttu-id="d1679-174">예:</span><span class="sxs-lookup"><span data-stu-id="d1679-174">For example:</span></span>

```csharp
QueueDescription qd = new QueueDescription();
qd.EnableBatchedOperations = false;
Queue q = namespaceManager.CreateQueue(qd);
```

<span data-ttu-id="d1679-175">일괄 처리된 저장소 액세스는 청구 가능한 메시징 작업의 수에 영향을 주지 않으며 큐, 토픽 또는 구독의 속성입니다.</span><span class="sxs-lookup"><span data-stu-id="d1679-175">Batched store access does not affect the number of billable messaging operations, and is a property of a queue, topic, or subscription.</span></span> <span data-ttu-id="d1679-176">또한 수신 모드와 독립적이며 클라이언트와 서비스 버스 서비스 간 사용되는 프로토콜과도 무관합니다.</span><span class="sxs-lookup"><span data-stu-id="d1679-176">It is independent of the receive mode and the protocol that is used between a client and the Service Bus service.</span></span>

## <a name="prefetching"></a><span data-ttu-id="d1679-177">프리페치</span><span class="sxs-lookup"><span data-stu-id="d1679-177">Prefetching</span></span>
<span data-ttu-id="d1679-178">프리페치에서는 큐 또는 구독 클라이언트가 수신 작업을 수행할 때 서비스에서 추가 메시지를 로드할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="d1679-178">Prefetching enables the queue or subscription client to load additional messages from the service when it performs a receive operation.</span></span> <span data-ttu-id="d1679-179">클라이언트는 이러한 메시지를 로컬 캐시에 저장합니다.</span><span class="sxs-lookup"><span data-stu-id="d1679-179">The client stores these messages in a local cache.</span></span> <span data-ttu-id="d1679-180">캐시 크기는 [QueueClient.PrefetchCount][QueueClient.PrefetchCount] 또는 [SubscriptionClient.PrefetchCount][SubscriptionClient.PrefetchCount] 속성으로 결정됩니다.</span><span class="sxs-lookup"><span data-stu-id="d1679-180">The size of the cache is determined by the [QueueClient.PrefetchCount][QueueClient.PrefetchCount] or [SubscriptionClient.PrefetchCount][SubscriptionClient.PrefetchCount] properties.</span></span> <span data-ttu-id="d1679-181">프리페치를 사용할 수 있는 각 클라이언트는 각각의 캐시를 유지합니다.</span><span class="sxs-lookup"><span data-stu-id="d1679-181">Each client that enables prefetching maintains its own cache.</span></span> <span data-ttu-id="d1679-182">캐시는 클라이언트 사이에서 공유되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="d1679-182">A cache is not shared across clients.</span></span> <span data-ttu-id="d1679-183">클라이언트가 수신 작업을 시작할 때 캐시가 비어 있으면 서비스에서 메시지의 배치를 전송합니다.</span><span class="sxs-lookup"><span data-stu-id="d1679-183">If the client initiates a receive operation and its cache is empty, the service transmits a batch of messages.</span></span> <span data-ttu-id="d1679-184">배치의 크기는 캐시의 크기와 256KB 중 더 작은 값입니다.</span><span class="sxs-lookup"><span data-stu-id="d1679-184">The size of the batch equals the size of the cache or 256 KB, whichever is smaller.</span></span> <span data-ttu-id="d1679-185">클라이언트가 수신 작업을 시작할 때 캐시에 메시지가 포함되어 있으면 캐시에서 해당 메시지를 가져옵니다.</span><span class="sxs-lookup"><span data-stu-id="d1679-185">If the client initiates a receive operation and the cache contains a message, the message is taken from the cache.</span></span>

<span data-ttu-id="d1679-186">메시지가 프리페치되는 경우 서비스는 프리페치된 메시지를 잠급니다.</span><span class="sxs-lookup"><span data-stu-id="d1679-186">When a message is prefetched, the service locks the prefetched message.</span></span> <span data-ttu-id="d1679-187">이렇게 하면 프리페치된 메시지를 다른 수신기가 받을 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="d1679-187">By doing this, the prefetched message cannot be received by a different receiver.</span></span> <span data-ttu-id="d1679-188">잠금이 만료되기 전에 수신기가 메시지를 완료할 수 없는 경우 다른 수신기가 메시지를 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="d1679-188">If the receiver cannot complete the message before the lock expires, the message becomes available to other receivers.</span></span> <span data-ttu-id="d1679-189">프리페치된 메시지의 복사본은 캐시에 남아 있습니다.</span><span class="sxs-lookup"><span data-stu-id="d1679-189">The prefetched copy of the message remains in the cache.</span></span> <span data-ttu-id="d1679-190">만료 및 캐시된 복사본을 사용하는 수신기가 해당 메시지를 완료하려고 하면 예외를 수신합니다.</span><span class="sxs-lookup"><span data-stu-id="d1679-190">The receiver that consumes the expired cached copy will receive an exception when it tries to complete that message.</span></span> <span data-ttu-id="d1679-191">기본적으로 메시지 잠금은 60초 후에 만료됩니다.</span><span class="sxs-lookup"><span data-stu-id="d1679-191">By default, the message lock expires after 60 seconds.</span></span> <span data-ttu-id="d1679-192">이 값은 5분으로 연장할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="d1679-192">This value can be extended to 5 minutes.</span></span> <span data-ttu-id="d1679-193">만료된 메시지를 사용하지 못하도록 하려면 캐시 크기가 언제나 잠금 시간 초과 간격 이내에 클라이언트가 사용할 수 있는 메시지 수보다 작아야 합니다.</span><span class="sxs-lookup"><span data-stu-id="d1679-193">To prevent the consumption of expired messages, the cache size should always be smaller than the number of messages that can be consumed by a client within the lock time-out interval.</span></span>

<span data-ttu-id="d1679-194">기본 잠금 만료 시간인 60초를 사용할 경우 [SubscriptionClient.PrefetchCount][SubscriptionClient.PrefetchCount]에는 모든 팩터리 수신기의 최대 처리 속도보다 20배 높은 값이 적합합니다.</span><span class="sxs-lookup"><span data-stu-id="d1679-194">When using the default lock expiration of 60 seconds, a good value for [SubscriptionClient.PrefetchCount][SubscriptionClient.PrefetchCount] is 20 times the maximum processing rates of all receivers of the factory.</span></span> <span data-ttu-id="d1679-195">예를 들어 팩터리에서 수신기 3개를 만들 경우 각 수신기는 초당 최대 10개의 메시지를 처리할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="d1679-195">For example, a factory creates 3 receivers, and each receiver can process up to 10 messages per second.</span></span> <span data-ttu-id="d1679-196">프리페치 수가 20 X 3 X 10 = 600을 초과해서는 안됩니다.</span><span class="sxs-lookup"><span data-stu-id="d1679-196">The prefetch count should not exceed 20 X 3 X 10 = 600.</span></span> <span data-ttu-id="d1679-197">기본적으로 [QueueClient.PrefetchCount][QueueClient.PrefetchCount]는 서비스에서 추가 메시지를 페치하지 않음을 의미하는 0으로 설정되어 있습니다.</span><span class="sxs-lookup"><span data-stu-id="d1679-197">By default, [QueueClient.PrefetchCount][QueueClient.PrefetchCount] is set to 0, which means that no additional messages are fetched from the service.</span></span>

<span data-ttu-id="d1679-198">메시지를 프리페치할 경우 전체 메시지 작업 수 또는 왕복 수가 감소하므로 큐 또는 구독에 대한 전체 처리량이 증가합니다.</span><span class="sxs-lookup"><span data-stu-id="d1679-198">Prefetching messages increases the overall throughput for a queue or subscription because it reduces the overall number of message operations, or round trips.</span></span> <span data-ttu-id="d1679-199">그러나 첫 번째 메시지를 페치하는 작업은 증가된 메시지 크기로 인해 더 오래 걸립니다.</span><span class="sxs-lookup"><span data-stu-id="d1679-199">Fetching the first message, however, will take longer (due to the increased message size).</span></span> <span data-ttu-id="d1679-200">프리페치된 메시지는 클라이언트에서 이미 다운로드한 메시지이므로 더 빠르게 수신할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="d1679-200">Receiving prefetched messages will be faster because these messages have already been downloaded by the client.</span></span>

<span data-ttu-id="d1679-201">메시지의 TTL(Time to Live) 속성은 서버가 클라이언트에 메시지를 보낼 때 서버에 의해 확인됩니다.</span><span class="sxs-lookup"><span data-stu-id="d1679-201">The time-to-live (TTL) property of a message is checked by the server at the time the server sends the message to the client.</span></span> <span data-ttu-id="d1679-202">클라이언트는 메시지를 수신할 때 메시지의 TTL 속성을 검사하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="d1679-202">The client does not check the message’s TTL property when the message is received.</span></span> <span data-ttu-id="d1679-203">대신, 클라이언트가 메시지를 캐시한 동안에는 메시지의 TTL이 경과된 경우에도 메시지를 수신할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="d1679-203">Instead, the message can be received even if the message’s TTL has passed while the message was cached by the client.</span></span>

<span data-ttu-id="d1679-204">프리페치는 청구 가능 메시징 작업의 수에 영향을 주지 않으며 서비스 버스 클라이언트 프로토콜에 대해서만 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="d1679-204">Prefetching does not affect the number of billable messaging operations, and is available only for the Service Bus client protocol.</span></span> <span data-ttu-id="d1679-205">HTTP 프로토콜은 프리페치를 지원하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="d1679-205">The HTTP protocol does not support prefetching.</span></span> <span data-ttu-id="d1679-206">프리페치는 동기 및 비동기 수신 작업에 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="d1679-206">Prefetching is available for both synchronous and asynchronous receive operations.</span></span>

## <a name="express-queues-and-topics"></a><span data-ttu-id="d1679-207">명시적 큐 및 토픽</span><span class="sxs-lookup"><span data-stu-id="d1679-207">Express queues and topics</span></span>

<span data-ttu-id="d1679-208">명시적 엔터티는 처리량이 높고 대기 시간이 감소된 시나리오를 가능하게 하며, 표준 메시징 계층에서만 지원됩니다.</span><span class="sxs-lookup"><span data-stu-id="d1679-208">Express entities enable high throughput and reduced latency scenarios, and are supported only in the Standard messaging tier.</span></span> <span data-ttu-id="d1679-209">[프리미엄 네임스페이스](service-bus-premium-messaging.md)에 생성된 엔터티는 기본 옵션을 지원하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="d1679-209">Entities created in [Premium namespaces](service-bus-premium-messaging.md) do not support the express option.</span></span> <span data-ttu-id="d1679-210">명시적 엔터티를 사용할 경우 메시지가 큐 또는 토픽으로 전송되면 메시지 저장소에 즉시 저장되지 않고</span><span class="sxs-lookup"><span data-stu-id="d1679-210">With express entities, if a message is sent to a queue or topic, the message is not immediately stored in the messaging store.</span></span> <span data-ttu-id="d1679-211">대신 메모리에 캐시됩니다.</span><span class="sxs-lookup"><span data-stu-id="d1679-211">Instead, it is cached in memory.</span></span> <span data-ttu-id="d1679-212">메시지가 큐에 몇 초 이상 남아 있을 경우 안정적 저장소에 자동으로 기록되므로 중단으로 인한 손실로부터 보호합니다.</span><span class="sxs-lookup"><span data-stu-id="d1679-212">If a message remains in the queue for more than a few seconds, it is automatically written to stable storage, thus protecting it against loss due to an outage.</span></span> <span data-ttu-id="d1679-213">메시지를 보낼 때에는 안정적 저장소에 액세스할 수 없기 때문에 메모리 캐시에 메시지를 쓰면 처리량이 증가하고 대기 시간이 감소합니다.</span><span class="sxs-lookup"><span data-stu-id="d1679-213">Writing the message into a memory cache increases throughput and reduces latency because there is no access to stable storage at the time the message is sent.</span></span> <span data-ttu-id="d1679-214">몇 초 이내에 사용된 메시지는 메시징 저장소에 기록되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="d1679-214">Messages that are consumed within a few seconds are not written to the messaging store.</span></span> <span data-ttu-id="d1679-215">아래 예제에서는 명시적 토픽을 만듭니다.</span><span class="sxs-lookup"><span data-stu-id="d1679-215">The following example creates an express topic.</span></span>

```csharp
TopicDescription td = new TopicDescription(TopicName);
td.EnableExpress = true;
namespaceManager.CreateTopic(td);
```

<span data-ttu-id="d1679-216">손실되어서는 안 되는 중요 정보가 포함된 메시지를 명시적 엔터티로 보낼 경우 발신기는 [ForcePersistence][ForcePersistence] 속성을 **true**로 설정하여 Service Bus가 메시지를 안정적 저장소에 즉시 기록하여 유지하도록 할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="d1679-216">If a message containing critical information that must not be lost is sent to an express entity, the sender can force Service Bus to immediately persist the message to stable storage by setting the [ForcePersistence][ForcePersistence] property to **true**.</span></span>

> [!NOTE]
> <span data-ttu-id="d1679-217">기본 엔터티는 트랜잭션을 지원하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="d1679-217">Express entities do not support transactions.</span></span>

## <a name="use-of-partitioned-queues-or-topics"></a><span data-ttu-id="d1679-218">분할된 큐 또는 토픽 사용</span><span class="sxs-lookup"><span data-stu-id="d1679-218">Use of partitioned queues or topics</span></span>
<span data-ttu-id="d1679-219">Service Bus는 내부적으로 동일한 노드와 메시징 저장소를 사용하여 메시징 엔터티(큐 또는 토픽)에 대한 모든 메시지를 처리 및 저장할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="d1679-219">Internally, Service Bus uses the same node and messaging store to process and store all messages for a messaging entity (queue or topic).</span></span> <span data-ttu-id="d1679-220">반면 분할된 큐 또는 토픽은 여러 노드와 메시징 저장소에 분산됩니다.</span><span class="sxs-lookup"><span data-stu-id="d1679-220">A partitioned queue or topic, on the other hand, is distributed across multiple nodes and messaging stores.</span></span> <span data-ttu-id="d1679-221">분할된 큐와 토픽은 일반 큐 및 토픽보다 높은 처리량뿐만 아니라 뛰어난 가용성을 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="d1679-221">Partitioned queues and topics not only yield a higher throughput than regular queues and topics, they also exhibit superior availability.</span></span> <span data-ttu-id="d1679-222">분할된 엔터티를 만들려면 다음 예제와 같이 [EnablePartitioning][EnablePartitioning] 속성을 **true**로 설정합니다.</span><span class="sxs-lookup"><span data-stu-id="d1679-222">To create a partitioned entity, set the [EnablePartitioning][EnablePartitioning] property to **true**, as shown in the following example.</span></span> <span data-ttu-id="d1679-223">분할된 엔터티에 대한 자세한 내용은 [분할된 메시징 엔터티][Partitioned messaging entities]를 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="d1679-223">For more information about partitioned entities, see [Partitioned messaging entities][Partitioned messaging entities].</span></span>

```csharp
// Create partitioned queue.
QueueDescription qd = new QueueDescription(QueueName);
qd.EnablePartitioning = true;
namespaceManager.CreateQueue(qd);
```

## <a name="use-of-multiple-queues"></a><span data-ttu-id="d1679-224">여러 큐 사용</span><span class="sxs-lookup"><span data-stu-id="d1679-224">Use of multiple queues</span></span>

<span data-ttu-id="d1679-225">분할된 큐 또는 토픽을 사용할 수 없거나 분할된 단일 큐 또는 토픽으로 예상 부하를 처리할 수 없을 경우 여러 메시징 엔터티를 사용해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="d1679-225">If it is not possible to use a partitioned queue or topic, or the expected load cannot be handled by a single partitioned queue or topic, you must use multiple messaging entities.</span></span> <span data-ttu-id="d1679-226">여러 엔터티를 사용할 때는 모든 엔터티에 동일한 클라이언트를 사용하는 대신 각 엔터티의 전용 클라이언트를 만듭니다.</span><span class="sxs-lookup"><span data-stu-id="d1679-226">When using multiple entities, create a dedicated client for each entity, instead of using the same client for all entities.</span></span>

## <a name="development-and-testing-features"></a><span data-ttu-id="d1679-227">개발 및 테스트 기능</span><span class="sxs-lookup"><span data-stu-id="d1679-227">Development and testing features</span></span>

<span data-ttu-id="d1679-228">Service Bus에는 특별히 **프로덕션 구성에서 사용해서는 안 되는** 개발에 사용되는 한 가지 기능이 있습니다. [TopicDescription.EnableFilteringMessagesBeforePublishing][]</span><span class="sxs-lookup"><span data-stu-id="d1679-228">Service Bus has one feature that is used specifically for development which **should never be used in production configurations**: [TopicDescription.EnableFilteringMessagesBeforePublishing][].</span></span>

<span data-ttu-id="d1679-229">새 규칙 또는 필터가 항목에 추가되면 [TopicDescription.EnableFilteringMessagesBeforePublishing][]을 사용하여 새 필터 식이 예상대로 작동하는지 확인할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="d1679-229">When new rules or filters are added to the topic, you can use [TopicDescription.EnableFilteringMessagesBeforePublishing][] to verify that the new filter expression is working as expected.</span></span>

## <a name="scenarios"></a><span data-ttu-id="d1679-230">시나리오</span><span class="sxs-lookup"><span data-stu-id="d1679-230">Scenarios</span></span>
<span data-ttu-id="d1679-231">다음 섹션에서는 일반적인 메시징 시나리오에 대해 설명하고 기본 서비스 버스 설정에 대해 간단히 소개합니다.</span><span class="sxs-lookup"><span data-stu-id="d1679-231">The following sections describe typical messaging scenarios and outline the preferred Service Bus settings.</span></span> <span data-ttu-id="d1679-232">처리량 속도는 적음(초당 1개 메시지 미만), 보통(초당 1개 메시지 이상, 초당 100개 메시지 미만), 높음(초당 100개 메시지 이상)으로 분류됩니다.</span><span class="sxs-lookup"><span data-stu-id="d1679-232">Throughput rates are classified as small (less than 1 message/second), moderate (1 message/second or greater but less than 100 messages/second) and high (100 messages/second or greater).</span></span> <span data-ttu-id="d1679-233">클라이언트 수는 적음(5개 이하), 보통(5개 초과, 20개 이하), 많음(20개 초과)으로 분류됩니다.</span><span class="sxs-lookup"><span data-stu-id="d1679-233">The number of clients are classified as small (5 or fewer), moderate (more than 5 but less than or equal to 20), and large (more than 20).</span></span>

### <a name="high-throughput-queue"></a><span data-ttu-id="d1679-234">처리량이 높은 큐</span><span class="sxs-lookup"><span data-stu-id="d1679-234">High-throughput queue</span></span>
<span data-ttu-id="d1679-235">목표: 단일 큐의 처리량을 최대화합니다.</span><span class="sxs-lookup"><span data-stu-id="d1679-235">Goal: Maximize the throughput of a single queue.</span></span> <span data-ttu-id="d1679-236">발신기와 수신기의 수가 작습니다.</span><span class="sxs-lookup"><span data-stu-id="d1679-236">The number of senders and receivers is small.</span></span>

* <span data-ttu-id="d1679-237">성능 및 가용성 향상을 위해 분할된 큐를 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="d1679-237">Use a partitioned queue for improved performance and availability.</span></span>
* <span data-ttu-id="d1679-238">큐에 대한 전반적 전송 속도를 높이려면 여러 메시지 팩터리를 만들어 발신기를 만듭니다.</span><span class="sxs-lookup"><span data-stu-id="d1679-238">To increase the overall send rate into the queue, use multiple message factories to create senders.</span></span> <span data-ttu-id="d1679-239">각 발신기에 대해 비동기 작업이나 여러 스레드를 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="d1679-239">For each sender, use asynchronous operations or multiple threads.</span></span>
* <span data-ttu-id="d1679-240">큐에서 전반적 수신 속도를 높이려면 여러 메시지 팩터리를 만들어 수신기를 만듭니다.</span><span class="sxs-lookup"><span data-stu-id="d1679-240">To increase the overall receive rate from the queue, use multiple message factories to create receivers.</span></span>
* <span data-ttu-id="d1679-241">클라이언트 쪽 일괄 처리를 활용하려면 비동기 작업을 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="d1679-241">Use asynchronous operations to take advantage of client-side batching.</span></span>
* <span data-ttu-id="d1679-242">일괄 처리 간격을 50ms로 설정하여 서비스 버스 클라이언트 프로토콜 전송 횟수를 줄입니다.</span><span class="sxs-lookup"><span data-stu-id="d1679-242">Set the batching interval to 50ms to reduce the number of Service Bus client protocol transmissions.</span></span> <span data-ttu-id="d1679-243">여러 발신기를 사용할 경우 일괄 처리 간격을 100ms로 높입니다.</span><span class="sxs-lookup"><span data-stu-id="d1679-243">If multiple senders are used, increase the batching interval to 100ms.</span></span>
* <span data-ttu-id="d1679-244">일괄 처리된 저장소 액세스는 사용하도록 설정한 상태로 둡니다.</span><span class="sxs-lookup"><span data-stu-id="d1679-244">Leave batched store access enabled.</span></span> <span data-ttu-id="d1679-245">그러면 메시지가 큐에 기록되는 전반적 속도가 향상됩니다.</span><span class="sxs-lookup"><span data-stu-id="d1679-245">This increases the overall rate at which messages can be written into the queue.</span></span>
* <span data-ttu-id="d1679-246">프리페치 수를 모든 팩터리 수신기의 최대 처리 속도의 20배로 설정합니다.</span><span class="sxs-lookup"><span data-stu-id="d1679-246">Set the prefetch count to 20 times the maximum processing rates of all receivers of a factory.</span></span> <span data-ttu-id="d1679-247">이렇게 하면 서비스 버스 클라이언트 프로토콜 전송 횟수가 줄어듭니다.</span><span class="sxs-lookup"><span data-stu-id="d1679-247">This reduces the number of Service Bus client protocol transmissions.</span></span>

### <a name="multiple-high-throughput-queues"></a><span data-ttu-id="d1679-248">처리량이 높은 복수 큐</span><span class="sxs-lookup"><span data-stu-id="d1679-248">Multiple high-throughput queues</span></span>
<span data-ttu-id="d1679-249">목표: 여러 큐의 전체 처리량을 극대화합니다.</span><span class="sxs-lookup"><span data-stu-id="d1679-249">Goal: Maximize overall throughput of multiple queues.</span></span> <span data-ttu-id="d1679-250">개별 큐의 처리량은 보통 또는 높음입니다.</span><span class="sxs-lookup"><span data-stu-id="d1679-250">The throughput of an individual queue is moderate or high.</span></span>

<span data-ttu-id="d1679-251">여러 큐에서 최대 처리량을 얻으려면 여기에서 설명하는 설정을 사용하여 단일 큐의 처리량을 최대화합니다.</span><span class="sxs-lookup"><span data-stu-id="d1679-251">To obtain maximum throughput across multiple queues, use the settings outlined to maximize the throughput of a single queue.</span></span> <span data-ttu-id="d1679-252">또한 다른 팩터리를 사용하여 다양한 큐에서 보내거나 받는 클라이언트를 만듭니다.</span><span class="sxs-lookup"><span data-stu-id="d1679-252">In addition, use different factories to create clients that send or receive from different queues.</span></span>

### <a name="low-latency-queue"></a><span data-ttu-id="d1679-253">대기 시간이 짧은 큐</span><span class="sxs-lookup"><span data-stu-id="d1679-253">Low latency queue</span></span>
<span data-ttu-id="d1679-254">목표: 큐 또는 토픽의 종단간 대기 시간을 최소화합니다.</span><span class="sxs-lookup"><span data-stu-id="d1679-254">Goal: Minimize end-to-end latency of a queue or topic.</span></span> <span data-ttu-id="d1679-255">발신기와 수신기의 수가 작습니다.</span><span class="sxs-lookup"><span data-stu-id="d1679-255">The number of senders and receivers is small.</span></span> <span data-ttu-id="d1679-256">큐의 처리량은 적음 또는 보통입니다.</span><span class="sxs-lookup"><span data-stu-id="d1679-256">The throughput of the queue is small or moderate.</span></span>

* <span data-ttu-id="d1679-257">가용성 향상을 위해 분할된 큐를 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="d1679-257">Use a partitioned queue for improved availability.</span></span>
* <span data-ttu-id="d1679-258">클라이언트 쪽 일괄 처리를 사용하지 않도록 설정합니다.</span><span class="sxs-lookup"><span data-stu-id="d1679-258">Disable client-side batching.</span></span> <span data-ttu-id="d1679-259">클라이언트에서 즉시 메시지를 보냅니다.</span><span class="sxs-lookup"><span data-stu-id="d1679-259">The client immediately sends a message.</span></span>
* <span data-ttu-id="d1679-260">일괄 처리된 저장소 액세스를 사용하지 않도록 설정합니다.</span><span class="sxs-lookup"><span data-stu-id="d1679-260">Disable batched store access.</span></span> <span data-ttu-id="d1679-261">서비스가 저장소에 즉시 메시지를 씁니다.</span><span class="sxs-lookup"><span data-stu-id="d1679-261">The service immediately writes the message to the store.</span></span>
* <span data-ttu-id="d1679-262">단일 클라이언트를 사용하는 경우 프리페치 수를 수신기의 처리 속도의 20배로 설정합니다.</span><span class="sxs-lookup"><span data-stu-id="d1679-262">If using a single client, set the prefetch count to 20 times the processing rate of the receiver.</span></span> <span data-ttu-id="d1679-263">동시에 여러 메시지가 큐에 도착할 경우 서비스 버스 클라이언트 프로토콜은 이러한 메시지를 동시에 전송합니다.</span><span class="sxs-lookup"><span data-stu-id="d1679-263">If multiple messages arrive at the queue at the same time, the Service Bus client protocol transmits them all at the same time.</span></span> <span data-ttu-id="d1679-264">클라이언트가 다음 메시지를 수신하면 해당 메시지는 이미 로컬 캐시에 있는 것입니다.</span><span class="sxs-lookup"><span data-stu-id="d1679-264">When the client receives the next message, that message is already in the local cache.</span></span> <span data-ttu-id="d1679-265">캐시는 작아야 합니다.</span><span class="sxs-lookup"><span data-stu-id="d1679-265">The cache should be small.</span></span>
* <span data-ttu-id="d1679-266">여러 클라이언트를 사용하는 경우 프리페치 수를 0으로 설정합니다.</span><span class="sxs-lookup"><span data-stu-id="d1679-266">If using multiple clients, set the prefetch count to 0.</span></span> <span data-ttu-id="d1679-267">이렇게 하면 첫 번째 클라이언트가 아직 첫 번째 메시지를 처리하는 동안 두 번째 클라이언트가 두 번째 메시지를 수신할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="d1679-267">By doing this, the second client can receive the second message while the first client is still processing the first message.</span></span>

### <a name="queue-with-a-large-number-of-senders"></a><span data-ttu-id="d1679-268">발신기 수가 많은 큐</span><span class="sxs-lookup"><span data-stu-id="d1679-268">Queue with a large number of senders</span></span>
<span data-ttu-id="d1679-269">목표: 발신기 수가 많은 큐 또는 토픽의 처리량 극대화</span><span class="sxs-lookup"><span data-stu-id="d1679-269">Goal: Maximize throughput of a queue or topic with a large number of senders.</span></span> <span data-ttu-id="d1679-270">각 발신기는 보통 속도의 메시지를 전송합니다.</span><span class="sxs-lookup"><span data-stu-id="d1679-270">Each sender sends messages with a moderate rate.</span></span> <span data-ttu-id="d1679-271">수신기의 수가 작습니다.</span><span class="sxs-lookup"><span data-stu-id="d1679-271">The number of receivers is small.</span></span>

<span data-ttu-id="d1679-272">서비스 버스는 메시지 엔터티에 대해 최대 1,000개의 동시 연결을 지원합니다(AMQP를 사용할 경우 5,000개).</span><span class="sxs-lookup"><span data-stu-id="d1679-272">Service Bus enables up to 1000 concurrent connections to a messaging entity (or 5000 using AMQP).</span></span> <span data-ttu-id="d1679-273">이 제한은 네임스페이스 수준에서 적용되며, 큐/토픽/구독은 네임스페이스당 동시 연결 수로 제한됩니다.</span><span class="sxs-lookup"><span data-stu-id="d1679-273">This limit is enforced at the namespace level, and queues/topics/subscriptions are capped by the limit of concurrent connections per namespace.</span></span> <span data-ttu-id="d1679-274">큐의 경우 이 숫자는 발신기와 수신기 사이에 공유됩니다.</span><span class="sxs-lookup"><span data-stu-id="d1679-274">For queues, this number is shared between senders and receivers.</span></span> <span data-ttu-id="d1679-275">발신기에 1,000개 연결이 모두 필요할 경우 큐를 토픽 및 단일 구독으로 대체해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="d1679-275">If all 1000 connections are required for senders, you should replace the queue with a topic and a single subscription.</span></span> <span data-ttu-id="d1679-276">토픽은 발신기로부터 최대 1,000개의 동시 연결을 지원하는 반면, 구독은 수신기로부터 추가 1,000개의 동시 연결을 지원합니다.</span><span class="sxs-lookup"><span data-stu-id="d1679-276">A topic accepts up to 1000 concurrent connections from senders, whereas the subscription accepts an additional 1000 concurrent connections from receivers.</span></span> <span data-ttu-id="d1679-277">1,000개보다 많은 동시 발신기가 필요할 경우 발신기는 HTTP를 통해 서비스 버스 프로토콜에 메시지를 전송해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="d1679-277">If more than 1000 concurrent senders are required, the senders should send messages to the Service Bus protocol via HTTP.</span></span>

<span data-ttu-id="d1679-278">처리량을 최대화하려면 다음을 수행합니다.</span><span class="sxs-lookup"><span data-stu-id="d1679-278">To maximize throughput, do the following:</span></span>

* <span data-ttu-id="d1679-279">성능 및 가용성 향상을 위해 분할된 큐를 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="d1679-279">Use a partitioned queue for improved performance and availability.</span></span>
* <span data-ttu-id="d1679-280">각 발신기가 다른 프로세스에 상주하는 경우 프로세스당 하나의 팩터리만 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="d1679-280">If each sender resides in a different process, use only a single factory per process.</span></span>
* <span data-ttu-id="d1679-281">클라이언트 쪽 일괄 처리를 활용하려면 비동기 작업을 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="d1679-281">Use asynchronous operations to take advantage of client-side batching.</span></span>
* <span data-ttu-id="d1679-282">서비스 버스 클라이언트 프로토콜 전송 수를 줄이려면 기본 일괄 처리 간격인 20ms를 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="d1679-282">Use the default batching interval of 20ms to reduce the number of Service Bus client protocol transmissions.</span></span>
* <span data-ttu-id="d1679-283">일괄 처리된 저장소 액세스는 사용하도록 설정한 상태로 둡니다.</span><span class="sxs-lookup"><span data-stu-id="d1679-283">Leave batched store access enabled.</span></span> <span data-ttu-id="d1679-284">그러면 메시지가 큐 또는 토픽에 기록되는 전반적 속도가 향상됩니다.</span><span class="sxs-lookup"><span data-stu-id="d1679-284">This increases the overall rate at which messages can be written into the queue or topic.</span></span>
* <span data-ttu-id="d1679-285">프리페치 수를 모든 팩터리 수신기의 최대 처리 속도의 20배로 설정합니다.</span><span class="sxs-lookup"><span data-stu-id="d1679-285">Set the prefetch count to 20 times the maximum processing rates of all receivers of a factory.</span></span> <span data-ttu-id="d1679-286">이렇게 하면 서비스 버스 클라이언트 프로토콜 전송 횟수가 줄어듭니다.</span><span class="sxs-lookup"><span data-stu-id="d1679-286">This reduces the number of Service Bus client protocol transmissions.</span></span>

### <a name="queue-with-a-large-number-of-receivers"></a><span data-ttu-id="d1679-287">수신기 수가 많은 큐</span><span class="sxs-lookup"><span data-stu-id="d1679-287">Queue with a large number of receivers</span></span>
<span data-ttu-id="d1679-288">목표: 수신기 수가 많은 큐 또는 구독의 수신 속도를 극대화합니다.</span><span class="sxs-lookup"><span data-stu-id="d1679-288">Goal: Maximize the receive rate of a queue or subscription with a large number of receivers.</span></span> <span data-ttu-id="d1679-289">각 수신자는 보통 속도로 메시지를 받습니다.</span><span class="sxs-lookup"><span data-stu-id="d1679-289">Each receiver receives messages at a moderate rate.</span></span> <span data-ttu-id="d1679-290">발신기의 수가 작습니다.</span><span class="sxs-lookup"><span data-stu-id="d1679-290">The number of senders is small.</span></span>

<span data-ttu-id="d1679-291">서비스 버스는 엔터티에 대해 최대 1,000개의 동시 연결을 지원합니다.</span><span class="sxs-lookup"><span data-stu-id="d1679-291">Service Bus enables up to 1000 concurrent connections to an entity.</span></span> <span data-ttu-id="d1679-292">큐에 1,000개보다 많은 수신기가 필요할 경우 큐를 토픽 및 여러 구독으로 대체해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="d1679-292">If a queue requires more than 1000 receivers, you should replace the queue with a topic and multiple subscriptions.</span></span> <span data-ttu-id="d1679-293">각 구독은 최대 1,000개의 동시 연결을 지원할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="d1679-293">Each subscription can support up to 1000 concurrent connections.</span></span> <span data-ttu-id="d1679-294">또는 수신자가 HTTP 프로토콜을 통해 큐에 액세스할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="d1679-294">Alternatively, receivers can access the queue via the HTTP protocol.</span></span>

<span data-ttu-id="d1679-295">처리량을 최대화하려면 다음을 수행합니다.</span><span class="sxs-lookup"><span data-stu-id="d1679-295">To maximize throughput, do the following:</span></span>

* <span data-ttu-id="d1679-296">성능 및 가용성 향상을 위해 분할된 큐를 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="d1679-296">Use a partitioned queue for improved performance and availability.</span></span>
* <span data-ttu-id="d1679-297">각 수신기가 다른 프로세스에 상주하는 경우 프로세스당 하나의 팩터리만 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="d1679-297">If each receiver resides in a different process, use only a single factory per process.</span></span>
* <span data-ttu-id="d1679-298">수신기는 동기 또는 비동기 작업을 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="d1679-298">Receivers can use synchronous or asynchronous operations.</span></span> <span data-ttu-id="d1679-299">개별 수신기의 수신 속도가 보통일 경우 완료 요청의 클라이언트 쪽 일괄 처리는 수신기 처리량에 영향을 주지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="d1679-299">Given the moderate receive rate of an individual receiver, client-side batching of a Complete request does not affect receiver throughput.</span></span>
* <span data-ttu-id="d1679-300">일괄 처리된 저장소 액세스는 사용하도록 설정한 상태로 둡니다.</span><span class="sxs-lookup"><span data-stu-id="d1679-300">Leave batched store access enabled.</span></span> <span data-ttu-id="d1679-301">이렇게 하면 엔터티의 전체 부하가 줄어듭니다.</span><span class="sxs-lookup"><span data-stu-id="d1679-301">This reduces the overall load of the entity.</span></span> <span data-ttu-id="d1679-302">또한 메시지가 큐 또는 토픽에 기록되는 전반적 속도가 향상됩니다.</span><span class="sxs-lookup"><span data-stu-id="d1679-302">It also reduces the overall rate at which messages can be written into the queue or topic.</span></span>
* <span data-ttu-id="d1679-303">프리페치 수를 작은 값으로 설정합니다(예: PrefetchCount = 10).</span><span class="sxs-lookup"><span data-stu-id="d1679-303">Set the prefetch count to a small value (for example, PrefetchCount = 10).</span></span> <span data-ttu-id="d1679-304">이렇게 하면 발신기에 많은 수의 메시지가 캐시된 동안 수신기가 유휴 상태가 되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="d1679-304">This prevents receivers from being idle while other receivers have large numbers of messages cached.</span></span>

### <a name="topic-with-a-small-number-of-subscriptions"></a><span data-ttu-id="d1679-305">구독 수가 적은 토픽</span><span class="sxs-lookup"><span data-stu-id="d1679-305">Topic with a small number of subscriptions</span></span>
<span data-ttu-id="d1679-306">목표: 구독 수가 적은 토픽의 처리량을 최대화합니다.</span><span class="sxs-lookup"><span data-stu-id="d1679-306">Goal: Maximize the throughput of a topic with a small number of subscriptions.</span></span> <span data-ttu-id="d1679-307">여러 구독에서 메시지를 수신합니다. 즉, 모든 구독의 수신 속도를 결합한 속도가 전송 속도보다 큼을 의미합니다.</span><span class="sxs-lookup"><span data-stu-id="d1679-307">A message is received by many subscriptions, which means the combined receive rate over all subscriptions is larger than the send rate.</span></span> <span data-ttu-id="d1679-308">발신기의 수가 작습니다.</span><span class="sxs-lookup"><span data-stu-id="d1679-308">The number of senders is small.</span></span> <span data-ttu-id="d1679-309">구독당 수신기의 수가 작습니다.</span><span class="sxs-lookup"><span data-stu-id="d1679-309">The number of receivers per subscription is small.</span></span>

<span data-ttu-id="d1679-310">처리량을 최대화하려면 다음을 수행합니다.</span><span class="sxs-lookup"><span data-stu-id="d1679-310">To maximize throughput, do the following:</span></span>

* <span data-ttu-id="d1679-311">성능 및 가용성 향상을 위해 분할된 토픽을 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="d1679-311">Use a partitioned topic for improved performance and availability.</span></span>
* <span data-ttu-id="d1679-312">토픽에 대한 전반적 전송 속도를 높이려면 여러 메시지 팩터리를 만들어 발신기를 만듭니다.</span><span class="sxs-lookup"><span data-stu-id="d1679-312">To increase the overall send rate into the topic, use multiple message factories to create senders.</span></span> <span data-ttu-id="d1679-313">각 발신기에 대해 비동기 작업이나 여러 스레드를 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="d1679-313">For each sender, use asynchronous operations or multiple threads.</span></span>
* <span data-ttu-id="d1679-314">구독에서 전반적 수신 속도를 높이려면 여러 메시지 팩터리를 만들어 수신기를 만듭니다.</span><span class="sxs-lookup"><span data-stu-id="d1679-314">To increase the overall receive rate from a subscription, use multiple message factories to create receivers.</span></span> <span data-ttu-id="d1679-315">각 수신기에 대해 비동기 작업이나 여러 스레드를 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="d1679-315">For each receiver, use asynchronous operations or multiple threads.</span></span>
* <span data-ttu-id="d1679-316">클라이언트 쪽 일괄 처리를 활용하려면 비동기 작업을 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="d1679-316">Use asynchronous operations to take advantage of client-side batching.</span></span>
* <span data-ttu-id="d1679-317">서비스 버스 클라이언트 프로토콜 전송 수를 줄이려면 기본 일괄 처리 간격인 20ms를 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="d1679-317">Use the default batching interval of 20ms to reduce the number of Service Bus client protocol transmissions.</span></span>
* <span data-ttu-id="d1679-318">일괄 처리된 저장소 액세스는 사용하도록 설정한 상태로 둡니다.</span><span class="sxs-lookup"><span data-stu-id="d1679-318">Leave batched store access enabled.</span></span> <span data-ttu-id="d1679-319">그러면 메시지가 토픽에 기록되는 전반적 속도가 향상됩니다.</span><span class="sxs-lookup"><span data-stu-id="d1679-319">This increases the overall rate at which messages can be written into the topic.</span></span>
* <span data-ttu-id="d1679-320">프리페치 수를 모든 팩터리 수신기의 최대 처리 속도의 20배로 설정합니다.</span><span class="sxs-lookup"><span data-stu-id="d1679-320">Set the prefetch count to 20 times the maximum processing rates of all receivers of a factory.</span></span> <span data-ttu-id="d1679-321">이렇게 하면 서비스 버스 클라이언트 프로토콜 전송 횟수가 줄어듭니다.</span><span class="sxs-lookup"><span data-stu-id="d1679-321">This reduces the number of Service Bus client protocol transmissions.</span></span>

### <a name="topic-with-a-large-number-of-subscriptions"></a><span data-ttu-id="d1679-322">구독 수가 많은 토픽</span><span class="sxs-lookup"><span data-stu-id="d1679-322">Topic with a large number of subscriptions</span></span>
<span data-ttu-id="d1679-323">목표: 구독 수가 많은 토픽의 처리량을 최대화합니다.</span><span class="sxs-lookup"><span data-stu-id="d1679-323">Goal: Maximize the throughput of a topic with a large number of subscriptions.</span></span> <span data-ttu-id="d1679-324">여러 구독에서 메시지를 수신합니다. 즉, 모든 구독의 수신 속도를 결합한 속도가 전송 속도보다 훨씬 큼을 의미합니다.</span><span class="sxs-lookup"><span data-stu-id="d1679-324">A message is received by many subscriptions, which means the combined receive rate over all subscriptions is much larger than the send rate.</span></span> <span data-ttu-id="d1679-325">발신기의 수가 작습니다.</span><span class="sxs-lookup"><span data-stu-id="d1679-325">The number of senders is small.</span></span> <span data-ttu-id="d1679-326">구독당 수신기의 수가 작습니다.</span><span class="sxs-lookup"><span data-stu-id="d1679-326">The number of receivers per subscription is small.</span></span>

<span data-ttu-id="d1679-327">모든 메시지가 모든 구독으로 라우팅될 경우 구독 수가 많은 토픽은 일반적으로 전반적 처리량이 감소합니다.</span><span class="sxs-lookup"><span data-stu-id="d1679-327">Topics with a large number of subscriptions typically expose a low overall throughput if all messages are routed to all subscriptions.</span></span> <span data-ttu-id="d1679-328">그 이유는 각 메시지가 여러 번 수신되며 토픽에 포함된 모든 메시지와 해당 구독이 동일한 저장소에 저장되기 때문입니다.</span><span class="sxs-lookup"><span data-stu-id="d1679-328">This is caused by the fact that each message is received many times, and all messages that are contained in a topic and all its subscriptions are stored in the same store.</span></span> <span data-ttu-id="d1679-329">구독당 발신기 수와 수신기 수가 작은 경우를 가정합니다.</span><span class="sxs-lookup"><span data-stu-id="d1679-329">It is assumed that the number of senders and number of receivers per subscription is small.</span></span> <span data-ttu-id="d1679-330">Service Bus는 토픽당 최대 2,000개의 구독을 지원합니다.</span><span class="sxs-lookup"><span data-stu-id="d1679-330">Service Bus supports up to 2,000 subscriptions per topic.</span></span>

<span data-ttu-id="d1679-331">처리량을 최대화하려면 다음을 수행합니다.</span><span class="sxs-lookup"><span data-stu-id="d1679-331">To maximize throughput, do the following:</span></span>

* <span data-ttu-id="d1679-332">성능 및 가용성 향상을 위해 분할된 토픽을 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="d1679-332">Use a partitioned topic for improved performance and availability.</span></span>
* <span data-ttu-id="d1679-333">클라이언트 쪽 일괄 처리를 활용하려면 비동기 작업을 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="d1679-333">Use asynchronous operations to take advantage of client-side batching.</span></span>
* <span data-ttu-id="d1679-334">서비스 버스 클라이언트 프로토콜 전송 수를 줄이려면 기본 일괄 처리 간격인 20ms를 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="d1679-334">Use the default batching interval of 20ms to reduce the number of Service Bus client protocol transmissions.</span></span>
* <span data-ttu-id="d1679-335">일괄 처리된 저장소 액세스는 사용하도록 설정한 상태로 둡니다.</span><span class="sxs-lookup"><span data-stu-id="d1679-335">Leave batched store access enabled.</span></span> <span data-ttu-id="d1679-336">그러면 메시지가 토픽에 기록되는 전반적 속도가 향상됩니다.</span><span class="sxs-lookup"><span data-stu-id="d1679-336">This increases the overall rate at which messages can be written into the topic.</span></span>
* <span data-ttu-id="d1679-337">프리페치 수를 초당 예상 수신 속도의 20배로 설정합니다.</span><span class="sxs-lookup"><span data-stu-id="d1679-337">Set the prefetch count to 20 times the expected receive rate in seconds.</span></span> <span data-ttu-id="d1679-338">이렇게 하면 서비스 버스 클라이언트 프로토콜 전송 횟수가 줄어듭니다.</span><span class="sxs-lookup"><span data-stu-id="d1679-338">This reduces the number of Service Bus client protocol transmissions.</span></span>

## <a name="next-steps"></a><span data-ttu-id="d1679-339">다음 단계</span><span class="sxs-lookup"><span data-stu-id="d1679-339">Next steps</span></span>
<span data-ttu-id="d1679-340">Service Bus 성능 최적화에 대한 자세한 내용은 [분할된 메시징 엔터티][Partitioned messaging entities]를 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="d1679-340">To learn more about optimizing Service Bus performance, see [Partitioned messaging entities][Partitioned messaging entities].</span></span>

[QueueClient]: /dotnet/api/microsoft.servicebus.messaging.queueclient
[MessageSender]: /dotnet/api/microsoft.servicebus.messaging.messagesender
[MessagingFactory]: /dotnet/api/microsoft.servicebus.messaging.messagingfactory
[PeekLock]: /dotnet/api/microsoft.servicebus.messaging.receivemode
[ReceiveAndDelete]: /dotnet/api/microsoft.servicebus.messaging.receivemode
[BatchFlushInterval]: /dotnet/api/microsoft.servicebus.messaging.netmessagingtransportsettings.batchflushinterval#Microsoft_ServiceBus_Messaging_NetMessagingTransportSettings_BatchFlushInterval
[EnableBatchedOperations]: /dotnet/api/microsoft.servicebus.messaging.queuedescription.enablebatchedoperations#Microsoft_ServiceBus_Messaging_QueueDescription_EnableBatchedOperations
[QueueClient.PrefetchCount]: /dotnet/api/microsoft.servicebus.messaging.queueclient.prefetchcount#Microsoft_ServiceBus_Messaging_QueueClient_PrefetchCount
[SubscriptionClient.PrefetchCount]: /dotnet/api/microsoft.servicebus.messaging.subscriptionclient.prefetchcount#Microsoft_ServiceBus_Messaging_SubscriptionClient_PrefetchCount
[ForcePersistence]: /dotnet/api/microsoft.servicebus.messaging.brokeredmessage.forcepersistence#Microsoft_ServiceBus_Messaging_BrokeredMessage_ForcePersistence
[EnablePartitioning]: /dotnet/api/microsoft.servicebus.messaging.queuedescription.enablepartitioning#Microsoft_ServiceBus_Messaging_QueueDescription_EnablePartitioning
[Partitioned messaging entities]: service-bus-partitioning.md
<span data-ttu-id="d1679-341">[TopicDescription.EnableFilteringMessagesBeforePublishing]: /dotnet/api/microsoft.servicebus.messaging.topicdescription.enablefilteringmessagesbeforepublishing#Microsoft_ServiceBus_Messaging_TopicDescription_EnableFilteringMessagesBeforePublishing</span><span class="sxs-lookup"><span data-stu-id="d1679-341">[TopicDescription.EnableFilteringMessagesBeforePublishing]: /dotnet/api/microsoft.servicebus.messaging.topicdescription.enablefilteringmessagesbeforepublishing#Microsoft_ServiceBus_Messaging_TopicDescription_EnableFilteringMessagesBeforePublishing</span></span>
