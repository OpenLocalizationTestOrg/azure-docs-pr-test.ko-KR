---
title: "Azure Service Bus 토픽 및 구독을 사용하는 응용 프로그램 만들기 | Microsoft Docs"
description: "Service Bus 토픽 및 구독에서 제공하는 게시-구독 기능 소개입니다."
services: service-bus-messaging
documentationcenter: na
author: sethmanheim
manager: timlt
editor: 
ms.assetid: a48fc9b0-b7b0-464e-8187-a517bf8b4eb4
ms.service: service-bus-messaging
ms.devlang: na
ms.topic: article
ms.tgt_pltfrm: na
ms.workload: na
ms.date: 04/07/2017
ms.author: sethm
ms.openlocfilehash: eb01120ce9578f716e5381c107faa93f0b36e358
ms.sourcegitcommit: 50e23e8d3b1148ae2d36dad3167936b4e52c8a23
ms.translationtype: MT
ms.contentlocale: ko-KR
ms.lasthandoff: 08/18/2017
---
# <a name="create-applications-that-use-service-bus-topics-and-subscriptions"></a><span data-ttu-id="36542-103">Service Bus 토픽 및 구독을 사용하는 응용 프로그램 만들기</span><span class="sxs-lookup"><span data-stu-id="36542-103">Create applications that use Service Bus topics and subscriptions</span></span>
<span data-ttu-id="36542-104">Azure 서비스 버스는 신뢰할 수 있는 메시지 큐 및 지속형 게시/구독 메시징을 포함하여 클라우드 기반, 메시지 지향 미들웨어 기술 집합을 지원합니다.</span><span class="sxs-lookup"><span data-stu-id="36542-104">Azure Service Bus supports a set of cloud-based, message-oriented middleware technologies including reliable message queuing and durable publish/subscribe messaging.</span></span> <span data-ttu-id="36542-105">이 문서는 [Service Bus 큐를 사용하는 응용 프로그램 만들기](service-bus-create-queues.md)에서 제공한 정보를 바탕으로 하며 Service Bus 토픽에서 제공하는 게시/구독 기능을 소개합니다.</span><span class="sxs-lookup"><span data-stu-id="36542-105">This article builds on the information provided in [Create applications that use Service Bus queues](service-bus-create-queues.md) and offers an introduction to the publish/subscribe capabilities offered by Service Bus topics.</span></span>

## <a name="evolving-retail-scenario"></a><span data-ttu-id="36542-106">유통업 확장 시나리오</span><span class="sxs-lookup"><span data-stu-id="36542-106">Evolving retail scenario</span></span>
<span data-ttu-id="36542-107">이 문서에서는 [Service Bus 큐를 사용하는 응용 프로그램 만들기](service-bus-create-queues.md)에서 사용한 유통업 시나리오를 계속 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="36542-107">This article continues the retail scenario used in [Create applications that use Service Bus queues](service-bus-create-queues.md).</span></span> <span data-ttu-id="36542-108">개별 POS 터미널의 판매 데이터가 재고 관리 시스템으로 전달되어 재고 보충 시점을 판단하는 데 사용되는 상황을 다시 떠올려 보겠습니다.</span><span class="sxs-lookup"><span data-stu-id="36542-108">Recall that sales data from individual Point of Sale (POS) terminals must be routed to an inventory management system which uses that data to determine when stock has to be replenished.</span></span> <span data-ttu-id="36542-109">각 POS 터미널은 **DataCollectionQueue** 큐에 메시지를 보내 판매 데이터를 보고합니다. 아래와 같이 인벤토리 관리 시스템에서 수신할 때까지 이 큐에 남아 있게 됩니다.</span><span class="sxs-lookup"><span data-stu-id="36542-109">Each POS terminal reports its sales data by sending messages to the **DataCollectionQueue** queue, where they remain until they are received by the inventory management system, as shown here:</span></span>

![Service Bus 1](./media/service-bus-create-topics-subscriptions/IC657161.gif)

<span data-ttu-id="36542-111">이 시나리오를 확대하기 위해 새로운 요구 사항을 시스템에 추가했습니다. 즉 매장 소유자가 실시간으로 매장 운영을 모니터링하고자 합니다.</span><span class="sxs-lookup"><span data-stu-id="36542-111">To evolve this scenario, a new requirement has been added to the system: the store owner wants to be able to monitor how the store is performing in real time.</span></span>

<span data-ttu-id="36542-112">이 요구 사항에 부합하기 위해 시스템은 판매 데이터 스트림을 "해제"해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="36542-112">To address this requirement, the system must "tap" off the sales data stream.</span></span> <span data-ttu-id="36542-113">POS 터미널이 재고 관리 시스템에 보낸 각각의 메시지는 이전처럼 유지하고자 하지만 매장 소유자에게 대시보드 보기를 제시할 때 사용하기 위해 각 메시지의 다른 사본이 필요합니다.</span><span class="sxs-lookup"><span data-stu-id="36542-113">We still want each message sent by the POS terminals to be sent to the inventory management system as before, but we want another copy of each message that we can use to present the dashboard view to the store owner.</span></span>

<span data-ttu-id="36542-114">이와 같이 여러 대상이 각 메시지를 소비하는 모든 상황에서 Service Bus *토픽*을 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="36542-114">In any situation such as this, in which you require each message to be consumed by multiple parties, you can use Service Bus *topics*.</span></span> <span data-ttu-id="36542-115">토픽은 게시된 각 메시지를 토픽에 등록된 하나 이상의 구독에서 사용할 수 있게 하는 게시/구독 패턴을 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="36542-115">Topics provide a publish/subscribe pattern in which each published message is made available to one or more subscriptions registered with the topic.</span></span> <span data-ttu-id="36542-116">반면 큐에서는 각각의 메시지를 단일 소비자가 수신합니다.</span><span class="sxs-lookup"><span data-stu-id="36542-116">In contrast, with queues each message is received by a single consumer.</span></span>

<span data-ttu-id="36542-117">메시지는 큐로 보내질 때와 같은 방식으로 토픽에 전달됩니다.</span><span class="sxs-lookup"><span data-stu-id="36542-117">Messages are sent to a topic in the same way as they are sent to a queue.</span></span> <span data-ttu-id="36542-118">그러나 메시지가 토픽으로부터 직접 수신되는 것이 아니라 구독으로부터 수신됩니다.</span><span class="sxs-lookup"><span data-stu-id="36542-118">However, messages are not received from the topic directly; they are received from subscriptions.</span></span> <span data-ttu-id="36542-119">토픽 구독은 토픽에 전송된 메시지의 사본을 받는 가상 큐로 간주할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="36542-119">You can think of a subscription to a topic as a virtual queue that receives copies of the messages that are sent to that topic.</span></span> <span data-ttu-id="36542-120">메시지는 큐에서 수신하는 방식과 동일하게 구독에서 수신됩니다.</span><span class="sxs-lookup"><span data-stu-id="36542-120">Messages are received from a subscription the same way as they are received from a queue.</span></span>

<span data-ttu-id="36542-121">유통업 시나리오를 다시 생각해보면 큐를 토픽이 대체하며, 재고 관리 시스템 구성 요소에서 사용할 수 있는 구독을 추가할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="36542-121">Going back to the retail scenario, the queue is replaced by a topic, and a subscription is added, which the inventory management system component can use.</span></span> <span data-ttu-id="36542-122">이제 시스템은 다음과 같이 나타납니다.</span><span class="sxs-lookup"><span data-stu-id="36542-122">The system now appears as follows:</span></span>

![Service Bus 2](./media/service-bus-create-topics-subscriptions/IC657165.gif)

<span data-ttu-id="36542-124">여기서의 구성은 이전 큐 기반 디자인과 동일하게 수행됩니다.</span><span class="sxs-lookup"><span data-stu-id="36542-124">The configuration here performs identically to the previous queue-based design.</span></span> <span data-ttu-id="36542-125">즉, 토픽에 보내는 메시지가 **재고** 구독으로 전달되어 **인벤토리 관리 시스템**에서 이를 소비하게 됩니다.</span><span class="sxs-lookup"><span data-stu-id="36542-125">That is, messages sent to the topic are routed to the **Inventory** subscription, from which the **Inventory Management System** consumes them.</span></span>

<span data-ttu-id="36542-126">관리 대시보드를 지원하기 위해 다음과 같이 토픽에 두 번째 구독을 만듭니다.</span><span class="sxs-lookup"><span data-stu-id="36542-126">In order to support the management dashboard, we create a second subscription on the topic, as shown here:</span></span>

![Service Bus 3](./media/service-bus-create-topics-subscriptions/IC657166.gif)

<span data-ttu-id="36542-128">이 구성에서는 POS 터미널로부터의 각 메시지가 **대시보드** 및 **인벤토리** 구독에서 사용할 수 있게 됩니다.</span><span class="sxs-lookup"><span data-stu-id="36542-128">With this configuration, each message from the POS terminals is made available to both the **Dashboard** and **Inventory** subscriptions.</span></span>

## <a name="show-me-the-code"></a><span data-ttu-id="36542-129">코드 표시</span><span class="sxs-lookup"><span data-stu-id="36542-129">Show me the code</span></span>
<span data-ttu-id="36542-130">[Service Bus 큐를 사용하는 응용 프로그램 만들기](service-bus-create-queues.md)에서는 Azure 계정에 등록하고 서비스 네임스페이스를 만드는 방법을 설명합니다.</span><span class="sxs-lookup"><span data-stu-id="36542-130">The article [Create applications that use Service Bus queues](service-bus-create-queues.md) describes how to sign up for an Azure account and create a service namespace.</span></span> <span data-ttu-id="36542-131">Service Bus 종속성을 참조하는 가장 쉬운 방법은 Service Bus [Nuget 패키지](https://www.nuget.org/packages/WindowsAzure.ServiceBus/)를 설치하는 것입니다.</span><span class="sxs-lookup"><span data-stu-id="36542-131">The easiest way to reference Service Bus dependencies is to install the Service Bus [Nuget package](https://www.nuget.org/packages/WindowsAzure.ServiceBus/).</span></span> <span data-ttu-id="36542-132">또한 Azure SDK의 일부로 Service Bus 라이브러리를 찾을 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="36542-132">You can also find the Service Bus libraries as part of the Azure SDK.</span></span> <span data-ttu-id="36542-133">이 다운로드는 [Azure SDK 다운로드 페이지](https://azure.microsoft.com/downloads/)에서 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="36542-133">The download is available at the [Azure SDK download page](https://azure.microsoft.com/downloads/).</span></span>

### <a name="create-the-topic-and-subscriptions"></a><span data-ttu-id="36542-134">토픽 및 구독 만들기</span><span class="sxs-lookup"><span data-stu-id="36542-134">Create the topic and subscriptions</span></span>
<span data-ttu-id="36542-135">Service Bus 메시징 엔터티(큐 및 토픽 게시/구독)에 대한 관리 작업은 [NamespaceManager](/dotnet/api/microsoft.servicebus.namespacemanager#microsoft_servicebus_namespacemanager) 클래스를 통해 수행됩니다.</span><span class="sxs-lookup"><span data-stu-id="36542-135">Management operations for Service Bus messaging entities (queues and publish/subscribe topics) are performed via the [NamespaceManager](/dotnet/api/microsoft.servicebus.namespacemanager#microsoft_servicebus_namespacemanager) class.</span></span> <span data-ttu-id="36542-136">특정 네임스페이스에 대한 **NamespaceManager** 인스턴스를 만들려면 적합한 자격 증명이 필요합니다.</span><span class="sxs-lookup"><span data-stu-id="36542-136">Appropriate credentials are required in order to create a **NamespaceManager** instance for a particular namespace.</span></span> <span data-ttu-id="36542-137">Service Bus는 [SAS(공유 액세스 서명)](service-bus-sas.md) 기반 보안 모델을 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="36542-137">Service Bus uses a [Shared Access Signature (SAS)](service-bus-sas.md) based security model.</span></span> <span data-ttu-id="36542-138">[TokenProvider](/dotnet/api/microsoft.servicebus.tokenprovider#microsoft_servicebus_tokenprovider) 클래스는 잘 알려진 일부 토큰 공급자를 반환하는 기본 제공 팩터리 메서드를 사용하여 보안 토큰 공급자를 나타냅니다.</span><span class="sxs-lookup"><span data-stu-id="36542-138">The [TokenProvider](/dotnet/api/microsoft.servicebus.tokenprovider#microsoft_servicebus_tokenprovider) class represents a security token provider with built-in factory methods returning some well-known token providers.</span></span> <span data-ttu-id="36542-139">[CreateSharedAccessSignatureTokenProvider](/dotnet/api/microsoft.servicebus.tokenprovider#Microsoft_ServiceBus_TokenProvider_CreateSharedAccessSignatureTokenProvider_System_String_) 메서드를 사용하여 SAS 자격 증명을 유지할 것입니다.</span><span class="sxs-lookup"><span data-stu-id="36542-139">We’ll use a [CreateSharedAccessSignatureTokenProvider](/dotnet/api/microsoft.servicebus.tokenprovider#Microsoft_ServiceBus_TokenProvider_CreateSharedAccessSignatureTokenProvider_System_String_) method to hold the SAS credentials.</span></span> <span data-ttu-id="36542-140">그러면 Service Bus 네임스페이스와 토큰 공급자의 기본 주소를 통해 [NamespaceManager](/dotnet/api/microsoft.servicebus.namespacemanager#microsoft_servicebus_namespacemanager) 인스턴스가 생성됩니다.</span><span class="sxs-lookup"><span data-stu-id="36542-140">The [NamespaceManager](/dotnet/api/microsoft.servicebus.namespacemanager#microsoft_servicebus_namespacemanager) instance is then constructed with the base address of the Service Bus namespace and the token provider.</span></span>

<span data-ttu-id="36542-141">[NamespaceManager](/dotnet/api/microsoft.servicebus.namespacemanager#microsoft_servicebus_namespacemanager) 클래스는 메시징 엔터티를 만들고 열거 및 삭제하기 위한 메서드를 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="36542-141">The [NamespaceManager](/dotnet/api/microsoft.servicebus.namespacemanager#microsoft_servicebus_namespacemanager) class provides methods to create, enumerate and delete messaging entities.</span></span> <span data-ttu-id="36542-142">여기에 표시된 코드는 **NamespaceManager** 인스턴스를 생성하여 **DataCollectionTopic** 토픽을 만드는 데 사용하는 방법을 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="36542-142">The code that is shown here shows how the **NamespaceManager** instance is created and used to create the **DataCollectionTopic** topic.</span></span>

```csharp
Uri uri = ServiceBusEnvironment.CreateServiceUri("sb", "test-blog", string.Empty);
string name = "RootManageSharedAccessKey";
string key = "abcdefghijklmopqrstuvwxyz";

TokenProvider tokenProvider = TokenProvider.CreateSharedAccessSignatureTokenProvider(name, key);
NamespaceManager namespaceManager = new NamespaceManager(uri, tokenProvider);

namespaceManager.CreateTopic("DataCollectionTopic");
```

<span data-ttu-id="36542-143">토픽의 속성을 설정하도록 하는 [CreateTopic](/dotnet/api/microsoft.servicebus.namespacemanager#Microsoft_ServiceBus_NamespaceManager_CreateTopic_System_String_) 메서드의 오버로드가 있습니다.</span><span class="sxs-lookup"><span data-stu-id="36542-143">Note that there are overloads of the [CreateTopic](/dotnet/api/microsoft.servicebus.namespacemanager#Microsoft_ServiceBus_NamespaceManager_CreateTopic_System_String_) method that enable you to set properties of the topic.</span></span> <span data-ttu-id="36542-144">예를 들어, 토픽에 전송된 메시지에 적용할 기본 TTL(Time-to-Live) 값을 설정할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="36542-144">For example, you can set the default time-to-live (TTL) value for messages sent to the topic.</span></span> <span data-ttu-id="36542-145">다음으로 **인벤토리** 및 **대시보드** 구독을 추가합니다.</span><span class="sxs-lookup"><span data-stu-id="36542-145">Next, add the **Inventory** and **Dashboard** subscriptions.</span></span>

```csharp
namespaceManager.CreateSubscription("DataCollectionTopic", "Inventory");
namespaceManager.CreateSubscription("DataCollectionTopic", "Dashboard");
```

### <a name="send-messages-to-the-topic"></a><span data-ttu-id="36542-146">토픽에 메시지 보내기</span><span class="sxs-lookup"><span data-stu-id="36542-146">Send messages to the topic</span></span>
<span data-ttu-id="36542-147">Service Bus 엔터티의 런타임 작업(예: 메시지 송수신)을 위해서는 응용 프로그램이 먼저[MessagingFactory](/dotnet/api/microsoft.servicebus.messaging.messagingfactory#microsoft_servicebus_messaging_messagingfactory) 개체를 만들어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="36542-147">For run-time operations on Service Bus entities; for example, sending and receiving messages, an application must first create a [MessagingFactory](/dotnet/api/microsoft.servicebus.messaging.messagingfactory#microsoft_servicebus_messaging_messagingfactory) object.</span></span> <span data-ttu-id="36542-148">[NamespaceManager](/dotnet/api/microsoft.servicebus.namespacemanager#microsoft_servicebus_namespacemanager) 클래스와 유사하게 **MessagingFactory** 인스턴스는 서비스 네임스페이스와 토큰 공급자의 기본 주소로부터 생성됩니다.</span><span class="sxs-lookup"><span data-stu-id="36542-148">Similar to the [NamespaceManager](/dotnet/api/microsoft.servicebus.namespacemanager#microsoft_servicebus_namespacemanager) class, the **MessagingFactory** instance is created from the base address of the service namespace and the token provider.</span></span>

```
MessagingFactory factory = MessagingFactory.Create(uri, tokenProvider);
```

<span data-ttu-id="36542-149">Service Bus 토픽으로 보내고 받은 메시지는 [BrokeredMessage](/dotnet/api/microsoft.servicebus.messaging.brokeredmessage) 클래스 인스턴스입니다.</span><span class="sxs-lookup"><span data-stu-id="36542-149">Messages sent to and received from Service Bus topics, are instances of the [BrokeredMessage](/dotnet/api/microsoft.servicebus.messaging.brokeredmessage) class.</span></span> <span data-ttu-id="36542-150">이 클래스에는 표준 속성 집합(예: [Label](/dotnet/api/microsoft.servicebus.messaging.brokeredmessage.label?view=azureservicebus-4.0.0#Microsoft_ServiceBus_Messaging_BrokeredMessage_Label) 및 [TimeToLive](/dotnet/api/microsoft.servicebus.messaging.brokeredmessage.timetolive?view=azureservicebus-4.0.0#Microsoft_ServiceBus_Messaging_BrokeredMessage_TimeToLive)), 응용 프로그램 속성을 저장하는 데 사용되는 사전 및 임의 응용 프로그램 데이터 본문이 있습니다.</span><span class="sxs-lookup"><span data-stu-id="36542-150">This class consists of a set of standard properties (such as [Label](/dotnet/api/microsoft.servicebus.messaging.brokeredmessage.label?view=azureservicebus-4.0.0#Microsoft_ServiceBus_Messaging_BrokeredMessage_Label) and [TimeToLive](/dotnet/api/microsoft.servicebus.messaging.brokeredmessage.timetolive?view=azureservicebus-4.0.0#Microsoft_ServiceBus_Messaging_BrokeredMessage_TimeToLive)), a dictionary that is used to hold application properties, and a body of arbitrary application data.</span></span> <span data-ttu-id="36542-151">응용 프로그램은 직렬화된 개체를 전달하여 본문을 설정할 수 있습니다(다음 예에서는 POS 터미널의 판매 데이터를 나타내는 **SalesData** 개체를 전달함). 개체 직렬화에는 [DataContractSerializer](https://msdn.microsoft.com/library/system.runtime.serialization.datacontractserializer.aspx)를 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="36542-151">An application can set the body by passing in any serializable object (the following example passes in a **SalesData** object that represents the sales data from the POS terminal), which will use the [DataContractSerializer](https://msdn.microsoft.com/library/system.runtime.serialization.datacontractserializer.aspx) to serialize the object.</span></span> <span data-ttu-id="36542-152">또는 [스트림](https://msdn.microsoft.com/library/system.io.stream.aspx) 개체를 제공할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="36542-152">Alternatively, a [Stream](https://msdn.microsoft.com/library/system.io.stream.aspx) object can be provided.</span></span>

```csharp
BrokeredMessage bm = new BrokeredMessage(salesData);
bm.Label = "SalesReport";
bm.Properties["StoreName"] = "Redmond";
bm.Properties["MachineID"] = "POS_1";
```

<span data-ttu-id="36542-153">토픽에 메시지를 보내는 가장 쉬운 방법은 [CreateMessageSender](/dotnet/api/microsoft.servicebus.messaging.messagingfactory#Microsoft_ServiceBus_Messaging_MessagingFactory_CreateMessageSender_System_String_)를 사용하여 [MessagingFactory](/dotnet/api/microsoft.servicebus.messaging.messagingfactory) 인스턴스에서 직접 [MessageSender](/dotnet/api/microsoft.servicebus.messaging.messagesender) 개체를 만드는 것입니다.</span><span class="sxs-lookup"><span data-stu-id="36542-153">The easiest way to send messages to the topic is to use [CreateMessageSender](/dotnet/api/microsoft.servicebus.messaging.messagingfactory#Microsoft_ServiceBus_Messaging_MessagingFactory_CreateMessageSender_System_String_) to create a [MessageSender](/dotnet/api/microsoft.servicebus.messaging.messagesender) object directly from the [MessagingFactory](/dotnet/api/microsoft.servicebus.messaging.messagingfactory) instance:</span></span>

```csharp
MessageSender sender = factory.CreateMessageSender("DataCollectionTopic");
sender.Send(bm);
```

### <a name="receive-messages-from-a-subscription"></a><span data-ttu-id="36542-154">구독에서 메시지 받기</span><span class="sxs-lookup"><span data-stu-id="36542-154">Receive messages from a subscription</span></span>
<span data-ttu-id="36542-155">큐 사용과 유사하게, 구독에서 메시지를 수신하기 위해 [CreateMessageReceiver](/dotnet/api/microsoft.servicebus.messaging.messagingfactory#Microsoft_ServiceBus_Messaging_MessagingFactory_CreateMessageReceiver_System_String_)를 사용하여 [MessagingFactory](/dotnet/api/microsoft.servicebus.messaging.messagingfactory)로부터 직접 만든 [MessageReceiver](/dotnet/api/microsoft.servicebus.messaging.messagereceiver) 개체를 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="36542-155">Similar to using queues, to receive messages from a subscription you can use a [MessageReceiver](/dotnet/api/microsoft.servicebus.messaging.messagereceiver) object which you create directly from the [MessagingFactory](/dotnet/api/microsoft.servicebus.messaging.messagingfactory) using [CreateMessageReceiver](/dotnet/api/microsoft.servicebus.messaging.messagingfactory#Microsoft_ServiceBus_Messaging_MessagingFactory_CreateMessageReceiver_System_String_).</span></span> <span data-ttu-id="36542-156">[Service Bus 큐를 사용하는 응용 프로그램 만들기](service-bus-create-queues.md)에서 설명한 것처럼 두 가지 수신 모드(**ReceiveAndDelete** 및 **PeekLock**) 중 하나를 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="36542-156">You can use one of the two different receive modes (**ReceiveAndDelete** and **PeekLock**), as discussed in [Create applications that use Service Bus queues](service-bus-create-queues.md).</span></span>

<span data-ttu-id="36542-157">구독에 대해 **MessageReceiver**를 만들 경우 *entityPath* 매개 변수는 `topicPath/subscriptions/subscriptionName` 형태입니다.</span><span class="sxs-lookup"><span data-stu-id="36542-157">Note that when you create a **MessageReceiver** for subscriptions, the *entityPath* parameter is of the form `topicPath/subscriptions/subscriptionName`.</span></span> <span data-ttu-id="36542-158">따라서 **DataCollectionTopic** 토픽의 **인벤토리** 구독에 대해 **MessageReceiver**를 만들려면 *entityPath*를 `DataCollectionTopic/subscriptions/Inventory`로 설정해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="36542-158">Therefore, to create a **MessageReceiver** for the **Inventory** subscription of the **DataCollectionTopic** topic, *entityPath* must be set to `DataCollectionTopic/subscriptions/Inventory`.</span></span> <span data-ttu-id="36542-159">코드는 다음과 같이 나타납니다.</span><span class="sxs-lookup"><span data-stu-id="36542-159">The code appears as follows:</span></span>

```csharp
MessageReceiver receiver = factory.CreateMessageReceiver("DataCollectionTopic/subscriptions/Inventory");
BrokeredMessage receivedMessage = receiver.Receive();
try
{
    ProcessMessage(receivedMessage);
    receivedMessage.Complete();
}
catch (Exception e)
{
    receivedMessage.Abandon();
}
```

## <a name="subscription-filters"></a><span data-ttu-id="36542-160">구독 필터</span><span class="sxs-lookup"><span data-stu-id="36542-160">Subscription filters</span></span>
<span data-ttu-id="36542-161">지금까지 이 시나리오에서는 토픽에 보낸 모든 메시지를 모든 등록된 구독에서 사용할 수 있었습니다.</span><span class="sxs-lookup"><span data-stu-id="36542-161">So far, in this scenario all messages sent to the topic are made available to all registered subscriptions.</span></span> <span data-ttu-id="36542-162">여기서 핵심은 "사용할 수 있다"는 것입니다.</span><span class="sxs-lookup"><span data-stu-id="36542-162">The key phrase here is "made available."</span></span> <span data-ttu-id="36542-163">Service Bus 구독이 토픽으로 전송된 모든 메시지를 확인하는 동안 가상 구독 큐로 이러한 메시지의 하위 집합을 복사할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="36542-163">While Service Bus subscriptions see all messages sent to the topic, you can copy only a subset of those messages to the virtual subscription queue.</span></span> <span data-ttu-id="36542-164">이 작업은 구독 *필터*를 사용하여 수행합니다.</span><span class="sxs-lookup"><span data-stu-id="36542-164">This is performed using subscription *filters*.</span></span> <span data-ttu-id="36542-165">구독을 만들 때 메시지 속성(예: [Label](/dotnet/api/microsoft.servicebus.messaging.brokeredmessage#Microsoft_ServiceBus_Messaging_BrokeredMessage_Label))과 응용 프로그램 속성(예: 이전 예제에서의 **StoreName**)에 모두 적용되는 SQL92 스타일 조건자 형태로 필터 식을 제공할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="36542-165">When you create a subscription, you can supply a filter expression in the form of a SQL92 style predicate that operates over the properties of the message, both the system properties (for example, [Label](/dotnet/api/microsoft.servicebus.messaging.brokeredmessage#Microsoft_ServiceBus_Messaging_BrokeredMessage_Label)) and the application properties, such as **StoreName** in the previous example.</span></span>

<span data-ttu-id="36542-166">이를 설명하기 위해 시나리오를 확장해 보겠습니다. 즉 두 번째 매장을 유통업 시나리오에 추가합니다.</span><span class="sxs-lookup"><span data-stu-id="36542-166">Evolving the scenario to illustrate this, a second store is to be added to our retail scenario.</span></span> <span data-ttu-id="36542-167">여전히 두 매장의 모든 POS 터미널에서 판매 데이터를 중앙 집중식 재고 관리 시스템에 전달해야 하지만 대시보드 도구를 사용하는 매장 관리자는 해당 매장의 성과에만 관심이 있습니다.  </span><span class="sxs-lookup"><span data-stu-id="36542-167">Sales data from all of the POS terminals from both stores still have to be routed to the centralized inventory management system, but a store manager using the dashboard tool is only interested in the performance of that store.</span></span> <span data-ttu-id="36542-168">이를 위해 구독 필터링을 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="36542-168">You can use subscription filtering to achieve this.</span></span> <span data-ttu-id="36542-169">POS 터미널이 메시지를 게시할 때는 메시지에 대해 **StoreName** 응용 프로그램 속성을 설정합니다.</span><span class="sxs-lookup"><span data-stu-id="36542-169">Note that when the POS terminals publish messages, they set the **StoreName** application property on the message.</span></span> <span data-ttu-id="36542-170">두 매장이 **레드몬드**와 **시애틀**이라고 하면 레드몬드 매장의 POS 터미널은 판매 데이터 메시지에 **StoreName**을 **Redmond**라고 표시하며 시애틀 매장의 POS 터미널은 **StoreName**을 **Seattle**이라고 표시합니다.</span><span class="sxs-lookup"><span data-stu-id="36542-170">Given two stores, for example **Redmond** and **Seattle**, the POS terminals in the Redmond store stamp their sales data messages with a **StoreName** equal to **Redmond**, whereas the Seattle store POS terminals use a **StoreName** equal to **Seattle**.</span></span> <span data-ttu-id="36542-171">Redmond 매장의 매장 관리자는 자신의 POS 터미널의 데이터만 보고자 합니다.</span><span class="sxs-lookup"><span data-stu-id="36542-171">The store manager of the Redmond store only wants to see data from its POS terminals.</span></span> <span data-ttu-id="36542-172">시스템은 다음과 같이 나타납니다.</span><span class="sxs-lookup"><span data-stu-id="36542-172">The system appears as follows:</span></span>

![Service-Bus4](./media/service-bus-create-topics-subscriptions/IC657167.gif)

<span data-ttu-id="36542-174">이 전달을 설정하기 위해 다음과 같이 **대시보드** 구독을 만듭니다.</span><span class="sxs-lookup"><span data-stu-id="36542-174">To set up this routing, you create the **Dashboard** subscription as follows:</span></span>

```csharp
SqlFilter dashboardFilter = new SqlFilter("StoreName = 'Redmond'");
namespaceManager.CreateSubscription("DataCollectionTopic", "Dashboard", dashboardFilter);
```

<span data-ttu-id="36542-175">이 [구독 필터](/dotnet/api/microsoft.servicebus.messaging.sqlfilter)를 사용하면 **StoreName** 속성이 **Redmond**로 설정된 메시지만 **대시보드** 구독의 가상 큐에 복사됩니다.</span><span class="sxs-lookup"><span data-stu-id="36542-175">With this [subscription filter](/dotnet/api/microsoft.servicebus.messaging.sqlfilter), only messages that have the **StoreName** property set to **Redmond** will be copied to the virtual queue for the **Dashboard** subscription.</span></span> <span data-ttu-id="36542-176">이 밖에도 구독 필터링에는 여러 기능이 있습니다.</span><span class="sxs-lookup"><span data-stu-id="36542-176">There is much more to subscription filtering, however.</span></span> <span data-ttu-id="36542-177">응용 프로그램은 구독의 가상 큐에 전달되는 메시지 속성을 수정할 수 있을 뿐 아니라 구독마다 여러 필터링 규칙을 적용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="36542-177">Applications can have multiple filter rules per subscription in addition to the ability to modify the properties of a message as it passes to a subscription's virtual queue.</span></span>

## <a name="summary"></a><span data-ttu-id="36542-178">요약</span><span class="sxs-lookup"><span data-stu-id="36542-178">Summary</span></span>
<span data-ttu-id="36542-179">[Service Bus 큐를 사용하는 응용 프로그램 만들기](service-bus-create-queues.md)에서 설명한 큐를 사용하는 모든 이유가 토픽에도 적용됩니다. 특히 다음 내용이 그렇습니다.</span><span class="sxs-lookup"><span data-stu-id="36542-179">All of the reasons to use queuing described in [Create applications that use Service Bus queues](service-bus-create-queues.md) also apply to topics, specifically:</span></span>

* <span data-ttu-id="36542-180">임시 분리 - 메시지 생산자와 소비자가 동시에 온라인 상태가 아니어도 됩니다.</span><span class="sxs-lookup"><span data-stu-id="36542-180">Temporal decoupling – message producers and consumers do not have to be online at the same time.</span></span>
* <span data-ttu-id="36542-181">부하 평준화 – 토픽을 통해 소비 응용 프로그램이 최대 부하 대신 평균 부하를 프로비저닝할 수 있으므로 부하의 최대치가 완화됩니다.</span><span class="sxs-lookup"><span data-stu-id="36542-181">Load leveling – peaks in load are smoothed out by the topic enabling consuming applications to be provisioned for average load instead of peak load.</span></span>
* <span data-ttu-id="36542-182">부하 분산 – 큐와 유사하게, 단일 구독에 대해 여러 소비자가 경쟁적으로 수신 대기할 수 있습니다. 각 메시지는 소비자 중 하나에게만 전달되므로 부하가 분산됩니다.</span><span class="sxs-lookup"><span data-stu-id="36542-182">Load balancing – similar to a queue, you can have multiple competing consumers listening on a single subscription, with each message handed off to only one of the consumers, thereby balancing load.</span></span>
* <span data-ttu-id="36542-183">느슨한 결합 – 기존 끝점에 미치는 영향 없이 메시징 네트워크를 확장할 수 있습니다. 예를 들어, 토픽에 대한 구독을 추가하거나 필터를 변경하여 새 소비자를 허용합니다.</span><span class="sxs-lookup"><span data-stu-id="36542-183">Loose coupling – you can evolve the messaging network without affecting existing endpoints; for example, adding subscriptions or changing filters to a topic to allow for new consumers.</span></span>

## <a name="next-steps"></a><span data-ttu-id="36542-184">다음 단계</span><span class="sxs-lookup"><span data-stu-id="36542-184">Next steps</span></span>

<span data-ttu-id="36542-185">POS 유통업 시나리오에서 큐를 사용하는 방법에 대한 정보는 [Service Bus 큐를 사용하는 응용 프로그램 만들기](service-bus-create-queues.md)를 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="36542-185">See [Create applications that use Service Bus queues](service-bus-create-queues.md) for information about how to use queues in the POS retail scenario.</span></span>

