---
title: "aaaAzure 서비스 버스 네임 스페이스 쌍이 | Microsoft Docs"
description: "쌍을 이루는 네임스페이스 구현의 세부 사항 및 비용"
services: service-bus-messaging
documentationcenter: na
author: sethmanheim
manager: timlt
editor: 
ms.assetid: 2440c8d3-ed2e-47e0-93cf-ab7fbb855d2e
ms.service: service-bus-messaging
ms.devlang: na
ms.topic: article
ms.tgt_pltfrm: na
ms.workload: na
ms.date: 05/25/2017
ms.author: sethm
ms.openlocfilehash: 4c44b2b95d2228e1ad8075b52634d88a1593d3b1
ms.sourcegitcommit: 523283cc1b3c37c428e77850964dc1c33742c5f0
ms.translationtype: MT
ms.contentlocale: ko-KR
ms.lasthandoff: 10/06/2017
---
# <a name="paired-namespace-implementation-details-and-cost-implications"></a><span data-ttu-id="3a28f-103">쌍을 이루는 네임스페이스 구현의 세부 사항 및 비용의 영향</span><span class="sxs-lookup"><span data-stu-id="3a28f-103">Paired namespace implementation details and cost implications</span></span>
<span data-ttu-id="3a28f-104">hello [PairNamespaceAsync] [ PairNamespaceAsync] 메서드를 사용 하는 [SendAvailabilityPairedNamespaceOptions] [ SendAvailabilityPairedNamespaceOptions] 인스턴스를 표시 하는 작업을 수행 사용자 대신 합니다.</span><span class="sxs-lookup"><span data-stu-id="3a28f-104">hello [PairNamespaceAsync][PairNamespaceAsync] method, using a [SendAvailabilityPairedNamespaceOptions][SendAvailabilityPairedNamespaceOptions] instance, performs visible tasks on your behalf.</span></span> <span data-ttu-id="3a28f-105">Hello 기능을 사용할 때 고려 사항 비용이 며, 되므로 유용 toounderstand 작업 수행 되는 경우 hello 동작을 예상할 수 있도록 합니다.</span><span class="sxs-lookup"><span data-stu-id="3a28f-105">Because there are cost considerations when using hello feature, it is useful toounderstand those tasks so that you expect hello behavior when it happens.</span></span> <span data-ttu-id="3a28f-106">hello API에서 사용자 대신 자동 동작을 수행 하는 hello 맞물릴 때:</span><span class="sxs-lookup"><span data-stu-id="3a28f-106">hello API engages hello following automatic behavior on your behalf:</span></span>

* <span data-ttu-id="3a28f-107">백로그 큐를 만듭니다.</span><span class="sxs-lookup"><span data-stu-id="3a28f-107">Creation of backlog queues.</span></span>
* <span data-ttu-id="3a28f-108">만들기는 [MessageSender] [ MessageSender] tooqueues 또는 항목을 설명 하는 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="3a28f-108">Creation of a [MessageSender][MessageSender] object that talks tooqueues or topics.</span></span>
* <span data-ttu-id="3a28f-109">메시징 엔터티를 사용할 수 없을 때 ping 경우 메시지를 전송 toohello 엔터티 시도 toodetect에서 해당 엔터티를 다시 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="3a28f-109">When a messaging entity becomes unavailable, sends ping messages toohello entity in an attempt toodetect when that entity becomes available again.</span></span>
* <span data-ttu-id="3a28f-110">"메시지 펌프" 집합의 메시지에서 이동 hello 백로그 큐 toohello 기본 큐를 만듭니다 필요에 따라.</span><span class="sxs-lookup"><span data-stu-id="3a28f-110">Optionally creates of a set of “message pumps” that move messages from hello backlog queues toohello primary queues.</span></span>
* <span data-ttu-id="3a28f-111">기본 및 보조 hello 닫기/오류 조정 [MessagingFactory] [ MessagingFactory] 인스턴스.</span><span class="sxs-lookup"><span data-stu-id="3a28f-111">Coordinates closing/faulting of hello primary and secondary [MessagingFactory][MessagingFactory] instances.</span></span>

<span data-ttu-id="3a28f-112">상위 수준 hello 기능은 다음과 같습니다: hello 주 엔터티가 정상 상태 이면 없는 동작이 변경 될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="3a28f-112">At a high level, hello feature works as follows: when hello primary entity is healthy, no behavior changes occur.</span></span> <span data-ttu-id="3a28f-113">Hello 때 [FailoverInterval] [ FailoverInterval] 기간이 경과 되 고 hello 주 엔터티는 일시적이 지 않은 후 없습니다 성공적인 보냅니다 표시 [MessagingException] [ MessagingException] 또는 [TimeoutException][TimeoutException], hello 다음 동작이 발생 합니다.</span><span class="sxs-lookup"><span data-stu-id="3a28f-113">When hello [FailoverInterval][FailoverInterval] duration elapses, and hello primary entity sees no successful sends after a non-transient [MessagingException][MessagingException] or a [TimeoutException][TimeoutException], hello following behavior occurs:</span></span>

1. <span data-ttu-id="3a28f-114">주 엔터티 해제 되 고 hello 시스템 ping hello 기본 엔터티에 ping를 성공적으로 전달 될 때까지 작업 toohello를 보냅니다.</span><span class="sxs-lookup"><span data-stu-id="3a28f-114">Send operations toohello primary entity are disabled and hello system pings hello primary entity until pings can be successfully delivered.</span></span>
2. <span data-ttu-id="3a28f-115">임의 백로그 큐가 선택됩니다.</span><span class="sxs-lookup"><span data-stu-id="3a28f-115">A random backlog queue is selected.</span></span>
3. <span data-ttu-id="3a28f-116">[BrokeredMessage] [ BrokeredMessage] 개체는 라우트된 toohello 백로그 큐를 선택 합니다.</span><span class="sxs-lookup"><span data-stu-id="3a28f-116">[BrokeredMessage][BrokeredMessage] objects are routed toohello chosen backlog queue.</span></span>
4. <span data-ttu-id="3a28f-117">선택한 백로그 큐는 송신 작업 toohello 실패 하면 해당 큐 hello 순환에서 끌어온 하 고 새 큐를 선택 합니다.</span><span class="sxs-lookup"><span data-stu-id="3a28f-117">If a send operation toohello chosen backlog queue fails, that queue is pulled from hello rotation and a new queue is selected.</span></span> <span data-ttu-id="3a28f-118">Hello에 대 한 보낸 사람 모두 [MessagingFactory] [ MessagingFactory] hello 오류의 인스턴스에 알아봅니다.</span><span class="sxs-lookup"><span data-stu-id="3a28f-118">All senders on hello [MessagingFactory][MessagingFactory] instance learn of hello failure.</span></span>

<span data-ttu-id="3a28f-119">다음 수치 hello hello 순서를 나타냅니다.</span><span class="sxs-lookup"><span data-stu-id="3a28f-119">hello following figures depict hello sequence.</span></span> <span data-ttu-id="3a28f-120">첫째, hello 보낸 메시지를 보냅니다.</span><span class="sxs-lookup"><span data-stu-id="3a28f-120">First, hello sender sends messages.</span></span>

![쌍을 이루는 네임스페이스][0]

<span data-ttu-id="3a28f-122">오류 toosend toohello 기본 큐, 시 hello 보낸 사람 메시지 tooa 임의로 선택 백로그 큐를 보내기 시작 합니다.</span><span class="sxs-lookup"><span data-stu-id="3a28f-122">Upon failure toosend toohello primary queue, hello sender begins sending messages tooa randomly chosen backlog queue.</span></span> <span data-ttu-id="3a28f-123">동시에 Ping 작업을 시작합니다.</span><span class="sxs-lookup"><span data-stu-id="3a28f-123">Simultaneously, it starts a ping task.</span></span>

![쌍을 이루는 네임스페이스][1]

<span data-ttu-id="3a28f-125">이 시점에서 hello 메시지 hello 보조 큐에는 이며 toohello 기본 큐 배달 되지 않은.</span><span class="sxs-lookup"><span data-stu-id="3a28f-125">At this point hello messages are still in hello secondary queue and have not been delivered toohello primary queue.</span></span> <span data-ttu-id="3a28f-126">기본 큐 hello 다시 정상 상태가 되 면 프로세스 하나 이상 hello 사이 펀을 실행 합니다.</span><span class="sxs-lookup"><span data-stu-id="3a28f-126">Once hello primary queue is healthy again, at least one process should be running hello syphon.</span></span> <span data-ttu-id="3a28f-127">hello 사이 펀 hello 메시지 배달 모든 hello 다양 한 백로그에서 큐 toohello 적절 한 대상 엔터티 (큐 및 토픽).</span><span class="sxs-lookup"><span data-stu-id="3a28f-127">hello syphon delivers hello messages from all hello various backlog queues toohello proper destination entities (queues and topics).</span></span>

![쌍을 이루는 네임스페이스][2]

<span data-ttu-id="3a28f-129">이 항목의 나머지 부분에서는 hello hello 세부 사항 이러한 각 작업이 작동 하는 방법을 설명 합니다.</span><span class="sxs-lookup"><span data-stu-id="3a28f-129">hello remainder of this topic discusses hello specific details of how these pieces work.</span></span>

## <a name="creation-of-backlog-queues"></a><span data-ttu-id="3a28f-130">백로그 큐 만들기</span><span class="sxs-lookup"><span data-stu-id="3a28f-130">Creation of backlog queues</span></span>
<span data-ttu-id="3a28f-131">hello [SendAvailabilityPairedNamespaceOptions] [ SendAvailabilityPairedNamespaceOptions] toohello 전달 된 개체가 [PairNamespaceAsync] [ PairNamespaceAsync] 메서드 hello를 나타냅니다. 백로그의 수를 큐 대기 하면 toouse 원하는 합니다.</span><span class="sxs-lookup"><span data-stu-id="3a28f-131">hello [SendAvailabilityPairedNamespaceOptions][SendAvailabilityPairedNamespaceOptions] object passed toohello [PairNamespaceAsync][PairNamespaceAsync] method indicates hello number of backlog queues you want toouse.</span></span> <span data-ttu-id="3a28f-132">각 백로그 큐는 hello를 사용 하 여 만든 후 다음 속성이 명시적으로 설정 됩니다 (다른 모든 값 toohello 설정 [QueueDescription] [ QueueDescription] 기본값):</span><span class="sxs-lookup"><span data-stu-id="3a28f-132">Each backlog queue is then created with hello following properties explicitly set (all other values are set toohello [QueueDescription][QueueDescription] defaults):</span></span>

| <span data-ttu-id="3a28f-133">Path</span><span class="sxs-lookup"><span data-stu-id="3a28f-133">Path</span></span> | <span data-ttu-id="3a28f-134">[기본 네임스페이스]/x-servicebus-transfer/[index] 여기서 [index]는 [0, BacklogQueueCount] 사이의 값입니다.</span><span class="sxs-lookup"><span data-stu-id="3a28f-134">[primary namespace]/x-servicebus-transfer/[index] where [index] is a value in [0, BacklogQueueCount)</span></span> |
| --- | --- |
| <span data-ttu-id="3a28f-135">MaxSizeInMegabytes</span><span class="sxs-lookup"><span data-stu-id="3a28f-135">MaxSizeInMegabytes</span></span> |<span data-ttu-id="3a28f-136">5120</span><span class="sxs-lookup"><span data-stu-id="3a28f-136">5120</span></span> |
| <span data-ttu-id="3a28f-137">MaxDeliveryCount</span><span class="sxs-lookup"><span data-stu-id="3a28f-137">MaxDeliveryCount</span></span> |<span data-ttu-id="3a28f-138">int.MaxValue</span><span class="sxs-lookup"><span data-stu-id="3a28f-138">int.MaxValue</span></span> |
| <span data-ttu-id="3a28f-139">DefaultMessageTimeToLive</span><span class="sxs-lookup"><span data-stu-id="3a28f-139">DefaultMessageTimeToLive</span></span> |<span data-ttu-id="3a28f-140">TimeSpan.MaxValue</span><span class="sxs-lookup"><span data-stu-id="3a28f-140">TimeSpan.MaxValue</span></span> |
| <span data-ttu-id="3a28f-141">AutoDeleteOnIdle</span><span class="sxs-lookup"><span data-stu-id="3a28f-141">AutoDeleteOnIdle</span></span> |<span data-ttu-id="3a28f-142">TimeSpan.MaxValue</span><span class="sxs-lookup"><span data-stu-id="3a28f-142">TimeSpan.MaxValue</span></span> |
| <span data-ttu-id="3a28f-143">LockDuration</span><span class="sxs-lookup"><span data-stu-id="3a28f-143">LockDuration</span></span> |<span data-ttu-id="3a28f-144">1분</span><span class="sxs-lookup"><span data-stu-id="3a28f-144">1 minute</span></span> |
| <span data-ttu-id="3a28f-145">EnableDeadLetteringOnMessageExpiration</span><span class="sxs-lookup"><span data-stu-id="3a28f-145">EnableDeadLetteringOnMessageExpiration</span></span> |<span data-ttu-id="3a28f-146">true</span><span class="sxs-lookup"><span data-stu-id="3a28f-146">true</span></span> |
| <span data-ttu-id="3a28f-147">EnableBatchedOperations</span><span class="sxs-lookup"><span data-stu-id="3a28f-147">EnableBatchedOperations</span></span> |<span data-ttu-id="3a28f-148">true</span><span class="sxs-lookup"><span data-stu-id="3a28f-148">true</span></span> |

<span data-ttu-id="3a28f-149">네임 스페이스에 대 한 첫 번째 백로그 큐 hello 생성 하는 예를 들어 **contoso** 라는 `contoso/x-servicebus-transfer/0`합니다.</span><span class="sxs-lookup"><span data-stu-id="3a28f-149">For example, hello first backlog queue created for namespace **contoso** is named `contoso/x-servicebus-transfer/0`.</span></span>

<span data-ttu-id="3a28f-150">Hello 큐를 만들 때 해당 큐가 있으면 hello 코드는 먼저 toosee를 확인 합니다.</span><span class="sxs-lookup"><span data-stu-id="3a28f-150">When creating hello queues, hello code first checks toosee if such a queue exists.</span></span> <span data-ttu-id="3a28f-151">Hello 큐가 없는 경우 hello 큐가 만들어집니다.</span><span class="sxs-lookup"><span data-stu-id="3a28f-151">If hello queue does not exist, then hello queue is created.</span></span> <span data-ttu-id="3a28f-152">hello 코드는 그렇지 않습니다 "추가" 백로그 큐를 정리 합니다.</span><span class="sxs-lookup"><span data-stu-id="3a28f-152">hello code does not clean up "extra" backlog queues.</span></span> <span data-ttu-id="3a28f-153">응용 프로그램을 기본 네임 스페이스 hello 경우 hello, 특히 **contoso** 백로그 큐 5 개 하지만 hello 경로로 백로그 큐 요청 `contoso/x-servicebus-transfer/7` 있는 경우 해당 추가 백로그 큐는 남아 있지만 사용 되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="3a28f-153">Specifically, if hello application with hello primary namespace **contoso** requests five backlog queues but a backlog queue with hello path `contoso/x-servicebus-transfer/7` exists, that extra backlog queue is still present but is not used.</span></span> <span data-ttu-id="3a28f-154">hello 시스템에서 사용 되지 않는 추가 백로그 큐 tooexist 명시적으로 허용 합니다.</span><span class="sxs-lookup"><span data-stu-id="3a28f-154">hello system explicitly allows extra backlog queues tooexist that would not be used.</span></span> <span data-ttu-id="3a28f-155">Hello 네임 스페이스 소유자는 사용 하지 않는/원치 않는 백로그 큐를 정리 됩니다.</span><span class="sxs-lookup"><span data-stu-id="3a28f-155">As hello namespace owner, you are responsible for cleaning up any unused/unwanted backlog queues.</span></span> <span data-ttu-id="3a28f-156">hello이이 결정은 서비스 버스 네임 스페이스에서 모든 hello 큐에 대 한 용도 존재 알 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="3a28f-156">hello reason for this decision is that Service Bus cannot know what purposes exist for all hello queues in your namespace.</span></span> <span data-ttu-id="3a28f-157">또한 큐 hello 지정 된 이름의 있지만 가정 hello에 맞지 않는 경우 [QueueDescription][QueueDescription], 이유는 hello 기본 동작에 대 한 직접 변경 합니다.</span><span class="sxs-lookup"><span data-stu-id="3a28f-157">Furthermore, if a queue exists with hello given name but does not meet hello assumed [QueueDescription][QueueDescription], then your reasons are your own for changing hello default behavior.</span></span> <span data-ttu-id="3a28f-158">가 보장 되지 수정 toohello 백로그 큐에 대 한 코드에서 만들어진입니다.</span><span class="sxs-lookup"><span data-stu-id="3a28f-158">No guarantees are made for modifications toohello backlog queues by your code.</span></span> <span data-ttu-id="3a28f-159">있는지 tootest 변경 내용을 철저 하 게 확인 합니다.</span><span class="sxs-lookup"><span data-stu-id="3a28f-159">Make sure tootest your changes thoroughly.</span></span>

## <a name="custom-messagesender"></a><span data-ttu-id="3a28f-160">사용자 지정 MessageSender</span><span class="sxs-lookup"><span data-stu-id="3a28f-160">Custom MessageSender</span></span>
<span data-ttu-id="3a28f-161">전송할 때, 모든 메시지가 통과 내부 [MessageSender] [ MessageSender] 작동 모든 항목 및 작업 "을 중단 합니다." 때 toohello 백로그 큐를 리디렉션하는 정상적으로 작동 하는 개체</span><span class="sxs-lookup"><span data-stu-id="3a28f-161">When sending, all messages go through an internal [MessageSender][MessageSender] object that behaves normally when everything works, and redirects toohello backlog queues when things "break."</span></span> <span data-ttu-id="3a28f-162">일시적이지 않은 오류가 발생할 경우 타이머가 시작됩니다.</span><span class="sxs-lookup"><span data-stu-id="3a28f-162">Upon receiving a non-transient failure, a timer starts.</span></span> <span data-ttu-id="3a28f-163">이후에 [TimeSpan] [ TimeSpan] hello로 구성 된 기간 [FailoverInterval] [ FailoverInterval] 성공 메시지가 전송 되는 속성 값 참여 하는 hello 장애 조치 합니다.</span><span class="sxs-lookup"><span data-stu-id="3a28f-163">After a [TimeSpan][TimeSpan] period consisting of hello [FailoverInterval][FailoverInterval] property value during which no successful messages are sent, hello failover is engaged.</span></span> <span data-ttu-id="3a28f-164">이 시점에서 hello 다음 작업이 수행 각 엔터티에 대해:</span><span class="sxs-lookup"><span data-stu-id="3a28f-164">At this point, hello following things happen for each entity:</span></span>

* <span data-ttu-id="3a28f-165">Ping 작업이 실행 마다 [PingPrimaryInterval] [ PingPrimaryInterval] toocheck hello 엔터티가 사용할 수 있는 경우.</span><span class="sxs-lookup"><span data-stu-id="3a28f-165">A ping task executes every [PingPrimaryInterval][PingPrimaryInterval] toocheck if hello entity is available.</span></span> <span data-ttu-id="3a28f-166">이 작업이 성공 하면 즉시 hello 엔터티를 사용 하는 모든 클라이언트 코드는 새 메시지 toohello 기본 네임 스페이스를 보내기 시작 합니다.</span><span class="sxs-lookup"><span data-stu-id="3a28f-166">Once this task succeeds, all client code that uses hello entity immediately starts sending new messages toohello primary namespace.</span></span>
* <span data-ttu-id="3a28f-167">다른 발신자에서 동일한 엔터티 hello 하면 앞으로 요청 toosend toothat [BrokeredMessage] [ BrokeredMessage] hello 백로그 큐에 toosit 수정 toobe 송신할 합니다.</span><span class="sxs-lookup"><span data-stu-id="3a28f-167">Future requests toosend toothat same entity from any other senders will result in hello [BrokeredMessage][BrokeredMessage] being sent toobe modified toosit in hello backlog queue.</span></span> <span data-ttu-id="3a28f-168">hello에서 일부 속성을 제거 하는 hello 수정 [BrokeredMessage] [ BrokeredMessage] 개체를 다른 위치에 저장 합니다.</span><span class="sxs-lookup"><span data-stu-id="3a28f-168">hello modification removes some properties from hello [BrokeredMessage][BrokeredMessage] object and stores them elsewhere.</span></span> <span data-ttu-id="3a28f-169">hello 다음과 같은 속성이 선택이 취소 되며 서비스 버스 및 허용 hello SDK tooprocess 메시지 균일 하 게 새 별칭을 아래에 추가 합니다.</span><span class="sxs-lookup"><span data-stu-id="3a28f-169">hello following properties are cleared and added under a new alias, allowing Service Bus and hello SDK tooprocess messages uniformly:</span></span>

| <span data-ttu-id="3a28f-170">이전 속성 이름</span><span class="sxs-lookup"><span data-stu-id="3a28f-170">Old Property Name</span></span> | <span data-ttu-id="3a28f-171">새 속성 이름</span><span class="sxs-lookup"><span data-stu-id="3a28f-171">New Property Name</span></span> |
| --- | --- |
| <span data-ttu-id="3a28f-172">SessionId</span><span class="sxs-lookup"><span data-stu-id="3a28f-172">SessionId</span></span> |<span data-ttu-id="3a28f-173">x-ms-sessionid</span><span class="sxs-lookup"><span data-stu-id="3a28f-173">x-ms-sessionid</span></span> |
| <span data-ttu-id="3a28f-174">TimeToLive</span><span class="sxs-lookup"><span data-stu-id="3a28f-174">TimeToLive</span></span> |<span data-ttu-id="3a28f-175">x-ms-timetolive</span><span class="sxs-lookup"><span data-stu-id="3a28f-175">x-ms-timetolive</span></span> |
| <span data-ttu-id="3a28f-176">ScheduledEnqueueTimeUtc</span><span class="sxs-lookup"><span data-stu-id="3a28f-176">ScheduledEnqueueTimeUtc</span></span> |<span data-ttu-id="3a28f-177">x-ms-path</span><span class="sxs-lookup"><span data-stu-id="3a28f-177">x-ms-path</span></span> |

<span data-ttu-id="3a28f-178">원래 대상 경로도 hello x ms 경로 속성으로 hello 메시지에도 저장 됩니다.</span><span class="sxs-lookup"><span data-stu-id="3a28f-178">hello original destination path is also stored within hello message as a property named x-ms-path.</span></span> <span data-ttu-id="3a28f-179">이 설계는 단일 백로그 큐에 많은 엔터티 toocoexist에 대 한 메시지를 허용합니다.</span><span class="sxs-lookup"><span data-stu-id="3a28f-179">This design allows messages for many entities toocoexist in a single backlog queue.</span></span> <span data-ttu-id="3a28f-180">hello 속성 hello 사이 펀에 의해 다시 변환 됩니다.</span><span class="sxs-lookup"><span data-stu-id="3a28f-180">hello properties are translated back by hello syphon.</span></span>

<span data-ttu-id="3a28f-181">사용자 지정 hello [MessageSender] [ MessageSender] 메시지 hello 256KB 제한에 근접 하 고 장애 조치 수행 중이 던 개체 문제가 발생할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="3a28f-181">hello custom [MessageSender][MessageSender] object can encounter issues when messages approach hello 256-KB limit and failover is engaged.</span></span> <span data-ttu-id="3a28f-182">사용자 지정 hello [MessageSender] [ MessageSender] 모든 큐 및 항목 hello 백로그 큐에서 메시지를 저장 하는 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="3a28f-182">hello custom [MessageSender][MessageSender] object stores messages for all queues and topics together in hello backlog queues.</span></span> <span data-ttu-id="3a28f-183">이 개체는 hello 백로그 큐 내에 함께 많은 보관의 메시지를 혼합합니다.</span><span class="sxs-lookup"><span data-stu-id="3a28f-183">This object mixes messages from many primaries together within hello backlog queues.</span></span> <span data-ttu-id="3a28f-184">toohandle 간의 부하 분산 알지 못할 각 다른 hello SDK 임의로 많은 클라이언트에서 각 백로그 큐 하나를 선택 [QueueClient] [ QueueClient] 또는 [TopicClient] [ TopicClient] 코드에서 만들어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="3a28f-184">toohandle load balancing among many clients that do not know each other, hello SDK randomly picks one backlog queue for each [QueueClient][QueueClient] or [TopicClient][TopicClient] you create in code.</span></span>

## <a name="pings"></a><span data-ttu-id="3a28f-185">Ping</span><span class="sxs-lookup"><span data-stu-id="3a28f-185">Pings</span></span>
<span data-ttu-id="3a28f-186">Ping 메시지는 빈 [BrokeredMessage] [ BrokeredMessage] 와 해당 [ContentType] [ ContentType] 속성이 설정 tooapplication/vnd.ms-servicebus-ping 및 [TimeToLive] [ TimeToLive] 1 초 값입니다.</span><span class="sxs-lookup"><span data-stu-id="3a28f-186">A ping message is an empty [BrokeredMessage][BrokeredMessage] with its [ContentType][ContentType] property set tooapplication/vnd.ms-servicebus-ping and a [TimeToLive][TimeToLive] value of 1 second.</span></span> <span data-ttu-id="3a28f-187">이러한 ping 서비스 버스의 한 특수 한 특성은: 모든 호출자가 요청할 때 하지 ping을 배달 hello 서버는 [BrokeredMessage][BrokeredMessage]합니다.</span><span class="sxs-lookup"><span data-stu-id="3a28f-187">This ping has one special characteristic in Service Bus: hello server never delivers a ping when any caller requests a [BrokeredMessage][BrokeredMessage].</span></span> <span data-ttu-id="3a28f-188">따라서 하지 않아도 toolearn 어떻게 tooreceive 하 고 이러한 메시지를 무시 합니다.</span><span class="sxs-lookup"><span data-stu-id="3a28f-188">Thus, you never have toolearn how tooreceive and ignore these messages.</span></span> <span data-ttu-id="3a28f-189">각 엔터티 (고유 큐 또는 토픽) 당 [MessagingFactory] [ MessagingFactory] 클라이언트당 인스턴스는 ping을 실행할 간주 되 면 toobe 사용할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="3a28f-189">Each entity (unique queue or topic) per [MessagingFactory][MessagingFactory] instance per client will be pinged when they are considered toobe unavailable.</span></span> <span data-ttu-id="3a28f-190">기본적으로 이 작업은 1분에 한 번씩 수행됩니다.</span><span class="sxs-lookup"><span data-stu-id="3a28f-190">By default, this happens once per minute.</span></span> <span data-ttu-id="3a28f-191">Ping 메시지 toobe 일반 서비스 버스 메시지로 간주 되며 대역폭 및 메시지 요금이 발생할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="3a28f-191">Ping messages are considered toobe regular Service Bus messages, and can result in charges for bandwidth and messages.</span></span> <span data-ttu-id="3a28f-192">Hello 클라이언트 hello 시스템을 사용할 수를 검색 하는 즉시 hello 메시지 중지 합니다.</span><span class="sxs-lookup"><span data-stu-id="3a28f-192">As soon as hello clients detect that hello system is available, hello messages stop.</span></span>

## <a name="hello-syphon"></a><span data-ttu-id="3a28f-193">hello 사이 펀</span><span class="sxs-lookup"><span data-stu-id="3a28f-193">hello syphon</span></span>
<span data-ttu-id="3a28f-194">Hello 응용 프로그램의 실행 프로그램을 하나 이상 hello 사이 펀 적극적으로 실행 되어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="3a28f-194">At least one executable program in hello application should be actively running hello syphon.</span></span> <span data-ttu-id="3a28f-195">hello 사이 펀 수행 긴 폴링 수신을 15 분 동안 지속 되 합니다.</span><span class="sxs-lookup"><span data-stu-id="3a28f-195">hello syphon performs a long poll receive that lasts 15 minutes.</span></span> <span data-ttu-id="3a28f-196">모든 엔터티를 사용할 수 있는 백로그 큐가 10을 hello hello 사이 펀 호출 hello 수신 40 번 / 시간, 일, 당 960 번 및 28800 시간 30 일 이내에에서 작업을 호스팅하는 응용 프로그램입니다.</span><span class="sxs-lookup"><span data-stu-id="3a28f-196">When all entities are available and you have 10 backlog queues, hello application that hosts hello syphon calls hello receive operation 40 times per hour, 960 times per day, and 28800 times in 30 days.</span></span> <span data-ttu-id="3a28f-197">Hello 사이 펀은 hello 백로그 toohello 기본 큐에서 메시지를 이동, 각 메시지에 요금 (메시지 크기와 대역폭에 대 한 표준 요금이 모든 단계에서 적용 됨)를 수행 하는 hello에서 발생 합니다.</span><span class="sxs-lookup"><span data-stu-id="3a28f-197">When hello syphon is actively moving messages from hello backlog toohello primary queue, each message experiences hello following charges (standard charges for message size and bandwidth apply in all stages):</span></span>

1. <span data-ttu-id="3a28f-198">Toohello 백로그를 보냅니다.</span><span class="sxs-lookup"><span data-stu-id="3a28f-198">Send toohello backlog.</span></span>
2. <span data-ttu-id="3a28f-199">Hello 백로그에서 받기</span><span class="sxs-lookup"><span data-stu-id="3a28f-199">Receive from hello backlog.</span></span>
3. <span data-ttu-id="3a28f-200">기본 toohello를 보냅니다.</span><span class="sxs-lookup"><span data-stu-id="3a28f-200">Send toohello primary.</span></span>
4. <span data-ttu-id="3a28f-201">기본 hello에서 수신 합니다.</span><span class="sxs-lookup"><span data-stu-id="3a28f-201">Receive from hello primary.</span></span>

## <a name="closefault-behavior"></a><span data-ttu-id="3a28f-202">닫기/오류 동작</span><span class="sxs-lookup"><span data-stu-id="3a28f-202">Close/fault behavior</span></span>
<span data-ttu-id="3a28f-203">Hello 사이 펀, 한 번 hello primary 또는 secondary 상태를 호스팅하는 응용 프로그램 내에서 [MessagingFactory] [ MessagingFactory] 가 닫히거나 정의와 오류가 발생 한/닫히는 파트너 및 hello 없이 사이 펀이이 상태를 검색 hello 사이 펀 작동 합니다.</span><span class="sxs-lookup"><span data-stu-id="3a28f-203">Within an application that hosts hello syphon, once hello primary or secondary [MessagingFactory][MessagingFactory] faults or is closed without its partner also being faulted/closed and hello syphon detects this state, hello syphon acts.</span></span> <span data-ttu-id="3a28f-204">하는 경우 다른 hello [MessagingFactory] [ MessagingFactory] 닫혀 있지 않으면 hello 사이 펀은 hello 아직 열려 5 초 안에 오류 [MessagingFactory] [ MessagingFactory] .</span><span class="sxs-lookup"><span data-stu-id="3a28f-204">If hello other [MessagingFactory][MessagingFactory] is not closed within 5 seconds, hello syphon will fault hello still open [MessagingFactory][MessagingFactory].</span></span>

## <a name="next-steps"></a><span data-ttu-id="3a28f-205">다음 단계</span><span class="sxs-lookup"><span data-stu-id="3a28f-205">Next steps</span></span>
<span data-ttu-id="3a28f-206">Service Bus 비동기 메시징에 대한 자세한 내용은 [비동기 메시징 패턴 및 고가용성][Asynchronous messaging patterns and high availability]을 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="3a28f-206">See [Asynchronous messaging patterns and high availability][Asynchronous messaging patterns and high availability] for a detailed discussion of Service Bus asynchronous messaging.</span></span> 

[PairNamespaceAsync]: /dotnet/api/microsoft.servicebus.messaging.messagingfactory#Microsoft_ServiceBus_Messaging_MessagingFactory_PairNamespaceAsync_Microsoft_ServiceBus_Messaging_PairedNamespaceOptions_
[SendAvailabilityPairedNamespaceOptions]: /dotnet/api/microsoft.servicebus.messaging.sendavailabilitypairednamespaceoptions
[MessageSender]: /dotnet/api/microsoft.servicebus.messaging.messagesender
[MessagingFactory]: /dotnet/api/microsoft.servicebus.messaging.messagingfactory
[FailoverInterval]: /dotnet/api/microsoft.servicebus.messaging.pairednamespaceoptions#Microsoft_ServiceBus_Messaging_PairedNamespaceOptions_FailoverInterval
[MessagingException]: /dotnet/api/microsoft.servicebus.messaging.messagingexception
[TimeoutException]: https://msdn.microsoft.com/library/azure/system.timeoutexception.aspx
[BrokeredMessage]: /dotnet/api/microsoft.servicebus.messaging.brokeredmessage
[QueueDescription]: /dotnet/api/microsoft.servicebus.messaging.queuedescription
[TimeSpan]: https://msdn.microsoft.com/library/azure/system.timespan.aspx
[PingPrimaryInterval]: /dotnet/api/microsoft.servicebus.messaging.sendavailabilitypairednamespaceoptions#Microsoft_ServiceBus_Messaging_SendAvailabilityPairedNamespaceOptions_PingPrimaryInterval
[QueueClient]: /dotnet/api/microsoft.servicebus.messaging.queueclient
[TopicClient]: /dotnet/api/microsoft.servicebus.messaging.topicclient
[ContentType]: /dotnet/api/microsoft.servicebus.messaging.brokeredmessage#Microsoft_ServiceBus_Messaging_BrokeredMessage_ContentType
[TimeToLive]: /dotnet/api/microsoft.servicebus.messaging.brokeredmessage#Microsoft_ServiceBus_Messaging_BrokeredMessage_TimeToLive
[Asynchronous messaging patterns and high availability]: service-bus-async-messaging.md
[0]: ./media/service-bus-paired-namespaces/IC673405.png
[1]: ./media/service-bus-paired-namespaces/IC673406.png
[2]: ./media/service-bus-paired-namespaces/IC673407.png
