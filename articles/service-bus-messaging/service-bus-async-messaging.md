---
title: "비동기 메시징 aaaService 버스 | Microsoft Docs"
description: "Azure Service Bus 비동기 메시지에 대한 설명입니다."
services: service-bus-messaging
documentationcenter: na
author: sethmanheim
manager: timlt
editor: 
ms.assetid: f1435549-e1f2-40cb-a280-64ea07b39fc7
ms.service: service-bus-messaging
ms.devlang: na
ms.topic: article
ms.tgt_pltfrm: na
ms.workload: na
ms.date: 04/19/2017
ms.author: sethm
ms.openlocfilehash: 5ab6ddf052155a9dd975b413cfaf393119c1999d
ms.sourcegitcommit: 523283cc1b3c37c428e77850964dc1c33742c5f0
ms.translationtype: MT
ms.contentlocale: ko-KR
ms.lasthandoff: 10/06/2017
---
# <a name="asynchronous-messaging-patterns-and-high-availability"></a><span data-ttu-id="9bf39-103">비동기 메시징 패턴 및 고가용성</span><span class="sxs-lookup"><span data-stu-id="9bf39-103">Asynchronous messaging patterns and high availability</span></span>

<span data-ttu-id="9bf39-104">비동기 메시징은 다양한 방식으로 구현할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="9bf39-104">Asynchronous messaging can be implemented in a variety of different ways.</span></span> <span data-ttu-id="9bf39-105">큐, 토픽 및 구독으로 Azure Service Bus는 저장소 및 전달 메커니즘을 통해 비동기를 지원합니다.</span><span class="sxs-lookup"><span data-stu-id="9bf39-105">With queues, topics, and subscriptions, Azure Service Bus supports asynchronism via a store and forward mechanism.</span></span> <span data-ttu-id="9bf39-106">일반 (동기) 작업에서 메시지 tooqueues 항목과 보내고 큐와 구독에서 메시지를 수신 합니다.</span><span class="sxs-lookup"><span data-stu-id="9bf39-106">In normal (synchronous) operation, you send messages tooqueues and topics, and receive messages from queues and subscriptions.</span></span> <span data-ttu-id="9bf39-107">작성하는 응용 프로그램은 항상 사용 가능한 이러한 엔터티에 따라 다릅니다.</span><span class="sxs-lookup"><span data-stu-id="9bf39-107">Applications you write depend on these entities always being available.</span></span> <span data-ttu-id="9bf39-108">Tooa 다양 한 상황 인해 hello 엔터티 상태 변경 방법 tooprovide 대부분의 요구 사항을 충족 시킬 수 있는 제한 된 기능 엔터티가 필요 합니다.</span><span class="sxs-lookup"><span data-stu-id="9bf39-108">When hello entity health changes, due tooa variety of circumstances, you need a way tooprovide a reduced capability entity that can satisfy most needs.</span></span>

<span data-ttu-id="9bf39-109">일반적으로 응용 프로그램 비동기 메시징 패턴 tooenable 여러 통신 시나리오를 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="9bf39-109">Applications typically use asynchronous messaging patterns tooenable a number of communication scenarios.</span></span> <span data-ttu-id="9bf39-110">클라이언트 전송할 수 있는 메시지 tooservices hello 서비스가 실행 되지 않는 경우에 응용 프로그램을 빌드할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="9bf39-110">You can build applications in which clients can send messages tooservices, even when hello service is not running.</span></span> <span data-ttu-id="9bf39-111">통신 버스트 발생 하는 응용 프로그램에 대 한 큐 위치 toobuffer 통신을 제공 하 여 로드 수준 hello를 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="9bf39-111">For applications that experience bursts of communications, a queue can help level hello load by providing a place toobuffer communications.</span></span> <span data-ttu-id="9bf39-112">마지막으로 얻을 수 있습니다 단순 하지만 효율적인 부하 분산 장치 toodistribute 메시지 여러 컴퓨터에서.</span><span class="sxs-lookup"><span data-stu-id="9bf39-112">Finally, you can get a simple but effective load balancer toodistribute messages across multiple machines.</span></span>

<span data-ttu-id="9bf39-113">이러한 엔터티 중 아무 메서드나 순서 toomaintain 가용성의 다양을 한 다른 방법으로 이러한 엔터티 수 지속형 메시징 시스템에 사용할 수 없는 표시 되는 것이 좋습니다.</span><span class="sxs-lookup"><span data-stu-id="9bf39-113">In order toomaintain availability of any of these entities, consider a number of different ways in which these entities can appear unavailable for a durable messaging system.</span></span> <span data-ttu-id="9bf39-114">일반적으로 hello 엔터티는 사용자가 작성 한 가지 방법으로 다음 hello 사용할 수 없는 tooapplications 참조 했습니다.</span><span class="sxs-lookup"><span data-stu-id="9bf39-114">Generally speaking, we see hello entity become unavailable tooapplications we write in hello following different ways:</span></span>

* <span data-ttu-id="9bf39-115">없습니다 toosend 메시지입니다.</span><span class="sxs-lookup"><span data-stu-id="9bf39-115">Unable toosend messages.</span></span>
* <span data-ttu-id="9bf39-116">없습니다 tooreceive 메시지입니다.</span><span class="sxs-lookup"><span data-stu-id="9bf39-116">Unable tooreceive messages.</span></span>
* <span data-ttu-id="9bf39-117">없습니다 toomanage 엔터티 (만들기, 검색, 업데이트 또는 엔터티를 삭제) 합니다.</span><span class="sxs-lookup"><span data-stu-id="9bf39-117">Unable toomanage entities (create, retrieve, update, or delete entities).</span></span>
* <span data-ttu-id="9bf39-118">없습니다 toocontact hello 서비스입니다.</span><span class="sxs-lookup"><span data-stu-id="9bf39-118">Unable toocontact hello service.</span></span>

<span data-ttu-id="9bf39-119">각 이러한 오류에 대 한 다른 오류 모드가 일정 수준의 제한 된 기능에는 응용 프로그램 toocontinue tooperform 작업할 수 있는 있습니다.</span><span class="sxs-lookup"><span data-stu-id="9bf39-119">For each of these failures, different failure modes exist that enable an application toocontinue tooperform work at some level of reduced capability.</span></span> <span data-ttu-id="9bf39-120">예를 들어 메시지를 보낼 수 있지만 받지 않는 시스템은 고객의 주문을 받을 수 있지만 이러한 주문을 처리할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="9bf39-120">For example, a system that can send messages but not receive them can still receive orders from customers but cannot process those orders.</span></span> <span data-ttu-id="9bf39-121">이 항목에서는 발생할 수 있는 잠재적인 문제 및 이러한 문제를 줄이는 방법을 설명합니다.</span><span class="sxs-lookup"><span data-stu-id="9bf39-121">This topic discusses potential issues that can occur, and how those issues are mitigated.</span></span> <span data-ttu-id="9bf39-122">서비스 버스에는 여러을 선택 해야 하는 완화 기능이 도입 되었습니다 및 hello hello 적용 되는 규칙 옵트인 이러한 완화 기능의 사용 절차도 설명 합니다.</span><span class="sxs-lookup"><span data-stu-id="9bf39-122">Service Bus has introduced a number of mitigations which you must opt into, and this topic also discusses hello rules governing hello use of those opt-in mitigations.</span></span>

## <a name="reliability-in-service-bus"></a><span data-ttu-id="9bf39-123">서비스 버스의 안정성</span><span class="sxs-lookup"><span data-stu-id="9bf39-123">Reliability in Service Bus</span></span>
<span data-ttu-id="9bf39-124">여러 가지 toohandle 메시지 및 엔터티 문제 및 hello 이러한 완화 기능의 적절 한 사용과 관련 된 지침도 있습니다.</span><span class="sxs-lookup"><span data-stu-id="9bf39-124">There are several ways toohandle message and entity issues, and there are guidelines governing hello appropriate use of those mitigations.</span></span> <span data-ttu-id="9bf39-125">toounderstand hello 지침 서비스 버스에서 발생 가능한 오류를 먼저 이해 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="9bf39-125">toounderstand hello guidelines, you must first understand what can fail in Service Bus.</span></span> <span data-ttu-id="9bf39-126">Azure 시스템의 toohello 디자인 인해 이러한 문제가 모두 경향이 toobe 수명이 짧은 합니다.</span><span class="sxs-lookup"><span data-stu-id="9bf39-126">Due toohello design of Azure systems, all of these issues tend toobe short-lived.</span></span> <span data-ttu-id="9bf39-127">상위 수준에서 사용 불가 hello 다른 이유로 다음과 같이 나타납니다.</span><span class="sxs-lookup"><span data-stu-id="9bf39-127">At a high level, hello different causes of unavailability appear as follows:</span></span>

* <span data-ttu-id="9bf39-128">서비스 버스가 의존하는 외부 시스템에서 제한합니다.</span><span class="sxs-lookup"><span data-stu-id="9bf39-128">Throttling from an external system on which Service Bus depends.</span></span> <span data-ttu-id="9bf39-129">제한은 계산 및 저장소 리소스와의 상호작용에서 발생합니다.</span><span class="sxs-lookup"><span data-stu-id="9bf39-129">Throttling occurs from interactions with storage and compute resources.</span></span>
* <span data-ttu-id="9bf39-130">서비스 버스가 의존하는 시스템에서 발생하는 문제입니다.</span><span class="sxs-lookup"><span data-stu-id="9bf39-130">Issue for a system on which Service Bus depends.</span></span> <span data-ttu-id="9bf39-131">예를 들어 저장소의 특정 부분에 문제가 발생할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="9bf39-131">For example, a given part of storage can encounter issues.</span></span>
* <span data-ttu-id="9bf39-132">단일 하위 시스템에서 서비스 버스의 오류입니다.</span><span class="sxs-lookup"><span data-stu-id="9bf39-132">Failure of Service Bus on single subsystem.</span></span> <span data-ttu-id="9bf39-133">이 경우 계산 노드 일관성이 없는 상태에 액세스할 수 고 자체적으로 다시 시작 해야에 모든 엔터티가 이것이 tooload 균형 tooother 노드 있습니다.</span><span class="sxs-lookup"><span data-stu-id="9bf39-133">In this situation, a compute node can get into an inconsistent state and must restart itself, causing all entities it serves tooload balance tooother nodes.</span></span> <span data-ttu-id="9bf39-134">단기간 동안 차례로 메시지 처리 속도가 느려질 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="9bf39-134">This in turn can cause a short period of slow message processing.</span></span>
* <span data-ttu-id="9bf39-135">Azure 데이터 센터 내에서 서비스 버스의 오류입니다.</span><span class="sxs-lookup"><span data-stu-id="9bf39-135">Failure of Service Bus within an Azure datacenter.</span></span> <span data-ttu-id="9bf39-136">hello 시스템 접근할 수 없거나 몇 분에서 길게는 몇 시간에 대 한 "치명적인 오류"입니다.</span><span class="sxs-lookup"><span data-stu-id="9bf39-136">This is a "catastrophic failure" during which hello system is unreachable for many minutes or a few hours.</span></span>

> [!NOTE]
> <span data-ttu-id="9bf39-137">hello 용어 **저장소** Azure 저장소와 SQL Azure를 모두 의미할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="9bf39-137">hello term **storage** can mean both Azure Storage and SQL Azure.</span></span>
> 
> 

<span data-ttu-id="9bf39-138">서비스 버스는 이런 문제에 대한 다양한 완화 방법을 포함합니다.</span><span class="sxs-lookup"><span data-stu-id="9bf39-138">Service Bus contains a number of mitigations for these issues.</span></span> <span data-ttu-id="9bf39-139">각 문제 및 개별 완화 기능 hello 다음 섹션에 설명 합니다.</span><span class="sxs-lookup"><span data-stu-id="9bf39-139">hello following sections discuss each issue and their respective mitigations.</span></span>

### <a name="throttling"></a><span data-ttu-id="9bf39-140">제한</span><span class="sxs-lookup"><span data-stu-id="9bf39-140">Throttling</span></span>
<span data-ttu-id="9bf39-141">서비스 버스로 제한을 사용하면 공동으로 메시지 속도를 관리할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="9bf39-141">With Service Bus, throttling enables cooperative message rate management.</span></span> <span data-ttu-id="9bf39-142">각 개별 서비스 버스 노드가 여러 엔터티가 있습니다.</span><span class="sxs-lookup"><span data-stu-id="9bf39-142">Each individual Service Bus node houses many entities.</span></span> <span data-ttu-id="9bf39-143">이러한 각 엔터티 CPU, 메모리, 저장소 및 기타 패싯과 기초로 하 여 hello 시스템에서 요구를 하도록 만듭니다.</span><span class="sxs-lookup"><span data-stu-id="9bf39-143">Each of those entities makes demands on hello system in terms of CPU, memory, storage, and other facets.</span></span> <span data-ttu-id="9bf39-144">패싯이 정의된 임계값을 초과하는 사용을 감지하면 서비스 버스는 지정된 요청을 거부할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="9bf39-144">When any of these facets detects usage that exceeds defined thresholds, Service Bus can deny a given request.</span></span> <span data-ttu-id="9bf39-145">hello 호출자가 받을 [ServerBusyException] [ ServerBusyException] 및 10 초 후 다시 시도 합니다.</span><span class="sxs-lookup"><span data-stu-id="9bf39-145">hello caller receives a [ServerBusyException][ServerBusyException] and retries after 10 seconds.</span></span>

<span data-ttu-id="9bf39-146">한 완화 수단으로 hello 코드 읽기 hello 오류 하 고 10 초 이상에 대 한 hello 메시지의 다시 시도 중지 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="9bf39-146">As a mitigation, hello code must read hello error and halt any retries of hello message for at least 10 seconds.</span></span> <span data-ttu-id="9bf39-147">Hello 오류 hello 고객 응용 프로그램의 여러 부분에서이 오류가 발생할 수 있으므로 각 독립적으로 실행 한다는 하지 hello 재시도 논리 것으로 예상 됩니다.</span><span class="sxs-lookup"><span data-stu-id="9bf39-147">Since hello error can happen across pieces of hello customer application, it is expected that each piece independently executes hello retry logic.</span></span> <span data-ttu-id="9bf39-148">hello 코드 hello 제한 가능성을 분할 된 큐 또는 항목을 사용 하 여 줄일 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="9bf39-148">hello code can reduce hello probability of being throttled by enabling partitioning on a queue or topic.</span></span>

### <a name="issue-for-an-azure-dependency"></a><span data-ttu-id="9bf39-149">Azure 종속성에서 발생하는 문제</span><span class="sxs-lookup"><span data-stu-id="9bf39-149">Issue for an Azure dependency</span></span>
<span data-ttu-id="9bf39-150">Azure 내의 다른 구성 요소에는 서비스 문제가 있는 경우도 있습니다.</span><span class="sxs-lookup"><span data-stu-id="9bf39-150">Other components within Azure can occasionally have service issues.</span></span> <span data-ttu-id="9bf39-151">예를 들어 서비스 버스가 사용하는 시스템이 업그레이드되는 경우 해당 시스템은 일시적으로 기능이 축소될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="9bf39-151">For example, when a system that Service Bus uses is being upgraded, that system can temporarily experience reduced capabilities.</span></span> <span data-ttu-id="9bf39-152">이러한 유형의 문제를 정기적으로 서비스 버스 주위 toowork 조사 하 여 완화 기능을 구현 합니다.</span><span class="sxs-lookup"><span data-stu-id="9bf39-152">toowork around these types of issues, Service Bus regularly investigates and implements mitigations.</span></span> <span data-ttu-id="9bf39-153">이러한 완화의 부작용도 물론 나타납니다.</span><span class="sxs-lookup"><span data-stu-id="9bf39-153">Side effects of these mitigations do appear.</span></span> <span data-ttu-id="9bf39-154">예를 들어 toohandle 일시적인 저장소 문제, 서비스 버스 메시지 보내기 작업 toowork를 일관 되 게 허용 하는 시스템을 구현 합니다.</span><span class="sxs-lookup"><span data-stu-id="9bf39-154">For example, toohandle transient issues with storage, Service Bus implements a system that allows message send operations toowork consistently.</span></span> <span data-ttu-id="9bf39-155">Hello 완화에서는 toohello 이기 때문 보낸된 메시지 too15 분 tooappear hello 영향을 받는 큐 또는 구독에서 차지 하 고 수신 작업에 대 한 준비가 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="9bf39-155">Due toohello nature of hello mitigation, a sent message can take up too15 minutes tooappear in hello affected queue or subscription and be ready for a receive operation.</span></span> <span data-ttu-id="9bf39-156">일반적으로 엔터티에는 대부분 이 문제가 발생하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="9bf39-156">Generally speaking, most entities will not experience this issue.</span></span> <span data-ttu-id="9bf39-157">그러나 Azure 내에서 서비스 버스에 hello 엔터티 수를 지정 된,이 완화 기능이 필요한 경우도 서비스 버스 고객의 작은 하위 집합에 대 한 합니다.</span><span class="sxs-lookup"><span data-stu-id="9bf39-157">However, given hello number of entities in Service Bus within Azure, this mitigation is sometimes needed for a small subset of Service Bus customers.</span></span>

### <a name="service-bus-failure-on-a-single-subsystem"></a><span data-ttu-id="9bf39-158">단일 하위 시스템에서 서비스 버스 오류</span><span class="sxs-lookup"><span data-stu-id="9bf39-158">Service Bus failure on a single subsystem</span></span>
<span data-ttu-id="9bf39-159">모든 응용 프로그램의 경우 일치 하지 않는 서비스 버스 toobecome의 내부 구성이 될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="9bf39-159">With any application, circumstances can cause an internal component of Service Bus toobecome inconsistent.</span></span> <span data-ttu-id="9bf39-160">서비스 버스에서이 감지한 경우 hello 응용 프로그램 tooaid 무슨 상황이 진단에서 데이터를 수집 합니다.</span><span class="sxs-lookup"><span data-stu-id="9bf39-160">When Service Bus detects this, it collects data from hello application tooaid in diagnosing what happened.</span></span> <span data-ttu-id="9bf39-161">Hello 데이터 수집 되 면 hello 응용 프로그램은 다시 시작 시도가 tooreturn 것 tooa 일관 된 상태입니다.</span><span class="sxs-lookup"><span data-stu-id="9bf39-161">Once hello data is collected, hello application is restarted in an attempt tooreturn it tooa consistent state.</span></span> <span data-ttu-id="9bf39-162">이 프로세스는 비교적 빠르게 수행 되며 결과 toobe tooa 구성에 사용할 수 없는 몇 분 중단 시간이 일반적인 경우에 나타나는 엔터티의 훨씬 짧기 있습니다.</span><span class="sxs-lookup"><span data-stu-id="9bf39-162">This process happens fairly quickly, and results in an entity appearing toobe unavailable for up tooa few minutes, though typical down times are much shorter.</span></span>

<span data-ttu-id="9bf39-163">이러한 경우 hello 클라이언트 응용 프로그램에서는 오류가 발생 하는 [System.TimeoutException] [ System.TimeoutException] 또는 [MessagingException] [ MessagingException] 예외입니다.</span><span class="sxs-lookup"><span data-stu-id="9bf39-163">In these cases, hello client application generates a [System.TimeoutException][System.TimeoutException] or [MessagingException][MessagingException] exception.</span></span> <span data-ttu-id="9bf39-164">서비스 버스에 자동화 된 클라이언트 다시 시도 논리의 hello 형태로이 문제에 대 한 완화 기능이 포함 되어 있습니다.</span><span class="sxs-lookup"><span data-stu-id="9bf39-164">Service Bus contains a mitigation for this issue in hello form of automated client retry logic.</span></span> <span data-ttu-id="9bf39-165">Hello 다시 시도 기간이 지 났 고 hello 메시지가 배달 되지 않은와 같은 다른 기능을 사용 하 여 탐색할 수 있습니다 [네임 스페이스 쌍이][paired namespaces]합니다.</span><span class="sxs-lookup"><span data-stu-id="9bf39-165">Once hello retry period is exhausted and hello message is not delivered, you can explore using other features such as [paired namespaces][paired namespaces].</span></span> <span data-ttu-id="9bf39-166">쌍을 이루는 네임스페이스에는 이 문서에서 설명하는 다른 주의 사항이 있습니다.</span><span class="sxs-lookup"><span data-stu-id="9bf39-166">Paired namespaces have other caveats that are discussed in that article.</span></span>

### <a name="failure-of-service-bus-within-an-azure-datacenter"></a><span data-ttu-id="9bf39-167">Azure 데이터 센터 내에서 서비스 버스의 오류</span><span class="sxs-lookup"><span data-stu-id="9bf39-167">Failure of Service Bus within an Azure datacenter</span></span>
<span data-ttu-id="9bf39-168">Azure 데이터 센터에서 실패에 대 한 hello 가장 큰 이유는 서비스 버스 또는 종속 시스템의 업그레이드 배포 실패 합니다.</span><span class="sxs-lookup"><span data-stu-id="9bf39-168">hello most probable reason for a failure in an Azure datacenter is a failed upgrade deployment of Service Bus or a dependent system.</span></span> <span data-ttu-id="9bf39-169">Hello 플랫폼은 성숙 되어 이러한 유형의 오류 hello 가능성 감소 했습니다.</span><span class="sxs-lookup"><span data-stu-id="9bf39-169">As hello platform has matured, hello likelihood of this type of failure has diminished.</span></span> <span data-ttu-id="9bf39-170">데이터 센터 오류가 hello 다음을 포함 하는 이유로 발생할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="9bf39-170">A datacenter failure can also happen for reasons that include hello following:</span></span>

* <span data-ttu-id="9bf39-171">전기 중단(전력 공급 및 전력 생산 불가).</span><span class="sxs-lookup"><span data-stu-id="9bf39-171">Electrical outage (power supply and generating power disappear).</span></span>
* <span data-ttu-id="9bf39-172">연결.(클라이언트와 Azure 간에 인터넷 끊김)</span><span class="sxs-lookup"><span data-stu-id="9bf39-172">Connectivity (internet break between your clients and Azure).</span></span>

<span data-ttu-id="9bf39-173">두 경우 모두 자연 또는 인위적 재해 hello 문제를 발생합니다.</span><span class="sxs-lookup"><span data-stu-id="9bf39-173">In both cases, a natural or man-made disaster caused hello issue.</span></span> <span data-ttu-id="9bf39-174">이 toowork 계속 메시지를 보낼 수, 사용할 수 있는지 확인 하 고 [네임 스페이스 쌍이] [ paired namespaces] tooenable 메시지 전송 toobe tooa 두 번째 위치 중 hello 기본 위치는 정상 다시 합니다.</span><span class="sxs-lookup"><span data-stu-id="9bf39-174">toowork around this and make sure that you can still send messages, you can use [paired namespaces][paired namespaces] tooenable messages toobe sent tooa second location while hello primary location is made healthy again.</span></span> <span data-ttu-id="9bf39-175">자세한 정보는 [Service Bus 중단 및 재해로부터 응용 프로그램을 보호하는 모범 사례][Best practices for insulating applications against Service Bus outages and disasters]를 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="9bf39-175">For more information, see [Best practices for insulating applications against Service Bus outages and disasters][Best practices for insulating applications against Service Bus outages and disasters].</span></span>

## <a name="paired-namespaces"></a><span data-ttu-id="9bf39-176">쌍을 이루는 네임스페이스</span><span class="sxs-lookup"><span data-stu-id="9bf39-176">Paired namespaces</span></span>
<span data-ttu-id="9bf39-177">hello [네임 스페이스 쌍이] [ paired namespaces] 기능은 있는 시나리오를 지원 합니다. 서비스 버스 엔터티 또는 데이터 센터 내에서 배포 수 없게 합니다.</span><span class="sxs-lookup"><span data-stu-id="9bf39-177">hello [paired namespaces][paired namespaces] feature supports scenarios in which a Service Bus entity or deployment within a data center becomes unavailable.</span></span> <span data-ttu-id="9bf39-178">이 이벤트는 자주 발생 하는 동안 분산된 시스템도 준비 해야 toohandle 최악의 시나리오입니다.</span><span class="sxs-lookup"><span data-stu-id="9bf39-178">While this event occurs infrequently, distributed systems still must be prepared toohandle worst case scenarios.</span></span> <span data-ttu-id="9bf39-179">일반적으로 이 이벤트는 서비스 버스가 의존 하는 일부 요소가 수명이 짧기 때문에 발생합니다.</span><span class="sxs-lookup"><span data-stu-id="9bf39-179">Typically, this event happens because some element on which Service Bus depends is experiencing a short-term issue.</span></span> <span data-ttu-id="9bf39-180">응용 프로그램 가용성 toomaintain 중단이 발생 하는 동안 서비스 버스를 사용할 수 있습니다 toohost 별도 데이터 센터에 두 개의 별도 네임 스페이스는 메시징 엔터티.</span><span class="sxs-lookup"><span data-stu-id="9bf39-180">toomaintain application availability during an outage, Service Bus users can use two separate namespaces, preferably in separate data centers, toohost their messaging entities.</span></span> <span data-ttu-id="9bf39-181">이 섹션의 나머지 부분은 hello hello 다음 용어를 사용 합니다.</span><span class="sxs-lookup"><span data-stu-id="9bf39-181">hello remainder of this section uses hello following terminology:</span></span>

* <span data-ttu-id="9bf39-182">기본 네임 스페이스: hello 네임 스페이스는 응용 프로그램 상호 작용, 송신 및 수신 작업입니다.</span><span class="sxs-lookup"><span data-stu-id="9bf39-182">Primary namespace: hello namespace with which your application interacts, for send and receive operations.</span></span>
* <span data-ttu-id="9bf39-183">보조 네임 스페이스: hello 백업 toohello 기본 네임 스페이스 역할을 하는 네임 스페이스입니다.</span><span class="sxs-lookup"><span data-stu-id="9bf39-183">Secondary namespace: hello namespace that acts as a backup toohello primary namespace.</span></span> <span data-ttu-id="9bf39-184">응용 프로그램 논리는 이 네임스페이스 상호작용하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="9bf39-184">Application logic does not interact with this namespace.</span></span>
* <span data-ttu-id="9bf39-185">장애 조치 간격: hello 양의 시간 tooaccept hello 응용 프로그램 하기 전에 일반적인 오류가 hello 기본 네임 스페이스 toohello 보조 네임 스페이스에서 전환 합니다.</span><span class="sxs-lookup"><span data-stu-id="9bf39-185">Failover interval: hello amount of time tooaccept normal failures before hello application switches from hello primary namespace toohello secondary namespace.</span></span>

<span data-ttu-id="9bf39-186">쌍을 이루는 네임스페이스는 *가용성 보내기*를 지원합니다.</span><span class="sxs-lookup"><span data-stu-id="9bf39-186">Paired namespaces support *send availability*.</span></span> <span data-ttu-id="9bf39-187">가용성 유지 능력 toosend hello 메시지를 보냅니다.</span><span class="sxs-lookup"><span data-stu-id="9bf39-187">Send availability preserves hello ability toosend messages.</span></span> <span data-ttu-id="9bf39-188">toouse 보내기 가용성 응용 프로그램 요구 사항을 준수 하는 hello를 충족 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="9bf39-188">toouse send availability, your application must meet hello following requirements:</span></span>

1. <span data-ttu-id="9bf39-189">Hello 기본 네임 스페이스에서 메시지 수신만 됩니다.</span><span class="sxs-lookup"><span data-stu-id="9bf39-189">Messages are only received from hello primary namespace.</span></span>
2. <span data-ttu-id="9bf39-190">지정 된 큐 또는 항목으로 전송 된 메시지 tooa 잘못 된 순서로 도착할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="9bf39-190">Messages sent tooa given queue or topic might arrive out of order.</span></span>
3. <span data-ttu-id="9bf39-191">세션 내의 메시지가 잘못된 순서로 도착할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="9bf39-191">Messages within a session might arrive out of order.</span></span> <span data-ttu-id="9bf39-192">세션의 정상적인 기능에 문제가 생겼습니다.</span><span class="sxs-lookup"><span data-stu-id="9bf39-192">This is a break from normal functionality of sessions.</span></span> <span data-ttu-id="9bf39-193">이 응용 프로그램이 세션 toologically 그룹 메시지를 사용 하는 것을 의미 합니다.</span><span class="sxs-lookup"><span data-stu-id="9bf39-193">This means that your application uses sessions toologically group messages.</span></span>
4. <span data-ttu-id="9bf39-194">세션 상태 hello 기본 네임 스페이스에만 유지 됩니다.</span><span class="sxs-lookup"><span data-stu-id="9bf39-194">Session state is only maintained on hello primary namespace.</span></span>
5. <span data-ttu-id="9bf39-195">hello 기본 큐는 온라인 상태로 전환 하 고 hello 보조 큐 hello 기본 큐에 모든 메시지를 전달 하기 전에 메시지 수락을 시작할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="9bf39-195">hello primary queue can come online and start accepting messages before hello secondary queue delivers all messages into hello primary queue.</span></span>

<span data-ttu-id="9bf39-196">hello Api, hello Api 구현 되는 방식 및 hello 기능을 사용 하는 샘플 코드를 보여 줍니다 hello 다음 섹션에 설명 합니다.</span><span class="sxs-lookup"><span data-stu-id="9bf39-196">hello following sections discuss hello APIs, how hello APIs are implemented, and shows sample code that uses hello feature.</span></span> <span data-ttu-id="9bf39-197">이 기능과 관련된 비용이 청구될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="9bf39-197">Note that there are billing implications associated with this feature.</span></span>

### <a name="hello-messagingfactorypairnamespaceasync-api"></a><span data-ttu-id="9bf39-198">hello MessagingFactory.PairNamespaceAsync API</span><span class="sxs-lookup"><span data-stu-id="9bf39-198">hello MessagingFactory.PairNamespaceAsync API</span></span>
<span data-ttu-id="9bf39-199">hello 쌍 이룬된 네임 스페이스 기능에는 hello 포함 [PairNamespaceAsync] [ PairNamespaceAsync] 메서드 hello [Microsoft.ServiceBus.Messaging.MessagingFactory] [ Microsoft.ServiceBus.Messaging.MessagingFactory] 클래스:</span><span class="sxs-lookup"><span data-stu-id="9bf39-199">hello paired namespaces feature includes hello [PairNamespaceAsync][PairNamespaceAsync] method on hello [Microsoft.ServiceBus.Messaging.MessagingFactory][Microsoft.ServiceBus.Messaging.MessagingFactory] class:</span></span>

```csharp
public Task PairNamespaceAsync(PairedNamespaceOptions options);
```

<span data-ttu-id="9bf39-200">Hello 작업이 완료 되 면 hello 네임 스페이스 쌍 이기도 대 한 시 완성 되었으며 tooact [MessageReceiver][MessageReceiver], [QueueClient] [ QueueClient], 또는 [TopicClient] [ TopicClient] hello를 사용 하 여 만든 [MessagingFactory] [ MessagingFactory] 인스턴스.</span><span class="sxs-lookup"><span data-stu-id="9bf39-200">When hello task completes, hello namespace pairing is also complete and ready tooact upon for any [MessageReceiver][MessageReceiver], [QueueClient][QueueClient], or [TopicClient][TopicClient] created with hello [MessagingFactory][MessagingFactory] instance.</span></span> <span data-ttu-id="9bf39-201">[Microsoft.ServiceBus.Messaging.PairedNamespaceOptions] [ Microsoft.ServiceBus.Messaging.PairedNamespaceOptions] hello hello에 대 한 기본 클래스를 여러 쌍 유형의에 사용할 수 있는는 [MessagingFactory] [ MessagingFactory] 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="9bf39-201">[Microsoft.ServiceBus.Messaging.PairedNamespaceOptions][Microsoft.ServiceBus.Messaging.PairedNamespaceOptions] is hello base class for hello different types of pairing that are available with a [MessagingFactory][MessagingFactory] object.</span></span> <span data-ttu-id="9bf39-202">현재 hello만 파생 클래스는 이름이 하나 [SendAvailabilityPairedNamespaceOptions][SendAvailabilityPairedNamespaceOptions], hello 보내기 가용성 요구 사항을 구현 하는 합니다.</span><span class="sxs-lookup"><span data-stu-id="9bf39-202">Currently, hello only derived class is one named [SendAvailabilityPairedNamespaceOptions][SendAvailabilityPairedNamespaceOptions], which implements hello send availability requirements.</span></span> <span data-ttu-id="9bf39-203">[SendAvailabilityPairedNamespaceOptions][SendAvailabilityPairedNamespaceOptions]에는 서로 간에 빌드한 생성자의 집합이 있습니다.</span><span class="sxs-lookup"><span data-stu-id="9bf39-203">[SendAvailabilityPairedNamespaceOptions][SendAvailabilityPairedNamespaceOptions] has a set of constructors that build on each other.</span></span> <span data-ttu-id="9bf39-204">Hello 생성자 hello로 대부분의 매개 변수를 살펴보면 이해할 수 hello의 hello 동작 다른 생성자입니다.</span><span class="sxs-lookup"><span data-stu-id="9bf39-204">Looking at hello constructor with hello most parameters, you can understand hello behavior of hello other constructors.</span></span>

```csharp
public SendAvailabilityPairedNamespaceOptions(
    NamespaceManager secondaryNamespaceManager,
    MessagingFactory messagingFactory,
    int backlogQueueCount,
    TimeSpan failoverInterval,
    bool enableSyphon)
```

<span data-ttu-id="9bf39-205">이러한 매개 변수에 있는 의미 다음 hello:</span><span class="sxs-lookup"><span data-stu-id="9bf39-205">These parameters have hello following meanings:</span></span>

* <span data-ttu-id="9bf39-206">*secondaryNamespaceManager*: 초기화 된 [NamespaceManager] [ NamespaceManager] 인스턴스 hello 보조 네임 스페이스에 대 한 해당 hello [PairNamespaceAsync] [ PairNamespaceAsync] 메서드도 tooset hello 보조 네임 스페이스를 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="9bf39-206">*secondaryNamespaceManager*: An initialized [NamespaceManager][NamespaceManager] instance for hello secondary namespace that hello [PairNamespaceAsync][PairNamespaceAsync] method can use tooset up hello secondary namespace.</span></span> <span data-ttu-id="9bf39-207">hello 네임 스페이스 관리자는 사용 되는 tooobtain hello 목록 hello 네임 스페이스와 toomake 존재 hello 필요한 백로그 큐에서 큐입니다.</span><span class="sxs-lookup"><span data-stu-id="9bf39-207">hello namespace manager is used tooobtain hello list of queues in hello namespace and toomake sure that hello required backlog queues exist.</span></span> <span data-ttu-id="9bf39-208">이러한 큐가 존재하지 않는 경우 만들어집니다.</span><span class="sxs-lookup"><span data-stu-id="9bf39-208">If those queues do not exist, they are created.</span></span> <span data-ttu-id="9bf39-209">[NamespaceManager] [ NamespaceManager] hello 기능 toocreate hello로 토큰 필요 **관리** 클레임입니다.</span><span class="sxs-lookup"><span data-stu-id="9bf39-209">[NamespaceManager][NamespaceManager] requires hello ability toocreate a token with hello **Manage** claim.</span></span>
* <span data-ttu-id="9bf39-210">*messagingFactory*: hello [MessagingFactory] [ MessagingFactory] hello 보조 네임 스페이스에 대 한 인스턴스.</span><span class="sxs-lookup"><span data-stu-id="9bf39-210">*messagingFactory*: hello [MessagingFactory][MessagingFactory] instance for hello secondary namespace.</span></span> <span data-ttu-id="9bf39-211">hello [MessagingFactory] [ MessagingFactory] 개체는 사용 되는 toosend 경우 hello [EnableSyphon] [ EnableSyphon] 너무 속성이**true** , hello 백로그 큐에서 메시지를 수신 합니다.</span><span class="sxs-lookup"><span data-stu-id="9bf39-211">hello [MessagingFactory][MessagingFactory] object is used toosend and, if hello [EnableSyphon][EnableSyphon] property is set too**true**, receive messages from hello backlog queues.</span></span>
* <span data-ttu-id="9bf39-212">*backlogQueueCount*: hello 백로그 수가 toocreate 큐 대기 합니다.</span><span class="sxs-lookup"><span data-stu-id="9bf39-212">*backlogQueueCount*: hello number of backlog queues toocreate.</span></span> <span data-ttu-id="9bf39-213">이 값은 적어도 1이어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="9bf39-213">This value must be at least 1.</span></span> <span data-ttu-id="9bf39-214">메시지 toohello 백로그를 보낼 때 이러한 큐 중 하나가 임의로 선택 됩니다.</span><span class="sxs-lookup"><span data-stu-id="9bf39-214">When sending messages toohello backlog, one of these queues is randomly chosen.</span></span> <span data-ttu-id="9bf39-215">Hello 값 too1를 설정한 경우 하나의 큐 수 있습니다 사용할 적이 있습니다.</span><span class="sxs-lookup"><span data-stu-id="9bf39-215">If you set hello value too1, then only one queue can ever be used.</span></span> <span data-ttu-id="9bf39-216">이런 경우가 발생 하 고 오류를 생성 하는 hello 백로그 큐 하나를 hello 클라이언트 수 tootry 다른 백로그 큐 아니며 toosend 메시지 실패할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="9bf39-216">When this happens and hello one backlog queue generates errors, hello client is not able tootry a different backlog queue and may fail toosend your message.</span></span> <span data-ttu-id="9bf39-217">이 값 toosome 더 큰 값 및 기본 hello 값 too10를 설정 하는 것이 좋습니다.</span><span class="sxs-lookup"><span data-stu-id="9bf39-217">We recommend setting this value toosome larger value and default hello value too10.</span></span> <span data-ttu-id="9bf39-218">이 tooa 더 높은 바꾸거나 데이터 크기에 따라 값이 낮을수록 매일 보내는 응용 프로그램.</span><span class="sxs-lookup"><span data-stu-id="9bf39-218">You can change this tooa higher or lower value depending on how much data your application sends per day.</span></span> <span data-ttu-id="9bf39-219">각 백로그 큐는 메시지의 too5 GB를 보유할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="9bf39-219">Each backlog queue can hold up too5 GB of messages.</span></span>
* <span data-ttu-id="9bf39-220">*failoverInterval*:는 toohello 보조 네임 스페이스를 통해 모든 단일 엔터티를 전환 하기 전에 hello 기본 네임 스페이스에서 실패에 허용 되는 시간의 hello 크기입니다.</span><span class="sxs-lookup"><span data-stu-id="9bf39-220">*failoverInterval*: hello amount of time during which you will accept failures on hello primary namespace before switching any single entity over toohello secondary namespace.</span></span> <span data-ttu-id="9bf39-221">장애 조치는 엔터티 단위로 발생합니다.</span><span class="sxs-lookup"><span data-stu-id="9bf39-221">Failovers occur on an entity-by-entity basis.</span></span> <span data-ttu-id="9bf39-222">단일 네임스페이스의 엔터티는 주로 서비스 버스 내의 다른 노드에 있습니다.</span><span class="sxs-lookup"><span data-stu-id="9bf39-222">Entities in a single namespace frequently live in different nodes within Service Bus.</span></span> <span data-ttu-id="9bf39-223">한 엔터티의 오류가 다른 오류를 의미하지는 않습니다.</span><span class="sxs-lookup"><span data-stu-id="9bf39-223">A failure in one entity does not imply a failure in another.</span></span> <span data-ttu-id="9bf39-224">이 값을 너무 설정할 수[System.TimeSpan.Zero] [ System.TimeSpan.Zero] toofailover toohello 첫 번째, 일시적이 지 않은 오류 직후 보조 합니다.</span><span class="sxs-lookup"><span data-stu-id="9bf39-224">You can set this value too[System.TimeSpan.Zero][System.TimeSpan.Zero] toofailover toohello secondary immediately after your first, non-transient failure.</span></span> <span data-ttu-id="9bf39-225">하며 hello 장애 조치 타이머를 트리거하는 오류는 변수가 [MessagingException] [ MessagingException] 어떤 hello에 [IsTransient] [ IsTransient] 속성은 false, 또는 [System.TimeoutException][System.TimeoutException]합니다.</span><span class="sxs-lookup"><span data-stu-id="9bf39-225">Failures that trigger hello failover timer are any [MessagingException][MessagingException] in which hello [IsTransient][IsTransient] property is false, or a [System.TimeoutException][System.TimeoutException].</span></span> <span data-ttu-id="9bf39-226">다른 예외와 같은 [UnauthorizedAccessException] [ UnauthorizedAccessException] hello 클라이언트를 올바르게 구성 되어를 나타내기 때문에 장애를 일으키지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="9bf39-226">Other exceptions, such as [UnauthorizedAccessException][UnauthorizedAccessException] do not cause failover, because they indicate that hello client is configured incorrectly.</span></span> <span data-ttu-id="9bf39-227">A [ServerBusyException] [ ServerBusyException] 않는 원인 장애 조치 되지 hello 올바른 패턴은 toowait 10 초이지만 시간 때문에 다음 hello 메시지를 다시 보냅니다.</span><span class="sxs-lookup"><span data-stu-id="9bf39-227">A [ServerBusyException][ServerBusyException] does not cause failover because hello correct pattern is toowait 10 seconds, then send hello message again.</span></span>
* <span data-ttu-id="9bf39-228">*enableSyphon*:는 특정 쌍이 되어야 또한 사이 펀 hello 보조 네임 스페이스 백 toohello 기본 네임 스페이스에서 메시지를 나타냅니다.</span><span class="sxs-lookup"><span data-stu-id="9bf39-228">*enableSyphon*: Indicates that this particular pairing should also syphon messages from hello secondary namespace back toohello primary namespace.</span></span> <span data-ttu-id="9bf39-229">일반적으로 메시지를 보내는 응용 프로그램을 설정 해야이 값이 너무**false**; 메시지를 수신 하는 응용 프로그램 너무이 값을 설정 해야**true**합니다.</span><span class="sxs-lookup"><span data-stu-id="9bf39-229">In general, applications that send messages should set this value too**false**; applications that receive messages should set this value too**true**.</span></span> <span data-ttu-id="9bf39-230">hello 이유는 있는지 자주 적은 메시지 발신자 보다 수신자입니다.</span><span class="sxs-lookup"><span data-stu-id="9bf39-230">hello reason for this is that frequently, there are fewer message receivers than message senders.</span></span> <span data-ttu-id="9bf39-231">수신자의 hello 수에 따라 toohave 단일 응용 프로그램 인스턴스 핸들 hello 사이 펀 의무를 선택할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="9bf39-231">Depending on hello number of receivers, you can choose toohave a single application instance handle hello syphon duties.</span></span> <span data-ttu-id="9bf39-232">여러 수신자를 사용하면 각 백로그 큐에 비용 청구의 영향을 미칩니다.</span><span class="sxs-lookup"><span data-stu-id="9bf39-232">Using many receivers has billing implications for each backlog queue.</span></span>

<span data-ttu-id="9bf39-233">toouse 코드 hello, 기본 만들 [MessagingFactory] [ MessagingFactory] 인스턴스, 보조 [MessagingFactory] [ MessagingFactory] 인스턴스, 보조 [NamespaceManager] [ NamespaceManager] 인스턴스 및 [SendAvailabilityPairedNamespaceOptions] [ SendAvailabilityPairedNamespaceOptions] 인스턴스.</span><span class="sxs-lookup"><span data-stu-id="9bf39-233">toouse hello code, create a primary [MessagingFactory][MessagingFactory] instance, a secondary [MessagingFactory][MessagingFactory] instance, a secondary [NamespaceManager][NamespaceManager] instance, and a [SendAvailabilityPairedNamespaceOptions][SendAvailabilityPairedNamespaceOptions] instance.</span></span> <span data-ttu-id="9bf39-234">hello 호출 hello 다음과 같이 간단할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="9bf39-234">hello call can be as simple as hello following:</span></span>

```csharp
SendAvailabilityPairedNamespaceOptions sendAvailabilityOptions = new SendAvailabilityPairedNamespaceOptions(secondaryNamespaceManager, secondary);
primary.PairNamespaceAsync(sendAvailabilityOptions).Wait();
```

<span data-ttu-id="9bf39-235">Hello에서 반환 된 작업을 hello 때 [PairNamespaceAsync] [ PairNamespaceAsync] 메서드가 완료 되 면 모든 항목이 설치 되 고 toouse 준비 합니다.</span><span class="sxs-lookup"><span data-stu-id="9bf39-235">When hello task returned by hello [PairNamespaceAsync][PairNamespaceAsync] method completes, everything is set up and ready toouse.</span></span> <span data-ttu-id="9bf39-236">Hello 작업이 반환 되기 전에 있습니다 완료 하지 않았을 수도 hello toowork 오른쪽 쌍으로 연결 하는 데 필요한 hello 백그라운드 작업을 모두 합니다.</span><span class="sxs-lookup"><span data-stu-id="9bf39-236">Before hello task is returned, you may not have completed all of hello background work necessary for hello pairing toowork right.</span></span> <span data-ttu-id="9bf39-237">결과적으로 시작 하지 않아야 hello 작업 반환 될 때까지 메시지를 송신 합니다.</span><span class="sxs-lookup"><span data-stu-id="9bf39-237">As a result, you should not start sending messages until hello task returns.</span></span> <span data-ttu-id="9bf39-238">잘못 된 자격 증명 또는 오류 toocreate hello 백로그 큐와 같은 오류가 발생 한 hello 작업이 완료 되 면이 예외가 throw 됩니다.</span><span class="sxs-lookup"><span data-stu-id="9bf39-238">If any failures occurred, such as bad credentials, or failure toocreate hello backlog queues, those exceptions will be thrown once hello task completes.</span></span> <span data-ttu-id="9bf39-239">Hello 큐 발견 되거나 hello를 검사 하 여 생성 된 hello 작업 반환 되 면 확인 [BacklogQueueCount] [ BacklogQueueCount] 속성에 사용자 [SendAvailabilityPairedNamespaceOptions] [ SendAvailabilityPairedNamespaceOptions] 인스턴스.</span><span class="sxs-lookup"><span data-stu-id="9bf39-239">Once hello task returns, verify that hello queues were found or created by examining hello [BacklogQueueCount][BacklogQueueCount] property on your [SendAvailabilityPairedNamespaceOptions][SendAvailabilityPairedNamespaceOptions] instance.</span></span> <span data-ttu-id="9bf39-240">코드 앞에 오는 hello에 대 한 작업을 다음과 같이 나타납니다.</span><span class="sxs-lookup"><span data-stu-id="9bf39-240">For hello preceding code, that operation appears as follows:</span></span>

```csharp
if (sendAvailabilityOptions.BacklogQueueCount < 1)
{
    // Handle case where no queues were created.
}
```

## <a name="next-steps"></a><span data-ttu-id="9bf39-241">다음 단계</span><span class="sxs-lookup"><span data-stu-id="9bf39-241">Next steps</span></span>
<span data-ttu-id="9bf39-242">서비스 버스의 비동기 메시징 hello 기본 사항 학습 한, 했으므로 대 한 자세한 내용을 보려면 [네임 스페이스 쌍이][paired namespaces]합니다.</span><span class="sxs-lookup"><span data-stu-id="9bf39-242">Now that you've learned hello basics of asynchronous messaging in Service Bus, read more details about [paired namespaces][paired namespaces].</span></span>

[ServerBusyException]: /dotnet/api/microsoft.servicebus.messaging.serverbusyexception
[System.TimeoutException]: https://msdn.microsoft.com/library/system.timeoutexception.aspx
[MessagingException]: /dotnet/api/microsoft.servicebus.messaging.messagingexception
[Best practices for insulating applications against Service Bus outages and disasters]: service-bus-outages-disasters.md
[Microsoft.ServiceBus.Messaging.MessagingFactory]: /dotnet/api/microsoft.servicebus.messaging.messagingfactory
[MessageReceiver]: /dotnet/api/microsoft.servicebus.messaging.messagereceiver
[QueueClient]: /dotnet/api/microsoft.servicebus.messaging.queueclient
[TopicClient]: /dotnet/api/microsoft.servicebus.messaging.topicclient
[Microsoft.ServiceBus.Messaging.PairedNamespaceOptions]: /dotnet/api/microsoft.servicebus.messaging.pairednamespaceoptions
[MessagingFactory]: /dotnet/api/microsoft.servicebus.messaging.messagingfactory
[SendAvailabilityPairedNamespaceOptions]: /dotnet/api/microsoft.servicebus.messaging.sendavailabilitypairednamespaceoptions
[NamespaceManager]: /dotnet/api/microsoft.servicebus.namespacemanager
[PairNamespaceAsync]: /dotnet/api/microsoft.servicebus.messaging.messagingfactory#Microsoft_ServiceBus_Messaging_MessagingFactory_PairNamespaceAsync_Microsoft_ServiceBus_Messaging_PairedNamespaceOptions_
[EnableSyphon]: /dotnet/api/microsoft.servicebus.messaging.sendavailabilitypairednamespaceoptions#Microsoft_ServiceBus_Messaging_SendAvailabilityPairedNamespaceOptions_EnableSyphon
[System.TimeSpan.Zero]: https://msdn.microsoft.com/library/system.timespan.zero.aspx
[IsTransient]: /dotnet/api/microsoft.servicebus.messaging.messagingexception#Microsoft_ServiceBus_Messaging_MessagingException_IsTransient
[UnauthorizedAccessException]: https://msdn.microsoft.com/library/system.unauthorizedaccessexception.aspx
[BacklogQueueCount]: /dotnet/api/microsoft.servicebus.messaging.sendavailabilitypairednamespaceoptions?redirectedfrom=MSDN#Microsoft_ServiceBus_Messaging_SendAvailabilityPairedNamespaceOptions_BacklogQueueCount
[paired namespaces]: service-bus-paired-namespaces.md
