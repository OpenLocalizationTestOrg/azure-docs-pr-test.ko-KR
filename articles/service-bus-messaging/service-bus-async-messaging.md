---
title: "Service Bus 비동기 메시징 | Microsoft Docs"
description: "Azure Service Bus 비동기 메시지에 대한 설명입니다."
services: service-bus-messaging
documentationcenter: na
author: sethmanheim
manager: timlt
editor: 
ms.assetid: f1435549-e1f2-40cb-a280-64ea07b39fc7
ms.service: service-bus-messaging
ms.devlang: na
ms.topic: article
ms.tgt_pltfrm: na
ms.workload: na
ms.date: 04/19/2017
ms.author: sethm
ms.openlocfilehash: 95d6f295ba145a55fe4ed3fc7c6f627c9d419a3c
ms.sourcegitcommit: f537befafb079256fba0529ee554c034d73f36b0
ms.translationtype: MT
ms.contentlocale: ko-KR
ms.lasthandoff: 07/11/2017
---
# <a name="asynchronous-messaging-patterns-and-high-availability"></a><span data-ttu-id="e3b73-103">비동기 메시징 패턴 및 고가용성</span><span class="sxs-lookup"><span data-stu-id="e3b73-103">Asynchronous messaging patterns and high availability</span></span>

<span data-ttu-id="e3b73-104">비동기 메시징은 다양한 방식으로 구현할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="e3b73-104">Asynchronous messaging can be implemented in a variety of different ways.</span></span> <span data-ttu-id="e3b73-105">큐, 토픽 및 구독으로 Azure Service Bus는 저장소 및 전달 메커니즘을 통해 비동기를 지원합니다.</span><span class="sxs-lookup"><span data-stu-id="e3b73-105">With queues, topics, and subscriptions, Azure Service Bus supports asynchronism via a store and forward mechanism.</span></span> <span data-ttu-id="e3b73-106">정상(동기) 작업에서 큐 및 토픽에 메시지를 보내고 큐 및 구독에서 메시지를 받습니다.</span><span class="sxs-lookup"><span data-stu-id="e3b73-106">In normal (synchronous) operation, you send messages to queues and topics, and receive messages from queues and subscriptions.</span></span> <span data-ttu-id="e3b73-107">작성하는 응용 프로그램은 항상 사용 가능한 이러한 엔터티에 따라 다릅니다.</span><span class="sxs-lookup"><span data-stu-id="e3b73-107">Applications you write depend on these entities always being available.</span></span> <span data-ttu-id="e3b73-108">다양한 상황으로 인해 엔터티 상태가 변경되면 대부분의 요구를 충족할 수 있는 축소된 기능 엔터티를 제공하는 방법이 필요합니다.</span><span class="sxs-lookup"><span data-stu-id="e3b73-108">When the entity health changes, due to a variety of circumstances, you need a way to provide a reduced capability entity that can satisfy most needs.</span></span>

<span data-ttu-id="e3b73-109">일반적으로 응용 프로그램은 비동기 메시징 패턴을 사용하여 다양한 통신 시나리오를 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="e3b73-109">Applications typically use asynchronous messaging patterns to enable a number of communication scenarios.</span></span> <span data-ttu-id="e3b73-110">서비스가 실행 중이지 않을 경우에도 클라이언트가 서비스로 메시지를 보낼 수 있는 응용 프로그램을 빌드할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="e3b73-110">You can build applications in which clients can send messages to services, even when the service is not running.</span></span> <span data-ttu-id="e3b73-111">통신의 버스트를 경험한 응용 프로그램의 경우 큐는 통신을 버퍼링할 장소를 제공하여 부하를 일정하게 할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="e3b73-111">For applications that experience bursts of communications, a queue can help level the load by providing a place to buffer communications.</span></span> <span data-ttu-id="e3b73-112">마지막으로 여러 컴퓨터 간에 메시지를 배포하는 간단하면서도 효율적인 부하 분산 장치를 얻을 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="e3b73-112">Finally, you can get a simple but effective load balancer to distribute messages across multiple machines.</span></span>

<span data-ttu-id="e3b73-113">이러한 엔터티의 가용성을 유지 관리하기 위해 이러한 엔터티가 지속 가능한 메시징 시스템에 사용 불가하다고 나타날 수 있는 다양한 다른 방법을 고려합니다.</span><span class="sxs-lookup"><span data-stu-id="e3b73-113">In order to maintain availability of any of these entities, consider a number of different ways in which these entities can appear unavailable for a durable messaging system.</span></span> <span data-ttu-id="e3b73-114">일반적으로 말해서 다음의 다른 방법으로 작성한 응용 프로그램에서 사용할 수 없게 되는 엔터티를 봅니다.</span><span class="sxs-lookup"><span data-stu-id="e3b73-114">Generally speaking, we see the entity become unavailable to applications we write in the following different ways:</span></span>

* <span data-ttu-id="e3b73-115">메시지를 보낼 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="e3b73-115">Unable to send messages.</span></span>
* <span data-ttu-id="e3b73-116">메시지를 받을 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="e3b73-116">Unable to receive messages.</span></span>
* <span data-ttu-id="e3b73-117">엔터티를 관리할 수 없습니다(엔터티 만들기, 검색, 업데이트 또는 삭제).</span><span class="sxs-lookup"><span data-stu-id="e3b73-117">Unable to manage entities (create, retrieve, update, or delete entities).</span></span>
* <span data-ttu-id="e3b73-118">서비스에 연결할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="e3b73-118">Unable to contact the service.</span></span>

<span data-ttu-id="e3b73-119">이러한 각 오류의 경우 다른 오류 모드는 응용 프로그램이 기능이 축소된 수준에서 계속 작업을 수행할 수 있도록 존재합니다.</span><span class="sxs-lookup"><span data-stu-id="e3b73-119">For each of these failures, different failure modes exist that enable an application to continue to perform work at some level of reduced capability.</span></span> <span data-ttu-id="e3b73-120">예를 들어 메시지를 보낼 수 있지만 받지 않는 시스템은 고객의 주문을 받을 수 있지만 이러한 주문을 처리할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="e3b73-120">For example, a system that can send messages but not receive them can still receive orders from customers but cannot process those orders.</span></span> <span data-ttu-id="e3b73-121">이 항목에서는 발생할 수 있는 잠재적인 문제 및 이러한 문제를 줄이는 방법을 설명합니다.</span><span class="sxs-lookup"><span data-stu-id="e3b73-121">This topic discusses potential issues that can occur, and how those issues are mitigated.</span></span> <span data-ttu-id="e3b73-122">Service Bus는 선택해야 하는 다양한 완화 방법을 도입하고 또한 이 항목도 이러한 옵트인 완화 방법의 사용을 제어하는 규칙을 설명합니다.</span><span class="sxs-lookup"><span data-stu-id="e3b73-122">Service Bus has introduced a number of mitigations which you must opt into, and this topic also discusses the rules governing the use of those opt-in mitigations.</span></span>

## <a name="reliability-in-service-bus"></a><span data-ttu-id="e3b73-123">서비스 버스의 안정성</span><span class="sxs-lookup"><span data-stu-id="e3b73-123">Reliability in Service Bus</span></span>
<span data-ttu-id="e3b73-124">메시지와 엔터티 문제를 처리하는 여러 방법이 있고 이러한 완화 방법을 적절하게 사용하도록 관리하는 지침이 있습니다.</span><span class="sxs-lookup"><span data-stu-id="e3b73-124">There are several ways to handle message and entity issues, and there are guidelines governing the appropriate use of those mitigations.</span></span> <span data-ttu-id="e3b73-125">지침을 이해하려면 먼저 서비스 버스에서 무엇이 실패할 수 있는지 이해해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="e3b73-125">To understand the guidelines, you must first understand what can fail in Service Bus.</span></span> <span data-ttu-id="e3b73-126">Azure 시스템의 설계로 인해 이러한 문제는 모두 수명이 짧은 경향이 있습니다.</span><span class="sxs-lookup"><span data-stu-id="e3b73-126">Due to the design of Azure systems, all of these issues tend to be short-lived.</span></span> <span data-ttu-id="e3b73-127">높은 수준에서 사용할 수 없는 다른 원인은 다음과 같이 나타납니다.</span><span class="sxs-lookup"><span data-stu-id="e3b73-127">At a high level, the different causes of unavailability appear as follows:</span></span>

* <span data-ttu-id="e3b73-128">서비스 버스가 의존하는 외부 시스템에서 제한합니다.</span><span class="sxs-lookup"><span data-stu-id="e3b73-128">Throttling from an external system on which Service Bus depends.</span></span> <span data-ttu-id="e3b73-129">제한은 계산 및 저장소 리소스와의 상호작용에서 발생합니다.</span><span class="sxs-lookup"><span data-stu-id="e3b73-129">Throttling occurs from interactions with storage and compute resources.</span></span>
* <span data-ttu-id="e3b73-130">서비스 버스가 의존하는 시스템에서 발생하는 문제입니다.</span><span class="sxs-lookup"><span data-stu-id="e3b73-130">Issue for a system on which Service Bus depends.</span></span> <span data-ttu-id="e3b73-131">예를 들어 저장소의 특정 부분에 문제가 발생할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="e3b73-131">For example, a given part of storage can encounter issues.</span></span>
* <span data-ttu-id="e3b73-132">단일 하위 시스템에서 서비스 버스의 오류입니다.</span><span class="sxs-lookup"><span data-stu-id="e3b73-132">Failure of Service Bus on single subsystem.</span></span> <span data-ttu-id="e3b73-133">이 상황에서 계산 노드는 일관성이 없는 상태일 수 있으며 자체를 다시 시작해야 하며 이는 부하를 다른 노드로 분산하는 모든 엔터티를 발생시킵니다.</span><span class="sxs-lookup"><span data-stu-id="e3b73-133">In this situation, a compute node can get into an inconsistent state and must restart itself, causing all entities it serves to load balance to other nodes.</span></span> <span data-ttu-id="e3b73-134">단기간 동안 차례로 메시지 처리 속도가 느려질 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="e3b73-134">This in turn can cause a short period of slow message processing.</span></span>
* <span data-ttu-id="e3b73-135">Azure 데이터 센터 내에서 서비스 버스의 오류입니다.</span><span class="sxs-lookup"><span data-stu-id="e3b73-135">Failure of Service Bus within an Azure datacenter.</span></span> <span data-ttu-id="e3b73-136">몇 분 또는 몇 시간 동안 시스템에 연결할 수 없는 "치명적 오류"입니다.</span><span class="sxs-lookup"><span data-stu-id="e3b73-136">This is a "catastrophic failure" during which the system is unreachable for many minutes or a few hours.</span></span>

> [!NOTE]
> <span data-ttu-id="e3b73-137">용어 **저장소**는 Azure Storage 및 SQL Azure를 의미할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="e3b73-137">The term **storage** can mean both Azure Storage and SQL Azure.</span></span>
> 
> 

<span data-ttu-id="e3b73-138">서비스 버스는 이런 문제에 대한 다양한 완화 방법을 포함합니다.</span><span class="sxs-lookup"><span data-stu-id="e3b73-138">Service Bus contains a number of mitigations for these issues.</span></span> <span data-ttu-id="e3b73-139">다음 섹션에서는 각 문제 및 해당 완화 방법을 설명합니다.</span><span class="sxs-lookup"><span data-stu-id="e3b73-139">The following sections discuss each issue and their respective mitigations.</span></span>

### <a name="throttling"></a><span data-ttu-id="e3b73-140">제한</span><span class="sxs-lookup"><span data-stu-id="e3b73-140">Throttling</span></span>
<span data-ttu-id="e3b73-141">서비스 버스로 제한을 사용하면 공동으로 메시지 속도를 관리할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="e3b73-141">With Service Bus, throttling enables cooperative message rate management.</span></span> <span data-ttu-id="e3b73-142">각 개별 서비스 버스 노드가 여러 엔터티가 있습니다.</span><span class="sxs-lookup"><span data-stu-id="e3b73-142">Each individual Service Bus node houses many entities.</span></span> <span data-ttu-id="e3b73-143">이러한 각 엔터티는 CPU, 메모리, 저장소 및 기타 측면에서 시스템에 요청을 만듭니다.</span><span class="sxs-lookup"><span data-stu-id="e3b73-143">Each of those entities makes demands on the system in terms of CPU, memory, storage, and other facets.</span></span> <span data-ttu-id="e3b73-144">패싯이 정의된 임계값을 초과하는 사용을 감지하면 서비스 버스는 지정된 요청을 거부할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="e3b73-144">When any of these facets detects usage that exceeds defined thresholds, Service Bus can deny a given request.</span></span> <span data-ttu-id="e3b73-145">호출자는 [ServerBusyException][ServerBusyException]을 수신하고 10 초 후에 다시 시도합니다.</span><span class="sxs-lookup"><span data-stu-id="e3b73-145">The caller receives a [ServerBusyException][ServerBusyException] and retries after 10 seconds.</span></span>

<span data-ttu-id="e3b73-146">완화 방법으로 코드는 오류를 읽고 적어도 10초 동안 메시지의 다시 시도를 중단해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="e3b73-146">As a mitigation, the code must read the error and halt any retries of the message for at least 10 seconds.</span></span> <span data-ttu-id="e3b73-147">오류는 고객 응용 프로그램의 조각에 발생할 수 있으므로 각 조각이 재시도 논리를 독립적으로 실행한다고 예상됩니다.</span><span class="sxs-lookup"><span data-stu-id="e3b73-147">Since the error can happen across pieces of the customer application, it is expected that each piece independently executes the retry logic.</span></span> <span data-ttu-id="e3b73-148">코드는 큐 또는 토픽에서 분할을 사용하여 제한될 가능성을 줄일 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="e3b73-148">The code can reduce the probability of being throttled by enabling partitioning on a queue or topic.</span></span>

### <a name="issue-for-an-azure-dependency"></a><span data-ttu-id="e3b73-149">Azure 종속성에서 발생하는 문제</span><span class="sxs-lookup"><span data-stu-id="e3b73-149">Issue for an Azure dependency</span></span>
<span data-ttu-id="e3b73-150">Azure 내의 다른 구성 요소에는 서비스 문제가 있는 경우도 있습니다.</span><span class="sxs-lookup"><span data-stu-id="e3b73-150">Other components within Azure can occasionally have service issues.</span></span> <span data-ttu-id="e3b73-151">예를 들어 서비스 버스가 사용하는 시스템이 업그레이드되는 경우 해당 시스템은 일시적으로 기능이 축소될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="e3b73-151">For example, when a system that Service Bus uses is being upgraded, that system can temporarily experience reduced capabilities.</span></span> <span data-ttu-id="e3b73-152">이러한 유형의 문제를 해결하려면 서비스 버스가 정기적으로 완화 방법을 조사하고 구현합니다.</span><span class="sxs-lookup"><span data-stu-id="e3b73-152">To work around these types of issues, Service Bus regularly investigates and implements mitigations.</span></span> <span data-ttu-id="e3b73-153">이러한 완화의 부작용도 물론 나타납니다.</span><span class="sxs-lookup"><span data-stu-id="e3b73-153">Side effects of these mitigations do appear.</span></span> <span data-ttu-id="e3b73-154">예를 들어 저장소에서 발생하는 일시적인 문제를 처리하려면 서비스 버스가 일관되 게 작동하도록 메시지 보내기 작업을 허용하는 시스템을 구현합니다.</span><span class="sxs-lookup"><span data-stu-id="e3b73-154">For example, to handle transient issues with storage, Service Bus implements a system that allows message send operations to work consistently.</span></span> <span data-ttu-id="e3b73-155">완화 방법의 특성 상 보낸 메시지는 영향을 받는 큐 또는 구독에 표시되고 수신 작업을 준비하는 데 최대 15분이 걸릴 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="e3b73-155">Due to the nature of the mitigation, a sent message can take up to 15 minutes to appear in the affected queue or subscription and be ready for a receive operation.</span></span> <span data-ttu-id="e3b73-156">일반적으로 엔터티에는 대부분 이 문제가 발생하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="e3b73-156">Generally speaking, most entities will not experience this issue.</span></span> <span data-ttu-id="e3b73-157">그러나 Azure 내에서 서비스 버스의 엔터티 수를 고려하면 이 완화 방법은 종종 서비스 버스 고객의 작은 하위 집합에 필요합니다.</span><span class="sxs-lookup"><span data-stu-id="e3b73-157">However, given the number of entities in Service Bus within Azure, this mitigation is sometimes needed for a small subset of Service Bus customers.</span></span>

### <a name="service-bus-failure-on-a-single-subsystem"></a><span data-ttu-id="e3b73-158">단일 하위 시스템에서 서비스 버스 오류</span><span class="sxs-lookup"><span data-stu-id="e3b73-158">Service Bus failure on a single subsystem</span></span>
<span data-ttu-id="e3b73-159">응용 프로그램의 경우 서비스 버스의 내부 구성 요소가 일치하지 않는 상황이 발생할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="e3b73-159">With any application, circumstances can cause an internal component of Service Bus to become inconsistent.</span></span> <span data-ttu-id="e3b73-160">서비스 버스가 이를 감지하는 경우 응용 프로그램에서 데이터를 수집하여 상황을 진단하기 위해 지원합니다.</span><span class="sxs-lookup"><span data-stu-id="e3b73-160">When Service Bus detects this, it collects data from the application to aid in diagnosing what happened.</span></span> <span data-ttu-id="e3b73-161">데이터가 수집되면 응용 프로그램은 일관 된 상태로 반환하기 위해 다시 시작됩니다.</span><span class="sxs-lookup"><span data-stu-id="e3b73-161">Once the data is collected, the application is restarted in an attempt to return it to a consistent state.</span></span> <span data-ttu-id="e3b73-162">이 프로세스는 매우 신속하게 발생하고 엔터티가 최대 몇 분 동안 사용 불가 상태로 나타날 수 있지만 일반적인 가동 중지 시간은 훨씬 짧습니다.</span><span class="sxs-lookup"><span data-stu-id="e3b73-162">This process happens fairly quickly, and results in an entity appearing to be unavailable for up to a few minutes, though typical down times are much shorter.</span></span>

<span data-ttu-id="e3b73-163">이러한 경우 클라이언트 응용 프로그램은 [System.TimeoutException][System.TimeoutException] 또는 [MessagingException][MessagingException] 예외를 생성합니다.</span><span class="sxs-lookup"><span data-stu-id="e3b73-163">In these cases, the client application generates a [System.TimeoutException][System.TimeoutException] or [MessagingException][MessagingException] exception.</span></span> <span data-ttu-id="e3b73-164">서비스 버스는 자동화된 클라이언트 다시 시도 논리의 형태로 이 문제에 대한 완화 방법을 포함합니다.</span><span class="sxs-lookup"><span data-stu-id="e3b73-164">Service Bus contains a mitigation for this issue in the form of automated client retry logic.</span></span> <span data-ttu-id="e3b73-165">다시 시도 기간이 끝나고 메시지가 전달되지 않으면 [쌍을 이루는 네임스페이스][paired namespaces]와 같은 다른 기능을 사용하여 탐색할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="e3b73-165">Once the retry period is exhausted and the message is not delivered, you can explore using other features such as [paired namespaces][paired namespaces].</span></span> <span data-ttu-id="e3b73-166">쌍을 이루는 네임스페이스에는 이 문서에서 설명하는 다른 주의 사항이 있습니다.</span><span class="sxs-lookup"><span data-stu-id="e3b73-166">Paired namespaces have other caveats that are discussed in that article.</span></span>

### <a name="failure-of-service-bus-within-an-azure-datacenter"></a><span data-ttu-id="e3b73-167">Azure 데이터 센터 내에서 서비스 버스의 오류</span><span class="sxs-lookup"><span data-stu-id="e3b73-167">Failure of Service Bus within an Azure datacenter</span></span>
<span data-ttu-id="e3b73-168">Azure 데이터 센터에 장애에 대한 가장 가능성이 높은 원인은 서비스 버스 또는 종속 시스템의 업그레이드 배포 실패입니다.</span><span class="sxs-lookup"><span data-stu-id="e3b73-168">The most probable reason for a failure in an Azure datacenter is a failed upgrade deployment of Service Bus or a dependent system.</span></span> <span data-ttu-id="e3b73-169">플랫폼이 완성되어 이러한 유형의 오류가 발생할 가능성이 감소했습니다.</span><span class="sxs-lookup"><span data-stu-id="e3b73-169">As the platform has matured, the likelihood of this type of failure has diminished.</span></span> <span data-ttu-id="e3b73-170">또한 데이터 센터 장애가 다음과 같은 이유로 발생할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="e3b73-170">A datacenter failure can also happen for reasons that include the following:</span></span>

* <span data-ttu-id="e3b73-171">전기 중단(전력 공급 및 전력 생산 불가).</span><span class="sxs-lookup"><span data-stu-id="e3b73-171">Electrical outage (power supply and generating power disappear).</span></span>
* <span data-ttu-id="e3b73-172">연결.(클라이언트와 Azure 간에 인터넷 끊김)</span><span class="sxs-lookup"><span data-stu-id="e3b73-172">Connectivity (internet break between your clients and Azure).</span></span>

<span data-ttu-id="e3b73-173">두 경우 모두 자연 재해 또는 인재가 문제를 발생시킵니다.</span><span class="sxs-lookup"><span data-stu-id="e3b73-173">In both cases, a natural or man-made disaster caused the issue.</span></span> <span data-ttu-id="e3b73-174">이 문제를 해결하고 메시지를 보낼 수 있는지 확인하려면 [쌍을 이루는 네임스페이스][paired namespaces]를 사용하여 기본 위치가 다시 정상인 동안 메시지를 보조 위치로 보내도록 할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="e3b73-174">To work around this and make sure that you can still send messages, you can use [paired namespaces][paired namespaces] to enable messages to be sent to a second location while the primary location is made healthy again.</span></span> <span data-ttu-id="e3b73-175">자세한 정보는 [Service Bus 중단 및 재해로부터 응용 프로그램을 보호하는 모범 사례][Best practices for insulating applications against Service Bus outages and disasters]를 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="e3b73-175">For more information, see [Best practices for insulating applications against Service Bus outages and disasters][Best practices for insulating applications against Service Bus outages and disasters].</span></span>

## <a name="paired-namespaces"></a><span data-ttu-id="e3b73-176">쌍을 이루는 네임스페이스</span><span class="sxs-lookup"><span data-stu-id="e3b73-176">Paired namespaces</span></span>
<span data-ttu-id="e3b73-177">[쌍을 이루는 네임스페이스][paired namespaces] 기능은 데이터 센터 내의 Service Bus 엔터티 또는 배포가 사용할 수 없게 된 시나리오를 지원합니다.</span><span class="sxs-lookup"><span data-stu-id="e3b73-177">The [paired namespaces][paired namespaces] feature supports scenarios in which a Service Bus entity or deployment within a data center becomes unavailable.</span></span> <span data-ttu-id="e3b73-178">이 이벤트가 드물게 발생하는 반면 분산된 시스템은 여전히 최악의 시나리오를 처리하기 위해 준비되어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="e3b73-178">While this event occurs infrequently, distributed systems still must be prepared to handle worst case scenarios.</span></span> <span data-ttu-id="e3b73-179">일반적으로 이 이벤트는 서비스 버스가 의존 하는 일부 요소가 수명이 짧기 때문에 발생합니다.</span><span class="sxs-lookup"><span data-stu-id="e3b73-179">Typically, this event happens because some element on which Service Bus depends is experiencing a short-term issue.</span></span> <span data-ttu-id="e3b73-180">정전 중 응용 프로그램 가용성을 유지 관리하려면 서비스 버스 사용자가 가급적이면 별도 데이터 센터에서 두 개의 별도 네임스페이스를 사용하여 메시징 엔터티를 호스팅할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="e3b73-180">To maintain application availability during an outage, Service Bus users can use two separate namespaces, preferably in separate data centers, to host their messaging entities.</span></span> <span data-ttu-id="e3b73-181">이 섹션의 나머지 부분에서는 다음과 같은 용어를 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="e3b73-181">The remainder of this section uses the following terminology:</span></span>

* <span data-ttu-id="e3b73-182">기본 네임스페이스: 응용 프로그램이 상호 작용하는 네임스페이스가 작업을 보내고 받습니다.</span><span class="sxs-lookup"><span data-stu-id="e3b73-182">Primary namespace: The namespace with which your application interacts, for send and receive operations.</span></span>
* <span data-ttu-id="e3b73-183">보조 네임스페이스: 기본 네임스페이스에 대한 백업의 역할을 하는 네임스페이스입니다.</span><span class="sxs-lookup"><span data-stu-id="e3b73-183">Secondary namespace: The namespace that acts as a backup to the primary namespace.</span></span> <span data-ttu-id="e3b73-184">응용 프로그램 논리는 이 네임스페이스 상호작용하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="e3b73-184">Application logic does not interact with this namespace.</span></span>
* <span data-ttu-id="e3b73-185">장애 조치 간격: 응용 프로그램이 기본 네임 스페이스에서 보조 네임스페이스로 전환하기 전에 일반적인 오류를 수락하는 시간의 양입니다.</span><span class="sxs-lookup"><span data-stu-id="e3b73-185">Failover interval: The amount of time to accept normal failures before the application switches from the primary namespace to the secondary namespace.</span></span>

<span data-ttu-id="e3b73-186">쌍을 이루는 네임스페이스는 *가용성 보내기*를 지원합니다.</span><span class="sxs-lookup"><span data-stu-id="e3b73-186">Paired namespaces support *send availability*.</span></span> <span data-ttu-id="e3b73-187">보내기 가용성은 메시지를 보내는 기능을 보존합니다.</span><span class="sxs-lookup"><span data-stu-id="e3b73-187">Send availability preserves the ability to send messages.</span></span> <span data-ttu-id="e3b73-188">보내기 가용성을 사용하려면 응용 프로그램이 다음 요구 사항을 충족해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="e3b73-188">To use send availability, your application must meet the following requirements:</span></span>

1. <span data-ttu-id="e3b73-189">기본 네임스페이스에서 메시지를 수신할 수만 있습니다.</span><span class="sxs-lookup"><span data-stu-id="e3b73-189">Messages are only received from the primary namespace.</span></span>
2. <span data-ttu-id="e3b73-190">지정된 큐 또는 토픽으로 보낸 메시지는 잘못된 순서로 도착할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="e3b73-190">Messages sent to a given queue or topic might arrive out of order.</span></span>
3. <span data-ttu-id="e3b73-191">세션 내의 메시지가 잘못된 순서로 도착할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="e3b73-191">Messages within a session might arrive out of order.</span></span> <span data-ttu-id="e3b73-192">세션의 정상적인 기능에 문제가 생겼습니다.</span><span class="sxs-lookup"><span data-stu-id="e3b73-192">This is a break from normal functionality of sessions.</span></span> <span data-ttu-id="e3b73-193">응용 프로그램이 세션을 논리적으로 그룹 메시지에 사용하는 것을 의미합니다.</span><span class="sxs-lookup"><span data-stu-id="e3b73-193">This means that your application uses sessions to logically group messages.</span></span>
4. <span data-ttu-id="e3b73-194">세션 상태는 기본 네임스페이스에서 유지 관리됩니다.</span><span class="sxs-lookup"><span data-stu-id="e3b73-194">Session state is only maintained on the primary namespace.</span></span>
5. <span data-ttu-id="e3b73-195">보조 큐가 기본 큐에 모든 메시지를 전달하기 전에 기본 큐는 온라인이 되어 메시지를 수락하기 시작할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="e3b73-195">The primary queue can come online and start accepting messages before the secondary queue delivers all messages into the primary queue.</span></span>

<span data-ttu-id="e3b73-196">다음 섹션에서는 API, 즉 API가 어떻게 구현되는지를 설명하고 기능을 사용하는 샘플 코드를 보여줍니다.</span><span class="sxs-lookup"><span data-stu-id="e3b73-196">The following sections discuss the APIs, how the APIs are implemented, and shows sample code that uses the feature.</span></span> <span data-ttu-id="e3b73-197">이 기능과 관련된 비용이 청구될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="e3b73-197">Note that there are billing implications associated with this feature.</span></span>

### <a name="the-messagingfactorypairnamespaceasync-api"></a><span data-ttu-id="e3b73-198">The MessagingFactory.PairNamespaceAsync API</span><span class="sxs-lookup"><span data-stu-id="e3b73-198">The MessagingFactory.PairNamespaceAsync API</span></span>
<span data-ttu-id="e3b73-199">쌍을 이루는 네임스페이스 기능은 [Microsoft.ServiceBus.Messaging.MessagingFactory][Microsoft.ServiceBus.Messaging.MessagingFactory] 클래스에 [PairNamespaceAsync][PairNamespaceAsync] 메서드를 포함합니다.</span><span class="sxs-lookup"><span data-stu-id="e3b73-199">The paired namespaces feature includes the [PairNamespaceAsync][PairNamespaceAsync] method on the [Microsoft.ServiceBus.Messaging.MessagingFactory][Microsoft.ServiceBus.Messaging.MessagingFactory] class:</span></span>

```csharp
public Task PairNamespaceAsync(PairedNamespaceOptions options);
```

<span data-ttu-id="e3b73-200">작업이 완료되면 네임스페이스 쌍이 완료되고 [MessagingFactory][MessagingFactory] 인스턴스로 만든 [MessageReceiver][MessageReceiver], [QueueClient][QueueClient] 또는 [TopicClient][TopicClient]에 대해 작업할 준비가 됩니다.</span><span class="sxs-lookup"><span data-stu-id="e3b73-200">When the task completes, the namespace pairing is also complete and ready to act upon for any [MessageReceiver][MessageReceiver], [QueueClient][QueueClient], or [TopicClient][TopicClient] created with the [MessagingFactory][MessagingFactory] instance.</span></span> <span data-ttu-id="e3b73-201">[Microsoft.ServiceBus.Messaging.PairedNamespaceOptions][Microsoft.ServiceBus.Messaging.PairedNamespaceOptions]는 [MessagingFactory][MessagingFactory] 개체와 사용할 수 있는 다양한 유형의 쌍에 대한 기본 클래스입니다.</span><span class="sxs-lookup"><span data-stu-id="e3b73-201">[Microsoft.ServiceBus.Messaging.PairedNamespaceOptions][Microsoft.ServiceBus.Messaging.PairedNamespaceOptions] is the base class for the different types of pairing that are available with a [MessagingFactory][MessagingFactory] object.</span></span> <span data-ttu-id="e3b73-202">현재 유일하게 파생된 클래스는 [SendAvailabilityPairedNamespaceOptions][SendAvailabilityPairedNamespaceOptions]이며 이는 보내기 가용성 요구 사항을 구현합니다.</span><span class="sxs-lookup"><span data-stu-id="e3b73-202">Currently, the only derived class is one named [SendAvailabilityPairedNamespaceOptions][SendAvailabilityPairedNamespaceOptions], which implements the send availability requirements.</span></span> <span data-ttu-id="e3b73-203">[SendAvailabilityPairedNamespaceOptions][SendAvailabilityPairedNamespaceOptions]에는 서로 간에 빌드한 생성자의 집합이 있습니다.</span><span class="sxs-lookup"><span data-stu-id="e3b73-203">[SendAvailabilityPairedNamespaceOptions][SendAvailabilityPairedNamespaceOptions] has a set of constructors that build on each other.</span></span> <span data-ttu-id="e3b73-204">대부분의 매개 변수가 있는 생성자를 살펴보면 다른 생성자의 동작을 이해할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="e3b73-204">Looking at the constructor with the most parameters, you can understand the behavior of the other constructors.</span></span>

```csharp
public SendAvailabilityPairedNamespaceOptions(
    NamespaceManager secondaryNamespaceManager,
    MessagingFactory messagingFactory,
    int backlogQueueCount,
    TimeSpan failoverInterval,
    bool enableSyphon)
```

<span data-ttu-id="e3b73-205">이러한 매개 변수는 다음과 같은 의미가 있습니다.</span><span class="sxs-lookup"><span data-stu-id="e3b73-205">These parameters have the following meanings:</span></span>

* <span data-ttu-id="e3b73-206">*secondaryNamespaceManager*: [PairNamespaceAsync][PairNamespaceAsync] 메서드가 보조 네임스페이스를 설정하는 데 사용할 수 있는 보조 네임 스페이스에 대해 초기화된 [NamespaceManager][NamespaceManager] 인스턴스입니다.</span><span class="sxs-lookup"><span data-stu-id="e3b73-206">*secondaryNamespaceManager*: An initialized [NamespaceManager][NamespaceManager] instance for the secondary namespace that the [PairNamespaceAsync][PairNamespaceAsync] method can use to set up the secondary namespace.</span></span> <span data-ttu-id="e3b73-207">네임스페이스 관리자는 네임스페이스에서 큐 목록을 가져오고 필요한 백로그 큐가 존재하는지 확인하는 데 사용됩니다.</span><span class="sxs-lookup"><span data-stu-id="e3b73-207">The namespace manager is used to obtain the list of queues in the namespace and to make sure that the required backlog queues exist.</span></span> <span data-ttu-id="e3b73-208">이러한 큐가 존재하지 않는 경우 만들어집니다.</span><span class="sxs-lookup"><span data-stu-id="e3b73-208">If those queues do not exist, they are created.</span></span> <span data-ttu-id="e3b73-209">[NamespaceManager][NamespaceManager]는 **관리** 클레임으로 토큰을 만드는 기능을 필요로 합니다.</span><span class="sxs-lookup"><span data-stu-id="e3b73-209">[NamespaceManager][NamespaceManager] requires the ability to create a token with the **Manage** claim.</span></span>
* <span data-ttu-id="e3b73-210">*messagingFactory*: 보조 네임스페이스에 대한 [MessagingFactory][MessagingFactory] 인스턴스입니다.</span><span class="sxs-lookup"><span data-stu-id="e3b73-210">*messagingFactory*: The [MessagingFactory][MessagingFactory] instance for the secondary namespace.</span></span> <span data-ttu-id="e3b73-211">[EnableSyphon][EnableSyphon] 속성이 **true**로 설정된 경우 [MessagingFactory][MessagingFactory] 개체는 백로그 큐에서 메시지를 보내고 받는 데 사용됩니다.</span><span class="sxs-lookup"><span data-stu-id="e3b73-211">The [MessagingFactory][MessagingFactory] object is used to send and, if the [EnableSyphon][EnableSyphon] property is set to **true**, receive messages from the backlog queues.</span></span>
* <span data-ttu-id="e3b73-212">*backlogQueueCount*: 만들려는 백로그 큐의 수입니다.</span><span class="sxs-lookup"><span data-stu-id="e3b73-212">*backlogQueueCount*: The number of backlog queues to create.</span></span> <span data-ttu-id="e3b73-213">이 값은 적어도 1이어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="e3b73-213">This value must be at least 1.</span></span> <span data-ttu-id="e3b73-214">백로그에 메시지를 보낼 때 이러한 큐 중 하나가 무작위로 선택됩니다.</span><span class="sxs-lookup"><span data-stu-id="e3b73-214">When sending messages to the backlog, one of these queues is randomly chosen.</span></span> <span data-ttu-id="e3b73-215">값을 1로 설정한 경우 하나의 큐만 사용될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="e3b73-215">If you set the value to 1, then only one queue can ever be used.</span></span> <span data-ttu-id="e3b73-216">이 문제가 발생하고 백로그 큐 하나에서 오류를 생성하면 클라이언트는 다른 백로그 큐를 시도할 수 없고 메시지를 전송하는 데 실패할 수도 있습니다.</span><span class="sxs-lookup"><span data-stu-id="e3b73-216">When this happens and the one backlog queue generates errors, the client is not able to try a different backlog queue and may fail to send your message.</span></span> <span data-ttu-id="e3b73-217">이 값을 큰 값으로, 기본값을 10으로 설정하는 것이 좋습니다.</span><span class="sxs-lookup"><span data-stu-id="e3b73-217">We recommend setting this value to some larger value and default the value to 10.</span></span> <span data-ttu-id="e3b73-218">이 응용 프로그램에서 하루에 보내는 데이터의 크기에 따라 더 높거나 낮은 값으로 변경할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="e3b73-218">You can change this to a higher or lower value depending on how much data your application sends per day.</span></span> <span data-ttu-id="e3b73-219">각 백로그 큐는 최대 5GB의 메시지를 보관할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="e3b73-219">Each backlog queue can hold up to 5 GB of messages.</span></span>
* <span data-ttu-id="e3b73-220">*failoverInterval*: 모든 단일 엔터티를 보조 네임스페이스로 전환하기 전에 기본 네임스페이스에 발생한 오류를 수락하는 데 걸리는 시간입니다.</span><span class="sxs-lookup"><span data-stu-id="e3b73-220">*failoverInterval*: The amount of time during which you will accept failures on the primary namespace before switching any single entity over to the secondary namespace.</span></span> <span data-ttu-id="e3b73-221">장애 조치는 엔터티 단위로 발생합니다.</span><span class="sxs-lookup"><span data-stu-id="e3b73-221">Failovers occur on an entity-by-entity basis.</span></span> <span data-ttu-id="e3b73-222">단일 네임스페이스의 엔터티는 주로 서비스 버스 내의 다른 노드에 있습니다.</span><span class="sxs-lookup"><span data-stu-id="e3b73-222">Entities in a single namespace frequently live in different nodes within Service Bus.</span></span> <span data-ttu-id="e3b73-223">한 엔터티의 오류가 다른 오류를 의미하지는 않습니다.</span><span class="sxs-lookup"><span data-stu-id="e3b73-223">A failure in one entity does not imply a failure in another.</span></span> <span data-ttu-id="e3b73-224">이 값을 [System.TimeSpan.Zero][System.TimeSpan.Zero]로 설정하여 먼저 일시적이지 않은 오류가 발생한 후에 즉시 보조에 대한 장애 조치를 할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="e3b73-224">You can set this value to [System.TimeSpan.Zero][System.TimeSpan.Zero] to failover to the secondary immediately after your first, non-transient failure.</span></span> <span data-ttu-id="e3b73-225">장애 조치 타이머를 트리거하는 오류는 [IsTransient][IsTransient] 속성이 false 또는 [System.TimeoutException][System.TimeoutException]인 [MessagingException][MessagingException]입니다.</span><span class="sxs-lookup"><span data-stu-id="e3b73-225">Failures that trigger the failover timer are any [MessagingException][MessagingException] in which the [IsTransient][IsTransient] property is false, or a [System.TimeoutException][System.TimeoutException].</span></span> <span data-ttu-id="e3b73-226">[UnauthorizedAccessException][UnauthorizedAccessException]과 같은 다른 예외는 클라이언트가 잘못 구성되어 있다고 나타내기 때문에 장애 조치를 발생하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="e3b73-226">Other exceptions, such as [UnauthorizedAccessException][UnauthorizedAccessException] do not cause failover, because they indicate that the client is configured incorrectly.</span></span> <span data-ttu-id="e3b73-227">[ServerBusyException][ServerBusyException]은 올바른 패턴이 10초를 기다리고 다음 메시지를 다시 보내기 때문에 장애 조치를 발생하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="e3b73-227">A [ServerBusyException][ServerBusyException] does not cause failover because the correct pattern is to wait 10 seconds, then send the message again.</span></span>
* <span data-ttu-id="e3b73-228">*enableSyphon*: 또한 이러한 특정 쌍은 보조 네임스페이스에서 기본 네임스페이스에 다시 사이펀 메시지를 나타냅니다.</span><span class="sxs-lookup"><span data-stu-id="e3b73-228">*enableSyphon*: Indicates that this particular pairing should also syphon messages from the secondary namespace back to the primary namespace.</span></span> <span data-ttu-id="e3b73-229">일반적으로 메시지를 보내는 응용 프로그램이 이 값을 **false**로 설정합니다. 메시지를 수신하는 응용 프로그램이 값을 **true**로 설정해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="e3b73-229">In general, applications that send messages should set this value to **false**; applications that receive messages should set this value to **true**.</span></span> <span data-ttu-id="e3b73-230">이러한 경우가 자주 있다는 이유로 메시지 발신자 보다 적은 메시지 수신자가 더 적습니다.</span><span class="sxs-lookup"><span data-stu-id="e3b73-230">The reason for this is that frequently, there are fewer message receivers than message senders.</span></span> <span data-ttu-id="e3b73-231">수신자의 수에 따라 단일 응용 프로그램 인스턴스가 사이펀 의무를 처리하도록 선택할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="e3b73-231">Depending on the number of receivers, you can choose to have a single application instance handle the syphon duties.</span></span> <span data-ttu-id="e3b73-232">여러 수신자를 사용하면 각 백로그 큐에 비용 청구의 영향을 미칩니다.</span><span class="sxs-lookup"><span data-stu-id="e3b73-232">Using many receivers has billing implications for each backlog queue.</span></span>

<span data-ttu-id="e3b73-233">코드를 사용하려면 기본 [MessagingFactory][MessagingFactory] 인스턴스, 보조 [MessagingFactory][MessagingFactory] 인스턴스, 보조 [NamespaceManager][NamespaceManager] 인스턴스 및 [SendAvailabilityPairedNamespaceOptions][SendAvailabilityPairedNamespaceOptions] 인스턴스를 만듭니다.</span><span class="sxs-lookup"><span data-stu-id="e3b73-233">To use the code, create a primary [MessagingFactory][MessagingFactory] instance, a secondary [MessagingFactory][MessagingFactory] instance, a secondary [NamespaceManager][NamespaceManager] instance, and a [SendAvailabilityPairedNamespaceOptions][SendAvailabilityPairedNamespaceOptions] instance.</span></span> <span data-ttu-id="e3b73-234">호출은 다음과 같이 간단할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="e3b73-234">The call can be as simple as the following:</span></span>

```csharp
SendAvailabilityPairedNamespaceOptions sendAvailabilityOptions = new SendAvailabilityPairedNamespaceOptions(secondaryNamespaceManager, secondary);
primary.PairNamespaceAsync(sendAvailabilityOptions).Wait();
```

<span data-ttu-id="e3b73-235">[PairNamespaceAsync][PairNamespaceAsync] 메서드에서 반환한 작업이 완료되면 모든 것이 설정되고 사용할 준비가 됩니다.</span><span class="sxs-lookup"><span data-stu-id="e3b73-235">When the task returned by the [PairNamespaceAsync][PairNamespaceAsync] method completes, everything is set up and ready to use.</span></span> <span data-ttu-id="e3b73-236">작업이 반환되기 전에 쌍이 올바로 작동하는 데 필요한 백그라운드 작업을 모두 완료하지 못했을 수도 있습니다.</span><span class="sxs-lookup"><span data-stu-id="e3b73-236">Before the task is returned, you may not have completed all of the background work necessary for the pairing to work right.</span></span> <span data-ttu-id="e3b73-237">결과적으로 작업을 반환할 때까지 메시지를 보내기 시작하지 말아야 합니다.</span><span class="sxs-lookup"><span data-stu-id="e3b73-237">As a result, you should not start sending messages until the task returns.</span></span> <span data-ttu-id="e3b73-238">잘못된 자격 증명 또는 백로그 큐 만들기 실패와 같은 오류가 발생한 경우 작업이 완료되면 해당 예외는 throw됩니다.</span><span class="sxs-lookup"><span data-stu-id="e3b73-238">If any failures occurred, such as bad credentials, or failure to create the backlog queues, those exceptions will be thrown once the task completes.</span></span> <span data-ttu-id="e3b73-239">작업이 반환되면 [SendAvailabilityPairedNamespaceOptions][SendAvailabilityPairedNamespaceOptions] 인스턴스에서 [BacklogQueueCount][BacklogQueueCount] 속성을 검사하여 큐를 찾거나 만들었는지 확인합니다.</span><span class="sxs-lookup"><span data-stu-id="e3b73-239">Once the task returns, verify that the queues were found or created by examining the [BacklogQueueCount][BacklogQueueCount] property on your [SendAvailabilityPairedNamespaceOptions][SendAvailabilityPairedNamespaceOptions] instance.</span></span> <span data-ttu-id="e3b73-240">앞의 코드의 경우 작업이 다음과 같이 나타납니다.</span><span class="sxs-lookup"><span data-stu-id="e3b73-240">For the preceding code, that operation appears as follows:</span></span>

```csharp
if (sendAvailabilityOptions.BacklogQueueCount < 1)
{
    // Handle case where no queues were created.
}
```

## <a name="next-steps"></a><span data-ttu-id="e3b73-241">다음 단계</span><span class="sxs-lookup"><span data-stu-id="e3b73-241">Next steps</span></span>
<span data-ttu-id="e3b73-242">이제 Service Bus에서 비동기 메시징의 기본 사항을 알아보았으므로 [쌍을 이루는 네임스페이스]에 대한 자세한 내용을 읽습니다.[paired namespaces]</span><span class="sxs-lookup"><span data-stu-id="e3b73-242">Now that you've learned the basics of asynchronous messaging in Service Bus, read more details about [paired namespaces][paired namespaces].</span></span>

[ServerBusyException]: /dotnet/api/microsoft.servicebus.messaging.serverbusyexception
[System.TimeoutException]: https://msdn.microsoft.com/library/system.timeoutexception.aspx
[MessagingException]: /dotnet/api/microsoft.servicebus.messaging.messagingexception
[Best practices for insulating applications against Service Bus outages and disasters]: service-bus-outages-disasters.md
[Microsoft.ServiceBus.Messaging.MessagingFactory]: /dotnet/api/microsoft.servicebus.messaging.messagingfactory
[MessageReceiver]: /dotnet/api/microsoft.servicebus.messaging.messagereceiver
[QueueClient]: /dotnet/api/microsoft.servicebus.messaging.queueclient
[TopicClient]: /dotnet/api/microsoft.servicebus.messaging.topicclient
[Microsoft.ServiceBus.Messaging.PairedNamespaceOptions]: /dotnet/api/microsoft.servicebus.messaging.pairednamespaceoptions
[MessagingFactory]: /dotnet/api/microsoft.servicebus.messaging.messagingfactory
[SendAvailabilityPairedNamespaceOptions]: /dotnet/api/microsoft.servicebus.messaging.sendavailabilitypairednamespaceoptions
[NamespaceManager]: /dotnet/api/microsoft.servicebus.namespacemanager
[PairNamespaceAsync]: /dotnet/api/microsoft.servicebus.messaging.messagingfactory#Microsoft_ServiceBus_Messaging_MessagingFactory_PairNamespaceAsync_Microsoft_ServiceBus_Messaging_PairedNamespaceOptions_
[EnableSyphon]: /dotnet/api/microsoft.servicebus.messaging.sendavailabilitypairednamespaceoptions#Microsoft_ServiceBus_Messaging_SendAvailabilityPairedNamespaceOptions_EnableSyphon
[System.TimeSpan.Zero]: https://msdn.microsoft.com/library/system.timespan.zero.aspx
[IsTransient]: /dotnet/api/microsoft.servicebus.messaging.messagingexception#Microsoft_ServiceBus_Messaging_MessagingException_IsTransient
[UnauthorizedAccessException]: https://msdn.microsoft.com/library/system.unauthorizedaccessexception.aspx
[BacklogQueueCount]: /dotnet/api/microsoft.servicebus.messaging.sendavailabilitypairednamespaceoptions?redirectedfrom=MSDN#Microsoft_ServiceBus_Messaging_SendAvailabilityPairedNamespaceOptions_BacklogQueueCount
[paired namespaces]: service-bus-paired-namespaces.md
