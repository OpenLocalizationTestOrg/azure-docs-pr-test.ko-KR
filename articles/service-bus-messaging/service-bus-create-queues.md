---
title: "Azure 서비스 버스 큐를 사용 하는 aaaWrite 응용 프로그램 | Microsoft Docs"
description: "어떻게 toowrite 간단한 큐 기반 응용 프로그램이 Azure 서비스 버스를 사용 합니다."
services: service-bus-messaging
documentationcenter: na
author: sethmanheim
manager: timlt
editor: 
ms.assetid: 754d91b3-1426-405e-84b4-fd36d65b114a
ms.service: service-bus-messaging
ms.devlang: na
ms.topic: article
ms.tgt_pltfrm: na
ms.workload: na
ms.date: 08/07/2017
ms.author: sethm
ms.openlocfilehash: 93b75902a06becd6e33e05298e09f5669d0e2aef
ms.sourcegitcommit: 523283cc1b3c37c428e77850964dc1c33742c5f0
ms.translationtype: MT
ms.contentlocale: ko-KR
ms.lasthandoff: 10/06/2017
---
# <a name="create-applications-that-use-service-bus-queues"></a><span data-ttu-id="ecc33-103">서비스 버스 큐를 사용하는 응용 프로그램 만들기</span><span class="sxs-lookup"><span data-stu-id="ecc33-103">Create applications that use Service Bus queues</span></span>
<span data-ttu-id="ecc33-104">이 항목 서비스 버스 큐에 설명 하 고 표시 방법을 toowrite 간단한 큐 기반 응용 프로그램 서비스 버스를 사용 하 합니다.</span><span class="sxs-lookup"><span data-stu-id="ecc33-104">This topic describes Service Bus queues and shows how toowrite a simple queue-based application that uses Service Bus.</span></span>

<span data-ttu-id="ecc33-105">소매 판매 데이터에서 개별 판매 POS 터미널 해야 라우팅할 tooan 재고를 보충 toobe 때에 데이터 toodetermine hello를 사용 하는 재고 관리 시스템은 hello world에서 시나리오를 살펴보겠습니다.</span><span class="sxs-lookup"><span data-stu-id="ecc33-105">Consider a scenario from hello world of retail in which sales data from individual Point-of-Sale (POS) terminals must be routed tooan inventory management system that uses hello data toodetermine when stock has toobe replenished.</span></span> <span data-ttu-id="ecc33-106">이 솔루션에서는 hello 다음 그림에에서 설명 된 대로 hello 터미널과 hello 재고 관리 시스템 간 hello 통신에 대 한 서비스 버스 메시징 사용:</span><span class="sxs-lookup"><span data-stu-id="ecc33-106">This solution uses Service Bus messaging for hello communication between hello terminals and hello inventory management system, as illustrated in hello following figure:</span></span>

![Service Bus 큐 이미지 1](./media/service-bus-create-queues/IC657161.gif)

<span data-ttu-id="ecc33-108">각 POS 터미널 toohello 메시지를 전송 하 여 판매 데이터를 보고 **DataCollectionQueue**합니다.</span><span class="sxs-lookup"><span data-stu-id="ecc33-108">Each POS terminal reports its sales data by sending messages toohello **DataCollectionQueue**.</span></span> <span data-ttu-id="ecc33-109">이러한 메시지는 hello 재고 관리 시스템에서 검색 될 때까지이 큐에 남아 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ecc33-109">These messages remain in this queue until they are retrieved by hello inventory management system.</span></span> <span data-ttu-id="ecc33-110">이 패턴을 종종 *비동기 메시징*hello POS 터미널 hello 재고 관리 시스템 toocontinue 처리의 회신에 대 한 toowait 없기 때문에, 합니다.</span><span class="sxs-lookup"><span data-stu-id="ecc33-110">This pattern is often termed *asynchronous messaging*, because hello POS terminal does not have toowait for a reply from hello inventory management system toocontinue processing.</span></span>

## <a name="why-queuing"></a><span data-ttu-id="ecc33-111">큐 작업 이유</span><span class="sxs-lookup"><span data-stu-id="ecc33-111">Why queuing?</span></span>
<span data-ttu-id="ecc33-112">이 응용 프로그램을 필요한 tooset hello 코드를 살펴보기 전에 직접 (동기적) toohello 재고 관리 시스템 대신 hello POS 터미널이이 시나리오에서 큐를 사용할 때의 장점 hello와 통신 하는 것이 좋습니다.</span><span class="sxs-lookup"><span data-stu-id="ecc33-112">Before we look at hello code that is required tooset up this application, consider hello advantages of using a queue in this scenario instead of having hello POS terminals talk directly (synchronously) toohello inventory management system.</span></span>

### <a name="temporal-decoupling"></a><span data-ttu-id="ecc33-113">임시 분리</span><span class="sxs-lookup"><span data-stu-id="ecc33-113">Temporal decoupling</span></span>
<span data-ttu-id="ecc33-114">Hello 비동기 메시징 패턴을 사용한 생산자와 소비자 조정은 toobe 온라인에 없는 hello 동시 합니다.</span><span class="sxs-lookup"><span data-stu-id="ecc33-114">With hello asynchronous messaging pattern, producers and consumers do not have toobe online at hello same time.</span></span> <span data-ttu-id="ecc33-115">사용 중인 파티가 hello tooreceive 준비 될 때까지 메시징 인프라 hello 메시지를 안정적으로 저장을 합니다.</span><span class="sxs-lookup"><span data-stu-id="ecc33-115">hello messaging infrastructure reliably stores messages until hello consuming party is ready tooreceive them.</span></span> <span data-ttu-id="ecc33-116">즉, hello 분산 응용 프로그램의 hello 구성 연결이 끊어질 수 있습니다, 하거나 자발적으로; 예를 들어, 유지 관리를 위해 또는 hello 전체 시스템 영향을 주지 않고 tooa 구성 요소 크래시 등 때문입니다.</span><span class="sxs-lookup"><span data-stu-id="ecc33-116">This means hello components of hello distributed application can be disconnected, either voluntarily; for example, for maintenance, or due tooa component crash, without affecting hello whole system.</span></span> <span data-ttu-id="ecc33-117">또한 응용 프로그램을 사용 하는 hello hello 하루 중 특정 시간 동안 toobe 온라인을 가질 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ecc33-117">Furthermore, hello consuming application may only have toobe online during certain times of hello day.</span></span> <span data-ttu-id="ecc33-118">예를 들어이 소매 시나리오 hello 재고 관리 시스템을 가질 수 toocome 온라인 hello hello 업무 종료 후.</span><span class="sxs-lookup"><span data-stu-id="ecc33-118">For example, in this retail scenario, hello inventory management system may only have toocome online after hello end of hello business day.</span></span>

### <a name="load-leveling"></a><span data-ttu-id="ecc33-119">부하 평준화 </span><span class="sxs-lookup"><span data-stu-id="ecc33-119">Load leveling</span></span>
<span data-ttu-id="ecc33-120">많은 응용 프로그램에서 시스템 부하 hello 처리에 필요한 각 작업 단위에 시간은 일반적으로 일정 반면 시간에 따라 다릅니다.</span><span class="sxs-lookup"><span data-stu-id="ecc33-120">In many applications system load varies over time, whereas hello processing time required for each unit of work is typically constant.</span></span> <span data-ttu-id="ecc33-121">조정은 메시지 생산자와 소비자 큐 사용 하 여 hello 소비 응용 프로그램 (hello 작업자)에에 toobe tooservice 최대 부하 대신 평균 부하를 프로 비전 합니다.</span><span class="sxs-lookup"><span data-stu-id="ecc33-121">Intermediating message producers and consumers with a queue means that hello consuming application (hello worker) only has toobe provisioned tooservice an average load rather than a peak load.</span></span> <span data-ttu-id="ecc33-122">hello 깊이 hello 큐의 크기가 계속 커집니다 및 계약 수신 부하가 hello 달라 집니다.</span><span class="sxs-lookup"><span data-stu-id="ecc33-122">hello depth of hello queue will grow and contract as hello incoming load varies.</span></span> <span data-ttu-id="ecc33-123">이 관계 toohello 양의 인프라 필요한 tooservice hello 응용 프로그램 부하 money 직접 저장합니다.</span><span class="sxs-lookup"><span data-stu-id="ecc33-123">This directly saves money with regard toohello amount of infrastructure required tooservice hello application load.</span></span>

![Service Bus 큐 이미지 2](./media/service-bus-create-queues/IC657162.gif)

### <a name="load-balancing"></a><span data-ttu-id="ecc33-125">부하 분산</span><span class="sxs-lookup"><span data-stu-id="ecc33-125">Load balancing</span></span>
<span data-ttu-id="ecc33-126">Hello로 로드 증가, 작업자 프로세스가 더 추가 된 tooread hello 작업자 큐에서 일 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ecc33-126">As hello load increases, more worker processes can be added tooread from hello worker queue.</span></span> <span data-ttu-id="ecc33-127">Hello 작업자 프로세스 중 하나에만 각 메시지를 처리 합니다.</span><span class="sxs-lookup"><span data-stu-id="ecc33-127">Each message is processed by only one of hello worker processes.</span></span> <span data-ttu-id="ecc33-128">또한이 끌어오기 기반 부하 분산 하면 hello 작업자 컴퓨터의 최적 사용률 hello 작업자 컴퓨터 큰지에 tooprocessing 전원와 다른 경우에 자신의 최대 속도로 메시지를 가져올 때 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ecc33-128">Furthermore, this pull-based load balancing allows for optimum usage of hello worker computers even if hello worker computers differ with regard tooprocessing power, as they will pull messages at their own maximum rate.</span></span> <span data-ttu-id="ecc33-129">이 패턴을 hello 경쟁 소비자 패턴을 종종 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ecc33-129">This pattern is often termed hello competing consumer pattern.</span></span>

![Service Bus 큐 이미지 3](./media/service-bus-create-queues/IC657163.gif)

### <a name="loose-coupling"></a><span data-ttu-id="ecc33-131">느슨한 결합</span><span class="sxs-lookup"><span data-stu-id="ecc33-131">Loose coupling</span></span>
<span data-ttu-id="ecc33-132">메시지 큐 toointermediate 메시지 생산자와 소비자 사이 사용 하 여 hello 구성 요소 간의 내장 함수는 느슨한 결합을 제공 합니다.</span><span class="sxs-lookup"><span data-stu-id="ecc33-132">Using message queuing toointermediate between message producers and consumers provides an intrinsic loose coupling between hello components.</span></span> <span data-ttu-id="ecc33-133">생산자와 소비자가 서로 인식 없기 때문에 hello 생산자에 영향을 주지 않고 소비자를 업그레이드할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ecc33-133">Because producers and consumers are not aware of each other, a consumer can be upgraded without having any effect on hello producer.</span></span> <span data-ttu-id="ecc33-134">또한 메시징 토폴로지 hello hello 기존 끝점에 영향을 주지 않고 개발할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ecc33-134">Furthermore, hello messaging topology can evolve without affecting hello existing endpoints.</span></span> <span data-ttu-id="ecc33-135">게시/구독에 대해 설명할 때 더 자세히 논의할 것입니다.</span><span class="sxs-lookup"><span data-stu-id="ecc33-135">We’ll discuss this more when we talk about publish/subscribe.</span></span>

## <a name="show-me-hello-code"></a><span data-ttu-id="ecc33-136">Hello 코드 보기</span><span class="sxs-lookup"><span data-stu-id="ecc33-136">Show me hello code</span></span>
<span data-ttu-id="ecc33-137">섹션에서는 방법을 다음 hello toouse 서비스 버스 toobuild이 응용이 프로그램입니다.</span><span class="sxs-lookup"><span data-stu-id="ecc33-137">hello following section shows how toouse Service Bus toobuild this application.</span></span>

### <a name="sign-up-for-an-azure-account"></a><span data-ttu-id="ecc33-138">Azure 계정 등록</span><span class="sxs-lookup"><span data-stu-id="ecc33-138">Sign up for an Azure account</span></span>
<span data-ttu-id="ecc33-139">서비스 버스 작업 순서 toostart에 Azure 계정이 필요 합니다.</span><span class="sxs-lookup"><span data-stu-id="ecc33-139">You’ll need an Azure account in order toostart working with Service Bus.</span></span> <span data-ttu-id="ecc33-140">아직 등록하지 않은 경우 [여기](https://azure.microsoft.com/pricing/free-trial/?WT.mc_id=A85619ABF)에서 무료 계정을 등록할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ecc33-140">If you do not already have one, you can sign up for a free account [here](https://azure.microsoft.com/pricing/free-trial/?WT.mc_id=A85619ABF).</span></span>

### <a name="create-a-namespace"></a><span data-ttu-id="ecc33-141">네임스페이스 만들기</span><span class="sxs-lookup"><span data-stu-id="ecc33-141">Create a namespace</span></span>
<span data-ttu-id="ecc33-142">구독이 있으면 [네임스페이스를 만들](service-bus-create-namespace-portal.md) 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ecc33-142">Once you have a subscription, you can [create a service namespace](service-bus-create-namespace-portal.md).</span></span> <span data-ttu-id="ecc33-143">각각의 네임스페이스는 서비스 버스 엔터티 집합에 대한 범위 컨테이너입니다.</span><span class="sxs-lookup"><span data-stu-id="ecc33-143">Each namespace acts as a scoping container for a set of Service Bus entities.</span></span> <span data-ttu-id="ecc33-144">모든 서비스 버스 계정에서 새 네임스페이스에 고유한 이름을 지정합니다.</span><span class="sxs-lookup"><span data-stu-id="ecc33-144">Give your new namespace a unique name across all Service Bus accounts.</span></span> 

### <a name="install-hello-nuget-package"></a><span data-ttu-id="ecc33-145">Hello NuGet 패키지 설치</span><span class="sxs-lookup"><span data-stu-id="ecc33-145">Install hello NuGet package</span></span>
<span data-ttu-id="ecc33-146">toouse hello 서비스 버스 네임 스페이스는 응용 프로그램 hello 서비스 버스 어셈블리, 특히 Microsoft.ServiceBus.dll 참조 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="ecc33-146">toouse hello Service Bus namespace, an application must reference hello Service Bus assembly, specifically Microsoft.ServiceBus.dll.</span></span> <span data-ttu-id="ecc33-147">Hello Microsoft Azure SDK의 일부분으로이 어셈블리를 찾을 수 있습니다 및을 hello 다운로드할 hello 수 [Azure SDK 다운로드 페이지](https://azure.microsoft.com/downloads/)합니다.</span><span class="sxs-lookup"><span data-stu-id="ecc33-147">You can find this assembly as part of hello Microsoft Azure SDK, and hello download is available at hello [Azure SDK download page](https://azure.microsoft.com/downloads/).</span></span> <span data-ttu-id="ecc33-148">그러나 hello [Service Bus NuGet 패키지](https://www.nuget.org/packages/WindowsAzure.ServiceBus) hello 가장 쉬운 방법은 tooget hello 서비스 버스 API 및 tooconfigure hello 서비스 버스 종속성의 모든 응용 프로그램은 합니다.</span><span class="sxs-lookup"><span data-stu-id="ecc33-148">However, hello [Service Bus NuGet package](https://www.nuget.org/packages/WindowsAzure.ServiceBus) is hello easiest way tooget hello Service Bus API and tooconfigure your application with all of hello Service Bus dependencies.</span></span>

### <a name="create-hello-queue"></a><span data-ttu-id="ecc33-149">Hello 큐 만들기</span><span class="sxs-lookup"><span data-stu-id="ecc33-149">Create hello queue</span></span>
<span data-ttu-id="ecc33-150">서비스 버스 메시징 엔터티 (큐 및 게시/구독 항목) hello를 통해 수행 됩니다에 대 한 관리 작업 [NamespaceManager](/dotnet/api/microsoft.servicebus.namespacemanager) 클래스입니다.</span><span class="sxs-lookup"><span data-stu-id="ecc33-150">Management operations for Service Bus messaging entities (queues and publish/subscribe topics) are performed via hello [NamespaceManager](/dotnet/api/microsoft.servicebus.namespacemanager) class.</span></span> <span data-ttu-id="ecc33-151">Service Bus는 [SAS(공유 액세스 서명)](service-bus-sas.md) 기반 보안 모델을 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="ecc33-151">Service Bus uses a [Shared Access Signature (SAS)](service-bus-sas.md) based security model.</span></span> <span data-ttu-id="ecc33-152">hello [TokenProvider](/dotnet/api/microsoft.servicebus.tokenprovider) 클래스 일부 잘 알려진 토큰 공급자를 반환 하는 기본 제공 팩터리 메서드로 보안 토큰 공급자를 나타냅니다.</span><span class="sxs-lookup"><span data-stu-id="ecc33-152">hello [TokenProvider](/dotnet/api/microsoft.servicebus.tokenprovider) class represents a security token provider with built-in factory methods returning some well-known token providers.</span></span> <span data-ttu-id="ecc33-153">에서는 한 [CreateSharedAccessSignatureTokenProvider](/dotnet/api/microsoft.servicebus.tokenprovider#Microsoft_ServiceBus_TokenProvider_CreateSharedAccessSignatureTokenProvider_System_String_) 메서드 toohold hello SAS 자격 증명입니다.</span><span class="sxs-lookup"><span data-stu-id="ecc33-153">We’ll use a [CreateSharedAccessSignatureTokenProvider](/dotnet/api/microsoft.servicebus.tokenprovider#Microsoft_ServiceBus_TokenProvider_CreateSharedAccessSignatureTokenProvider_System_String_) method toohold hello SAS credentials.</span></span> <span data-ttu-id="ecc33-154">hello [NamespaceManager](/dotnet/api/microsoft.servicebus.namespacemanager) hello hello 서비스 버스 네임 스페이스 및 hello 토큰 공급자의 기본 주소를 가진 인스턴스 생성 합니다.</span><span class="sxs-lookup"><span data-stu-id="ecc33-154">hello [NamespaceManager](/dotnet/api/microsoft.servicebus.namespacemanager) instance is then constructed with hello base address of hello Service Bus namespace and hello token provider.</span></span>

<span data-ttu-id="ecc33-155">hello [NamespaceManager](/dotnet/api/microsoft.servicebus.namespacemanager) toocreate 메서드를 제공 하는 클래스, 열거 및 메시징 엔터티를 삭제 합니다.</span><span class="sxs-lookup"><span data-stu-id="ecc33-155">hello [NamespaceManager](/dotnet/api/microsoft.servicebus.namespacemanager) class provides methods toocreate, enumerate and delete messaging entities.</span></span> <span data-ttu-id="ecc33-156">표시 된 코드는 여기 표시 방법을 hello hello [NamespaceManager](/dotnet/api/microsoft.servicebus.namespacemanager) 인스턴스가 생성 되 고 사용 되는 toocreate hello **DataCollectionQueue** 큐입니다.</span><span class="sxs-lookup"><span data-stu-id="ecc33-156">hello code that is shown here shows how hello [NamespaceManager](/dotnet/api/microsoft.servicebus.namespacemanager) instance is created and used toocreate hello **DataCollectionQueue** queue.</span></span>

```csharp
Uri uri = ServiceBusEnvironment.CreateServiceUri("sb", 
                "test-blog", string.Empty);
string name = "RootManageSharedAccessKey";
string key = "abcdefghijklmopqrstuvwxyz";

TokenProvider tokenProvider = 
    TokenProvider.CreateSharedAccessSignatureTokenProvider(name, key);
NamespaceManager namespaceManager = 
    new NamespaceManager(uri, tokenProvider);
namespaceManager.CreateQueue("DataCollectionQueue");
```

<span data-ttu-id="ecc33-157">Hello의 오버 로드는 [CreateQueue](/dotnet/api/microsoft.servicebus.namespacemanager#Microsoft_ServiceBus_NamespaceManager_CreateQueue_System_String_) hello 큐 toobe 튜닝의 속성을 사용 하도록 설정 하는 메서드입니다.</span><span class="sxs-lookup"><span data-stu-id="ecc33-157">Note that there are overloads of hello [CreateQueue](/dotnet/api/microsoft.servicebus.namespacemanager#Microsoft_ServiceBus_NamespaceManager_CreateQueue_System_String_) method that enable properties of hello queue toobe tuned.</span></span> <span data-ttu-id="ecc33-158">예를 들어 toohello 큐에 전송 된 메시지에 대 한 hello 기본 활성 시간 (TTL) 값을 설정할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ecc33-158">For example, you can set hello default time-to-live (TTL) value for messages sent toohello queue.</span></span>

### <a name="send-messages-toohello-queue"></a><span data-ttu-id="ecc33-159">송신 메시지 toohello 큐</span><span class="sxs-lookup"><span data-stu-id="ecc33-159">Send messages toohello queue</span></span>
<span data-ttu-id="ecc33-160">Service Bus 엔터티의 런타임 작업(예: 메시지 송수신)을 위해서는 응용 프로그램이 먼저[MessagingFactory](/dotnet/api/microsoft.servicebus.messaging.messagingfactory) 개체를 만들어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="ecc33-160">For run-time operations on Service Bus entities; for example, sending and receiving messages, an application must first create a [MessagingFactory](/dotnet/api/microsoft.servicebus.messaging.messagingfactory) object.</span></span> <span data-ttu-id="ecc33-161">비슷한 toohello [NamespaceManager](/dotnet/api/microsoft.servicebus.namespacemanager) 클래스 hello [MessagingFactory](/dotnet/api/microsoft.servicebus.messaging.messagingfactory) hello hello 서비스 네임 스페이스 및 hello 토큰 공급자의 기준 주소에서 인스턴스가 만들어집니다.</span><span class="sxs-lookup"><span data-stu-id="ecc33-161">Similar toohello [NamespaceManager](/dotnet/api/microsoft.servicebus.namespacemanager) class, hello [MessagingFactory](/dotnet/api/microsoft.servicebus.messaging.messagingfactory) instance is created from hello base address of hello service namespace and hello token provider.</span></span>

```csharp
 BrokeredMessage bm = new BrokeredMessage(salesData);
 bm.Label = "SalesReport";
 bm.Properties["StoreName"] = "Redmond";
 bm.Properties["MachineID"] = "POS_1";
```

<span data-ttu-id="ecc33-162">메시지 전송 및 서비스 버스에서 수신 큐는 hello 인스턴스의 [BrokeredMessage](/dotnet/api/microsoft.servicebus.messaging.brokeredmessage) 클래스입니다.</span><span class="sxs-lookup"><span data-stu-id="ecc33-162">Messages sent to, and received from Service Bus queues are instances of hello [BrokeredMessage](/dotnet/api/microsoft.servicebus.messaging.brokeredmessage) class.</span></span> <span data-ttu-id="ecc33-163">이 클래스의 표준 속성 집합으로 구성 됩니다 (같은 [레이블](/dotnet/api/microsoft.servicebus.messaging.brokeredmessage#Microsoft_ServiceBus_Messaging_BrokeredMessage_Label) 및 [TimeToLive](/dotnet/api/microsoft.servicebus.messaging.brokeredmessage#Microsoft_ServiceBus_Messaging_BrokeredMessage_TimeToLive)), 사용 되는 toohold 응용 프로그램 속성을 사전 및 임의 응용 프로그램 데이터의 본문입니다.</span><span class="sxs-lookup"><span data-stu-id="ecc33-163">This class consists of a set of standard properties (such as [Label](/dotnet/api/microsoft.servicebus.messaging.brokeredmessage#Microsoft_ServiceBus_Messaging_BrokeredMessage_Label) and [TimeToLive](/dotnet/api/microsoft.servicebus.messaging.brokeredmessage#Microsoft_ServiceBus_Messaging_BrokeredMessage_TimeToLive)), a dictionary that is used toohold application properties, and a body of arbitrary application data.</span></span> <span data-ttu-id="ecc33-164">응용 프로그램 직렬화 된 개체에서를 전달 하 여 hello 본문을 설정할 수 있습니다 (hello 다음 예제에서는 전달에 **SalesData** hello POS 터미널에서 hello 판매 데이터를 나타내는 개체), 있으며 hello를 사용 합니다 [ DataContractSerializer](https://msdn.microsoft.com/library/system.runtime.serialization.datacontractserializer.aspx) tooserialize hello 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="ecc33-164">An application can set hello body by passing in any serializable object (hello following example passes in a **SalesData** object that represents hello sales data from hello POS terminal), which will use hello [DataContractSerializer](https://msdn.microsoft.com/library/system.runtime.serialization.datacontractserializer.aspx) tooserialize hello object.</span></span> <span data-ttu-id="ecc33-165">또는 [스트림](https://msdn.microsoft.com/library/system.io.stream.aspx) 개체를 제공할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ecc33-165">Alternatively, a [Stream](https://msdn.microsoft.com/library/system.io.stream.aspx) object can be provided.</span></span>

<span data-ttu-id="ecc33-166">가장 쉬운 방법은 toosend 메시지 tooa 우리의 사례 hello에 큐를 지정 된 hello **DataCollectionQueue**, toouse은 [CreateMessageSender](/dotnet/api/microsoft.servicebus.messaging.messagingfactory#Microsoft_ServiceBus_Messaging_MessagingFactory_CreateMessageSender_System_String_) toocreate는 [MessageSender](/dotnet/api/microsoft.servicebus.messaging.messagesender) 개체 hello에서 직접 [MessagingFactory](/dotnet/api/microsoft.servicebus.messaging.messagingfactory) 인스턴스.</span><span class="sxs-lookup"><span data-stu-id="ecc33-166">hello easiest way toosend messages tooa given queue, in our case hello **DataCollectionQueue**, is toouse [CreateMessageSender](/dotnet/api/microsoft.servicebus.messaging.messagingfactory#Microsoft_ServiceBus_Messaging_MessagingFactory_CreateMessageSender_System_String_) toocreate a [MessageSender](/dotnet/api/microsoft.servicebus.messaging.messagesender) object directly from hello [MessagingFactory](/dotnet/api/microsoft.servicebus.messaging.messagingfactory) instance.</span></span>

```csharp
MessageSender sender = factory.CreateMessageSender("DataCollectionQueue");
sender.Send(bm);
```

### <a name="receiving-messages-from-hello-queue"></a><span data-ttu-id="ecc33-167">Hello 큐에서 메시지 받기</span><span class="sxs-lookup"><span data-stu-id="ecc33-167">Receiving messages from hello queue</span></span>
<span data-ttu-id="ecc33-168">사용할 수 있습니다 tooreceive hello 큐에서 메시지는 [MessageReceiver](/dotnet/api/microsoft.servicebus.messaging.messagereceiver) hello에서 직접 만들 수 있는 개체 [MessagingFactory](/dotnet/api/microsoft.servicebus.messaging.messagingfactory) 를 사용 하 여 [CreateMessageReceiver](/dotnet/api/microsoft.servicebus.messaging.messagingfactory#Microsoft_ServiceBus_Messaging_MessagingFactory_CreateMessageReceiver_System_String_)합니다.</span><span class="sxs-lookup"><span data-stu-id="ecc33-168">tooreceive messages from hello queue, you can use a [MessageReceiver](/dotnet/api/microsoft.servicebus.messaging.messagereceiver) object which you create directly from hello [MessagingFactory](/dotnet/api/microsoft.servicebus.messaging.messagingfactory) using [CreateMessageReceiver](/dotnet/api/microsoft.servicebus.messaging.messagingfactory#Microsoft_ServiceBus_Messaging_MessagingFactory_CreateMessageReceiver_System_String_).</span></span> <span data-ttu-id="ecc33-169">메시지 수신기는 **ReceiveAndDelete** 및 **PeekLock**의 두 가지 모드로 작동할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ecc33-169">Message receivers can work in two different modes: **ReceiveAndDelete** and **PeekLock**.</span></span> <span data-ttu-id="ecc33-170">hello [ReceiveMode](/dotnet/api/microsoft.servicebus.messaging.receivemode) 매개 변수 toohello로 hello 메시지 수신기를 만들 때 설정 됩니다 [CreateMessageReceiver](/dotnet/api/microsoft.servicebus.messaging.messagingfactory?redirectedfrom=MSDN#Microsoft_ServiceBus_Messaging_MessagingFactory_CreateMessageReceiver_System_String_Microsoft_ServiceBus_Messaging_ReceiveMode_) 호출 합니다.</span><span class="sxs-lookup"><span data-stu-id="ecc33-170">hello [ReceiveMode](/dotnet/api/microsoft.servicebus.messaging.receivemode) is set when hello message receiver is created, as a parameter toohello [CreateMessageReceiver](/dotnet/api/microsoft.servicebus.messaging.messagingfactory?redirectedfrom=MSDN#Microsoft_ServiceBus_Messaging_MessagingFactory_CreateMessageReceiver_System_String_Microsoft_ServiceBus_Messaging_ReceiveMode_) call.</span></span>

<span data-ttu-id="ecc33-171">Hello를 사용 하는 경우 **ReceiveAndDelete** 모드 hello 수신은 1 단계 작업입니다; 즉, 서비스 버스 hello 요청을 받으면 hello 메시지 사용 되는 것을 표시 하 고 toohello 응용 프로그램을 반환 합니다.</span><span class="sxs-lookup"><span data-stu-id="ecc33-171">When using hello **ReceiveAndDelete** mode, hello receive is a single-shot operation; that is, when Service Bus receives hello request, it marks hello message as being consumed and returns it toohello application.</span></span> <span data-ttu-id="ecc33-172">**ReceiveAndDelete** 모드는 hello 가장 간단한 모델 이며는 hello에 응용 프로그램이 toooccur 실패할 경우 메시지를 처리 하지 감당할 수 없는 시나리오에 가장 적합 합니다.</span><span class="sxs-lookup"><span data-stu-id="ecc33-172">**ReceiveAndDelete** mode is hello simplest model and works best for scenarios in which hello application can tolerate not processing a message if a failure were toooccur.</span></span> <span data-ttu-id="ecc33-173">toounderstand hello는 hello 소비자 문제에 요청을 수신 하는 시나리오 및 후 처리 하기 전에 크래시 합니다.</span><span class="sxs-lookup"><span data-stu-id="ecc33-173">toounderstand this, consider a scenario in which hello consumer issues hello receive request and then crashes before processing it.</span></span> <span data-ttu-id="ecc33-174">서비스 버스 hello 메시지 사용 되는 것으로 표시 되어 있으므로 시기 hello 응용 프로그램 다시 시작 되 고 메시지를 사용 하는 시작 누락 됩니다 hello 크래시 전에 사용 된 hello 메시지입니다.</span><span class="sxs-lookup"><span data-stu-id="ecc33-174">Since Service Bus marked hello message as being consumed, when hello application restarts and starts consuming messages again, it will have missed hello message that was consumed before hello crash.</span></span>

<span data-ttu-id="ecc33-175">**PeekLock** 모드 hello 수신 하므로 누락 된 메시지를 허용할 수 없는 가능한 toosupport 응용 프로그램 2 단계 작업이 됩니다.</span><span class="sxs-lookup"><span data-stu-id="ecc33-175">In **PeekLock** mode, hello receive becomes a two-stage operation, which makes it possible toosupport applications that cannot tolerate missing messages.</span></span> <span data-ttu-id="ecc33-176">서비스 버스 hello 요청을 받은 다음 메시지 toobe hello 사용 다른 소비자가 수신할 tooprevent 잠근 하 고 toohello 응용 프로그램 반환 찾습니다.</span><span class="sxs-lookup"><span data-stu-id="ecc33-176">When Service Bus receives hello request, it finds hello next message toobe consumed, locks it tooprevent other consumers receiving it, and then returns it toohello application.</span></span> <span data-ttu-id="ecc33-177">Hello hello의 두 번째 단계를 완료 후 hello 응용 프로그램 hello 메시지 처리를 완료 (또는 이후 처리를 위해 안정적으로 저장)를 호출 하 여 수신 프로세스 [완료](/dotnet/api/microsoft.servicebus.messaging.brokeredmessage#Microsoft_ServiceBus_Messaging_BrokeredMessage_Complete) hello 받은 메시지에 합니다.</span><span class="sxs-lookup"><span data-stu-id="ecc33-177">After hello application finishes processing hello message (or stores it reliably for future processing), it completes hello second stage of hello receive process by calling [Complete](/dotnet/api/microsoft.servicebus.messaging.brokeredmessage#Microsoft_ServiceBus_Messaging_BrokeredMessage_Complete) on hello received message.</span></span> <span data-ttu-id="ecc33-178">서비스 버스 hello를 표시 하는 경우 [완료](/dotnet/api/microsoft.servicebus.messaging.brokeredmessage#Microsoft_ServiceBus_Messaging_BrokeredMessage_Complete) 호출, hello 메시지를 사용 중으로 표시 합니다.</span><span class="sxs-lookup"><span data-stu-id="ecc33-178">When Service Bus sees hello [Complete](/dotnet/api/microsoft.servicebus.messaging.brokeredmessage#Microsoft_ServiceBus_Messaging_BrokeredMessage_Complete) call, it marks hello message as being consumed.</span></span>

<span data-ttu-id="ecc33-179">다른 두 결과 가능합니다.</span><span class="sxs-lookup"><span data-stu-id="ecc33-179">Two other outcomes are possible.</span></span> <span data-ttu-id="ecc33-180">첫째, hello 응용 프로그램 수 없는 경우 몇 가지 이유로 tooprocess 환영 메시지가, 호출할 수 있는 [중단](/dotnet/api/microsoft.servicebus.messaging.brokeredmessage#Microsoft_ServiceBus_Messaging_BrokeredMessage_Abandon) hello 받은 메시지에 (대신 [완료](/dotnet/api/microsoft.servicebus.messaging.brokeredmessage#Microsoft_ServiceBus_Messaging_BrokeredMessage_Complete)).</span><span class="sxs-lookup"><span data-stu-id="ecc33-180">First, if hello application is unable tooprocess hello message for some reason, it can call [Abandon](/dotnet/api/microsoft.servicebus.messaging.brokeredmessage#Microsoft_ServiceBus_Messaging_BrokeredMessage_Abandon) on hello received message (instead of [Complete](/dotnet/api/microsoft.servicebus.messaging.brokeredmessage#Microsoft_ServiceBus_Messaging_BrokeredMessage_Complete)).</span></span> <span data-ttu-id="ecc33-181">동일한 소비자 hello 사용 하거나, 서비스 버스 toounlock hello 메시지와 수신 다시 사용할 수 있는 toobe 확인이 또는 다른 완료 소비자입니다.</span><span class="sxs-lookup"><span data-stu-id="ecc33-181">This causes Service Bus toounlock hello message and make it available toobe received again, either by hello same consumer or by another completing consumer.</span></span> <span data-ttu-id="ecc33-182">둘째, hello 잠금과 관련 있는 제한 시간은 및 hello 메시지 및 사용할 수 있는 toobe 확인 hello 잠금 제한 시간 만료 전에 (예를 들어 hello 응용 프로그램이 충돌할 경우), 서비스 버스에서 잠금 해제 한 후 hello 응용 hello 메시지를 처리할 수 없는 경우 수신 다시 (기본적으로 수행 된 [중단](/dotnet/api/microsoft.servicebus.messaging.brokeredmessage#Microsoft_ServiceBus_Messaging_BrokeredMessage_Abandon) 기본적으로 작업).</span><span class="sxs-lookup"><span data-stu-id="ecc33-182">Second, there is a time-out associated with hello lock and if hello application cannot process hello message before hello lock time-out expires (for example, if hello application crashes), then Service Bus will unlock hello message and make it available toobe received again (essentially performing an [Abandon](/dotnet/api/microsoft.servicebus.messaging.brokeredmessage#Microsoft_ServiceBus_Messaging_BrokeredMessage_Abandon) operation by default).</span></span>

<span data-ttu-id="ecc33-183">경우 hello 응용 프로그램이 크래시 되 hello 메시지를 처리 한 후 하지만 hello 하기 전에 확인 [완료](/dotnet/api/microsoft.servicebus.messaging.brokeredmessage#Microsoft_ServiceBus_Messaging_BrokeredMessage_Complete) 요청이 전달 된 경우 hello 메시지를 다시 시작할 때 다시 전달한 toohello 응용 프로그램 수입니다.</span><span class="sxs-lookup"><span data-stu-id="ecc33-183">Note that if hello application crashes after it processes hello message but before hello [Complete](/dotnet/api/microsoft.servicebus.messaging.brokeredmessage#Microsoft_ServiceBus_Messaging_BrokeredMessage_Complete) request was issued, hello message will be redelivered toohello application when it restarts.</span></span> <span data-ttu-id="ecc33-184">이 종종 * 적어도 한 번 * 처리 합니다.</span><span class="sxs-lookup"><span data-stu-id="ecc33-184">This is often termed *At Least Once * processing.</span></span> <span data-ttu-id="ecc33-185">즉, 각 메시지가 최소 한 번 처리 되지만 특정 상황 hello에 동일한 메시지를 다시 배달 될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ecc33-185">This means that each message will be processed at least once but in certain situations hello same message may be redelivered.</span></span> <span data-ttu-id="ecc33-186">Hello 시나리오 중복 처리가 허용 되지 않는, 추가 논리는 hello 응용 프로그램 toodetect 중복 항목이 필요 합니다.</span><span class="sxs-lookup"><span data-stu-id="ecc33-186">If hello scenario cannot tolerate duplicate processing, then additional logic is required in hello application toodetect duplicates.</span></span> <span data-ttu-id="ecc33-187">Hello에 따라 수행할 수 있습니다 [MessageId](/dotnet/api/microsoft.servicebus.messaging.brokeredmessage#Microsoft_ServiceBus_Messaging_BrokeredMessage_MessageId) hello 메시지의 속성입니다.</span><span class="sxs-lookup"><span data-stu-id="ecc33-187">This can be achieved based on hello [MessageId](/dotnet/api/microsoft.servicebus.messaging.brokeredmessage#Microsoft_ServiceBus_Messaging_BrokeredMessage_MessageId) property of hello message.</span></span> <span data-ttu-id="ecc33-188">이 속성의 값 hello 배달 시도 간에 일정 하 게 유지 합니다.</span><span class="sxs-lookup"><span data-stu-id="ecc33-188">hello value of this property remains constant across delivery attempts.</span></span> <span data-ttu-id="ecc33-189">이를 *정확히 한 번* 처리라고 합니다.</span><span class="sxs-lookup"><span data-stu-id="ecc33-189">This is termed *Exactly Once* processing.</span></span>

<span data-ttu-id="ecc33-190">hello 여기에 표시 된 코드를 받아서 처리 hello를 사용 하는 메시지 **PeekLock** 되지 않은 경우 hello 기본 설정인 모드 [ReceiveMode](/dotnet/api/microsoft.servicebus.messaging.receivemode) 값이 명시적으로 제공 합니다.</span><span class="sxs-lookup"><span data-stu-id="ecc33-190">hello code that is shown here receives and processes a message using hello **PeekLock** mode, which is hello default if no [ReceiveMode](/dotnet/api/microsoft.servicebus.messaging.receivemode) value is explicitly provided.</span></span>

```csharp
MessageReceiver receiver = factory.CreateMessageReceiver("DataCollectionQueue");
BrokeredMessage receivedMessage = receiver.Receive();
try
{
    ProcessMessage(receivedMessage);
    receivedMessage.Complete();
}
catch (Exception e)
{
    receivedMessage.Abandon();
}
```

### <a name="use-hello-queue-client"></a><span data-ttu-id="ecc33-191">Hello 큐 클라이언트 사용</span><span class="sxs-lookup"><span data-stu-id="ecc33-191">Use hello queue client</span></span>
<span data-ttu-id="ecc33-192">만든이 섹션의 앞부분에 나오는 예제 hello [MessageSender](/dotnet/api/microsoft.servicebus.messaging.messagesender) 및 [MessageReceiver](/dotnet/api/microsoft.servicebus.messaging.messagereceiver) hello에서 직접 개체 [MessagingFactory](/dotnet/api/microsoft.servicebus.messaging.messagingfactory) toosend 및 메시지를 수신 합니다. hello 큐에서 각각.</span><span class="sxs-lookup"><span data-stu-id="ecc33-192">hello examples earlier in this section created [MessageSender](/dotnet/api/microsoft.servicebus.messaging.messagesender) and [MessageReceiver](/dotnet/api/microsoft.servicebus.messaging.messagereceiver) objects directly from hello [MessagingFactory](/dotnet/api/microsoft.servicebus.messaging.messagingfactory) toosend and receive messages from hello queue, respectively.</span></span> <span data-ttu-id="ecc33-193">또 다른 방법은 toouse는 [QueueClient](/dotnet/api/microsoft.servicebus.messaging.queueclient) 개체를 지 원하는 모두 보내기 및 받기 작업에서 추가 toomore 고급 세션과 같은 기능을 합니다.</span><span class="sxs-lookup"><span data-stu-id="ecc33-193">An alternative approach is toouse a [QueueClient](/dotnet/api/microsoft.servicebus.messaging.queueclient) object, which supports both send and receive operations in addition toomore advanced features, such as sessions.</span></span>

```csharp
QueueClient queueClient = factory.CreateQueueClient("DataCollectionQueue");
queueClient.Send(bm);

BrokeredMessage message = queueClient.Receive();

try
{
    ProcessMessage(message);
    message.Complete();
}
catch (Exception e)
{
    message.Abandon();
} 
```

## <a name="next-steps"></a><span data-ttu-id="ecc33-194">다음 단계</span><span class="sxs-lookup"><span data-stu-id="ecc33-194">Next steps</span></span>
<span data-ttu-id="ecc33-195">큐의 hello 기본 사항 학습 한, 했으므로 참조 [서비스 버스 항목 및 구독을 사용 하는 응용 프로그램을 만들](service-bus-create-topics-subscriptions.md) toocontinue 서비스 버스 주제의 hello 게시/구독 기능을 사용 하 여이 설명 하 고 구독입니다.</span><span class="sxs-lookup"><span data-stu-id="ecc33-195">Now that you've learned hello basics of queues, see [Create applications that use Service Bus topics and subscriptions](service-bus-create-topics-subscriptions.md) toocontinue this discussion using hello publish/subscribe capabilities of Service Bus topics and subscriptions.</span></span>

