---
title: "분할된 Azure Service Bus 큐 및 토픽 만들기 | Microsoft Docs"
description: "여러 메시지 broker를 사용하여 Service Bus 큐 및 항목을 분할하는 방법을 설명합니다."
services: service-bus-messaging
documentationcenter: na
author: sethmanheim
manager: timlt
editor: 
ms.assetid: a0c7d5a2-4876-42cb-8344-a1fc988746e7
ms.service: service-bus-messaging
ms.devlang: na
ms.topic: article
ms.tgt_pltfrm: na
ms.workload: na
ms.date: 08/07/2017
ms.author: sethm;hillaryc
ms.openlocfilehash: 5a4e69ea7e13cb017f8fb432c524c6a8ce9228a8
ms.sourcegitcommit: 50e23e8d3b1148ae2d36dad3167936b4e52c8a23
ms.translationtype: MT
ms.contentlocale: ko-KR
ms.lasthandoff: 08/18/2017
---
# <a name="partitioned-queues-and-topics"></a><span data-ttu-id="1b436-103">분할 큐 및 항목</span><span class="sxs-lookup"><span data-stu-id="1b436-103">Partitioned queues and topics</span></span>
<span data-ttu-id="1b436-104">Azure Service Bus에서는 여러 메시지 broker가 메시지를 처리하고 여러 메시징 저장소가 메시지를 저장하도록 합니다.</span><span class="sxs-lookup"><span data-stu-id="1b436-104">Azure Service Bus employs multiple message brokers to process messages and multiple messaging stores to store messages.</span></span> <span data-ttu-id="1b436-105">일반적인 큐 또는 항목은 단일 메시지 broker에서 처리되며 하나의 메시징 저장소에 저장됩니다.</span><span class="sxs-lookup"><span data-stu-id="1b436-105">A conventional queue or topic is handled by a single message broker and stored in one messaging store.</span></span> <span data-ttu-id="1b436-106">Service Bus *파티션*을 사용하면 큐 및 항목 또는 *메시징 엔터티*가 여러 메시지 broker 및 메시징 저장소에 분할될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="1b436-106">Service Bus *partitions* enable queues and topics, or *messaging entities*, to be partitioned across multiple message brokers and messaging stores.</span></span> <span data-ttu-id="1b436-107">즉, 분할된 엔터티의 전체 처리량은 단일 메시지 broker 또는 메시징 저장소의 성능으로 제한되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="1b436-107">This means that the overall throughput of a partitioned entity is no longer limited by the performance of a single message broker or messaging store.</span></span> <span data-ttu-id="1b436-108">또한 메시징 스토어가 일시적으로 중단된 경우에도 분할된 큐 또는 항목을 계속 렌더링할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="1b436-108">In addition, a temporary outage of a messaging store does not render a partitioned queue or topic unavailable.</span></span> <span data-ttu-id="1b436-109">분할된 큐 및 항목은 트랜잭션 및 세션에 대한 지원 같은 모든 고급 Service Bus 기능을 포함할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="1b436-109">Partitioned queues and topics can contain all advanced Service Bus features, such as support for transactions and sessions.</span></span>

<span data-ttu-id="1b436-110">Service Bus 내부 구조에 대한 내용은 [Service Bus 아키텍처][Service Bus architecture] 문서를 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="1b436-110">For information about Service Bus internals, see the [Service Bus architecture][Service Bus architecture] article.</span></span>

<span data-ttu-id="1b436-111">표준 및 프리미엄 메시징 둘 다의 모든 큐 및 토픽에서 엔티티가 생성될 때 기본적으로 파티션이 사용되도록 설정됩니다.</span><span class="sxs-lookup"><span data-stu-id="1b436-111">Partitioning is enabled by default at entity creation on all queues and topics in both Standard and Premium messaging.</span></span> <span data-ttu-id="1b436-112">분할 없이 표준 메시징 계층 엔터티를 만들 수 있지만 프리미엄 네임스페이스의 큐 및 토픽은 항상 분할되므로 이 옵션을 사용하지 않도록 설정할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="1b436-112">You can create Standard messaging tier entities without partitioning, but queues and topics in a Premium namespace are always partitioned; this option cannot be disabled.</span></span> 

<span data-ttu-id="1b436-113">표준 또는 프리미엄 계층에서 기존 큐 또는 토픽에 대해 분할 옵션을 변경할 수 없으며 엔터티를 만들 때만 이 옵션을 설정할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="1b436-113">It is not possible to change the partitioning option on an existing queue or topic in either Standard or Premium tiers, you can only set the option when you create the entity.</span></span>

## <a name="how-it-works"></a><span data-ttu-id="1b436-114">작동 방법</span><span class="sxs-lookup"><span data-stu-id="1b436-114">How it works</span></span>

<span data-ttu-id="1b436-115">분할된 큐 및 항목 각각은 여러 조각으로 구성됩니다.</span><span class="sxs-lookup"><span data-stu-id="1b436-115">Each partitioned queue or topic consists of multiple fragments.</span></span> <span data-ttu-id="1b436-116">각 조각은 다른 메시징 저장소에 저장되고 서로 다른 메시지 broker에서 처리됩니다.</span><span class="sxs-lookup"><span data-stu-id="1b436-116">Each fragment is stored in a different messaging store and handled by a different message broker.</span></span> <span data-ttu-id="1b436-117">분할된 큐 또는 항목으로 메시지를 보내면 Service Bus는 메시지를 조각 중 하나에 할당합니다.</span><span class="sxs-lookup"><span data-stu-id="1b436-117">When a message is sent to a partitioned queue or topic, Service Bus assigns the message to one of the fragments.</span></span> <span data-ttu-id="1b436-118">선택은 발신자가 지정할 수 있는 Service Bus 또는 파티션 키에서 임의로 수행됩니다.</span><span class="sxs-lookup"><span data-stu-id="1b436-118">The selection is done randomly by Service Bus or by using a partition key that the sender can specify.</span></span>

<span data-ttu-id="1b436-119">클라이언트가 분할된 큐 또는 분할된 항목의 구독에서 메시지를 받으려는 경우 Service Bus는 메시지에 모든 조각을 쿼리한 다음 수신자에게 메시징 저장소 중 하나에서 획득되는 첫 번째 메시지를 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="1b436-119">When a client wants to receive a message from a partitioned queue, or from a subscription to a partitioned topic, Service Bus queries all fragments for messages, then returns the first message that is obtained from any of the messaging stores to the receiver.</span></span> <span data-ttu-id="1b436-120">Service Bus는 추가 수신 요청을 받을 때 다른 메시지를 캐시하고 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="1b436-120">Service Bus caches the other messages and returns them when it receives additional receive requests.</span></span> <span data-ttu-id="1b436-121">수신하는 클라이언트는 분할을 인식하지 못합니다. 분할된 큐 또는 항목의 클라이언트 연결 동작(예, 읽기, 완료, 연기, 효력 상실, 프리페치)은 일반적인 엔터티 동작과 동일합니다.</span><span class="sxs-lookup"><span data-stu-id="1b436-121">A receiving client is not aware of the partitioning; the client-facing behavior of a partitioned queue or topic (for example, read, complete, defer, deadletter, prefetching) is identical to the behavior of a regular entity.</span></span>

<span data-ttu-id="1b436-122">분할된 큐 또는 항목에 메시지를 보내거나 메시지를 받을 때 추가 비용이 없습니다.</span><span class="sxs-lookup"><span data-stu-id="1b436-122">There is no additional cost when sending a message to, or receiving a message from, a partitioned queue or topic.</span></span>

## <a name="enable-partitioning"></a><span data-ttu-id="1b436-123">분할 사용</span><span class="sxs-lookup"><span data-stu-id="1b436-123">Enable partitioning</span></span>

<span data-ttu-id="1b436-124">Azure Service Bus로 분할된 큐 및 항목을 사용하려면 Azure SDK 버전 2.2 이상을 사용하거나 HTTP 요청에서 `api-version=2013-10`를 지정합니다.</span><span class="sxs-lookup"><span data-stu-id="1b436-124">To use partitioned queues and topics with Azure Service Bus, use the Azure SDK version 2.2 or later, or specify `api-version=2013-10` in your HTTP requests.</span></span>

### <a name="standard"></a><span data-ttu-id="1b436-125">Standard</span><span class="sxs-lookup"><span data-stu-id="1b436-125">Standard</span></span>

<span data-ttu-id="1b436-126">표준 메시징 계층에서 Service Bus 큐 및 토픽은 1, 2, 3, 4 또는 5GB 크기로 만들 수 있습니다(기본값은 1GB).</span><span class="sxs-lookup"><span data-stu-id="1b436-126">In the Standard messaging tier, you can create Service Bus queues and topics in 1, 2, 3, 4, or 5 GB sizes (the default is 1 GB).</span></span> <span data-ttu-id="1b436-127">분할을 사용하는 경우 Service Bus는 사용자가 지정한 각 GB마다 엔터티의 16개 사본(16개 파티션)을 만듭니다.</span><span class="sxs-lookup"><span data-stu-id="1b436-127">With partitioning enabled, Service Bus creates 16 copies (16 partitions) of the entity for each GB you specify.</span></span> <span data-ttu-id="1b436-128">따라서 크기가 5GB인 큐를 만들 경우 16개의 파티션에서 최대 큐 크기는 (5 \* 16) = 80GB가 됩니다.</span><span class="sxs-lookup"><span data-stu-id="1b436-128">As such, if you create a queue that's 5 GB in size, with 16 partitions the maximum queue size becomes (5 \* 16) = 80 GB.</span></span> <span data-ttu-id="1b436-129">[Azure Portal][Azure portal]의 해당 엔터티에 대한 **개요** 블레이드에서 해당 항목을 보면 분할된 큐 또는 토픽의 최대 크기를 확인할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="1b436-129">You can see the maximum size of your partitioned queue or topic by looking at its entry on the [Azure portal][Azure portal], in the **Overview** blade for that entity.</span></span>

### <a name="premium"></a><span data-ttu-id="1b436-130">Premium</span><span class="sxs-lookup"><span data-stu-id="1b436-130">Premium</span></span>

<span data-ttu-id="1b436-131">프리미어 계층 네임스페이스에서 Service Bus 큐 및 항목은 1, 2, 3, 4, 5, 10, 20, 40 또는 80GB 크기로 만들 수 있습니다(기본값은 1GB).</span><span class="sxs-lookup"><span data-stu-id="1b436-131">In a Premium tier namespace, you can create Service Bus queues and topics in 1, 2, 3, 4, 5, 10, 20, 40, or 80 GB sizes (the default is 1 GB).</span></span> <span data-ttu-id="1b436-132">기본적으로 분할이 사용되도록 설정되면 Service Bus는 엔터티마다 두 개의 파티션을 만듭니다.</span><span class="sxs-lookup"><span data-stu-id="1b436-132">With partitioning enabled by default, Service Bus creates two partitions per entity.</span></span> <span data-ttu-id="1b436-133">[Azure Portal][Azure portal]의 해당 엔터티에 대한 **개요** 블레이드에서 해당 항목을 보면 분할된 큐 또는 토픽의 최대 크기를 확인할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="1b436-133">You can see the maximum size of your partitioned queue or topic by looking at its entry on the [Azure portal][Azure portal], in the **Overview** blade for that entity.</span></span>

<span data-ttu-id="1b436-134">프리미엄 메시징 계층의 분할에 대한 자세한 내용은 [Service Bus 프리미엄 및 표준 메시징 계층](service-bus-premium-messaging.md)을 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="1b436-134">For more information about partitioning in the Premium messaging tier, see [Service Bus Premium and Standard messaging tiers](service-bus-premium-messaging.md).</span></span> 

### <a name="create-a-partitioned-entity"></a><span data-ttu-id="1b436-135">분할된 엔터티 만들기</span><span class="sxs-lookup"><span data-stu-id="1b436-135">Create a partitioned entity</span></span>

<span data-ttu-id="1b436-136">분할된 큐 또는 항목을 만들 수 있는 여러 방법이 있습니다.</span><span class="sxs-lookup"><span data-stu-id="1b436-136">There are several ways to create a partitioned queue or topic.</span></span> <span data-ttu-id="1b436-137">응용 프로그램에서 큐 또는 항목을 만들 때 [QueueDescription.EnablePartitioning][QueueDescription.EnablePartitioning] 또는 [TopicDescription.EnablePartitioning][TopicDescription.EnablePartitioning] 속성을 각각 **true**로 설정하여 큐 또는 항목에 분할을 설정할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="1b436-137">When you create the queue or topic from your application, you can enable partitioning for the queue or topic by respectively setting the [QueueDescription.EnablePartitioning][QueueDescription.EnablePartitioning] or [TopicDescription.EnablePartitioning][TopicDescription.EnablePartitioning] property to **true**.</span></span> <span data-ttu-id="1b436-138">이러한 속성은 큐 또는 항목이 만들어진 시점에 설정되어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="1b436-138">These properties must be set at the time the queue or topic is created.</span></span> <span data-ttu-id="1b436-139">앞서 설명한 것처럼 기존 큐 또는 토픽에서 이러한 속성을 변경하는 것은 불가능합니다.</span><span class="sxs-lookup"><span data-stu-id="1b436-139">As stated previously, it is not possible to change these properties on an existing queue or topic.</span></span> <span data-ttu-id="1b436-140">예:</span><span class="sxs-lookup"><span data-stu-id="1b436-140">For example:</span></span>

```csharp
// Create partitioned topic
NamespaceManager ns = NamespaceManager.CreateFromConnectionString(myConnectionString);
TopicDescription td = new TopicDescription(TopicName);
td.EnablePartitioning = true;
ns.CreateTopic(td);
```

<span data-ttu-id="1b436-141">또는 [Azure Portal][Azure portal]이나 Visual Studio에서 분할된 큐나 토픽을 만들 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="1b436-141">Alternatively, you can create a partitioned queue or topic in the [Azure portal][Azure portal] or in Visual Studio.</span></span> <span data-ttu-id="1b436-142">포털에서 큐 또는 토픽을 만들 때 큐 또는 토픽 **Create** 블레이드에 있는 **분할 사용** 옵션이 기본적으로 선택되어 있습니다.</span><span class="sxs-lookup"><span data-stu-id="1b436-142">When you create a queue or topic in the portal, the **Enable partitioning** option in the queue or topic **Create** blade is checked by default.</span></span> <span data-ttu-id="1b436-143">이 옵션은 표준 계층 엔터티에서만 사용하지 않도록 설정할 수 있고 프리미엄 계층 분할은 항상 사용됩니다.</span><span class="sxs-lookup"><span data-stu-id="1b436-143">You can only disable this option in a Standard tier entity; in the Premium tier partitioning is always enabled.</span></span> <span data-ttu-id="1b436-144">Visual Studio에서 **새 큐** 또는 **새 항목** 대화 상자의 **분할 사용** 확인란을 클릭합니다.</span><span class="sxs-lookup"><span data-stu-id="1b436-144">In Visual Studio, click the **Enable Partitioning** checkbox in the **New Queue** or **New Topic** dialog box.</span></span>

## <a name="use-of-partition-keys"></a><span data-ttu-id="1b436-145">파티션 키의 사용</span><span class="sxs-lookup"><span data-stu-id="1b436-145">Use of partition keys</span></span>
<span data-ttu-id="1b436-146">메시지가 분할된 큐 또는 항목에 큐를 넣으면 Service Bus는 파티션 키의 존재를 확인합니다.</span><span class="sxs-lookup"><span data-stu-id="1b436-146">When a message is enqueued into a partitioned queue or topic, Service Bus checks for the presence of a partition key.</span></span> <span data-ttu-id="1b436-147">파티션 키를 찾으면 해당 키를 기반으로 조각을 선택합니다.</span><span class="sxs-lookup"><span data-stu-id="1b436-147">If it finds one, it selects the fragment based on that key.</span></span> <span data-ttu-id="1b436-148">파티션 키를 찾지 못하면 내부 알고리즘을 기반으로 조각을 선택합니다.</span><span class="sxs-lookup"><span data-stu-id="1b436-148">If it does not find a partition key, it selects the fragment based on an internal algorithm.</span></span>

### <a name="using-a-partition-key"></a><span data-ttu-id="1b436-149">파티션 키 사용</span><span class="sxs-lookup"><span data-stu-id="1b436-149">Using a partition key</span></span>
<span data-ttu-id="1b436-150">세션 또는 트랜잭션과 같은 일부 시나리오에서는 특정 조각에 저장할 메시지가 필요합니다.</span><span class="sxs-lookup"><span data-stu-id="1b436-150">Some scenarios, such as sessions or transactions, require messages to be stored in a specific fragment.</span></span> <span data-ttu-id="1b436-151">이러한 모든 시나리오에서는 파티션 키를 사용해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="1b436-151">All these scenarios require the use of a partition key.</span></span> <span data-ttu-id="1b436-152">동일한 파티션 키를 사용하는 모든 메시지는 동일한 조각에 할당됩니다.</span><span class="sxs-lookup"><span data-stu-id="1b436-152">All messages that use the same partition key are assigned to the same fragment.</span></span> <span data-ttu-id="1b436-153">조각을 일시적으로 사용할 수 없는 경우 Service Bus가 오류를 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="1b436-153">If the fragment is temporarily unavailable, Service Bus returns an error.</span></span>

<span data-ttu-id="1b436-154">시나리오에 따라 다양한 메시지 속성이 파티션 키로 사용됩니다.</span><span class="sxs-lookup"><span data-stu-id="1b436-154">Depending on the scenario, different message properties are used as a partition key:</span></span>

<span data-ttu-id="1b436-155">**SessionId**: 메시지에 [BrokeredMessage.SessionId][BrokeredMessage.SessionId] 속성 집합이 있으면 Service Bus는 해당 속성을 파티션 키로 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="1b436-155">**SessionId**: If a message has the [BrokeredMessage.SessionId][BrokeredMessage.SessionId] property set, then Service Bus uses this property as the partition key.</span></span> <span data-ttu-id="1b436-156">이러한 방식으로 동일한 세션에 속한 모든 메시지가 동일한 메시지 broker에서 처리됩니다.</span><span class="sxs-lookup"><span data-stu-id="1b436-156">This way, all messages that belong to the same session are handled by the same message broker.</span></span> <span data-ttu-id="1b436-157">이를 사용하면 Service Bus가 세션 상태의 일관성 뿐만 아니라 메시지 순서를 보장할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="1b436-157">This enables Service Bus to guarantee message ordering as well as the consistency of session states.</span></span>

<span data-ttu-id="1b436-158">**PartitionKey**: 메시지에 [BrokeredMessage.PartitionKey][BrokeredMessage.PartitionKey] 속성이 있지만 [BrokeredMessage.SessionId][BrokeredMessage.SessionId] 속성 집합이 없으면 Service Bus는 [PartitionKey][PartitionKey] 속성을 파티션 키로 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="1b436-158">**PartitionKey**: If a message has the [BrokeredMessage.PartitionKey][BrokeredMessage.PartitionKey] property but not the [BrokeredMessage.SessionId][BrokeredMessage.SessionId] property set, then Service Bus uses the [PartitionKey][PartitionKey] property as the partition key.</span></span> <span data-ttu-id="1b436-159">메시지에 [SessionId][SessionId] 및 [PartitionKey][PartitionKey] 속성 집합이 모두 있으면 속성이 모두 동일해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="1b436-159">If the message has both the [SessionId][SessionId] and the [PartitionKey][PartitionKey] properties set, both properties must be identical.</span></span> <span data-ttu-id="1b436-160">[PartitionKey][PartitionKey] 속성이 [SessionId][SessionId] 속성이 아닌 다른 값으로 설정되면 Service Bus는 잘못된 작업 예외를 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="1b436-160">If the [PartitionKey][PartitionKey] property is set to a different value than the [SessionId][SessionId] property, Service Bus returns an invalid operation exception.</span></span> <span data-ttu-id="1b436-161">발신자가 비 세션 인식 트랜잭션 메시지를 보내는 경우 [PartitionKey][PartitionKey] 속성을 사용해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="1b436-161">The [PartitionKey][PartitionKey] property should be used if a sender sends non-session aware transactional messages.</span></span> <span data-ttu-id="1b436-162">파티션 키는 트랜잭션 내에서 전송되는 모든 메시지가 동일한 메시징 broker에서 처리되도록 합니다.</span><span class="sxs-lookup"><span data-stu-id="1b436-162">The partition key ensures that all messages that are sent within a transaction are handled by the same messaging broker.</span></span>

<span data-ttu-id="1b436-163">**MessageId**: 큐 또는 항목에 [QueueDescription.RequiresDuplicateDetection][QueueDescription.RequiresDuplicateDetection] 속성이 **true**로 설정되고 [BrokeredMessage.SessionId][BrokeredMessage.SessionId] 또는 [BrokeredMessage.PartitionKey][BrokeredMessage.PartitionKey] 속성이 설정되지 않은 경우 [BrokeredMessage.MessageId][BrokeredMessage.MessageId] 속성이 파티션 키로 제공됩니다.</span><span class="sxs-lookup"><span data-stu-id="1b436-163">**MessageId**: If the queue or topic has the [QueueDescription.RequiresDuplicateDetection][QueueDescription.RequiresDuplicateDetection] property set to **true** and the [BrokeredMessage.SessionId][BrokeredMessage.SessionId] or [BrokeredMessage.PartitionKey][BrokeredMessage.PartitionKey] properties are not set, then the [BrokeredMessage.MessageId][BrokeredMessage.MessageId] property serves as the partition key.</span></span> <span data-ttu-id="1b436-164">(보내는 응용 프로그램이 메시지 ID를 할당하지 않으면 Microsoft .NET 및 AMQP 라이브러리는 자동으로 메시지 ID를 할당함) 이 경우에 동일한 메시지의 모든 복사본이 동일한 메시지 broker에서 처리됩니다.</span><span class="sxs-lookup"><span data-stu-id="1b436-164">(Note that the Microsoft .NET and AMQP libraries automatically assign a message ID if the sending application does not.) In this case, all copies of the same message are handled by the same message broker.</span></span> <span data-ttu-id="1b436-165">따라서 Service Bus가 중복 메시지를 감지하고 제거할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="1b436-165">This enables Service Bus to detect and eliminate duplicate messages.</span></span> <span data-ttu-id="1b436-166">[QueueDescription.RequiresDuplicateDetection][QueueDescription.RequiresDuplicateDetection] 속성이 **true**로 설정되지 않으면 Service Bus는 [MessageId][MessageId] 속성을 파티션 키로 고려하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="1b436-166">If the [QueueDescription.RequiresDuplicateDetection][QueueDescription.RequiresDuplicateDetection] property is not set to **true**, Service Bus does not consider the [MessageId][MessageId] property as a partition key.</span></span>

### <a name="not-using-a-partition-key"></a><span data-ttu-id="1b436-167">파티션 키 사용하지 않음</span><span class="sxs-lookup"><span data-stu-id="1b436-167">Not using a partition key</span></span>
<span data-ttu-id="1b436-168">파티션 키가 없으면 Service Bus는 분할된 큐 또는 항목의 모든 조각에 라운드 로빈 방식으로 메시지를 분산합니다.</span><span class="sxs-lookup"><span data-stu-id="1b436-168">In the absence of a partition key, Service Bus distributes messages in a round-robin fashion to all the fragments of the partitioned queue or topic.</span></span> <span data-ttu-id="1b436-169">선택한 조각을 사용할 수 없으면 Service Bus는 다른 조각에 메시지를 할당합니다.</span><span class="sxs-lookup"><span data-stu-id="1b436-169">If the chosen fragment is not available, Service Bus assigns the message to a different fragment.</span></span> <span data-ttu-id="1b436-170">이러한 방식으로 메시징 저장소를 일시적으로 사용할 수 없음에도 불구하고 보내기 작업은 성공합니다.</span><span class="sxs-lookup"><span data-stu-id="1b436-170">This way, the send operation succeeds despite the temporary unavailability of a messaging store.</span></span> <span data-ttu-id="1b436-171">그러나 파티션 키가 제공하는 순서가 보장되지는 않습니다.</span><span class="sxs-lookup"><span data-stu-id="1b436-171">However, you will not achieve the guaranteed ordering that a partition key provides.</span></span>

<span data-ttu-id="1b436-172">가용성(파티션 키 없음) 및 일관성(파티션 키 사용) 간 상쇄 관계에 대한 보다 자세한 설명을 보려면 [이 문서](../event-hubs/event-hubs-availability-and-consistency.md)를 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="1b436-172">For a more in-depth discussion of the tradeoff between availability (no partition key) and consistency (using a partition key), see [this article](../event-hubs/event-hubs-availability-and-consistency.md).</span></span> <span data-ttu-id="1b436-173">이 정보는 분할된 Service Bus 엔터티 및 Event Hubs 파티션에 동일하게 적용됩니다.</span><span class="sxs-lookup"><span data-stu-id="1b436-173">This information applies equally to partitioned Service Bus entities and Event Hubs partitions.</span></span>

<span data-ttu-id="1b436-174">메시지를 다른 조각으로 큐에 넣도록 Service Bus에 충분한 시간을 주려면 메시지를 보내는 클라이언트에서 지정된 [MessagingFactorySettings.OperationTimeout][MessagingFactorySettings.OperationTimeout] 값은 15초보다 커야 합니다.</span><span class="sxs-lookup"><span data-stu-id="1b436-174">To give Service Bus enough time to enqueue the message into a different fragment, the [MessagingFactorySettings.OperationTimeout][MessagingFactorySettings.OperationTimeout] value specified by the client that sends the message must be greater than 15 seconds.</span></span> <span data-ttu-id="1b436-175">[OperationTimeout][OperationTimeout] 속성을 기본값인 60초로 설정하는 것이 좋습니다.</span><span class="sxs-lookup"><span data-stu-id="1b436-175">It is recommended that you set the [OperationTimeout][OperationTimeout] property to the default value of 60 seconds.</span></span>

<span data-ttu-id="1b436-176">파티션 키는 특정 조각에 메시지를 "고정"합니다.</span><span class="sxs-lookup"><span data-stu-id="1b436-176">Note that a partition key "pins" a message to a specific fragment.</span></span> <span data-ttu-id="1b436-177">이 조각이 보관된 메시징 저장소를 사용할 수 없으면 Service Bus는 오류를 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="1b436-177">If the messaging store that holds this fragment is unavailable, Service Bus returns an error.</span></span> <span data-ttu-id="1b436-178">파티션 키가 없으면 Service Bus는 다른 조각을 선택할 수 있고 작업은 성공합니다.</span><span class="sxs-lookup"><span data-stu-id="1b436-178">In the absence of a partition key, Service Bus can choose a different fragment and the operation succeeds.</span></span> <span data-ttu-id="1b436-179">그러므로 필요한 경우가 아니면 파티션 키를 제공하지 않는 것이 좋습니다.</span><span class="sxs-lookup"><span data-stu-id="1b436-179">Therefore, it is recommended that you do not supply a partition key unless it is required.</span></span>

## <a name="advanced-topics-use-transactions-with-partitioned-entities"></a><span data-ttu-id="1b436-180">고급 항목: 분할된 엔터티로 트랜잭션 사용</span><span class="sxs-lookup"><span data-stu-id="1b436-180">Advanced topics: use transactions with partitioned entities</span></span>
<span data-ttu-id="1b436-181">트랜잭션의 일부로 전송되는 메시지는 파티션 키를 지정해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="1b436-181">Messages that are sent as part of a transaction must specify a partition key.</span></span> <span data-ttu-id="1b436-182">[BrokeredMessage.SessionId][BrokeredMessage.SessionId], [BrokeredMessage.PartitionKey][BrokeredMessage.PartitionKey] 또는 [BrokeredMessage.MessageId][BrokeredMessage.MessageId] 속성 중 하나일 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="1b436-182">This can be one of the following properties: [BrokeredMessage.SessionId][BrokeredMessage.SessionId], [BrokeredMessage.PartitionKey][BrokeredMessage.PartitionKey], or [BrokeredMessage.MessageId][BrokeredMessage.MessageId].</span></span> <span data-ttu-id="1b436-183">동일한 트랜잭션의 일부로 전송되는 모든 메시지는 동일한 파티션 키를 지정해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="1b436-183">All messages that are sent as part of the same transaction must specify the same partition key.</span></span> <span data-ttu-id="1b436-184">트랜잭션 내에서 파티션 키 없이 메시지를 보내려면 Service Bus는 잘못된 작업 예외를 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="1b436-184">If you attempt to send a message without a partition key within a transaction, Service Bus returns an invalid operation exception.</span></span> <span data-ttu-id="1b436-185">다른 파티션 키를 가진 동일한 트랜잭션 내에서 여러 메시지를 보내려면 Service Bus는 잘못된 작업 예외를 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="1b436-185">If you attempt to send multiple messages within the same transaction that have different partition keys, Service Bus returns an invalid operation exception.</span></span> <span data-ttu-id="1b436-186">예:</span><span class="sxs-lookup"><span data-stu-id="1b436-186">For example:</span></span>

```csharp
CommittableTransaction committableTransaction = new CommittableTransaction();
using (TransactionScope ts = new TransactionScope(committableTransaction))
{
    BrokeredMessage msg = new BrokeredMessage("This is a message");
    msg.PartitionKey = "myPartitionKey";
    messageSender.Send(msg); 
    ts.Complete();
}
committableTransaction.Commit();
```

<span data-ttu-id="1b436-187">파티션 키로 제공한 속성을 설정하면 Service Bus는 특정 조각에 메시지를 고정합니다.</span><span class="sxs-lookup"><span data-stu-id="1b436-187">If any of the properties that serve as a partition key are set, Service Bus pins the message to a specific fragment.</span></span> <span data-ttu-id="1b436-188">이 동작은 트랜잭션이 사용되는지 여부와 상관 없이 발생합니다.</span><span class="sxs-lookup"><span data-stu-id="1b436-188">This behavior occurs whether or not a transaction is used.</span></span> <span data-ttu-id="1b436-189">필요하지 않은 경우 파티션 키를 지정하지 않는 것이 좋습니다.</span><span class="sxs-lookup"><span data-stu-id="1b436-189">It is recommended that you do not specify a partition key if it is not necessary.</span></span>

## <a name="using-sessions-with-partitioned-entities"></a><span data-ttu-id="1b436-190">분할된 엔터티로 세션 사용</span><span class="sxs-lookup"><span data-stu-id="1b436-190">Using sessions with partitioned entities</span></span>
<span data-ttu-id="1b436-191">세션 인식 토픽 또는 큐에 트랜잭션 메시지를 보내려면 메시지에 [BrokeredMessage.SessionId][BrokeredMessage.SessionId] 속성 집합이 있어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="1b436-191">To send a transactional message to a session-aware topic or queue, the message must have the [BrokeredMessage.SessionId][BrokeredMessage.SessionId] property set.</span></span> <span data-ttu-id="1b436-192">[BrokeredMessage.PartitionKey][BrokeredMessage.PartitionKey] 속성도 지정될 경우 [SessionId][SessionId] 속성과 동일해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="1b436-192">If the [BrokeredMessage.PartitionKey][BrokeredMessage.PartitionKey] property is specified as well, it must be identical to the [SessionId][SessionId] property.</span></span> <span data-ttu-id="1b436-193">다른 경우 Service Bus가 잘못된 작업 예외를 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="1b436-193">If they differ, Service Bus returns an invalid operation exception.</span></span>

<span data-ttu-id="1b436-194">일반(분할되지 않은) 큐 또는 항목과 달리 단일 트랜잭션을 사용하여 다른 세션에 여러 메시지를 보낼 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="1b436-194">Unlike regular (non-partitioned) queues or topics, it is not possible to use a single transaction to send multiple messages to different sessions.</span></span> <span data-ttu-id="1b436-195">시도할 경우 Service Bus가 잘못된 작업 예외를 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="1b436-195">If attempted, Service Bus returns an invalid operation exception.</span></span> <span data-ttu-id="1b436-196">예:</span><span class="sxs-lookup"><span data-stu-id="1b436-196">For example:</span></span>

```csharp
CommittableTransaction committableTransaction = new CommittableTransaction();
using (TransactionScope ts = new TransactionScope(committableTransaction))
{
    BrokeredMessage msg = new BrokeredMessage("This is a message");
    msg.SessionId = "mySession";
    messageSender.Send(msg); 
    ts.Complete();
}
committableTransaction.Commit();
```

## <a name="automatic-message-forwarding-with-partitioned-entities"></a><span data-ttu-id="1b436-197">분할된 엔터티로 자동 메시지 전달</span><span class="sxs-lookup"><span data-stu-id="1b436-197">Automatic message forwarding with partitioned entities</span></span>
<span data-ttu-id="1b436-198">Service Bus는 분할된 엔터티 간에 자동 메시지 전달을 지원합니다.</span><span class="sxs-lookup"><span data-stu-id="1b436-198">Service Bus supports automatic message forwarding from, to, or between partitioned entities.</span></span> <span data-ttu-id="1b436-199">자동 메시지 전달을 사용하려면 원본 큐 또는 구독에 [QueueDescription.ForwardTo][QueueDescription.ForwardTo] 속성을 설정합니다.</span><span class="sxs-lookup"><span data-stu-id="1b436-199">To enable automatic message forwarding, set the [QueueDescription.ForwardTo][QueueDescription.ForwardTo] property on the source queue or subscription.</span></span> <span data-ttu-id="1b436-200">메시지가 파티션 키([SessionId][SessionId], [PartitionKey][PartitionKey] 또는 [MessageId][MessageId])를 지정하는 경우 해당 파티션 키를 대상 엔터티에 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="1b436-200">If the message specifies a partition key ([SessionId][SessionId], [PartitionKey][PartitionKey], or [MessageId][MessageId]), that partition key is used for the destination entity.</span></span>

## <a name="considerations-and-guidelines"></a><span data-ttu-id="1b436-201">고려 사항 및 지침</span><span class="sxs-lookup"><span data-stu-id="1b436-201">Considerations and guidelines</span></span>
* <span data-ttu-id="1b436-202">**높은 일관성 기능**: 엔터티가 세션, 중복 검색 또는 분할 키의 명시적 제어와 같은 기능을 사용하면 메시징 작업이 항상 특정 부분으로 라우팅됩니다.</span><span class="sxs-lookup"><span data-stu-id="1b436-202">**High consistency features**: If an entity uses features such as sessions, duplicate detection, or explicit control of partitioning key, then the messaging operations are always routed to specific fragments.</span></span> <span data-ttu-id="1b436-203">어떤 부분이라도 트래픽이 높아지거나 기본 저장소가 손상되면 해당 작업은 실패하고 가용성은 줄어듭니다.</span><span class="sxs-lookup"><span data-stu-id="1b436-203">If any of the fragments experience high traffic or the underlying store is unhealthy, those operations fail and availability is reduced.</span></span> <span data-ttu-id="1b436-204">결과적으로 분할되지 않은 엔터티보다 일관성은 훨씬 높아집니다. 모든 트래픽이 아닌 트래픽 일부에서만 문제가 나타나기 때문입니다.</span><span class="sxs-lookup"><span data-stu-id="1b436-204">Overall, the consistency is still much higher than non-partitioned entities; only a subset of traffic is experiencing issues, as opposed to all the traffic.</span></span> <span data-ttu-id="1b436-205">자세한 내용은 이 [가용성 및 일관성 논의](../event-hubs/event-hubs-availability-and-consistency.md)를 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="1b436-205">For more information, see this [discussion of availability and consistency](../event-hubs/event-hubs-availability-and-consistency.md).</span></span>
* <span data-ttu-id="1b436-206">**관리**: 생성, 업데이트 및 삭제와 같은 작업은 엔터티의 모든 부분에서 수행되어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="1b436-206">**Management**: Operations such as Create, Update and Delete must be performed on all the fragments of the entity.</span></span> <span data-ttu-id="1b436-207">어떤 부분이라도 손상되면 이러한 작업이 실패할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="1b436-207">If any fragment is unhealthy it could result in failures for these operations.</span></span> <span data-ttu-id="1b436-208">Get 작업의 경우 메시지 수와 같은 정보를 모든 부분에서 집계해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="1b436-208">For the Get operation, information such as message counts must be aggregated from all fragments.</span></span> <span data-ttu-id="1b436-209">어떤 부분이라도 손상되면 엔터티 가용성 상태가 제한으로 보고됩니다.</span><span class="sxs-lookup"><span data-stu-id="1b436-209">If any fragment is unhealthy, the entity availability status is reported as limited.</span></span>
* <span data-ttu-id="1b436-210">**저용량 메시지 시나리오**: 이런 시나리오에서, 특히 HTTP 프로토콜을 사용하는 경우 모든 메시지를 가져오기 위해 여러 수신 작업을 수행해야 할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="1b436-210">**Low volume message scenarios**: For such scenarios, especially when using the HTTP protocol, you may have to perform multiple receive operations in order to obtain all the messages.</span></span> <span data-ttu-id="1b436-211">수신 요청의 경우 프런트 엔드는 모든 부분에 대해 수신을 수행하고 수신된 모든 응답을 캐시합니다.</span><span class="sxs-lookup"><span data-stu-id="1b436-211">For receive requests, the front end performs a receive on all the fragments and caches all the responses received.</span></span> <span data-ttu-id="1b436-212">동일한 연결에 대한 후속 수신 요청은 이러한 캐싱 덕분에 수신 대기 시간이 감소합니다.</span><span class="sxs-lookup"><span data-stu-id="1b436-212">A subsequent receive request on the same connection would benefit from this caching and receive latencies will be lower.</span></span> <span data-ttu-id="1b436-213">그러나 연결이 여러 개 있거나 HTTP를 사용하는 경우 각 요청에 대해 새 연결이 설정됩니다.</span><span class="sxs-lookup"><span data-stu-id="1b436-213">However, if you have multiple connections or use HTTP, that establishes a new connection for each request.</span></span> <span data-ttu-id="1b436-214">따라서 동일한 노드에 요청이 들어온다고 보장할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="1b436-214">As such, there is no guarantee that it would land on the same node.</span></span> <span data-ttu-id="1b436-215">모든 기존 메시지가 잠기고 다른 프런트 엔드에 캐시될 경우 수신 작업은 **null**을 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="1b436-215">If all existing messages are locked and cached in another front end, the receive operation returns **null**.</span></span> <span data-ttu-id="1b436-216">결과적으로 메시지가 만료되고 다시 받을 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="1b436-216">Messages eventually expire and you can receive them again.</span></span> <span data-ttu-id="1b436-217">HTTP 연결 유지를 사용하는 것이 좋습니다.</span><span class="sxs-lookup"><span data-stu-id="1b436-217">HTTP keep-alive is recommended.</span></span>
* <span data-ttu-id="1b436-218">**메시지 찾아보기/엿보기**: [PeekBatch](/dotnet/api/microsoft.servicebus.messaging.queueclient#Microsoft_ServiceBus_Messaging_QueueClient_PeekBatch_System_Int32_)가 [MessageCount](/dotnet/api/microsoft.servicebus.messaging.queuedescription#Microsoft_ServiceBus_Messaging_QueueDescription_MessageCount) 속성에 지정된 메시지 수를 항상 반환하지는 않습니다.</span><span class="sxs-lookup"><span data-stu-id="1b436-218">**Browse/Peek messages**: [PeekBatch](/dotnet/api/microsoft.servicebus.messaging.queueclient#Microsoft_ServiceBus_Messaging_QueueClient_PeekBatch_System_Int32_) does not always return the number of messages specified in the [MessageCount](/dotnet/api/microsoft.servicebus.messaging.queuedescription#Microsoft_ServiceBus_Messaging_QueueDescription_MessageCount) property.</span></span> <span data-ttu-id="1b436-219">그 이유에는 일반적으로 다음 두 가지가 있습니다.</span><span class="sxs-lookup"><span data-stu-id="1b436-219">There are two common reasons for this.</span></span> <span data-ttu-id="1b436-220">하나는 메시지 컬렉션의 집계 크기가 최대 크기인 256KB를 초과하기 때문입니다.</span><span class="sxs-lookup"><span data-stu-id="1b436-220">One reason is that the aggregated size of the collection of messages exceeds the maximum size of 256KB.</span></span> <span data-ttu-id="1b436-221">또 다른 이유는 큐 또는 토픽이 [EnablePartitioning 속성](/dotnet/api/microsoft.servicebus.messaging.queuedescription#Microsoft_ServiceBus_Messaging_QueueDescription_EnablePartitioning)을 **true**로 설정하면 파티션에 요청된 메시지 수를 완료하기 위한 충분한 메시지에 없을 수 있기 때문입니다.</span><span class="sxs-lookup"><span data-stu-id="1b436-221">Another reason is that if the queue or topic has the [EnablePartitioning property](/dotnet/api/microsoft.servicebus.messaging.queuedescription#Microsoft_ServiceBus_Messaging_QueueDescription_EnablePartitioning) set to **true**, a partition may not have enough messages to complete the requested number of messages.</span></span> <span data-ttu-id="1b436-222">일반적으로 응용 프로그램이 특정 개수의 메시지를 받으려는 경우 해당 메시지 수에 도달할 때까지 또는 엿볼 수 있는 추가 메시지가 없게 될 때까지 [PeekBatch](/dotnet/api/microsoft.servicebus.messaging.queueclient#Microsoft_ServiceBus_Messaging_QueueClient_PeekBatch_System_Int32_)를 반복적으로 호출해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="1b436-222">In general, if an application wants to receive a specific number of messages, it should call [PeekBatch](/dotnet/api/microsoft.servicebus.messaging.queueclient#Microsoft_ServiceBus_Messaging_QueueClient_PeekBatch_System_Int32_) repeatedly until it gets that number of messages, or there are no more messages to peek.</span></span> <span data-ttu-id="1b436-223">코드 샘플을 비롯한 자세한 내용은 [QueueClient.PeekBatch](/dotnet/api/microsoft.servicebus.messaging.queueclient#Microsoft_ServiceBus_Messaging_QueueClient_PeekBatch_System_Int32_) 또는 [SubscriptionClient.PeekBatch](/dotnet/api/microsoft.servicebus.messaging.subscriptionclient#Microsoft_ServiceBus_Messaging_SubscriptionClient_PeekBatch_System_Int32_)를 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="1b436-223">For more information, including code samples, see [QueueClient.PeekBatch](/dotnet/api/microsoft.servicebus.messaging.queueclient#Microsoft_ServiceBus_Messaging_QueueClient_PeekBatch_System_Int32_) or [SubscriptionClient.PeekBatch](/dotnet/api/microsoft.servicebus.messaging.subscriptionclient#Microsoft_ServiceBus_Messaging_SubscriptionClient_PeekBatch_System_Int32_).</span></span>

## <a name="latest-added-features"></a><span data-ttu-id="1b436-224">최근에 추가된 기능</span><span class="sxs-lookup"><span data-stu-id="1b436-224">Latest added features</span></span>
* <span data-ttu-id="1b436-225">이제 분할된 엔터티에 대해 규칙 추가 또는 제거가 지원됩니다.</span><span class="sxs-lookup"><span data-stu-id="1b436-225">Add or remove rule is now supported with partitioned entities.</span></span> <span data-ttu-id="1b436-226">분할되지 않은 엔터티와 달리, 트랜잭션에서 이러한 작업은 지원되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="1b436-226">Different from non-partitioned entities, these operations are not supported under transactions.</span></span> 
* <span data-ttu-id="1b436-227">AMQP는 분할된 엔터티와 메시지를 주고받기 위해 지원됩니다.</span><span class="sxs-lookup"><span data-stu-id="1b436-227">AMQP is now supported for sending and receiving messages to and from a partitioned entity.</span></span>
* <span data-ttu-id="1b436-228">현재 AMQP는 [일괄 전송](/dotnet/api/microsoft.servicebus.messaging.queueclient#Microsoft_ServiceBus_Messaging_QueueClient_SendBatch_System_Collections_Generic_IEnumerable_Microsoft_ServiceBus_Messaging_BrokeredMessage__), [일괄 수신](/dotnet/api/microsoft.servicebus.messaging.queueclient#Microsoft_ServiceBus_Messaging_QueueClient_ReceiveBatch_System_Int32_), [시퀀스 번호로 수신](/dotnet/api/microsoft.servicebus.messaging.queueclient#Microsoft_ServiceBus_Messaging_QueueClient_Receive_System_Int64_), [엿보기](/dotnet/api/microsoft.servicebus.messaging.queueclient#Microsoft_ServiceBus_Messaging_QueueClient_Peek), [잠금 갱신](/dotnet/api/microsoft.servicebus.messaging.queueclient#Microsoft_ServiceBus_Messaging_QueueClient_RenewMessageLock_System_Guid_), [메시지 예약](/dotnet/api/microsoft.servicebus.messaging.queueclient#Microsoft_ServiceBus_Messaging_QueueClient_ScheduleMessageAsync_Microsoft_ServiceBus_Messaging_BrokeredMessage_System_DateTimeOffset_), [예약된 메시지 취소](/dotnet/api/microsoft.servicebus.messaging.queueclient#Microsoft_ServiceBus_Messaging_QueueClient_CancelScheduledMessageAsync_System_Int64_), [규칙 추가](/dotnet/api/microsoft.servicebus.messaging.ruledescription), [규칙 제거](/dotnet/api/microsoft.servicebus.messaging.ruledescription), [세션 잠금 갱신](/dotnet/api/microsoft.servicebus.messaging.messagesession#Microsoft_ServiceBus_Messaging_MessageSession_RenewLock), [세션 상태 설정](/dotnet/api/microsoft.servicebus.messaging.messagesession#Microsoft_ServiceBus_Messaging_MessageSession_SetState_System_IO_Stream_), [세션 상태 가져오기](/dotnet/api/microsoft.servicebus.messaging.messagesession#Microsoft_ServiceBus_Messaging_MessageSession_GetState) 및 [세션 열거](/dotnet/api/microsoft.servicebus.messaging.queueclient#Microsoft_ServiceBus_Messaging_QueueClient_GetMessageSessionsAsync) 작업에 지원됩니다.</span><span class="sxs-lookup"><span data-stu-id="1b436-228">AMQP is now supported for the following operations: [Batch Send](/dotnet/api/microsoft.servicebus.messaging.queueclient#Microsoft_ServiceBus_Messaging_QueueClient_SendBatch_System_Collections_Generic_IEnumerable_Microsoft_ServiceBus_Messaging_BrokeredMessage__), [Batch Receive](/dotnet/api/microsoft.servicebus.messaging.queueclient#Microsoft_ServiceBus_Messaging_QueueClient_ReceiveBatch_System_Int32_), [Receive by Sequence Number](/dotnet/api/microsoft.servicebus.messaging.queueclient#Microsoft_ServiceBus_Messaging_QueueClient_Receive_System_Int64_), [Peek](/dotnet/api/microsoft.servicebus.messaging.queueclient#Microsoft_ServiceBus_Messaging_QueueClient_Peek), [Renew Lock](/dotnet/api/microsoft.servicebus.messaging.queueclient#Microsoft_ServiceBus_Messaging_QueueClient_RenewMessageLock_System_Guid_), [Schedule Message](/dotnet/api/microsoft.servicebus.messaging.queueclient#Microsoft_ServiceBus_Messaging_QueueClient_ScheduleMessageAsync_Microsoft_ServiceBus_Messaging_BrokeredMessage_System_DateTimeOffset_), [Cancel Scheduled Message](/dotnet/api/microsoft.servicebus.messaging.queueclient#Microsoft_ServiceBus_Messaging_QueueClient_CancelScheduledMessageAsync_System_Int64_), [Add Rule](/dotnet/api/microsoft.servicebus.messaging.ruledescription), [Remove Rule](/dotnet/api/microsoft.servicebus.messaging.ruledescription), [Session Renew Lock](/dotnet/api/microsoft.servicebus.messaging.messagesession#Microsoft_ServiceBus_Messaging_MessageSession_RenewLock), [Set Session State](/dotnet/api/microsoft.servicebus.messaging.messagesession#Microsoft_ServiceBus_Messaging_MessageSession_SetState_System_IO_Stream_), [Get Session State](/dotnet/api/microsoft.servicebus.messaging.messagesession#Microsoft_ServiceBus_Messaging_MessageSession_GetState), and [Enumerate Sessions](/dotnet/api/microsoft.servicebus.messaging.queueclient#Microsoft_ServiceBus_Messaging_QueueClient_GetMessageSessionsAsync).</span></span>

## <a name="partitioned-entities-limitations"></a><span data-ttu-id="1b436-229">분할된 엔터티 제한 사항</span><span class="sxs-lookup"><span data-stu-id="1b436-229">Partitioned entities limitations</span></span>
<span data-ttu-id="1b436-230">현재 Service Bus에서는 분할된 큐 및 항목에 다음과 같은 제한 사항이 적용됩니다.</span><span class="sxs-lookup"><span data-stu-id="1b436-230">Currently Service Bus imposes the following limitations on partitioned queues and topics:</span></span>

* <span data-ttu-id="1b436-231">분할된 큐 및 항목은 단일 트랜잭션에서 다른 세션에 속한 보내는 메시지를 지원하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="1b436-231">Partitioned queues and topics do not support sending messages that belong to different sessions in a single transaction.</span></span>
* <span data-ttu-id="1b436-232">Service Bus는 현재 네임스페이스당 최대 100개의 분할된 큐 또는 항목을 허용합니다.</span><span class="sxs-lookup"><span data-stu-id="1b436-232">Service Bus currently allows up to 100 partitioned queues or topics per namespace.</span></span> <span data-ttu-id="1b436-233">각 분할된 큐 또는 항목은 네임스페이스 당 10,000개의 엔터티를 할당량으로 계산합니다(프리미엄 계층에는 적용되지 않음).</span><span class="sxs-lookup"><span data-stu-id="1b436-233">Each partitioned queue or topic counts towards the quota of 10,000 entities per namespace (does not apply to Premium tier).</span></span>

## <a name="next-steps"></a><span data-ttu-id="1b436-234">다음 단계</span><span class="sxs-lookup"><span data-stu-id="1b436-234">Next steps</span></span>
<span data-ttu-id="1b436-235">[분할된 Service Bus 큐 및 토픽에 대한 AMQP 1.0 지원][AMQP 1.0 support for Service Bus partitioned queues and topics] 설명을 참조하여 메시지 엔터티 분할에 대해 자세히 알아봅니다.</span><span class="sxs-lookup"><span data-stu-id="1b436-235">See the discussion of [AMQP 1.0 support for Service Bus partitioned queues and topics][AMQP 1.0 support for Service Bus partitioned queues and topics] to learn more about partitioning messaging entities.</span></span> 

[Service Bus architecture]: service-bus-architecture.md
[Azure portal]: https://portal.azure.com
[QueueDescription.EnablePartitioning]: /dotnet/api/microsoft.servicebus.messaging.queuedescription#Microsoft_ServiceBus_Messaging_QueueDescription_EnablePartitioning
[TopicDescription.EnablePartitioning]: /dotnet/api/microsoft.servicebus.messaging.topicdescription#Microsoft_ServiceBus_Messaging_TopicDescription_EnablePartitioning
[BrokeredMessage.SessionId]: /dotnet/api/microsoft.servicebus.messaging.brokeredmessage#Microsoft_ServiceBus_Messaging_BrokeredMessage_SessionId
[BrokeredMessage.PartitionKey]: /dotnet/api/microsoft.servicebus.messaging.brokeredmessage#Microsoft_ServiceBus_Messaging_BrokeredMessage_PartitionKey
[SessionId]: /dotnet/api/microsoft.servicebus.messaging.brokeredmessage#Microsoft_ServiceBus_Messaging_BrokeredMessage_SessionId
[PartitionKey]: /dotnet/api/microsoft.servicebus.messaging.brokeredmessage#Microsoft_ServiceBus_Messaging_BrokeredMessage_PartitionKey
[QueueDescription.RequiresDuplicateDetection]: /dotnet/api/microsoft.servicebus.messaging.queuedescription#Microsoft_ServiceBus_Messaging_QueueDescription_RequiresDuplicateDetection
[BrokeredMessage.MessageId]: /dotnet/api/microsoft.servicebus.messaging.brokeredmessage#Microsoft_ServiceBus_Messaging_BrokeredMessage_MessageId
[MessageId]: /dotnet/api/microsoft.servicebus.messaging.brokeredmessage#Microsoft_ServiceBus_Messaging_BrokeredMessage_MessageId
[MessagingFactorySettings.OperationTimeout]: /dotnet/api/microsoft.servicebus.messaging.messagingfactorysettings#Microsoft_ServiceBus_Messaging_MessagingFactorySettings_OperationTimeout
[OperationTimeout]: /dotnet/api/microsoft.servicebus.messaging.messagingfactorysettings#Microsoft_ServiceBus_Messaging_MessagingFactorySettings_OperationTimeout
[QueueDescription.ForwardTo]: /dotnet/api/microsoft.servicebus.messaging.queuedescription#Microsoft_ServiceBus_Messaging_QueueDescription_ForwardTo
[AMQP 1.0 support for Service Bus partitioned queues and topics]: service-bus-partitioned-queues-and-topics-amqp-overview.md
