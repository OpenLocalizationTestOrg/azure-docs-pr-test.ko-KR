---
title: "서비스 패브릭 응용 프로그램에 대 한 계획 aaaCapacity | Microsoft Docs"
description: "Tooidentify 서비스 패브릭 응용 프로그램에 필요한 계산 노드 수를 hello 하는 방법을 설명 합니다."
services: service-fabric
documentationcenter: .net
author: mani-ramaswamy
manager: markfuss
editor: 
ms.assetid: 9fa47be0-50a2-4a51-84a5-20992af94bea
ms.service: service-fabric
ms.devlang: dotnet
ms.topic: article
ms.tgt_pltfrm: NA
ms.workload: NA
ms.date: 8/9/2017
ms.author: subramar
ms.openlocfilehash: 44a69e9d8ec5efcc43122dc42e8f923ef37378f2
ms.sourcegitcommit: 523283cc1b3c37c428e77850964dc1c33742c5f0
ms.translationtype: MT
ms.contentlocale: ko-KR
ms.lasthandoff: 10/06/2017
---
# <a name="capacity-planning-for-service-fabric-applications"></a><span data-ttu-id="ab94f-103">서비스 패브릭 응용 프로그램의 용량 계획</span><span class="sxs-lookup"><span data-stu-id="ab94f-103">Capacity planning for Service Fabric applications</span></span>
<span data-ttu-id="ab94f-104">이 문서에 설명 어떻게 tooestimate hello 양 리소스 (Cpu, RAM, 디스크 저장소)의 필요한 toorun Azure 서비스 패브릭 응용 프로그램입니다.</span><span class="sxs-lookup"><span data-stu-id="ab94f-104">This document teaches you how tooestimate hello amount of resources (CPUs, RAM, disk storage) you need toorun your Azure Service Fabric applications.</span></span> <span data-ttu-id="ab94f-105">시간이 지남에 따라 것이 일반적 리소스 요구 사항 toochange입니다.</span><span class="sxs-lookup"><span data-stu-id="ab94f-105">It is common for your resource requirements toochange over time.</span></span> <span data-ttu-id="ab94f-106">일반적으로 서비스를 개발/테스트하는 단계에서는 리소스가 적게 필요하고, 프로덕션 단계로 넘어가서 응용 프로그램의 인기가 높아지면 더 많은 리소스가 필요하게 됩니다.</span><span class="sxs-lookup"><span data-stu-id="ab94f-106">You typically require few resources as you develop/test your service, and then require more resources as you go into production and your application grows in popularity.</span></span> <span data-ttu-id="ab94f-107">응용 프로그램을 디자인할 때는 hello 장기 요구 사항을 통해 생각 하 고 서비스 tooscale toomeet 높은 고객 요구를 허용 하는 항목을 선택 합니다.</span><span class="sxs-lookup"><span data-stu-id="ab94f-107">When you design your application, think through hello long-term requirements and make choices that allow your service tooscale toomeet high customer demand.</span></span>

 <span data-ttu-id="ab94f-108">서비스 패브릭 클러스터를 만들 때 가상 컴퓨터 (Vm)의 종류 hello 클러스터를 하 게 결정할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ab94f-108">When you create a Service Fabric cluster, you decide what kinds of virtual machines (VMs) make up hello cluster.</span></span> <span data-ttu-id="ab94f-109">각 VM 제한 된 양의 Cpu (코어 및 속도), 네트워크 대역폭, RAM 및 디스크 저장소의 hello 형태로 리소스 함께 제공 됩니다.</span><span class="sxs-lookup"><span data-stu-id="ab94f-109">Each VM comes with a limited amount of resources in hello form of CPUs (cores and speed), network bandwidth, RAM, and disk storage.</span></span> <span data-ttu-id="ab94f-110">까지 확장 되면서 서비스 시간이 지남에 따라 tooVMs 더 큰 리소스를 제공 및/또는 더 많은 Vm tooyour 클러스터를 추가 하는 업그레이드할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ab94f-110">As your service grows over time, you can upgrade tooVMs that offer greater resources and/or add more VMs tooyour cluster.</span></span> <span data-ttu-id="ab94f-111">후자의 toodo hello, 설계 해야 서비스에 처음 toohello 클러스터 동적으로 추가 하는 새 Vm를 이용할 수 있도록 합니다.</span><span class="sxs-lookup"><span data-stu-id="ab94f-111">toodo hello latter, you must architect your service initially so it can take advantage of new VMs that get dynamically added toohello cluster.</span></span>

<span data-ttu-id="ab94f-112">일부 서비스는 hello Vm 자체에서 거의 toono 데이터를 관리합니다.</span><span class="sxs-lookup"><span data-stu-id="ab94f-112">Some services manage little toono data on hello VMs themselves.</span></span> <span data-ttu-id="ab94f-113">따라서 용량 계획 hello를 선택 하는 성능에 주로 초점을 맞추어야 이러한 서비스에 대 한 Cpu (코어 및 속도) hello Vm의 적절 한 합니다.</span><span class="sxs-lookup"><span data-stu-id="ab94f-113">Therefore, capacity planning for these services should focus primarily on performance, which means selecting hello appropriate CPUs (cores and speed) of hello VMs.</span></span> <span data-ttu-id="ab94f-114">또한 네트워크 대역폭을 고려해야 하고 네트워크 전송 빈도와 전송되는 데이터 양을 고려해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="ab94f-114">In addition, you should consider network bandwidth, including how frequently network transfers are occurring and how much data is being transferred.</span></span> <span data-ttu-id="ab94f-115">서비스를 서비스 사용량 증가 함에 따라 잘 tooperform 필요한 경우 더 많은 Vm toohello 클러스터를 추가할 수 있으며 모든 hello Vm 간에 부하를 hello 네트워크 요청을 분산 시킵니다.</span><span class="sxs-lookup"><span data-stu-id="ab94f-115">If your service needs tooperform well as service usage increases, you can add more VMs toohello cluster and load balance hello network requests across all hello VMs.</span></span>

<span data-ttu-id="ab94f-116">Hello Vm에 많은 양의 데이터를 관리 하는 서비스에 대 한 용량 계획 노력을 기울여야 주로 크기입니다.</span><span class="sxs-lookup"><span data-stu-id="ab94f-116">For services that manage large amounts of data on hello VMs, capacity planning should focus primarily on size.</span></span> <span data-ttu-id="ab94f-117">따라서 hello VM의 RAM 및 디스크 저장소의 hello 용량을 신중 하 게 고려해 야 합니다.</span><span class="sxs-lookup"><span data-stu-id="ab94f-117">Thus, you should carefully consider hello capacity of hello VM's RAM and disk storage.</span></span> <span data-ttu-id="ab94f-118">windows에서 hello 가상 메모리 관리 시스템을 사용 하면 디스크 공간 RAM tooapplication 코드와 같습니다.</span><span class="sxs-lookup"><span data-stu-id="ab94f-118">hello virtual memory management system in Windows makes disk space look like RAM tooapplication code.</span></span> <span data-ttu-id="ab94f-119">또한 hello 서비스 패브릭 런타임에서 메모리와 이동 hello 콜드 데이터 toodisk에만 핫 데이터를 유지 하는 스마트 페이징을 제공 합니다.</span><span class="sxs-lookup"><span data-stu-id="ab94f-119">In addition, hello Service Fabric runtime provides smart paging keeping only hot data in memory and moving hello cold data toodisk.</span></span> <span data-ttu-id="ab94f-120">따라서 응용 프로그램 hello VM에 실제로 사용할 수 있는 것 보다 많은 메모리를 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ab94f-120">Applications can thus use more memory than is physically available on hello VM.</span></span> <span data-ttu-id="ab94f-121">Hello VM RAM에 더 많은 디스크 저장소를 유지할 수 있으므로 성능이 향상 단순히 더 많은 RAM이 필요 합니다.</span><span class="sxs-lookup"><span data-stu-id="ab94f-121">Having more RAM simply increases performance, since hello VM can keep more disk storage in RAM.</span></span> <span data-ttu-id="ab94f-122">선택한 VM hello hello VM에서 원하는 디스크 충분히 큰 toostore hello 데이터가 있어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="ab94f-122">hello VM you select should have a disk large enough toostore hello data that you want on hello VM.</span></span> <span data-ttu-id="ab94f-123">마찬가지로, VM hello 원하는 성능 hello는 충분 한 RAM tooprovide가 있어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="ab94f-123">Similarly, hello VM should have enough RAM tooprovide you with hello performance you desire.</span></span> <span data-ttu-id="ab94f-124">시간이 지남에 따라 증가 하는 서비스의 데이터를 모든 hello Vm에서 더 많은 Vm toohello 클러스터 및 파티션 hello 데이터를 추가할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ab94f-124">If your service's data grows over time, you can add more VMs toohello cluster and partition hello data across all hello VMs.</span></span>

## <a name="determine-how-many-nodes-you-need"></a><span data-ttu-id="ab94f-125">필요한 노드 수를 결정합니다.</span><span class="sxs-lookup"><span data-stu-id="ab94f-125">Determine how many nodes you need</span></span>
<span data-ttu-id="ab94f-126">서비스를 분할 하면 tooscale 서비스의 데이터.</span><span class="sxs-lookup"><span data-stu-id="ab94f-126">Partitioning your service allows you tooscale out your service's data.</span></span> <span data-ttu-id="ab94f-127">분할에 대한 자세한 내용은 [Service Fabric 분할](service-fabric-concepts-partitioning.md)을 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="ab94f-127">For more information on partitioning, see [Partitioning Service Fabric](service-fabric-concepts-partitioning.md).</span></span> <span data-ttu-id="ab94f-128">각 파티션은 단일 VM에 맞는 크기여야 합니다. 하지만 여러(작은) 파티션을 단일 VM에 배치할 수도 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ab94f-128">Each partition must fit within a single VM, but multiple (small) partitions can be placed on a single VM.</span></span> <span data-ttu-id="ab94f-129">따라서 큰 파티션을 몇 개만 두는 것보다 작은 파티션을 여러 개 두는 것이 훨씬 유연합니다.</span><span class="sxs-lookup"><span data-stu-id="ab94f-129">So, having more small partitions gives you greater flexibility than having a few larger partitions.</span></span> <span data-ttu-id="ab94f-130">hello 절충 경우 서비스 패브릭 오버 헤드가 증가 파티션의 많은 것 파티션에서 트랜잭션 처리 작업을 수행할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="ab94f-130">hello trade-off is that having lots of partitions increases Service Fabric overhead and you cannot perform transacted operations across partitions.</span></span> <span data-ttu-id="ab94f-131">이기도 잠재적인 느려지고 네트워크 트래픽이 서비스 코드 tooaccess 가지 서로 다른 파티션을에 거주 하는 데이터를 자주 있어야 하는 경우.</span><span class="sxs-lookup"><span data-stu-id="ab94f-131">There is also more potential network traffic if your service code frequently needs tooaccess pieces of data that live in different partitions.</span></span> <span data-ttu-id="ab94f-132">서비스를 디자인할 때 이러한 장점 및 단점 tooarrive 효과적인 분할 전략에 신중 하 게 고려해 야 합니다.</span><span class="sxs-lookup"><span data-stu-id="ab94f-132">When designing your service, you should carefully consider these pros and cons tooarrive at an effective partitioning strategy.</span></span>

<span data-ttu-id="ab94f-133">응용 프로그램에 단일 상태 저장 서비스 toogrow tooDB_Size GB 1 년에 예상 되는 저장소 크기를 가진 경우를 가정해 봅니다.</span><span class="sxs-lookup"><span data-stu-id="ab94f-133">Let's assume your application has a single stateful service that has a store size that you expect toogrow tooDB_Size GB in a year.</span></span> <span data-ttu-id="ab94f-134">더 많은 응용 프로그램 (및 파티션)으로 기꺼이 tooadd는 해당 년 이상 증가 발생 합니다.</span><span class="sxs-lookup"><span data-stu-id="ab94f-134">You are willing tooadd more applications (and partitions) as you experience growth beyond that year.</span></span>  <span data-ttu-id="ab94f-135">hello 복제 계수로 (RF) hello 복제본 수에 따라 서비스 영향 총 DB_Size hello에 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ab94f-135">hello replication factor (RF), which determines hello number of replicas for your service impacts hello total DB_Size.</span></span> <span data-ttu-id="ab94f-136">hello 모든 복제본에서 총 DB_Size는 hello DB_Size 곱한 복제 요소입니다.</span><span class="sxs-lookup"><span data-stu-id="ab94f-136">hello total DB_Size across all replicas is hello Replication Factor multiplied by DB_Size.</span></span>  <span data-ttu-id="ab94f-137">Node_Size hello 디스크 공간/RAM 나타내는 노드당 toouse에 원하는 서비스입니다.</span><span class="sxs-lookup"><span data-stu-id="ab94f-137">Node_Size represents hello disk space/RAM per node you want toouse for your service.</span></span> <span data-ttu-id="ab94f-138">최상의 성능을 위해 hello DB_Size hello 클러스터 및 VM을 선택 해야 하는 hello의 RAM hello 주위에 있는 Node_Size 메모리에 적합 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="ab94f-138">For best performance, hello DB_Size should fit into memory across hello cluster, and a Node_Size that is around hello RAM of hello VM should be chosen.</span></span> <span data-ttu-id="ab94f-139">Hello RAM 용량 보다 큰 Node_Size를 할당 하 여 hello 서비스 패브릭 런타임에서 제공 하는 hello 페이징에 의존 하 고 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ab94f-139">By allocating a Node_Size that is larger than hello RAM capacity, you are relying on hello paging provided by hello Service Fabric runtime.</span></span> <span data-ttu-id="ab94f-140">따라서 성능 전체 데이터로 간주 되 면 toobe 핫 데이터 입/출력을 페이징 되 후 hello) (이후 최적이 아닐 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ab94f-140">Thus, your performance may not be optimal if your entire data is considered toobe hot (since then hello data is paged in/out).</span></span> <span data-ttu-id="ab94f-141">그러나 많은 서비스의 hello 데이터의 일부만 뜨거움, 비용 효율적인는 합니다.</span><span class="sxs-lookup"><span data-stu-id="ab94f-141">However, for many services where only a fraction of hello data is hot, it is more cost-effective.</span></span>

<span data-ttu-id="ab94f-142">최상의 성능을 위해 필요한 노드 hello 수는 다음과 같이 계산할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ab94f-142">hello number of nodes required for maximum performance can be computed as follows:</span></span>

```
Number of Nodes = (DB_Size * RF)/Node_Size

```


## <a name="account-for-growth"></a><span data-ttu-id="ab94f-143">성장 고려</span><span class="sxs-lookup"><span data-stu-id="ab94f-143">Account for growth</span></span>
<span data-ttu-id="ab94f-144">또한 하 여 서비스 toogrow 예상 되는 DB_Size hello에 따라 노드 toocompute hello 수 toohello DB_Size로 시작 하는 것이 좋습니다.</span><span class="sxs-lookup"><span data-stu-id="ab94f-144">You may want toocompute hello number of nodes based on hello DB_Size that you expect your service toogrow to, in addition toohello DB_Size that you began with.</span></span> <span data-ttu-id="ab94f-145">그런 다음까지 확장 되면서 서비스 하지 과도 하 게 프로 비전 하는 노드의 hello 수 있도록 hello 노드 수를 증가 합니다.</span><span class="sxs-lookup"><span data-stu-id="ab94f-145">Then, grow hello number of nodes as your service grows so that you are not over-provisioning hello number of nodes.</span></span> <span data-ttu-id="ab94f-146">하지만 hello 파티션 수가 최대 증가에 서비스를 실행 하는 경우 필요한 노드 hello 수 기반으로 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="ab94f-146">But hello number of partitions should be based on hello number of nodes that are needed when you're running your service at maximum growth.</span></span>

<span data-ttu-id="ab94f-147">그 좋은 toohave 언제 든 지 사용할 수 있는 몇 가지 추가 하는 컴퓨터 (예를 들어 경우 몇 가지 Vm 작동이) 모든 예기치 않은 스파이크 또는 오류를 처리할 수 있도록 됩니다.</span><span class="sxs-lookup"><span data-stu-id="ab94f-147">It is good toohave some extra machines available at any time so that you can handle any unexpected spikes or failure (for example, if a few VMs go down).</span></span>  <span data-ttu-id="ab94f-148">예상된 프로그램 스파이크를 사용 하 여 hello 여분의 공간을 결정 해야, 시작 지점 tooreserve는 몇 가지 추가 Vm (5-10% 추가).</span><span class="sxs-lookup"><span data-stu-id="ab94f-148">While hello extra capacity should be determined by using your expected spikes, a starting point is tooreserve a few extra VMs (5-10 percent extra).</span></span>

<span data-ttu-id="ab94f-149">hello 위의 단일 상태 저장 서비스를 가정합니다.</span><span class="sxs-lookup"><span data-stu-id="ab94f-149">hello preceding assumes a single stateful service.</span></span> <span data-ttu-id="ab94f-150">상태 저장 서비스의 여러 개 있는 경우 hello 방정식에 다른 서비스 hello tooadd hello와 관련 된 DB_Size 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="ab94f-150">If you have more than one stateful service, you have tooadd hello DB_Size associated with hello other services into hello equation.</span></span> <span data-ttu-id="ab94f-151">또는 hello 개별적으로 각 상태 저장 서비스에 대 한 노드 수를 계산할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ab94f-151">Alternatively, you can compute hello number of nodes separately for each stateful service.</span></span>  <span data-ttu-id="ab94f-152">분산되지 않은 복제본 또는 파티션이 서비스 내에 존재할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ab94f-152">Your service may have replicas or partitions that aren't balanced.</span></span> <span data-ttu-id="ab94f-153">파티션이 다른 파티션보다 더 많은 데이터를 포함할 수도 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ab94f-153">Keep in mind that partitions may also have more data than others.</span></span> <span data-ttu-id="ab94f-154">분할에 대한 자세한 내용은 [모범 사례의 분할 문서](service-fabric-concepts-partitioning.md)을 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="ab94f-154">For more information on partitioning, see [partitioning article on best practices](service-fabric-concepts-partitioning.md).</span></span> <span data-ttu-id="ab94f-155">그러나 hello 이전 식은 파티션 및 복제본 서비스 패브릭 보장는 hello 복제본 사이 분산 되어 hello 노드 최적화 된 방식에서 때문에 중립적입니다.</span><span class="sxs-lookup"><span data-stu-id="ab94f-155">However, hello preceding equation is partition and replica agnostic, because Service Fabric ensures that hello replicas are spread out among hello nodes in an optimized manner.</span></span>

## <a name="use-a-spreadsheet-for-cost-calculation"></a><span data-ttu-id="ab94f-156">비용 계산을 위한 스프레드시트 사용</span><span class="sxs-lookup"><span data-stu-id="ab94f-156">Use a spreadsheet for cost calculation</span></span>
<span data-ttu-id="ab94f-157">이제 hello 수식에 몇 가지 실수 해 보겠습니다.</span><span class="sxs-lookup"><span data-stu-id="ab94f-157">Now let's put some real numbers in hello formula.</span></span> <span data-ttu-id="ab94f-158">[예제 스프레드시트](https://servicefabricsdkstorage.blob.core.windows.net/publicrelease/SF%20VM%20Cost%20calculator-NEW.xlsx) tooplan 세 가지 유형의 데이터 개체를 포함 하는 응용 프로그램에 대 한 용량을 hello 하는 방법을 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="ab94f-158">An [example spreadsheet](https://servicefabricsdkstorage.blob.core.windows.net/publicrelease/SF%20VM%20Cost%20calculator-NEW.xlsx) shows how tooplan hello capacity for an application that contains three types of data objects.</span></span> <span data-ttu-id="ab94f-159">각 개체에 대 한 우리 대략적인 크기와 toohave 라고 생각 하는 개체 수입니다.</span><span class="sxs-lookup"><span data-stu-id="ab94f-159">For each object, we approximate its size and how many objects we expect toohave.</span></span> <span data-ttu-id="ab94f-160">또한 각 개체 유형에 대해 원하는 복제본 수를 선택합니다.</span><span class="sxs-lookup"><span data-stu-id="ab94f-160">We also select how many replicas we want of each object type.</span></span> <span data-ttu-id="ab94f-161">hello 스프레드시트 hello 총 메모리 toobe hello 클러스터에 저장 된 양을 계산 합니다.</span><span class="sxs-lookup"><span data-stu-id="ab94f-161">hello spreadsheet calculates hello total amount of memory toobe stored in hello cluster.</span></span>

<span data-ttu-id="ab94f-162">그런 다음 VM 크기와 월간 비용을 입력합니다.</span><span class="sxs-lookup"><span data-stu-id="ab94f-162">Then we enter a VM size and monthly cost.</span></span> <span data-ttu-id="ab94f-163">Hello VM 크기에 따라, hello 스프레드시트 최소 데이터 toophysically 맞게 toosplit hello 노드에서 사용 해야 하는 파티션 수를 hello 지시 합니다.</span><span class="sxs-lookup"><span data-stu-id="ab94f-163">Based on hello VM size, hello spreadsheet tells you hello minimum number of partitions you must use toosplit your data toophysically fit on hello nodes.</span></span> <span data-ttu-id="ab94f-164">많은 수의 응용 프로그램의 특정 계산 및 네트워크 트래픽 수요 파티션의 tooaccommodate 원하는 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ab94f-164">You may desire a larger number of partitions tooaccommodate your application's specific computation and network traffic needs.</span></span> <span data-ttu-id="ab94f-165">hello 스프레드시트 하나의 toosix에서 hello hello 사용자 프로필 개체를 관리 하는 파티션 수에 증가 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="ab94f-165">hello spreadsheet shows hello number of partitions that are managing hello user profile objects has increased from one toosix.</span></span>

<span data-ttu-id="ab94f-166">이제,이 모든 정보에 따라, hello 스프레드시트 표시 26 개 노드 클러스터에 필요한 hello 파티션과 복제본을 사용 하 여 모든 hello 데이터를 물리적으로 가져올 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ab94f-166">Now, based on all this information, hello spreadsheet shows that you could physically get all hello data with hello desired partitions and replicas on a 26-node cluster.</span></span> <span data-ttu-id="ab94f-167">그러나이 클러스터는 수 빽빽하게 묶여 있으므로 몇 가지 추가 노드 tooaccommodate 노드 오류 및 업그레이드 할 수도 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ab94f-167">However, this cluster would be densely packed, so you may want some additional nodes tooaccommodate node failures and upgrades.</span></span> <span data-ttu-id="ab94f-168">hello 스프레드시트는 빈 노드를 갖기 때문에 없는 추가 가치를 얻을 57 개 이상의 노드가 표시 됩니다.</span><span class="sxs-lookup"><span data-stu-id="ab94f-168">hello spreadsheet also shows that having more than 57 nodes provides no additional value because you would have empty nodes.</span></span> <span data-ttu-id="ab94f-169">다시 할 수 있습니다 57 노드 위에 toogo 그래도 tooaccommodate 노드 오류 및 업그레이드.</span><span class="sxs-lookup"><span data-stu-id="ab94f-169">Again, you may want toogo above 57 nodes anyway tooaccommodate node failures and upgrades.</span></span> <span data-ttu-id="ab94f-170">Hello 스프레드시트 toomatch 응용 프로그램의 특정 요구를 수정할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ab94f-170">You can tweak hello spreadsheet toomatch your application's specific needs.</span></span>   

![비용 계산을 위한 스프레드시트][Image1]

## <a name="next-steps"></a><span data-ttu-id="ab94f-172">다음 단계</span><span class="sxs-lookup"><span data-stu-id="ab94f-172">Next steps</span></span>
<span data-ttu-id="ab94f-173">체크 아웃 [분할 서비스 패브릭 서비스] [ 10] toolearn 서비스를 분할 하는 방법에 대 한 자세한 합니다.</span><span class="sxs-lookup"><span data-stu-id="ab94f-173">Check out [Partitioning Service Fabric services][10] toolearn more about partitioning your service.</span></span>

<!--Image references-->
[Image1]: ./media/SF-Cost.png

<!--Link references--In actual articles, you only need a single period before hello slash-->
[10]: service-fabric-concepts-partitioning.md
