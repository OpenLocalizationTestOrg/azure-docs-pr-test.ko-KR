---
title: "서비스 아키텍처 aaaReliable | Microsoft Docs"
description: "상태 저장 및 상태 비저장 서비스에 대 한 hello 신뢰할 수 있는 서비스 아키텍처의 개요"
services: service-fabric
documentationcenter: .net
author: AlanWarwick
manager: timlt
editor: vturecek
ms.assetid: af002ae6-7f6d-4769-b049-82aa1ba0891b
ms.service: Service-Fabric
ms.devlang: dotnet
ms.topic: article
ms.tgt_pltfrm: NA
ms.workload: NA
ms.date: 03/30/2016
ms.author: alanwar
redirect_url: /azure/service-fabric/service-fabric-reliable-services-introduction
ms.openlocfilehash: d2d0ec9600275ae248ab7717be269cc7204a1e4d
ms.sourcegitcommit: 523283cc1b3c37c428e77850964dc1c33742c5f0
ms.translationtype: MT
ms.contentlocale: ko-KR
ms.lasthandoff: 10/06/2017
---
# <a name="architecture-for-stateful-and-stateless-reliable-services"></a><span data-ttu-id="68e2b-103">상태 비저장 Reliable Services를 위한 아키텍처</span><span class="sxs-lookup"><span data-stu-id="68e2b-103">Architecture for stateful and stateless Reliable Services</span></span>
<span data-ttu-id="68e2b-104">Azure 서비스 패브릭 Reliable Service는 상태 저장이거나 상태 비저장일 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="68e2b-104">An Azure Service Fabric Reliable Service may be stateful or stateless.</span></span> <span data-ttu-id="68e2b-105">각 서비스 유형은 특정 아키텍처 내에서 실행됩니다.</span><span class="sxs-lookup"><span data-stu-id="68e2b-105">Each type of service runs within a specific architecture.</span></span> <span data-ttu-id="68e2b-106">이러한 아키텍처는 이 문서에 설명되어 있습니다.</span><span class="sxs-lookup"><span data-stu-id="68e2b-106">These architectures are described in this article.</span></span>
<span data-ttu-id="68e2b-107">Hello 참조 [신뢰할 수 있는 서비스 개요](service-fabric-reliable-services-introduction.md) hello 차이점 상태 저장 및 상태 비저장 서비스에 대 한 자세한 내용은 합니다.</span><span class="sxs-lookup"><span data-stu-id="68e2b-107">See hello [Reliable Service overview](service-fabric-reliable-services-introduction.md) for more information about hello differences between stateful and stateless services.</span></span>

## <a name="stateful-reliable-services"></a><span data-ttu-id="68e2b-108">상태 저장 신뢰할 수 있는 서비스</span><span class="sxs-lookup"><span data-stu-id="68e2b-108">Stateful Reliable Services</span></span>
### <a name="architecture-of-a-stateful-service"></a><span data-ttu-id="68e2b-109">상태 저장 서비스의 아키텍처</span><span class="sxs-lookup"><span data-stu-id="68e2b-109">Architecture of a stateful service</span></span>
![상태 저장 서비스의 아키텍처 다이어그램](./media/service-fabric-reliable-services-platform-architecture/reliable-stateful-service-architecture.png)

### <a name="stateful-reliable-service"></a><span data-ttu-id="68e2b-111">상태 저장 신뢰할 수 있는 서비스</span><span class="sxs-lookup"><span data-stu-id="68e2b-111">Stateful Reliable Service</span></span>
<span data-ttu-id="68e2b-112">신뢰할 수 있는 상태 저장 서비스는 hello StatefulService 또는 StatefulServiceBase 클래스 중 하나에서 파생 될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="68e2b-112">A stateful Reliable Service can derive from either hello StatefulService or StatefulServiceBase class.</span></span> <span data-ttu-id="68e2b-113">이러한 기본 클래스는 모두 서비스 패브릭에서 제공하며,</span><span class="sxs-lookup"><span data-stu-id="68e2b-113">Both of these base classes are provided by Service Fabric.</span></span> <span data-ttu-id="68e2b-114">다양 한 수준의 지원과 hello 서비스 패브릭 클러스터 내에서 서비스로 서비스 패브릭-tooparticipate와 상태 저장 서비스 toointerface hello에 대 한 추상화를 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="68e2b-114">They offer various levels of support and abstraction for hello stateful service toointerface with Service Fabric--and tooparticipate as a service within hello Service Fabric cluster.</span></span>

<span data-ttu-id="68e2b-115">StatefulService는 StatefulServiceBase에서 파생됩니다.</span><span class="sxs-lookup"><span data-stu-id="68e2b-115">StatefulService derives from StatefulServiceBase.</span></span> <span data-ttu-id="68e2b-116">StatefulServiceBase 더 큰 유연성, 서비스를 제공 하지만 더 많은 서비스 패브릭의 hello 내부 이해 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="68e2b-116">StatefulServiceBase offers services more flexibility, but requires more understanding of hello internals of Service Fabric.</span></span>
<span data-ttu-id="68e2b-117">Hello 참조 [신뢰할 수 있는 서비스 개요](service-fabric-reliable-services-introduction.md) 및 [고급 사용 하는 신뢰할 수 있는 서비스](service-fabric-reliable-services-advanced-usage.md) 쓰기 hello StatefulService 및 StatefulServiceBase 클래스를 사용 하 여 서비스의 hello 사항에 대 한 자세한 내용은 .</span><span class="sxs-lookup"><span data-stu-id="68e2b-117">See hello [Reliable Service overview](service-fabric-reliable-services-introduction.md) and [Reliable Service advanced usage](service-fabric-reliable-services-advanced-usage.md) for more information on hello specifics of writing services by using hello StatefulService and StatefulServiceBase classes.</span></span>

<span data-ttu-id="68e2b-118">기본 클래스를 모두 hello 수명 및 hello 서비스 구현의 역할을 관리합니다.</span><span class="sxs-lookup"><span data-stu-id="68e2b-118">Both base classes manage hello lifetime and role of hello service implementation.</span></span> <span data-ttu-id="68e2b-119">hello 서비스 구현에서 hello 서비스 구현 수명 주기-이 시점에 작업 toodo에 있는 경우 또는 toocreate 통신 수신기 개체를 읽으려는 경우 hello 서비스 구현에서 기본 클래스의 가상 메서드를 재정의 될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="68e2b-119">hello service implementation may override virtual methods of either base class if hello service implementation has work toodo at those points in hello service implementation lifecycle--or if it wants toocreate a communication listener object.</span></span> <span data-ttu-id="68e2b-120">참고는 서비스 구현에서 위의 hello 다이어그램 ICommunicationListener, 노출 자체 통신 수신기 개체를 구현할 수 있습니다 하지만 hello 통신 수신기를 구현 하는 서비스 패브릭으로-hello 서비스 구현으로 사용 하는 서비스 패브릭에서 구현 되는 통신 수신기 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="68e2b-120">Note that although a service implementation may implement its own communication listener object exposing ICommunicationListener, in hello diagram above, hello communication listener is implemented by Service Fabric--as hello service implementation uses a communication listener that is implemented by Service Fabric.</span></span>

<span data-ttu-id="68e2b-121">상태 저장 서비스의 신뢰할 수 있는 신뢰할 수 있는 컬렉션의 신뢰할 수 있는 상태 관리자 tootake 이점은 hello를 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="68e2b-121">A stateful Reliable Service uses hello reliable state manager tootake advantage of reliable collections.</span></span> <span data-ttu-id="68e2b-122">신뢰할 수 있는 컬렉션은 로컬 데이터 구조를 항상 사용 가능한 toohello 서비스--는, 서비스 장애 조치에 관계 없이 사용할 수 있는 경우가 있습니다.</span><span class="sxs-lookup"><span data-stu-id="68e2b-122">Reliable collections are local data structures that are highly available toohello service--that is, they are always available, regardless of service failovers.</span></span> <span data-ttu-id="68e2b-123">신뢰할 수 있는 컬렉션의 각 유형은 신뢰할 수 있는 상태 제공자에 의해 구현됩니다.</span><span class="sxs-lookup"><span data-stu-id="68e2b-123">Each type of reliable collection is implemented by a reliable state provider.</span></span>
<span data-ttu-id="68e2b-124">신뢰할 수 있는 컬렉션에 대 한 자세한 내용은 참조 hello [신뢰할 수 있는 컬렉션 개요](service-fabric-reliable-services-reliable-collections.md)합니다.</span><span class="sxs-lookup"><span data-stu-id="68e2b-124">For more information on reliable collections, see hello [reliable collections overview](service-fabric-reliable-services-reliable-collections.md).</span></span>

### <a name="reliable-state-manager-and-state-providers"></a><span data-ttu-id="68e2b-125">신뢰할 수 있는 상태 관리자와 제공자</span><span class="sxs-lookup"><span data-stu-id="68e2b-125">Reliable state manager and state providers</span></span>
<span data-ttu-id="68e2b-126">hello 신뢰할 수 있는 상태 관리자는 신뢰할 수 있는 상태 공급자를 관리 하는 hello 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="68e2b-126">hello reliable state manager is hello object that manages reliable state providers.</span></span> <span data-ttu-id="68e2b-127">Hello 기능 toocreate, 삭제, 열거 및 hello 신뢰할 수 있는 상태 공급자가 유지 되 고 항상 사용 가능한 확인 된이 있습니다.</span><span class="sxs-lookup"><span data-stu-id="68e2b-127">It has hello functionality toocreate, delete, enumerate, and ensure that hello reliable state providers are persisted and highly available.</span></span> <span data-ttu-id="68e2b-128">신뢰할 수 있는 상태 제공자 인스턴스는 사전이나 큐와 같은 지속적이고 항상 사용 가능한 데이터 구조체의 인스턴스를 나타냅니다.</span><span class="sxs-lookup"><span data-stu-id="68e2b-128">A reliable state provider instance represents an instance of a persisted and highly available data structure, such as a dictionary or a queue.</span></span>

<span data-ttu-id="68e2b-129">각 신뢰할 수 있는 상태 공급자는 상태 저장 서비스 toointeract hello 신뢰할 수 있는 상태 공급자와 함께 사용 되는 인터페이스를 노출 합니다.</span><span class="sxs-lookup"><span data-stu-id="68e2b-129">Each reliable state provider exposes an interface that is used by a stateful service toointeract with hello reliable state provider.</span></span> <span data-ttu-id="68e2b-130">예를 들어 IReliableDictionary 있고 hello 신뢰할 수 있는 사전으로 사용 되는 toointerface IReliableQueue hello 신뢰할 수 있는 큐와 toointerface를 사용된 합니다.</span><span class="sxs-lookup"><span data-stu-id="68e2b-130">For example, IReliableDictionary is used toointerface with hello reliable dictionary, while IReliableQueue is used toointerface with hello reliable queue.</span></span> <span data-ttu-id="68e2b-131">모든 신뢰할 수 있는 상태 공급자 hello IReliableState 인터페이스를 구현합니다.</span><span class="sxs-lookup"><span data-stu-id="68e2b-131">All reliable state providers implement hello IReliableState interface.</span></span>

<span data-ttu-id="68e2b-132">hello 신뢰할 수 있는 상태 관리자 이라는 IReliableStateManager 상태 저장 서비스에서 액세스 tooit 수 있는 인터페이스를 있습니다.</span><span class="sxs-lookup"><span data-stu-id="68e2b-132">hello reliable state manager has an interface named IReliableStateManager, which allows access tooit from a stateful service.</span></span> <span data-ttu-id="68e2b-133">인터페이스 tooreliable 상태 공급자 IReliableStateManager 통해 반환 됩니다.</span><span class="sxs-lookup"><span data-stu-id="68e2b-133">Interfaces tooreliable state providers are returned through IReliableStateManager.</span></span>

<span data-ttu-id="68e2b-134">hello 신뢰할 수 있는 상태 관리자는 새로운 유형의 신뢰할 수 있는 컬렉션 동적으로 연결 될 수 있도록 플러그 인 아키텍처를 사용 합니다.</span><span class="sxs-lookup"><span data-stu-id="68e2b-134">hello reliable state manager uses a plug-in architecture so that new types of reliable collections can be plugged in dynamically.</span></span>

<span data-ttu-id="68e2b-135">신뢰할 수 있는 사전 hello 및 신뢰할 수 있는 큐는 고성능, 버전 관리 된 차등 저장소의 hello 구현 시 작성 됩니다.</span><span class="sxs-lookup"><span data-stu-id="68e2b-135">hello reliable dictionary and reliable queue are built upon hello implementation of a high-performance, versioned differential store.</span></span>

### <a name="transactional-replicator"></a><span data-ttu-id="68e2b-136">트랜잭션 복제자</span><span class="sxs-lookup"><span data-stu-id="68e2b-136">Transactional replicator</span></span>
<span data-ttu-id="68e2b-137">hello 트랜잭션 복제기 구성 요소는 hello 서비스를 실행 하는 모든 복제본 hello 상태 서비스 (즉, 신뢰할 수 있는 상태 관리자 hello 및 hello 신뢰할 수 있는 컬렉션 내에서 hello 상태)이 일치 하는지 확인 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="68e2b-137">hello transactional replicator component is responsible for ensuring that hello state of a service (that is, hello state within hello reliable state manager and hello reliable collections) is consistent across all replicas running hello service.</span></span> <span data-ttu-id="68e2b-138">또한 hello 로그 hello 상태가 유지 되도록 보장 합니다.</span><span class="sxs-lookup"><span data-stu-id="68e2b-138">It also ensures that hello state is persisted in hello log.</span></span> <span data-ttu-id="68e2b-139">hello 개인 메커니즘을 통해 트랜잭션 복제기 hello와 관리자 인터페이스를 신뢰할 수 있는 상태입니다.</span><span class="sxs-lookup"><span data-stu-id="68e2b-139">hello reliable state manager interfaces with hello transactional replicator via a private mechanism.</span></span>

<span data-ttu-id="68e2b-140">hello 트랜잭션 복제기 최신 상태 정보를 포함 하는 모든 복제 되도록 hello 서비스 인스턴스의 다른 복제본과 네트워크 프로토콜 toocommunicate 상태를 사용 합니다.</span><span class="sxs-lookup"><span data-stu-id="68e2b-140">hello transactional replicator uses a network protocol toocommunicate state with other replicas of hello service instance so that all replicas have up-to-date state information.</span></span>

<span data-ttu-id="68e2b-141">hello 트랜잭션 복제기 hello 상태 정보 프로세스 후에 유지 하거나 노드 충돌 로그 toopersist 상태 정보를 사용 합니다.</span><span class="sxs-lookup"><span data-stu-id="68e2b-141">hello transactional replicator uses a log toopersist state information so that hello state information survives process or node crashes.</span></span> <span data-ttu-id="68e2b-142">개인 메커니즘을 통해 hello 인터페이스 toohello 로그가입니다.</span><span class="sxs-lookup"><span data-stu-id="68e2b-142">hello interface toohello log is via a private mechanism.</span></span>

### <a name="log"></a><span data-ttu-id="68e2b-143">로그</span><span class="sxs-lookup"><span data-stu-id="68e2b-143">Log</span></span>
<span data-ttu-id="68e2b-144">hello 로그 구성 toospinning 또는 반도체 디스크를 쓰기 위한 최적화할 수 있는 고성능 영구 저장소를 제공 합니다.</span><span class="sxs-lookup"><span data-stu-id="68e2b-144">hello log component provides a high-performance persistent store that can be optimized for writing toospinning or solid-state disks.</span></span>  <span data-ttu-id="68e2b-145">hello 로그의 hello 디자인 hello 상태 저장 서비스를 실행 하는 toobe 로컬 toohello 노드가 hello 영구 저장소 (예: 하드 디스크)입니다.</span><span class="sxs-lookup"><span data-stu-id="68e2b-145">hello design of hello log is for hello persistent storage (i.e., hard disks) toobe local toohello nodes that are running hello stateful service.</span></span> <span data-ttu-id="68e2b-146">따라서 낮은 대기 시간과 높은 처리량, 로컬 toohello 노드 하지 않는 비교 tooremote 영구 저장소로 있습니다.</span><span class="sxs-lookup"><span data-stu-id="68e2b-146">This allows for low latencies and high throughput, as compared tooremote persistent storage, which is not local toohello node.</span></span>

<span data-ttu-id="68e2b-147">hello 로그 구성 요소는 여러 로그 파일을 사용 합니다.</span><span class="sxs-lookup"><span data-stu-id="68e2b-147">hello log component uses multiple log files.</span></span> <span data-ttu-id="68e2b-148">상태 데이터를 저장 하기 위한 hello 가장 낮은 대기 시간과 높은 처리량 제공할 수 있습니다 하는 대로 모든 복제본에서 사용 하는 노드 수준 공유 로그 파일이 있습니다.</span><span class="sxs-lookup"><span data-stu-id="68e2b-148">There is a node-wide shared log file that all replicas use as it can provide hello lowest latency and highest throughput for storing state data.</span></span> <span data-ttu-id="68e2b-149">기본적으로 hello 공유 로그는 hello 서비스 패브릭 노드 작업 디렉터리에 위치 하 하지만 hello 공유 로그에 대 한 예약 된 디스크에 이상적으로 다른 위치에 배치 하는 구성 된 toobe 수도 있습니다.</span><span class="sxs-lookup"><span data-stu-id="68e2b-149">By default hello shared log is placed in hello Service Fabric node work directory but it may also be configured toobe placed at another location, ideally on a disk reserved for only hello shared log.</span></span> <span data-ttu-id="68e2b-150">또한 각 복제본 hello 서비스에 대 한 전용된 로그 파일을 개이고 hello 전용된 로그 hello 서비스의 작업 디렉터리 내에 배치 됩니다.</span><span class="sxs-lookup"><span data-stu-id="68e2b-150">Each replica for hello service also has a dedicated log file and hello dedicated log is placed within hello service's work directory.</span></span> <span data-ttu-id="68e2b-151">다른 위치에 배치 되지 메커니즘 tooconfigure 전용 hello 로그 toobe 있습니다.</span><span class="sxs-lookup"><span data-stu-id="68e2b-151">There is no mechanism tooconfigure hello dedicated log toobe placed at a different location.</span></span>

<span data-ttu-id="68e2b-152">hello 공유 로그는 hello 복제본의 상태 정보에 대 한 전환 영역, hello 동안 전용된 로그 파일은 hello 최종 대상 유지 됩니다.</span><span class="sxs-lookup"><span data-stu-id="68e2b-152">hello shared log is a transitional area for hello replica's state information, while hello dedicated log file is hello final destination where it is persisted.</span></span> <span data-ttu-id="68e2b-153">이 설계에 hello 상태 정보는 첫 번째 서 면된 toohello 공유 로그 파일 및 다음 지연 hello 백그라운드에서 toohello 전용된 로그 파일을 이동 합니다.</span><span class="sxs-lookup"><span data-stu-id="68e2b-153">In this design, hello state information is first written toohello shared log file and then lazily moved toohello dedicated log file in hello background.</span></span> <span data-ttu-id="68e2b-154">이러한 방식으로 hello 쓰기 toohello 공유 로그는 hello 가장 낮은 대기 시간 및 hello 서비스 toomake 진행 상황을 더 빠르게 수 있는 가장 높은 처리량 합니다.</span><span class="sxs-lookup"><span data-stu-id="68e2b-154">In this way, hello write toohello shared log would have hello lowest latency and highest throughput which allows hello service toomake progress faster.</span></span>

<span data-ttu-id="68e2b-155">읽기 및 쓰기 toohello 공유 로그 hello 공유 하는 로그 파일에 대 한 hello 디스크에 직접 IO toopreallocated 공간을 통해 수행 됩니다.</span><span class="sxs-lookup"><span data-stu-id="68e2b-155">Reads and writes toohello shared log are done via direct IO toopreallocated space on hello disk for hello shared log file.</span></span> <span data-ttu-id="68e2b-156">전용된 로그와 hello 드라이브에서 디스크 공간 사용을 최적화 하는 tooallow, hello 전용된 로그 파일에 NTFS 스파스 파일로 생성 됩니다.</span><span class="sxs-lookup"><span data-stu-id="68e2b-156">tooallow optimal use of disk space on hello drive with dedicated logs, hello dedicated log file is created as a NTFS sparse file.</span></span> <span data-ttu-id="68e2b-157">이 사용할 수 있음을 3tb의 디스크 공간 및 hello 운영 체제는 실제로 사용 보다 훨씬 더 많은 디스크 공간을 사용 하 여 hello 전용 로그 파일에 표시 됩니다.</span><span class="sxs-lookup"><span data-stu-id="68e2b-157">Note that this will allow overprovisioning of disk space and hello OS will show hello dedicated log files using much more disk space than is actually used.</span></span>

<span data-ttu-id="68e2b-158">최소한의 사용자 모드 인터페이스 toohello 로그 외에도 hello 로그는 커널 모드 드라이버로 기록 됩니다.</span><span class="sxs-lookup"><span data-stu-id="68e2b-158">Aside from a minimal user-mode interface toohello log, hello log is written as a kernel-mode driver.</span></span> <span data-ttu-id="68e2b-159">커널 모드 드라이버를 실행 하 여 tooall 서비스를 사용 하는 hello 로그 hello 최고의 성능을 제공할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="68e2b-159">By running as a kernel-mode driver, hello log can provide hello highest performance tooall services that use it.</span></span>

<span data-ttu-id="68e2b-160">Hello 로그를 구성 하는 방법에 대 한 자세한 내용은 참조 [신뢰할 수 있는 상태 저장 서비스 구성](service-fabric-reliable-services-configuration.md)합니다.</span><span class="sxs-lookup"><span data-stu-id="68e2b-160">For more information about configuring hello log, see [Configuring stateful Reliable Services](service-fabric-reliable-services-configuration.md).</span></span>

## <a name="stateless-reliable-service"></a><span data-ttu-id="68e2b-161">상태 비저장 신뢰할 수 있는 서비스</span><span class="sxs-lookup"><span data-stu-id="68e2b-161">Stateless Reliable Service</span></span>
### <a name="architecture-of-a-stateless-service"></a><span data-ttu-id="68e2b-162">상태 저장 서비스의 아키텍처</span><span class="sxs-lookup"><span data-stu-id="68e2b-162">Architecture of a stateless service</span></span>
![상태 비저장 서비스의 아키텍처 다이어그램](./media/service-fabric-reliable-services-platform-architecture/reliable-stateless-service-architecture.png)

### <a name="stateless-reliable-service"></a><span data-ttu-id="68e2b-164">상태 비저장 신뢰할 수 있는 서비스</span><span class="sxs-lookup"><span data-stu-id="68e2b-164">Stateless Reliable Service</span></span>
<span data-ttu-id="68e2b-165">상태 비저장 서비스 구현을 StatelessService hello 또는 StatelessServiceBase 클래스에서 파생 됩니다.</span><span class="sxs-lookup"><span data-stu-id="68e2b-165">Stateless service implementations derive from hello StatelessService or StatelessServiceBase class.</span></span> <span data-ttu-id="68e2b-166">hello StatelessServiceBase 클래스 hello StatelessService 클래스 보다 더 높은 유연성을 허용 합니다.</span><span class="sxs-lookup"><span data-stu-id="68e2b-166">hello StatelessServiceBase class allows more flexibility than hello StatelessService class.</span></span>
<span data-ttu-id="68e2b-167">기본 클래스를 모두 hello 수명 및 서비스의 역할을 관리합니다.</span><span class="sxs-lookup"><span data-stu-id="68e2b-167">Both base classes manage hello lifetime and role of a service.</span></span>

<span data-ttu-id="68e2b-168">hello 서비스에서 hello 서비스 수명 주기-이 시점에 작업 toodo에 또는 toocreate 통신 수신기 개체를 읽으려는 경우 hello 서비스 구현에서 기본 클래스의 가상 메서드를 재정의 될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="68e2b-168">hello service implementation may override virtual methods of either base class if hello service has work toodo at those points in hello service lifecycle--or if it wants toocreate a communication listener object.</span></span> <span data-ttu-id="68e2b-169">Hello 서비스 위의 hello 다이어그램에서 ICommunicationListener를 노출 하는 자체 통신 수신기 개체를 구현할 수 있지만 hello 통신 수신기를 구현 하는 서비스 패브릭에서 서비스 구현에는 통신을 사용 하는 참고 서비스 패브릭에서 구현 되는 수신기 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="68e2b-169">Note that although hello service may implement its own communication listener object exposing ICommunicationListener, in hello diagram above, hello communication listener is implemented by Service Fabric, as that service implementation uses a communication listener that is implemented by Service Fabric.</span></span>

<span data-ttu-id="68e2b-170">Hello 참조 [신뢰할 수 있는 서비스 개요](service-fabric-reliable-services-introduction.md) 및 [고급 사용 하는 신뢰할 수 있는 서비스](service-fabric-reliable-services-advanced-usage.md) hello StatelessService 및 StatelessServiceBase 클래스를 사용 하 여 서비스를 작성의 hello 사항에 대 한 자세한 내용은 .</span><span class="sxs-lookup"><span data-stu-id="68e2b-170">See hello [Reliable Service overview](service-fabric-reliable-services-introduction.md) and [Reliable Service advanced usage](service-fabric-reliable-services-advanced-usage.md) for more information on hello specifics of writing services using hello StatelessService and StatelessServiceBase classes.</span></span>

<!--Every topic should have next steps and links toohello next logical set of content tookeep hello customer engaged-->
## <a name="next-steps"></a><span data-ttu-id="68e2b-171">다음 단계</span><span class="sxs-lookup"><span data-stu-id="68e2b-171">Next steps</span></span>
<span data-ttu-id="68e2b-172">서비스 패브릭에 대한 자세한 내용은 다음을 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="68e2b-172">For more information about Service Fabric, see:</span></span>

[<span data-ttu-id="68e2b-173">Reliable Services 개요</span><span class="sxs-lookup"><span data-stu-id="68e2b-173">Reliable service overview</span></span>](service-fabric-reliable-services-introduction.md)

[<span data-ttu-id="68e2b-174">빠른 시작</span><span class="sxs-lookup"><span data-stu-id="68e2b-174">Quick start</span></span>](service-fabric-reliable-services-quick-start.md)

[<span data-ttu-id="68e2b-175">신뢰할 수 있는 컬렉션 개요</span><span class="sxs-lookup"><span data-stu-id="68e2b-175">Reliable collections overview</span></span>](service-fabric-reliable-services-reliable-collections.md)

[<span data-ttu-id="68e2b-176">Reliable Services 고급 사용법</span><span class="sxs-lookup"><span data-stu-id="68e2b-176">Reliable service advanced usage</span></span>](service-fabric-reliable-services-advanced-usage.md)

[<span data-ttu-id="68e2b-177">Reliable Services 구성</span><span class="sxs-lookup"><span data-stu-id="68e2b-177">Reliable service configuration</span></span>](service-fabric-reliable-services-configuration.md)  

