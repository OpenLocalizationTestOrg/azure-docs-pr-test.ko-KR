---
title: "Service Fabric 클러스터 Resource Manager - 선호도 | Microsoft Docs"
description: "서비스 패브릭 서비스에 대한 선호도 구성의 개요"
services: service-fabric
documentationcenter: .net
author: masnider
manager: timlt
editor: 
ms.assetid: 678073e1-d08d-46c4-a811-826e70aba6c4
ms.service: Service-Fabric
ms.devlang: dotnet
ms.topic: article
ms.tgt_pltfrm: NA
ms.workload: NA
ms.date: 08/18/2017
ms.author: masnider
ms.openlocfilehash: 3efda4ee4016245668e5da431d7b8868a21c790e
ms.sourcegitcommit: 50e23e8d3b1148ae2d36dad3167936b4e52c8a23
ms.translationtype: MT
ms.contentlocale: ko-KR
ms.lasthandoff: 08/18/2017
---
# <a name="configuring-and-using-service-affinity-in-service-fabric"></a><span data-ttu-id="83629-103">서비스 패브릭에서 서비스 선호도 구성 및 사용</span><span class="sxs-lookup"><span data-stu-id="83629-103">Configuring and using service affinity in Service Fabric</span></span>
<span data-ttu-id="83629-104">선호도는 주로 더 큰 모놀리식 응용 프로그램을 클라우드 및 마이크로 서비스 환경으로 쉽게 전환하도록 해주는 컨트롤입니다.</span><span class="sxs-lookup"><span data-stu-id="83629-104">Affinity is a control that is provided mainly to help ease the transition of larger monolithic applications into the cloud and microservices world.</span></span> <span data-ttu-id="83629-105">또한 서비스의 성능 향상을 위한 최적화로 사용되지만 이 경우 부작용이 있을 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="83629-105">It is also used as an optimization for improving the performance of services, although doing so can have side effects.</span></span>

<span data-ttu-id="83629-106">더 큰 앱 또는 마이크로 서비스를 고려하지 않고 설계한 앱을 Service Fabric(또는 모든 분산 환경)으로 가져오고 있다고 가정해 보겠습니다.</span><span class="sxs-lookup"><span data-stu-id="83629-106">Let’s say you’re bringing a larger app, or one that just wasn’t designed with microservices in mind, to Service Fabric (or any distributed environment).</span></span> <span data-ttu-id="83629-107">이 유형의 전환이 일반적입니다.</span><span class="sxs-lookup"><span data-stu-id="83629-107">This type of transition is common.</span></span> <span data-ttu-id="83629-108">전체 앱을 환경에 변환하고 패키징한 다음 문제 없이 실행하여 시작합니다.</span><span class="sxs-lookup"><span data-stu-id="83629-108">You start by lifting the entire app into the environment, packaging it, and making sure it is running smoothly.</span></span> <span data-ttu-id="83629-109">그런 다음 여러 개의 작은 서비스로 나눈 다음 서로 통신할 수 있도록 합니다.</span><span class="sxs-lookup"><span data-stu-id="83629-109">Then you start breaking it down into different smaller services that all talk to each other.</span></span>

<span data-ttu-id="83629-110">결국 응용 프로그램에 몇 가지 문제가 발생하고 있음을 알 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="83629-110">Eventually you may find that the application is experiencing some issues.</span></span> <span data-ttu-id="83629-111">이러한 문제는 대개 다음 범주 중 하나에 해당합니다.</span><span class="sxs-lookup"><span data-stu-id="83629-111">The issues usually fall into one of these categories:</span></span>

1. <span data-ttu-id="83629-112">모놀리식 앱의 구성 요소 X는 구성 요소 Y에 대해 문서화되지 않은 종속성을 가지며, 해당 구성 요소들을 별도의 서비스로 전환했습니다.</span><span class="sxs-lookup"><span data-stu-id="83629-112">Some component X in the monolithic app had an undocumented dependency on component Y, and you just turned those components into separate services.</span></span> <span data-ttu-id="83629-113">현재 이러한 서비스는 클러스터의 다른 노드에서 실행되고 있으므로 끊어졌습니다.</span><span class="sxs-lookup"><span data-stu-id="83629-113">Since these services are now running on different nodes in the cluster, they're broken.</span></span>
2. <span data-ttu-id="83629-114">이러한 구성 요소는 로컬로 명명된 파이프 | 공유 메모리 | 디스크의 파일을 통해 통신하며, 성능상의 이유로 즉시 공유 리소스에 쓸 수 있어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="83629-114">These components communicate via (local named pipes | shared memory | files on disk) and they really need to be able to write to a shared local resource for performance reasons right now.</span></span> <span data-ttu-id="83629-115">이러한 강한 종속성은 나중에 제거될 것입니다.</span><span class="sxs-lookup"><span data-stu-id="83629-115">That hard dependency gets removed later, maybe.</span></span>
3. <span data-ttu-id="83629-116">모든 것이 좋지만, 이들 두 구성 요소는 실제 통신이 잦고 성능에 민감한 것으로 나타났습니다.</span><span class="sxs-lookup"><span data-stu-id="83629-116">Everything is fine, but it turns out that these two components are actually chatty/performance sensitive.</span></span> <span data-ttu-id="83629-117">이들을 별도의 서비스로 이동시켰을 때 응용 프로그램의 전반적인 성능이 나빠지거나 대기 시간이 늘어났습니다.</span><span class="sxs-lookup"><span data-stu-id="83629-117">When they moved them into separate services overall application performance tanked or latency increased.</span></span> <span data-ttu-id="83629-118">결과적으로, 전체 응용 프로그램은 기대를 충족하지 못하게 됩니다.</span><span class="sxs-lookup"><span data-stu-id="83629-118">As a result, the overall application is not meeting expectations.</span></span>

<span data-ttu-id="83629-119">이러한 경우 리팩터링 작업을 손실하지 않으려고 하고 거대한 기념물로 남으려고 하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="83629-119">In these cases, we don’t want to lose our refactoring work, and don’t want to go back to the monolith.</span></span> <span data-ttu-id="83629-120">마지막 조건은 일반 최적화로 바람직할 수도 있습니다.</span><span class="sxs-lookup"><span data-stu-id="83629-120">The last condition may even be desirable as a plain optimization.</span></span> <span data-ttu-id="83629-121">그러나 자연스럽게 서비스로 작동하도록 구성 요소를 다시 디자인할 수 있거나 다른 방법으로 성능 기대치를 해결할 수 있게 될 때까지 어느 정도의 근접성이 필요합니다.</span><span class="sxs-lookup"><span data-stu-id="83629-121">However, until we can redesign the components to work naturally as services (or until we can solve the performance expectations some other way) we're going to need some sense of locality.</span></span>

<span data-ttu-id="83629-122">그렇다면 어떻게 해야 할까요?</span><span class="sxs-lookup"><span data-stu-id="83629-122">What to do?</span></span> <span data-ttu-id="83629-123">이제 선호도를 켤 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="83629-123">Well, you could try turning on affinity.</span></span>

## <a name="how-to-configure-affinity"></a><span data-ttu-id="83629-124">선호도를 구성하는 방법</span><span class="sxs-lookup"><span data-stu-id="83629-124">How to configure affinity</span></span>
<span data-ttu-id="83629-125">선호도를 설정하려면 두 개의 서로 다른 서비스 간의 선호도 관계를 정의합니다.</span><span class="sxs-lookup"><span data-stu-id="83629-125">To set up affinity, you define an affinity relationship between two different services.</span></span> <span data-ttu-id="83629-126">선호도를 다른 서비스에 있는 한 서비스를 "가리키고" "이 서비스는 해당 서비스가 실행되고 있는 장소에서만 실행될 수 있습니다."라고 생각할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="83629-126">You can think of affinity as “pointing” one service at another and saying “This service can only run where that service is running.”</span></span> <span data-ttu-id="83629-127">경우에 따라 부모 자식 관계(부모에 있는 자식을 가리키는 경우)를 의미하기도 합니다.</span><span class="sxs-lookup"><span data-stu-id="83629-127">Sometimes we refer to affinity as a parent/child relationship (where you point the child at the parent).</span></span> <span data-ttu-id="83629-128">선호도는 한 서비스의 복제본 또는 인스턴스가 다른 서비스의 복제본 또는 인스턴스와 동일한 노드에 배치되도록 합니다.</span><span class="sxs-lookup"><span data-stu-id="83629-128">Affinity ensures that the replicas or instances of one service are placed on the same nodes as those of another service.</span></span>

```csharp
ServiceCorrelationDescription affinityDescription = new ServiceCorrelationDescription();
affinityDescription.Scheme = ServiceCorrelationScheme.Affinity;
affinityDescription.ServiceName = new Uri("fabric:/otherApplication/parentService");
serviceDescription.Correlations.Add(affinityDescription);
await fabricClient.ServiceManager.CreateServiceAsync(serviceDescription);
```

> [!NOTE]
> <span data-ttu-id="83629-129">자식 서비스는 단일 선호도 관계에만 참여할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="83629-129">A child service can only participate in a single affinity relationship.</span></span> <span data-ttu-id="83629-130">자식이 한 번에 두 부모 서비스와 선호도 관계를 맺도록 하려는 경우 몇 가지 옵션이 있습니다.</span><span class="sxs-lookup"><span data-stu-id="83629-130">If you wanted the child to be affinitized to two parent services at once you have a couple options:</span></span>
> - <span data-ttu-id="83629-131">관계를 역순으로 지정합니다(현재 자식 서비스에서 parentService1 및 parentService2를 가리키도록 함). 또는</span><span class="sxs-lookup"><span data-stu-id="83629-131">Reverse the relationships (have parentService1 and parentService2 point at the current child service), or</span></span>
> - <span data-ttu-id="83629-132">규칙에 따라 부모 중 하나를 허브로 지정하고 모든 서비스에서 해당 서비스를 가리키도록 합니다.</span><span class="sxs-lookup"><span data-stu-id="83629-132">Designate one of the parents as a hub by convention and have all services point at that service.</span></span> 
>
> <span data-ttu-id="83629-133">결과적으로 클러스터의 배치 동작이 동일해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="83629-133">The resulting placement behavior in the cluster should be the same.</span></span>
>

## <a name="different-affinity-options"></a><span data-ttu-id="83629-134">서로 다른 선호도 옵션</span><span class="sxs-lookup"><span data-stu-id="83629-134">Different affinity options</span></span>
<span data-ttu-id="83629-135">선호도는 몇 가지 상관 관계 구성표 중 하나를 통해 표시되며, 두 가지 모드가 있습니다.</span><span class="sxs-lookup"><span data-stu-id="83629-135">Affinity is represented via one of several correlation schemes, and has two different modes.</span></span> <span data-ttu-id="83629-136">선호도의 가장 일반적인 모드는 NonAlignedAffinity라고 하는 것입니다.</span><span class="sxs-lookup"><span data-stu-id="83629-136">The most common mode of affinity is what we call NonAlignedAffinity.</span></span> <span data-ttu-id="83629-137">NonAlignedAffinity에서 서로 다른 서비스의 복제본 또는 인스턴스는 같은 노드에 배치됩니다.</span><span class="sxs-lookup"><span data-stu-id="83629-137">In NonAlignedAffinity, the replicas or instances of the different services are placed on the same nodes.</span></span> <span data-ttu-id="83629-138">다른 모드는 AlignedAffinity입니다.</span><span class="sxs-lookup"><span data-stu-id="83629-138">The other mode is AlignedAffinity.</span></span> <span data-ttu-id="83629-139">정렬된 선호도는 상태 저장 서비스에서만 유용합니다.</span><span class="sxs-lookup"><span data-stu-id="83629-139">Aligned Affinity is useful only with stateful services.</span></span> <span data-ttu-id="83629-140">선호도가 정렬된 두 개의 상태 저장 서비스를 구성하면 이러한 서비스의 주 복제본이 서로 동일한 노드에 배치될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="83629-140">Configuring two stateful services to have aligned affinity ensures that the primaries of those services are placed on the same nodes as each other.</span></span> <span data-ttu-id="83629-141">또한 해당 서비스에 대한 각 보조 복제본 쌍이 동일한 노드에 배치됩니다.</span><span class="sxs-lookup"><span data-stu-id="83629-141">It also causes each pair of secondaries for those services to be placed on the same nodes.</span></span> <span data-ttu-id="83629-142">상태 저장 서비스를 위해 NonAlignedAffinity를 구성할 수도 있습니다(덜 일반적임).</span><span class="sxs-lookup"><span data-stu-id="83629-142">It is also possible (though less common) to configure NonAlignedAffinity for stateful services.</span></span> <span data-ttu-id="83629-143">NonAlignedAffinity의 경우 두 상태 저장 서비스의 서로 다른 복제본이 동일한 노드에서 실행되지만 주 복제본은 다른 노드에 있을 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="83629-143">For NonAlignedAffinity, the different replicas of the two stateful services would run on the same nodes, but their primaries could end up on different nodes.</span></span>

<span data-ttu-id="83629-144"><center>
![선호도 모드 및 그 영향][Image1]
</center></span><span class="sxs-lookup"><span data-stu-id="83629-144"><center>
![Affinity Modes and Their Effects][Image1]
</center></span></span>

### <a name="best-effort-desired-state"></a><span data-ttu-id="83629-145">최상의 노력이 필요한 상태</span><span class="sxs-lookup"><span data-stu-id="83629-145">Best effort desired state</span></span>
<span data-ttu-id="83629-146">선호도 관계는 최상의 노력입니다.</span><span class="sxs-lookup"><span data-stu-id="83629-146">An affinity relationship is best effort.</span></span> <span data-ttu-id="83629-147">동일한 실행 가능 프로세스에서 실행되는 배열 또는 안정성에 대해 동일한 보증을 제공하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="83629-147">It does not provide the same guarantees of collocation or reliability that running in the same executable process does.</span></span> <span data-ttu-id="83629-148">선호도 관계의 서비스는 실패할 수 있으며 독립적으로 이동할 수 있는 기본적으로 다른 엔터티입니다.</span><span class="sxs-lookup"><span data-stu-id="83629-148">The services in an affinity relationship are fundamentally different entities that can fail and be moved independently.</span></span> <span data-ttu-id="83629-149">선호도 관계도 중단될 수 있지만 이러한 중단은 일시적입니다.</span><span class="sxs-lookup"><span data-stu-id="83629-149">An affinity relationship could also break, though these breaks are temporary.</span></span> <span data-ttu-id="83629-150">예를 들어 용량 제한은 선호도 관계에 있는 일부 서비스 개체만 지정된 노드에 맞출 수 있음을 의미할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="83629-150">For example, capacity limitations may mean that only some of the service objects in the affinity relationship can fit on a given node.</span></span> <span data-ttu-id="83629-151">이러한 경우 선호도 관계가 준비되었더라도 다른 제약 조건으로 인해 적용될 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="83629-151">In these cases even though there's an affinity relationship in place, it can't be enforced due to the other constraints.</span></span> <span data-ttu-id="83629-152">이렇게 할 수 있다면 나중에 위반이 자동으로 수정됩니다.</span><span class="sxs-lookup"><span data-stu-id="83629-152">If it is possible to do so, the violation is automatically corrected later.</span></span>

### <a name="chains-vs-stars"></a><span data-ttu-id="83629-153">체인 모양과 별 모양의 비교</span><span class="sxs-lookup"><span data-stu-id="83629-153">Chains vs. stars</span></span>
<span data-ttu-id="83629-154">현재 Cluster Resource Manager는 선호도 관계의 체인을 모델링할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="83629-154">Today the Cluster Resource Manager isn't able to model chains of affinity relationships.</span></span> <span data-ttu-id="83629-155">즉, 한 선호도 관계에서 자식인 서비스는 다른 선호도 관계에서 부모가 될 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="83629-155">What this means is that a service that is a child in one affinity relationship can’t be a parent in another affinity relationship.</span></span> <span data-ttu-id="83629-156">이러한 형식의 관계를 모델링하려는 경우 체인이 아닌 별 모양으로 효과적으로 모델링해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="83629-156">If you want to model this type of relationship, you effectively have to model it as a star, rather than a chain.</span></span> <span data-ttu-id="83629-157">체인을 별 모양으로 움직이려면 최하위 자식은 첫 번째 자식 부모의 부모가 될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="83629-157">To move from a chain to a star, the bottommost child would be parented to the first child’s parent instead.</span></span> <span data-ttu-id="83629-158">서비스의 정렬에 따라 이 작업을 여러 번 수행해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="83629-158">Depending on the arrangement of your services, you may have to do this multiple times.</span></span> <span data-ttu-id="83629-159">기본 부모 서비스가 없는 경우 자리 표시자로 사용되는 서비스를 만들어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="83629-159">If there's no natural parent service, you may have to create one that serves as a placeholder.</span></span> <span data-ttu-id="83629-160">요구 사항에 따라 [응용 프로그램 그룹](service-fabric-cluster-resource-manager-application-groups.md)을 살펴볼 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="83629-160">Depending on your requirements, you may also want to look into [Application Groups](service-fabric-cluster-resource-manager-application-groups.md).</span></span>

<span data-ttu-id="83629-161"><center>
![선호도 관계의 컨텍스트에서 체인 모양과 별 모양의 비교][Image2]
</center></span><span class="sxs-lookup"><span data-stu-id="83629-161"><center>
![Chains vs. Stars in the Context of Affinity Relationships][Image2]
</center></span></span>

<span data-ttu-id="83629-162">또 다른 사항으로 현재의 선호도 관계에는 방향성이 있다는 점입니다.</span><span class="sxs-lookup"><span data-stu-id="83629-162">Another thing to note about affinity relationships today is that they are directional.</span></span> <span data-ttu-id="83629-163">즉 선호도 규칙은 자식이 부모와 함께 배치되도록 합니다.</span><span class="sxs-lookup"><span data-stu-id="83629-163">This means that the affinity rule only enforces that the child placed with the parent.</span></span> <span data-ttu-id="83629-164">부모가 자식과 함께 있도록 보장하지는 않습니다.</span><span class="sxs-lookup"><span data-stu-id="83629-164">It does not ensure that the parent is located with the child.</span></span> <span data-ttu-id="83629-165">또한 서로 다른 서비스에서 별도의 수명 주기를 가지고 있고 독립적으로 실패하고 이동할 수 있기 때문에 선호도 관계가 완벽하거나 즉시 적용될 수 없다는 점에 유의해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="83629-165">It is also important to note that the affinity relationship can't be perfect or instantly enforced since different services have with different lifecycles and can fail and move independently.</span></span> <span data-ttu-id="83629-166">예를 들어 크래시로 인해 부모가 갑자기 다른 노드로 장애 조치되었다고 가정해 보겠습니다.</span><span class="sxs-lookup"><span data-stu-id="83629-166">For example, let's say the parent suddenly fails over to another node because it crashed.</span></span> <span data-ttu-id="83629-167">서비스를 계속, 일관성 있게, 사용할 수 있도록 유지하는 것이 우선 순위이므로 클러스터 리소스 관리자와 장애 조치(Failover) 관리자는 장애 조치를 먼저 처리합니다.</span><span class="sxs-lookup"><span data-stu-id="83629-167">The Cluster Resource Manager and Failover Manager handle the failover first, since keeping the services up, consistent, and available is the priority.</span></span> <span data-ttu-id="83629-168">장애 조치가 완료되면 선호도 관계는 끊어지지만 클러스터 리소스 관리자에서는 자식이 부모와 함께 있지 않다는 알기 전까지 모든 것이 문제가 없다고 간주합니다.</span><span class="sxs-lookup"><span data-stu-id="83629-168">Once the failover completes, the affinity relationship is broken, but the Cluster Resource Manager thinks everything is fine until it notices that the child is not located with the parent.</span></span> <span data-ttu-id="83629-169">이러한 종류의 검사는 정기적으로 수행됩니다.</span><span class="sxs-lookup"><span data-stu-id="83629-169">These sorts of checks are performed periodically.</span></span> <span data-ttu-id="83629-170">클러스터 리소스 관리자에서 제약 조건을 평가하는 방법에 대한 자세한 내용은 [이 문서](service-fabric-cluster-resource-manager-management-integration.md#constraint-types)에서 설명하고 있으며, [이 문서](service-fabric-cluster-resource-manager-balancing.md)에서는 이러한 제약 조건을 평가하는 빈도를 구성하는 방법에 대해 자세히 설명합니다.</span><span class="sxs-lookup"><span data-stu-id="83629-170">More information on how the Cluster Resource Manager evaluates constraints is available in [this article](service-fabric-cluster-resource-manager-management-integration.md#constraint-types), and [this one](service-fabric-cluster-resource-manager-balancing.md) talks more about how to configure the cadence on which these constraints are evaluated.</span></span>   


### <a name="partitioning-support"></a><span data-ttu-id="83629-171">분할 지원</span><span class="sxs-lookup"><span data-stu-id="83629-171">Partitioning support</span></span>
<span data-ttu-id="83629-172">마지막으로 선호도에 대해 알아두어야 할 사항으로 선호도 관계는 부모가 분할된 곳에서는 지원되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="83629-172">The final thing to notice about affinity is that affinity relationships aren’t supported where the parent is partitioned.</span></span> <span data-ttu-id="83629-173">분할된 부모 서비스는 결국 지원될 수 있지만 오늘날에는 허용되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="83629-173">Partitioned parent services may be supported eventually, but today it is not allowed.</span></span>

## <a name="next-steps"></a><span data-ttu-id="83629-174">다음 단계</span><span class="sxs-lookup"><span data-stu-id="83629-174">Next steps</span></span>
- <span data-ttu-id="83629-175">서비스 구성에 대한 자세한 내용은 [서비스 구성에 대한 자세한 정보](service-fabric-cluster-resource-manager-configure-services.md)에서 알아봅니다.</span><span class="sxs-lookup"><span data-stu-id="83629-175">For more information on configuring services, [Learn about configuring Services](service-fabric-cluster-resource-manager-configure-services.md)</span></span>
- <span data-ttu-id="83629-176">서비스를 작은 컴퓨터 집합으로 제한하거나 서비스 로드를 집계하려면 [응용 프로그램 그룹](service-fabric-cluster-resource-manager-application-groups.md)을 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="83629-176">To limit services to a small set of machines or aggregating the load of services, use [Application Groups](service-fabric-cluster-resource-manager-application-groups.md)</span></span>

[Image1]:./media/service-fabric-cluster-resource-manager-advanced-placement-rules-affinity/cluster-resrouce-manager-affinity-modes.png
[Image2]:./media/service-fabric-cluster-resource-manager-advanced-placement-rules-affinity/cluster-resource-manager-chains-vs-stars.png