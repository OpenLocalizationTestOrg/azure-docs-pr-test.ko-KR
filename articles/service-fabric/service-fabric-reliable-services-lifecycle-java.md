---
title: "Azure 서비스 패브릭 신뢰할 수 있는 서비스의 수명 주기 hello aaaOverview | Microsoft Docs"
description: "서비스 패브릭 신뢰할 수 있는 서비스의 hello 다른 수명 주기 이벤트에 알아보기"
services: Service-Fabric
documentationcenter: java
author: PavanKunapareddyMSFT
manager: timlt
ms.assetid: 
ms.service: Service-Fabric
ms.devlang: java
ms.topic: article
ms.tgt_pltfrm: NA
ms.workload: NA
ms.date: 06/30/2017
ms.author: pakunapa;
ms.openlocfilehash: 6d48c217d12bc5248c2da57b544aac747cecd872
ms.sourcegitcommit: 523283cc1b3c37c428e77850964dc1c33742c5f0
ms.translationtype: MT
ms.contentlocale: ko-KR
ms.lasthandoff: 10/06/2017
---
# <a name="reliable-services-lifecycle-overview"></a><span data-ttu-id="b65b6-103">Reliable Services 수명 주기 개요</span><span class="sxs-lookup"><span data-stu-id="b65b6-103">Reliable services lifecycle overview</span></span>
> [!div class="op_single_selector"]
> * [<span data-ttu-id="b65b6-104">Windows에서 C#</span><span class="sxs-lookup"><span data-stu-id="b65b6-104">C# on Windows</span></span>](service-fabric-reliable-services-lifecycle.md)
> * [<span data-ttu-id="b65b6-105">Linux에서 Java</span><span class="sxs-lookup"><span data-stu-id="b65b6-105">Java on Linux</span></span>](service-fabric-reliable-services-lifecycle-java.md)
>
>

<span data-ttu-id="b65b6-106">신뢰할 수 있는 서비스의 hello 주기를 고려할 때는 hello 수명 주기의 hello 기본 사항 가장 중요 한 hello 됩니다.</span><span class="sxs-lookup"><span data-stu-id="b65b6-106">When thinking about hello lifecycles of Reliable Services, hello basics of hello lifecycle are hello most important.</span></span> <span data-ttu-id="b65b6-107">일반적으로:</span><span class="sxs-lookup"><span data-stu-id="b65b6-107">In general:</span></span>

* <span data-ttu-id="b65b6-108">시작 중</span><span class="sxs-lookup"><span data-stu-id="b65b6-108">During Startup</span></span>
  * <span data-ttu-id="b65b6-109">서비스가 생성됩니다.</span><span class="sxs-lookup"><span data-stu-id="b65b6-109">Services are constructed</span></span>
  * <span data-ttu-id="b65b6-110">기회 tooconstruct 변수와 0 개 이상의 수신기를 반환 합니다.</span><span class="sxs-lookup"><span data-stu-id="b65b6-110">They have an opportunity tooconstruct and return zero or more listeners</span></span>
  * <span data-ttu-id="b65b6-111">반환 된 모든 수신기 열려 hello 서비스와의 통신을 허용 합니다.</span><span class="sxs-lookup"><span data-stu-id="b65b6-111">Any returned listeners are opened, allowing communication with hello service</span></span>
  * <span data-ttu-id="b65b6-112">hello 서비스 runAsync 메서드가 호출 되 면 장기 실행 서비스 toodo hello 또는 작업을 배경 허용</span><span class="sxs-lookup"><span data-stu-id="b65b6-112">hello Service's runAsync method is called, allowing hello service toodo long running or background work</span></span>
* <span data-ttu-id="b65b6-113">종료 중</span><span class="sxs-lookup"><span data-stu-id="b65b6-113">During shutdown</span></span>
  * <span data-ttu-id="b65b6-114">hello 취소 토큰 전달된 toorunAsync 취소 되 고 hello 수신기 닫혀 있습니다.</span><span class="sxs-lookup"><span data-stu-id="b65b6-114">hello cancellation token passed toorunAsync is canceled, and hello listeners are closed</span></span>
  * <span data-ttu-id="b65b6-115">완료 되 면 hello 서비스 개체 자체은 이벤트 소멸</span><span class="sxs-lookup"><span data-stu-id="b65b6-115">Once that is complete, hello service object itself is destructed</span></span>

<span data-ttu-id="b65b6-116">이러한 이벤트의 순서 지정 정확한 hello 자세한 내용은 있습니다.</span><span class="sxs-lookup"><span data-stu-id="b65b6-116">There are details around hello exact ordering of these events.</span></span> <span data-ttu-id="b65b6-117">특히 이벤트 hello 순서 Stateless 또는 상태 저장 hello 신뢰할 수 있는 서비스 인지에 따라 약간 변경 될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="b65b6-117">In particular, hello order of events may change slightly depending on whether hello Reliable Service is Stateless or Stateful.</span></span> <span data-ttu-id="b65b6-118">또한 상태 저장 서비스에 대 한 주 스왑 시나리오 hello와 toodeal이 있는 합니다.</span><span class="sxs-lookup"><span data-stu-id="b65b6-118">In addition, for stateful services, we have toodeal with hello Primary swap scenario.</span></span> <span data-ttu-id="b65b6-119">이 시퀀스 하는 동안 주 hello 역할은 전송 된 tooanother 복제 (또는 다시 시작) hello 서비스를 종료 하지 않고 있습니다.</span><span class="sxs-lookup"><span data-stu-id="b65b6-119">During this sequence, hello role of Primary is transferred tooanother replica (or comes back) without hello service shutting down.</span></span> <span data-ttu-id="b65b6-120">마지막으로, 오류나 오류 조건에 대 한 toothink을 했습니다.</span><span class="sxs-lookup"><span data-stu-id="b65b6-120">Finally, we have toothink about error or failure conditions.</span></span>

## <a name="stateless-service-startup"></a><span data-ttu-id="b65b6-121">상태 비저장 서비스 시작</span><span class="sxs-lookup"><span data-stu-id="b65b6-121">Stateless service startup</span></span>
<span data-ttu-id="b65b6-122">상태 비저장 서비스의 hello 수명 주기는 매우 간단 합니다.</span><span class="sxs-lookup"><span data-stu-id="b65b6-122">hello lifecycle of a stateless service is fairly straightforward.</span></span> <span data-ttu-id="b65b6-123">이벤트의 hello 순서는 다음과 같습니다.</span><span class="sxs-lookup"><span data-stu-id="b65b6-123">Here's hello order of events:</span></span>

1. <span data-ttu-id="b65b6-124">hello 서비스가 생성 되</span><span class="sxs-lookup"><span data-stu-id="b65b6-124">hello Service is constructed</span></span>
2. <span data-ttu-id="b65b6-125">그런 다음 두 가지 작업이 병렬로 수행됩니다.</span><span class="sxs-lookup"><span data-stu-id="b65b6-125">Then, in parallel two things happen:</span></span>
    - <span data-ttu-id="b65b6-126">`StatelessService.createServiceInstanceListeners()`이 호출되고 반환된 모든 수신기가 열립니다(`CommunicationListener.openAsync()`이 각 수신기에서 호출됨).</span><span class="sxs-lookup"><span data-stu-id="b65b6-126">`StatelessService.createServiceInstanceListeners()` is invoked and any returned listeners are Opened (`CommunicationListener.openAsync()` is called on each listener)</span></span>
    - <span data-ttu-id="b65b6-127">서비스의 runAsync 메서드 hello (`StatelessService.runAsync()`) 호출</span><span class="sxs-lookup"><span data-stu-id="b65b6-127">hello service's runAsync method (`StatelessService.runAsync()`) is called</span></span>
3. <span data-ttu-id="b65b6-128">있는 경우 hello 서비스의 onOpenAsync 메서드는 (특히, `StatelessService.onOpenAsync()` 호출 됩니다.</span><span class="sxs-lookup"><span data-stu-id="b65b6-128">If present, hello service's own onOpenAsync method is called (Specifically, `StatelessService.onOpenAsync()` is called.</span></span> <span data-ttu-id="b65b6-129">이 항목은 일반적이지 않은 재정의이지만 사용 가능합니다).</span><span class="sxs-lookup"><span data-stu-id="b65b6-129">This is an uncommon override but it is available).</span></span>

<span data-ttu-id="b65b6-130">것이 중요 한 toonote 한지 hello 호출 toocreate 및 열기 hello 수신기 및 runAsync 간 순서가 없습니다.</span><span class="sxs-lookup"><span data-stu-id="b65b6-130">It is important toonote that there is no ordering between hello calls toocreate and open hello listeners and runAsync.</span></span> <span data-ttu-id="b65b6-131">hello 수신기 runAsync를 시작 하기 전에 열릴 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="b65b6-131">hello listeners may open before runAsync is started.</span></span> <span data-ttu-id="b65b6-132">마찬가지로, runAsync 될 수 hello 통신 수신기 열려 있거나도 생성 되기 전에 호출 됩니다.</span><span class="sxs-lookup"><span data-stu-id="b65b6-132">Similarly, runAsync may end up invoked before hello communication listeners are open or have even been constructed.</span></span> <span data-ttu-id="b65b6-133">동기화가 필요한 경우 연습 toohello 구현자로 유지 됩니다.</span><span class="sxs-lookup"><span data-stu-id="b65b6-133">If any synchronization is required, it is left as an exercise toohello implementer.</span></span> <span data-ttu-id="b65b6-134">일반적인 솔루션:</span><span class="sxs-lookup"><span data-stu-id="b65b6-134">Common solutions:</span></span>

* <span data-ttu-id="b65b6-135">경우에 따라 다른 정보를 만들거나 수행할 때까지 수신기는 작동할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="b65b6-135">Sometimes listeners can't function until some other information is created or work done.</span></span> <span data-ttu-id="b65b6-136">작업 도중에 hello 수행 hello 서비스의 생성자에서 일반적으로 상태 비저장 서비스에 대 한 `createServiceInstanceListeners()` 를 호출 하거나 자체 hello 수신기의 hello 생성의 일부로 합니다.</span><span class="sxs-lookup"><span data-stu-id="b65b6-136">For stateless services that work can usually be done in hello service's constructor, during hello `createServiceInstanceListeners()` call, or as a part of hello construction of hello listener itself.</span></span>
* <span data-ttu-id="b65b6-137">경우에 따라 hello runAsync의 코드를 원하지 않습니다 toostart hello 수신기 열려 있는 될 때까지.</span><span class="sxs-lookup"><span data-stu-id="b65b6-137">Sometimes hello code in runAsync does not want toostart until hello listeners are open.</span></span> <span data-ttu-id="b65b6-138">이 경우에 추가 조정이 필요합니다.</span><span class="sxs-lookup"><span data-stu-id="b65b6-138">In this case additional coordination is necessary.</span></span> <span data-ttu-id="b65b6-139">일반적인 솔루션은 때 수행한 tooactual 작업을 계속 하기 전에 runAsync이 선택 되어 있는 나타내는 hello 수신기 내에서 일부 플래그입니다.</span><span class="sxs-lookup"><span data-stu-id="b65b6-139">One common solution is some flag within hello listeners indicating when they have completed, which is checked in runAsync before continuing tooactual work.</span></span>

## <a name="stateless-service-shutdown"></a><span data-ttu-id="b65b6-140">상태 비저장 서비스 종료</span><span class="sxs-lookup"><span data-stu-id="b65b6-140">Stateless service shutdown</span></span>
<span data-ttu-id="b65b6-141">상태 비저장 서비스를 종료할 때 hello 동일한 패턴 뒤, 반대 방향으로 바로:</span><span class="sxs-lookup"><span data-stu-id="b65b6-141">When shutting down a stateless service, hello same pattern is followed, just in reverse:</span></span>

1. <span data-ttu-id="b65b6-142">병렬로</span><span class="sxs-lookup"><span data-stu-id="b65b6-142">In parallel</span></span>
    - <span data-ttu-id="b65b6-143">열려 있는 수신기 닫힙니다(각 수신기에서 `CommunicationListener.closeAsync()`을 호출함).</span><span class="sxs-lookup"><span data-stu-id="b65b6-143">Any open listeners are Closed (`CommunicationListener.closeAsync()` is called on each listener)</span></span>
    - <span data-ttu-id="b65b6-144">hello 취소 토큰이 전달 너무`runAsync()` 취소 (hello 취소 토큰을 검사 `isCancelled` 속성 true를 반환 hello 토큰을 호출 하 고 `throwIfCancellationRequested` 메서드가 throw는 `CancellationException`)</span><span class="sxs-lookup"><span data-stu-id="b65b6-144">hello cancellation token passed too`runAsync()` is canceled (checking hello cancellation token's `isCancelled` property returns true, and if called hello token's `throwIfCancellationRequested` method throws a `CancellationException`)</span></span>
2. <span data-ttu-id="b65b6-145">한 번 `closeAsync()` 각 수신기에서 완료 되 고 `runAsync()` 도 완료 되 면 hello 서비스의 `StatelessService.onCloseAsync()` 있는 경우 메서드가 호출 되 (다시 이것이 일반적이 지 않은 재정의).</span><span class="sxs-lookup"><span data-stu-id="b65b6-145">Once `closeAsync()` completes on each listener and `runAsync()` also completes, hello service's `StatelessService.onCloseAsync()` method is called, if present (again this is an uncommon override).</span></span>
3. <span data-ttu-id="b65b6-146">후 `StatelessService.onCloseAsync()` 완료 되 면 서비스 개체 hello은 이벤트 소멸</span><span class="sxs-lookup"><span data-stu-id="b65b6-146">After `StatelessService.onCloseAsync()` completes, hello service object is destructed</span></span>

## <a name="notes-on-service-lifecycle"></a><span data-ttu-id="b65b6-147">서비스 수명 주기에 대한 참고 사항</span><span class="sxs-lookup"><span data-stu-id="b65b6-147">Notes on service lifecycle</span></span>
* <span data-ttu-id="b65b6-148">두 hello `runAsync()` 메서드와 hello `createServiceInstanceListeners` 호출은 선택 사항입니다.</span><span class="sxs-lookup"><span data-stu-id="b65b6-148">Both hello `runAsync()` method and hello `createServiceInstanceListeners` calls are optional.</span></span> <span data-ttu-id="b65b6-149">서비스에는 이러한 항목이 있거나 없을 수도 있습니다.</span><span class="sxs-lookup"><span data-stu-id="b65b6-149">A service may have one of them, both, or neither.</span></span> <span data-ttu-id="b65b6-150">예를 들어 응답 toouser 호출에는 모든 작업을 수행 하는 hello 서비스, 있는지 사용할 필요가 없다고 tooimplement `runAsync()`합니다.</span><span class="sxs-lookup"><span data-stu-id="b65b6-150">For example, if hello service does all its work in response toouser calls, there is no need for it tooimplement `runAsync()`.</span></span> <span data-ttu-id="b65b6-151">Hello 통신 수신기만 및 해당 관련된 코드는 필요 합니다.</span><span class="sxs-lookup"><span data-stu-id="b65b6-151">Only hello communication listeners and their associated code are necessary.</span></span> <span data-ttu-id="b65b6-152">마찬가지로, 만들고 통신 수신기를 반환 hello 서비스 toodo를 작동 하는 배경만 있을 수 있습니다는 선택 사항, 하며만 tooimplement`runAsync()`</span><span class="sxs-lookup"><span data-stu-id="b65b6-152">Similarly, creating and returning communication listeners is optional, as hello service may have only background work toodo, and so only needs tooimplement `runAsync()`</span></span>
* <span data-ttu-id="b65b6-153">서비스 toocomplete에 대해 유효한 `runAsync()` 성공적으로 및에서 반환 합니다.</span><span class="sxs-lookup"><span data-stu-id="b65b6-153">It is valid for a service toocomplete `runAsync()` successfully and return from it.</span></span> <span data-ttu-id="b65b6-154">실패 조건으로 간주 되지 않으므로 하 고는 hello 서비스 완료 하는 hello 백그라운드 작업을 나타냅니다.</span><span class="sxs-lookup"><span data-stu-id="b65b6-154">This is not considered a failure condition and would represent hello background work of hello service completing.</span></span> <span data-ttu-id="b65b6-155">신뢰할 수 있는 상태 저장 서비스에 대 한 `runAsync()` hello 서비스 주에서 강등 다음 백 tooprimary를 승격 하는 경우 다시 호출 합니다.</span><span class="sxs-lookup"><span data-stu-id="b65b6-155">For stateful reliable services `runAsync()` would be called again if hello service were demoted from primary and then promoted back tooprimary.</span></span>
* <span data-ttu-id="b65b6-156">서비스에서 종료 되 면 `runAsync()` 오류 일부 예기치 않은 예외를 throw 하 여입니다와 hello 서비스 개체 종료 되 고 상태 오류를 보고 합니다.</span><span class="sxs-lookup"><span data-stu-id="b65b6-156">If a service exits from `runAsync()` by throwing some unexpected exception, this is a failure and hello service object is shut down and a health error reported.</span></span>
* <span data-ttu-id="b65b6-157">이러한 방법 중에서 반환 하는 방법에 시간 제한이 없으며 상태인 동안 즉시 hello 기능 toowrite 손실 되 고 모든 실제 작업을 완료할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="b65b6-157">While there is no time limit on returning from these methods, you immediately lose hello ability toowrite and therefore cannot complete any real work.</span></span> <span data-ttu-id="b65b6-158">가능한 한 빨리 hello 취소 요청을 받으면 반환 하는 것이 좋습니다.</span><span class="sxs-lookup"><span data-stu-id="b65b6-158">It is recommended that you return as quickly as possible upon receiving hello cancellation request.</span></span> <span data-ttu-id="b65b6-159">서비스는 적절 한 시간 내에 서비스 패브릭 강제로 수 toothese API 호출 응답 하지 않을 경우 서비스를 종료 합니다.</span><span class="sxs-lookup"><span data-stu-id="b65b6-159">If your service does not respond toothese API calls in a reasonable amount of time Service Fabric may forcibly terminate your service.</span></span> <span data-ttu-id="b65b6-160">이러한 상황은 일반적으로 응용 프로그램을 업그레이드하거나 서비스를 삭제할 때 발생합니다.</span><span class="sxs-lookup"><span data-stu-id="b65b6-160">Usually this only happens during application upgrades or when a service is being deleted.</span></span> <span data-ttu-id="b65b6-161">이 시간 제한은 기본적으로 15분입니다.</span><span class="sxs-lookup"><span data-stu-id="b65b6-161">This timeout is 15 minutes by default.</span></span>
* <span data-ttu-id="b65b6-162">Hello에서 발생 한 실패 `onCloseAsync()` path 결과에서 `onAbort()` hello에 대 한 마지막 발생할 가능성이 있는 최상의 기회는 호출 되 고 tooclean를 서비스 하 고 요청할가 있는 모든 리소스를 해제 합니다.</span><span class="sxs-lookup"><span data-stu-id="b65b6-162">Failures in hello `onCloseAsync()` path result in `onAbort()` being called which is a last-chance best-effort opportunity for hello service tooclean up and release any resources that they have claimed.</span></span>

> [!NOTE]
> <span data-ttu-id="b65b6-163">상태 저장 Reliable Services는 Java에서 아직 지원되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="b65b6-163">Stateful reliable services are not supported in java yet.</span></span>
>
>

## <a name="next-steps"></a><span data-ttu-id="b65b6-164">다음 단계</span><span class="sxs-lookup"><span data-stu-id="b65b6-164">Next steps</span></span>
* [<span data-ttu-id="b65b6-165">TooReliable 서비스 소개</span><span class="sxs-lookup"><span data-stu-id="b65b6-165">Introduction tooReliable Services</span></span>](service-fabric-reliable-services-introduction.md)
* [<span data-ttu-id="b65b6-166">Reliable Services 빠른 시작</span><span class="sxs-lookup"><span data-stu-id="b65b6-166">Reliable Services quick start</span></span>](service-fabric-reliable-services-quick-start.md)
* [<span data-ttu-id="b65b6-167">신뢰할 수 있는 서비스 고급 사용법</span><span class="sxs-lookup"><span data-stu-id="b65b6-167">Reliable Services advanced usage</span></span>](service-fabric-reliable-services-advanced-usage.md)
