---
title: "Azure Service Fabric Reliable Services의 수명 주기 개요 | Microsoft Docs"
description: "Service Fabric Reliable Services의 다른 수명 주기 이벤트에 대해 알아보기"
services: Service-Fabric
documentationcenter: java
author: PavanKunapareddyMSFT
manager: timlt
ms.assetid: 
ms.service: Service-Fabric
ms.devlang: java
ms.topic: article
ms.tgt_pltfrm: NA
ms.workload: NA
ms.date: 06/30/2017
ms.author: pakunapa;
ms.openlocfilehash: 80eb68346dd05c256c60725eb082aa0651fe7cbd
ms.sourcegitcommit: 50e23e8d3b1148ae2d36dad3167936b4e52c8a23
ms.translationtype: MT
ms.contentlocale: ko-KR
ms.lasthandoff: 08/18/2017
---
# <a name="reliable-services-lifecycle-overview"></a><span data-ttu-id="57132-103">Reliable Services 수명 주기 개요</span><span class="sxs-lookup"><span data-stu-id="57132-103">Reliable services lifecycle overview</span></span>
> [!div class="op_single_selector"]
> * [<span data-ttu-id="57132-104">Windows에서 C#</span><span class="sxs-lookup"><span data-stu-id="57132-104">C# on Windows</span></span>](service-fabric-reliable-services-lifecycle.md)
> * [<span data-ttu-id="57132-105">Linux에서 Java</span><span class="sxs-lookup"><span data-stu-id="57132-105">Java on Linux</span></span>](service-fabric-reliable-services-lifecycle-java.md)
>
>

<span data-ttu-id="57132-106">Reliable Services의 수명 주기를 고려할 경우 수명 주기에 대한 기본 사항이 가장 중요합니다.</span><span class="sxs-lookup"><span data-stu-id="57132-106">When thinking about the lifecycles of Reliable Services, the basics of the lifecycle are the most important.</span></span> <span data-ttu-id="57132-107">일반적으로:</span><span class="sxs-lookup"><span data-stu-id="57132-107">In general:</span></span>

* <span data-ttu-id="57132-108">시작 중</span><span class="sxs-lookup"><span data-stu-id="57132-108">During Startup</span></span>
  * <span data-ttu-id="57132-109">서비스가 생성됩니다.</span><span class="sxs-lookup"><span data-stu-id="57132-109">Services are constructed</span></span>
  * <span data-ttu-id="57132-110">0개 이상의 수신기를 생성하고 반환할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="57132-110">They have an opportunity to construct and return zero or more listeners</span></span>
  * <span data-ttu-id="57132-111">반환된 모든 수신기 열리면 서비스와의 통신이 가능합니다.</span><span class="sxs-lookup"><span data-stu-id="57132-111">Any returned listeners are opened, allowing communication with the service</span></span>
  * <span data-ttu-id="57132-112">서비스의 runAsync 메서드를 호출하면 서비스가 장기 실행 중인 백그라운드 작업을 수행할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="57132-112">The Service's runAsync method is called, allowing the service to do long running or background work</span></span>
* <span data-ttu-id="57132-113">종료 중</span><span class="sxs-lookup"><span data-stu-id="57132-113">During shutdown</span></span>
  * <span data-ttu-id="57132-114">runAsync에 전달된 취소 토큰이 취소되고 수신기 닫힙니다.</span><span class="sxs-lookup"><span data-stu-id="57132-114">The cancellation token passed to runAsync is canceled, and the listeners are closed</span></span>
  * <span data-ttu-id="57132-115">작업이 완료되면 서비스 개체 자체는 소멸됩니다.</span><span class="sxs-lookup"><span data-stu-id="57132-115">Once that is complete, the service object itself is destructed</span></span>

<span data-ttu-id="57132-116">이러한 이벤트의 정확한 순서에 대한 세부 정보가 있습니다.</span><span class="sxs-lookup"><span data-stu-id="57132-116">There are details around the exact ordering of these events.</span></span> <span data-ttu-id="57132-117">특히 이벤트의 순서는 Reliable Service가 상태 비저장인지 또는 상태 저장인지에 따라 약간 변경될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="57132-117">In particular, the order of events may change slightly depending on whether the Reliable Service is Stateless or Stateful.</span></span> <span data-ttu-id="57132-118">또한 상태 저장 서비스의 경우 주 복제본 교환 시나리오를 처리해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="57132-118">In addition, for stateful services, we have to deal with the Primary swap scenario.</span></span> <span data-ttu-id="57132-119">이 과정 중에 서비스를 종료하지 않고 주 복제본의 역할을 다른 복제본으로 전송하거나 복구합니다.</span><span class="sxs-lookup"><span data-stu-id="57132-119">During this sequence, the role of Primary is transferred to another replica (or comes back) without the service shutting down.</span></span> <span data-ttu-id="57132-120">마지막으로 오류 또는 실패 조건에 대해 고려해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="57132-120">Finally, we have to think about error or failure conditions.</span></span>

## <a name="stateless-service-startup"></a><span data-ttu-id="57132-121">상태 비저장 서비스 시작</span><span class="sxs-lookup"><span data-stu-id="57132-121">Stateless service startup</span></span>
<span data-ttu-id="57132-122">상태 비저장 서비스의 수명 주기는 매우 간단합니다.</span><span class="sxs-lookup"><span data-stu-id="57132-122">The lifecycle of a stateless service is fairly straightforward.</span></span> <span data-ttu-id="57132-123">이벤트의 순서는 다음과 같습니다.</span><span class="sxs-lookup"><span data-stu-id="57132-123">Here's the order of events:</span></span>

1. <span data-ttu-id="57132-124">서비스를 생성합니다.</span><span class="sxs-lookup"><span data-stu-id="57132-124">The Service is constructed</span></span>
2. <span data-ttu-id="57132-125">그런 다음 두 가지 작업이 병렬로 수행됩니다.</span><span class="sxs-lookup"><span data-stu-id="57132-125">Then, in parallel two things happen:</span></span>
    - <span data-ttu-id="57132-126">`StatelessService.createServiceInstanceListeners()`이 호출되고 반환된 모든 수신기가 열립니다(`CommunicationListener.openAsync()`이 각 수신기에서 호출됨).</span><span class="sxs-lookup"><span data-stu-id="57132-126">`StatelessService.createServiceInstanceListeners()` is invoked and any returned listeners are Opened (`CommunicationListener.openAsync()` is called on each listener)</span></span>
    - <span data-ttu-id="57132-127">서비스의 runAsync 메서드(`StatelessService.runAsync()`)를 호출합니다.</span><span class="sxs-lookup"><span data-stu-id="57132-127">The service's runAsync method (`StatelessService.runAsync()`) is called</span></span>
3. <span data-ttu-id="57132-128">있는 경우 서비스의 onOpenAsync 메서드를 호출합니다.(특히, `StatelessService.onOpenAsync()`을 호출합니다.</span><span class="sxs-lookup"><span data-stu-id="57132-128">If present, the service's own onOpenAsync method is called (Specifically, `StatelessService.onOpenAsync()` is called.</span></span> <span data-ttu-id="57132-129">이 항목은 일반적이지 않은 재정의이지만 사용 가능합니다).</span><span class="sxs-lookup"><span data-stu-id="57132-129">This is an uncommon override but it is available).</span></span>

<span data-ttu-id="57132-130">수신기 및 runAsync를 만들고 여는 호출 간에 순서가 없다는 점이 중요합니다.</span><span class="sxs-lookup"><span data-stu-id="57132-130">It is important to note that there is no ordering between the calls to create and open the listeners and runAsync.</span></span> <span data-ttu-id="57132-131">runAsync가 시작되기 전에 수신기가 열릴 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="57132-131">The listeners may open before runAsync is started.</span></span> <span data-ttu-id="57132-132">마찬가지로 통신 수신기를 열고 생성하기 전에 runAsync를 호출할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="57132-132">Similarly, runAsync may end up invoked before the communication listeners are open or have even been constructed.</span></span> <span data-ttu-id="57132-133">동기화가 필요한 경우 구현 작업에 연습으로 남겨 둡니다.</span><span class="sxs-lookup"><span data-stu-id="57132-133">If any synchronization is required, it is left as an exercise to the implementer.</span></span> <span data-ttu-id="57132-134">일반적인 솔루션:</span><span class="sxs-lookup"><span data-stu-id="57132-134">Common solutions:</span></span>

* <span data-ttu-id="57132-135">경우에 따라 다른 정보를 만들거나 수행할 때까지 수신기는 작동할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="57132-135">Sometimes listeners can't function until some other information is created or work done.</span></span> <span data-ttu-id="57132-136">상태 비저장 서비스의 경우 일반적으로 서비스의 생성자에서 `createServiceInstanceListeners()`를 호출하는 동안이나 수신기 구성의 일부로 해당 작업을 수행할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="57132-136">For stateless services that work can usually be done in the service's constructor, during the `createServiceInstanceListeners()` call, or as a part of the construction of the listener itself.</span></span>
* <span data-ttu-id="57132-137">경우에 따라 runAsync의 코드는 수신기 열릴 때까지 시작하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="57132-137">Sometimes the code in runAsync does not want to start until the listeners are open.</span></span> <span data-ttu-id="57132-138">이 경우에 추가 조정이 필요합니다.</span><span class="sxs-lookup"><span data-stu-id="57132-138">In this case additional coordination is necessary.</span></span> <span data-ttu-id="57132-139">어떤 일반적인 솔루션은 완료된 시기를 나타내는 수신기 내의 일부 플래그이며 실제 작업을 계속하기 전에 runAsync에서 확인됩니다.</span><span class="sxs-lookup"><span data-stu-id="57132-139">One common solution is some flag within the listeners indicating when they have completed, which is checked in runAsync before continuing to actual work.</span></span>

## <a name="stateless-service-shutdown"></a><span data-ttu-id="57132-140">상태 비저장 서비스 종료</span><span class="sxs-lookup"><span data-stu-id="57132-140">Stateless service shutdown</span></span>
<span data-ttu-id="57132-141">상태 비저장 서비스를 종료할 경우 동일한 패턴이 역방향으로 다음과 같이 따라옵니다.</span><span class="sxs-lookup"><span data-stu-id="57132-141">When shutting down a stateless service, the same pattern is followed, just in reverse:</span></span>

1. <span data-ttu-id="57132-142">병렬로</span><span class="sxs-lookup"><span data-stu-id="57132-142">In parallel</span></span>
    - <span data-ttu-id="57132-143">열려 있는 수신기 닫힙니다(각 수신기에서 `CommunicationListener.closeAsync()`을 호출함).</span><span class="sxs-lookup"><span data-stu-id="57132-143">Any open listeners are Closed (`CommunicationListener.closeAsync()` is called on each listener)</span></span>
    - <span data-ttu-id="57132-144">`runAsync()`에 전달된 취소 토큰이 취소됩니다(취소 토큰의 `isCancelled` 속성을 확인하면 true를 반환하고, 호출되는 경우 토큰의 `throwIfCancellationRequested` 메서드에서 `CancellationException`이 발생됨(throw)).</span><span class="sxs-lookup"><span data-stu-id="57132-144">The cancellation token passed to `runAsync()` is canceled (checking the cancellation token's `isCancelled` property returns true, and if called the token's `throwIfCancellationRequested` method throws a `CancellationException`)</span></span>
2. <span data-ttu-id="57132-145">`closeAsync()`이 각 수신기에 완료되고 `runAsync()`도 완료되면 있는 경우 서비스의 `StatelessService.onCloseAsync()` 메서드를 호출합니다(일반적이지 않은 재정의임).</span><span class="sxs-lookup"><span data-stu-id="57132-145">Once `closeAsync()` completes on each listener and `runAsync()` also completes, the service's `StatelessService.onCloseAsync()` method is called, if present (again this is an uncommon override).</span></span>
3. <span data-ttu-id="57132-146">`StatelessService.onCloseAsync()`이 완료되면 서비스 개체는 소멸됩니다.</span><span class="sxs-lookup"><span data-stu-id="57132-146">After `StatelessService.onCloseAsync()` completes, the service object is destructed</span></span>

## <a name="notes-on-service-lifecycle"></a><span data-ttu-id="57132-147">서비스 수명 주기에 대한 참고 사항</span><span class="sxs-lookup"><span data-stu-id="57132-147">Notes on service lifecycle</span></span>
* <span data-ttu-id="57132-148">`runAsync()` 메서드 및 `createServiceInstanceListeners` 호출은 모두 선택 사항입니다.</span><span class="sxs-lookup"><span data-stu-id="57132-148">Both the `runAsync()` method and the `createServiceInstanceListeners` calls are optional.</span></span> <span data-ttu-id="57132-149">서비스에는 이러한 항목이 있거나 없을 수도 있습니다.</span><span class="sxs-lookup"><span data-stu-id="57132-149">A service may have one of them, both, or neither.</span></span> <span data-ttu-id="57132-150">예를 들어, 서비스가 모든 작업을 사용자 호출에 대한 응답으로 수행할 경우 `runAsync()`을(를) 구현할 필요가 없습니다.</span><span class="sxs-lookup"><span data-stu-id="57132-150">For example, if the service does all its work in response to user calls, there is no need for it to implement `runAsync()`.</span></span> <span data-ttu-id="57132-151">통신 수신기 및 해당 관련 코드만이 필요합니다.</span><span class="sxs-lookup"><span data-stu-id="57132-151">Only the communication listeners and their associated code are necessary.</span></span> <span data-ttu-id="57132-152">마찬가지로 통신 수신기를 만들고 반환하는 작업은 선택적이며 서비스가 백그라운드 작업을 수행해야 하므로 `runAsync()`을 구현해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="57132-152">Similarly, creating and returning communication listeners is optional, as the service may have only background work to do, and so only needs to implement `runAsync()`</span></span>
* <span data-ttu-id="57132-153">서비스가 `runAsync()`을 성공적으로 완료하고 거기에서 반환하는 작업이 유효합니다.</span><span class="sxs-lookup"><span data-stu-id="57132-153">It is valid for a service to complete `runAsync()` successfully and return from it.</span></span> <span data-ttu-id="57132-154">실패 조건으로 간주되지 않고 완료 중인 서비스의 백그라운드 작업을 나타냅니다.</span><span class="sxs-lookup"><span data-stu-id="57132-154">This is not considered a failure condition and would represent the background work of the service completing.</span></span> <span data-ttu-id="57132-155">상태 저장 Reliable Services의 경우 서비스가 주 복제본에서 강등되는 경우 `runAsync()`을 다시 호출한 다음 다시 주 복제본으로 승격됩니다.</span><span class="sxs-lookup"><span data-stu-id="57132-155">For stateful reliable services `runAsync()` would be called again if the service were demoted from primary and then promoted back to primary.</span></span>
* <span data-ttu-id="57132-156">서비스가 일부 예기치 않은 예외를 throw하여 `runAsync()`에서 종료되는 경우 오류로서 서비스 개체가 종료되고 상태 오류가 보고됩니다.</span><span class="sxs-lookup"><span data-stu-id="57132-156">If a service exits from `runAsync()` by throwing some unexpected exception, this is a failure and the service object is shut down and a health error reported.</span></span>
* <span data-ttu-id="57132-157">이러한 메서드에서 반환에는 시간 제한이 없으며 작성할 수 있는 기능이 즉시 손실되고 모든 실제 작업을 완료할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="57132-157">While there is no time limit on returning from these methods, you immediately lose the ability to write and therefore cannot complete any real work.</span></span> <span data-ttu-id="57132-158">취소 요청을 받는 즉시 최대한 신속하게 반환하는 것이 좋습니다.</span><span class="sxs-lookup"><span data-stu-id="57132-158">It is recommended that you return as quickly as possible upon receiving the cancellation request.</span></span> <span data-ttu-id="57132-159">서비스가 적절한 시간 내에 이러한 API 호출에 응답하지 않으면 Service Fabric은 서비스를 강제로 종료할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="57132-159">If your service does not respond to these API calls in a reasonable amount of time Service Fabric may forcibly terminate your service.</span></span> <span data-ttu-id="57132-160">이러한 상황은 일반적으로 응용 프로그램을 업그레이드하거나 서비스를 삭제할 때 발생합니다.</span><span class="sxs-lookup"><span data-stu-id="57132-160">Usually this only happens during application upgrades or when a service is being deleted.</span></span> <span data-ttu-id="57132-161">이 시간 제한은 기본적으로 15분입니다.</span><span class="sxs-lookup"><span data-stu-id="57132-161">This timeout is 15 minutes by default.</span></span>
* <span data-ttu-id="57132-162">`onCloseAsync()` 경로의 오류로 인해 `onAbort()`가 호출되고 이것이 서비스에서 요구하는 리소스를 정리하고 릴리스할 수 있는 마지막 방법입니다.</span><span class="sxs-lookup"><span data-stu-id="57132-162">Failures in the `onCloseAsync()` path result in `onAbort()` being called which is a last-chance best-effort opportunity for the service to clean up and release any resources that they have claimed.</span></span>

> [!NOTE]
> <span data-ttu-id="57132-163">상태 저장 Reliable Services는 Java에서 아직 지원되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="57132-163">Stateful reliable services are not supported in java yet.</span></span>
>
>

## <a name="next-steps"></a><span data-ttu-id="57132-164">다음 단계</span><span class="sxs-lookup"><span data-stu-id="57132-164">Next steps</span></span>
* [<span data-ttu-id="57132-165">Reliable Services 소개</span><span class="sxs-lookup"><span data-stu-id="57132-165">Introduction to Reliable Services</span></span>](service-fabric-reliable-services-introduction.md)
* [<span data-ttu-id="57132-166">Reliable Services 빠른 시작</span><span class="sxs-lookup"><span data-stu-id="57132-166">Reliable Services quick start</span></span>](service-fabric-reliable-services-quick-start.md)
* [<span data-ttu-id="57132-167">신뢰할 수 있는 서비스 고급 사용법</span><span class="sxs-lookup"><span data-stu-id="57132-167">Reliable Services advanced usage</span></span>](service-fabric-reliable-services-advanced-usage.md)
