---
title: "Service Fabric의 신뢰할 수 있는 서비스 프로그래밍 모델 개요 | Microsoft Docs"
description: "서비스 패브릭의 신뢰할 수 있는 서비스 프로그래밍 모델에 대해 알아보고 사용자 고유의 서비스 작성을 시작합니다."
services: Service-Fabric
documentationcenter: .net
author: masnider
manager: timlt
editor: vturecek; mani-ramaswamy
ms.assetid: 0c88a533-73f8-4ae1-a939-67d17456ac06
ms.service: Service-Fabric
ms.devlang: dotnet
ms.topic: article
ms.tgt_pltfrm: NA
ms.workload: NA
ms.date: 8/9/2017
ms.author: masnider;
ms.openlocfilehash: 601b1c7713c9785d949c1c72000ec7f3f63dd682
ms.sourcegitcommit: 50e23e8d3b1148ae2d36dad3167936b4e52c8a23
ms.translationtype: MT
ms.contentlocale: ko-KR
ms.lasthandoff: 08/18/2017
---
# <a name="reliable-services-overview"></a><span data-ttu-id="4e16e-103">신뢰할 수 있는 서비스 개요</span><span class="sxs-lookup"><span data-stu-id="4e16e-103">Reliable Services overview</span></span>
<span data-ttu-id="4e16e-104">Azure 서비스 패브릭은 상태 비저장 및 상태 저장 신뢰할 수 있는 서비스의 작성과 관리를 단순화합니다.</span><span class="sxs-lookup"><span data-stu-id="4e16e-104">Azure Service Fabric simplifies writing and managing stateless and stateful Reliable Services.</span></span> <span data-ttu-id="4e16e-105">이 항목은 다음에 대해 설명합니다.</span><span class="sxs-lookup"><span data-stu-id="4e16e-105">This topic covers:</span></span>

* <span data-ttu-id="4e16e-106">상태 비저장 및 상태 저장 서비스를 위한 신뢰할 수 있는 서비스 프로그래밍 모델.</span><span class="sxs-lookup"><span data-stu-id="4e16e-106">The Reliable Services programming model for stateless and stateful services.</span></span>
* <span data-ttu-id="4e16e-107">신뢰할 수 있는 서비스를 작성할 때 선택해야 하는 옵션.</span><span class="sxs-lookup"><span data-stu-id="4e16e-107">The choices you have to make when writing a Reliable Service.</span></span>
* <span data-ttu-id="4e16e-108">신뢰할 수 있는 서비스를 사용할 때의 일부 시나리오 및 예와 신뢰할 수 있는 서비스를 작성하는 방법.</span><span class="sxs-lookup"><span data-stu-id="4e16e-108">Some scenarios and examples of when to use Reliable Services and how they are written.</span></span>

<span data-ttu-id="4e16e-109">신뢰할 수 있는 서비스는 서비스 패브릭에서 사용할 수 있는 프로그래밍 모델 중 하나입니다.</span><span class="sxs-lookup"><span data-stu-id="4e16e-109">Reliable Services is one of the programming models available on Service Fabric.</span></span> <span data-ttu-id="4e16e-110">다른 하나는 Reliable Actor 프로그래밍 모델로서 Reliable Services 모델을 기반으로 가상 행위자 프로그래밍 모델을 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="4e16e-110">The other is the Reliable Actor programming model, which provides a virtual Actor programming model on top of the Reliable Services model.</span></span> <span data-ttu-id="4e16e-111">신뢰할 수 있는 행위자 프로그래밍 모델에 대한 자세한 내용은 [서비스 패브릭 신뢰할 수 있는 행위자 소개](service-fabric-reliable-actors-introduction.md)를 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="4e16e-111">For more information on the Reliable Actors programming model, see [Introduction to Service Fabric Reliable Actors](service-fabric-reliable-actors-introduction.md).</span></span>

<span data-ttu-id="4e16e-112">서비스 패브릭은 [서비스 패브릭 응용 프로그램 관리](service-fabric-deploy-remove-applications.md)를 통해 프로비저닝 및 배포에서 업그레이드 및 삭제까지 서비스의 수명을 관리합니다.</span><span class="sxs-lookup"><span data-stu-id="4e16e-112">Service Fabric manages the lifetime of services, from provisioning and deployment through upgrade and deletion, via [Service Fabric application management](service-fabric-deploy-remove-applications.md).</span></span>

## <a name="what-are-reliable-services"></a><span data-ttu-id="4e16e-113">신뢰할 수 있는 서비스는 무엇입니까?</span><span class="sxs-lookup"><span data-stu-id="4e16e-113">What are Reliable Services?</span></span>
<span data-ttu-id="4e16e-114">Reliable Services는 단순하고 강력한 최고 수준의 프로그래밍 모델을 제공하여 응용 프로그램에 중요한 내용을 나타낼 수 있도록 합니다.</span><span class="sxs-lookup"><span data-stu-id="4e16e-114">Reliable Services gives you a simple, powerful, top-level programming model to help you express what is important to your application.</span></span> <span data-ttu-id="4e16e-115">신뢰할 수 있는 서비스 프로그래밍 모델은 다음을 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="4e16e-115">With the Reliable Services programming model, you get:</span></span>

* <span data-ttu-id="4e16e-116">Service Fabric 프로그래밍 API의 나머지 부분에 액세스합니다.</span><span class="sxs-lookup"><span data-stu-id="4e16e-116">Access to the rest of the Service Fabric programming APIs.</span></span> <span data-ttu-id="4e16e-117">[게스트 실행 파일](service-fabric-deploy-existing-app.md)로 모델링된 Service Fabric 서비스와는 달리 Reliable Services는 Service Fabric API의 나머지 부분을 직접 사용하게 됩니다.</span><span class="sxs-lookup"><span data-stu-id="4e16e-117">Unlike Service Fabric Services modeled as [Guest Executables](service-fabric-deploy-existing-app.md), Reliable Services get to use the rest of the Service Fabric APIs directly.</span></span> <span data-ttu-id="4e16e-118">그러면 서비스에서 다음을 수행할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="4e16e-118">This allows services to:</span></span>
  * <span data-ttu-id="4e16e-119">시스템 쿼리</span><span class="sxs-lookup"><span data-stu-id="4e16e-119">query the system</span></span>
  * <span data-ttu-id="4e16e-120">클러스터의 엔터티에 대한 상태 보고</span><span class="sxs-lookup"><span data-stu-id="4e16e-120">report health about entities in the cluster</span></span>
  * <span data-ttu-id="4e16e-121">구성 및 코드 변경 내용에 대한 알림 수신</span><span class="sxs-lookup"><span data-stu-id="4e16e-121">receive notifications about configuration and code changes</span></span>
  * <span data-ttu-id="4e16e-122">다른 서비스 찾기 및 통신</span><span class="sxs-lookup"><span data-stu-id="4e16e-122">find and communicate with other services,</span></span>
  * <span data-ttu-id="4e16e-123">(선택 사항)[신뢰할 수 있는 컬렉션](service-fabric-reliable-services-reliable-collections.md) 사용</span><span class="sxs-lookup"><span data-stu-id="4e16e-123">(optionally) use the [Reliable Collections](service-fabric-reliable-services-reliable-collections.md)</span></span>
  * <span data-ttu-id="4e16e-124">...및 다른 많은 기능에 액세스 권한 부여, 모두 여러 프로그래밍 언어에서 최고 수준의 프로그래밍 모델에서 비롯됨</span><span class="sxs-lookup"><span data-stu-id="4e16e-124">...and giving them access to many other capabilities, all from a first class programming model in several programming languages.</span></span>
* <span data-ttu-id="4e16e-125">기존에 사용하던 프로그래밍 모델과 비슷한 사용자 고유의 코드를 실행하기 위한 간단한 모델.</span><span class="sxs-lookup"><span data-stu-id="4e16e-125">A simple model for running your own code that looks like programming models you are used to.</span></span> <span data-ttu-id="4e16e-126">사용자의 코드에는 잘 정의된 진입점과 쉽게 관리되는 수명 주기가 있습니다.</span><span class="sxs-lookup"><span data-stu-id="4e16e-126">Your code has a well-defined entry point and easily managed lifecycle.</span></span>
* <span data-ttu-id="4e16e-127">플러그형 통신 모델.</span><span class="sxs-lookup"><span data-stu-id="4e16e-127">A pluggable communication model.</span></span> <span data-ttu-id="4e16e-128">[Web API](service-fabric-reliable-services-communication-webapi.md), WebSockets, 사용자 지정 TCP 프로토콜 또는 다른 프로그램과 함께 HTTP와 같은 원하는 전송 프로토콜을 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="4e16e-128">Use the transport of your choice, such as HTTP with [Web API](service-fabric-reliable-services-communication-webapi.md), WebSockets, custom TCP protocols, or anything else.</span></span> <span data-ttu-id="4e16e-129">신뢰할 수 있는 서비스는 훌륭한 기본 옵션을 제공하거나 직접 만들 수 있게 지원합니다.</span><span class="sxs-lookup"><span data-stu-id="4e16e-129">Reliable Services provide some great out-of-the-box options you can use, or you can provide your own.</span></span>
* <span data-ttu-id="4e16e-130">상태 저장 서비스의 경우 Reliable Services 프로그래밍 모델을 통해 [신뢰할 수 있는 컬렉션](service-fabric-reliable-services-reliable-collections.md)을 사용하여 일관되고 안정적으로 서비스 내에 상태를 바로 저장할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="4e16e-130">For stateful services, the Reliable Services programming model allows you to consistently and reliably store your state right inside your service by using [Reliable Collections](service-fabric-reliable-services-reliable-collections.md).</span></span> <span data-ttu-id="4e16e-131">신뢰할 수 있는 컬렉션은 C# 컬렉션을 사용해본 적이 있는 사람에게 친숙한 고가용성인 신뢰할 수 있는 컬렉션 클래스의 간단한 집합입니다.</span><span class="sxs-lookup"><span data-stu-id="4e16e-131">Reliable Collections are a simple set of highly available and reliable collection classes that will be familiar to anyone who has used C# collections.</span></span> <span data-ttu-id="4e16e-132">일반적으로 서비스는 신뢰할 수 있는 상태 관리를 위한 외부 시스템이 필요합니다.</span><span class="sxs-lookup"><span data-stu-id="4e16e-132">Traditionally, services needed external systems for Reliable state management.</span></span> <span data-ttu-id="4e16e-133">신뢰할 수 있는 컬렉션을 사용하면 고가용성 외부 저장소에 기대하게 되는 것과 동일한 고가용성 및 안정성으로 컴퓨터 옆에 상태를 저장할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="4e16e-133">With Reliable Collections, you can store your state next to your compute with the same high availability and reliability you've come to expect from highly available external stores.</span></span> <span data-ttu-id="4e16e-134">작동하는 데 필요한 계산 및 상태를 공동 배치하기 때문에 이 모델도 대기 시간을 개선합니다.</span><span class="sxs-lookup"><span data-stu-id="4e16e-134">This model also improves latency because you are co-locating the compute and state it needs to function.</span></span>

<span data-ttu-id="4e16e-135">Reliable Services의 개요는 다음 Microsoft Virtual Academy 비디오를 시청하세요. <center>
<a target="_blank" href="https://mva.microsoft.com/en-US/training-courses/building-microservices-applications-on-azure-service-fabric-16747?l=HhD9566yC_4106218965">
<img src="./media/service-fabric-reliable-services-introduction/ReliableServicesVid.png" WIDTH="360" HEIGHT="244" />
</a>
</center></span><span class="sxs-lookup"><span data-stu-id="4e16e-135">Watch this Microsoft Virtual Academy video for an overview of Reliable services: <center>
<a target="_blank" href="https://mva.microsoft.com/en-US/training-courses/building-microservices-applications-on-azure-service-fabric-16747?l=HhD9566yC_4106218965">
<img src="./media/service-fabric-reliable-services-introduction/ReliableServicesVid.png" WIDTH="360" HEIGHT="244" />
</a>
</center></span></span>

## <a name="what-makes-reliable-services-different"></a><span data-ttu-id="4e16e-136">신뢰할 수 있는 서비스가 다른 서비스와 다른 점은 무엇입니까?</span><span class="sxs-lookup"><span data-stu-id="4e16e-136">What makes Reliable Services different?</span></span>
<span data-ttu-id="4e16e-137">서비스 패브릭의 신뢰할 수 있는 서비스는 이전에 작성하던 서비스와 다릅니다.</span><span class="sxs-lookup"><span data-stu-id="4e16e-137">Reliable Services in Service Fabric are different from services you may have written before.</span></span> <span data-ttu-id="4e16e-138">서비스 패브릭은 안정성, 가용성, 일관성 및 확장성을 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="4e16e-138">Service Fabric provides reliability, availability, consistency, and scalability.</span></span>

* <span data-ttu-id="4e16e-139">**안정성** - 사용자 컴퓨터가 실패하거나 네트워크 문제가 발생한 안정적이지 않은 환경 또는 서비스 자체가 오류 및 작동 중단이나 실패가 발생하는 경우에도 서비스가 작동합니다.</span><span class="sxs-lookup"><span data-stu-id="4e16e-139">**Reliability** - Your service stays up even in unreliable environments where your machines fail or hit network issues, or in cases where the services themselves encounter errors and crash or fail.</span></span> <span data-ttu-id="4e16e-140">상태 저장 서비스의 상태는 네트워크 또는 다른 오류가 있는 경우에도 유지됩니다.</span><span class="sxs-lookup"><span data-stu-id="4e16e-140">For stateful services, your state is preserved even in the presence of network or other failures.</span></span>
* <span data-ttu-id="4e16e-141">**가용성** - 연결 가능하고 응답성이 뛰어난 서비스입니다.</span><span class="sxs-lookup"><span data-stu-id="4e16e-141">**Availability** - Your service is reachable and responsive.</span></span> <span data-ttu-id="4e16e-142">Service Fabric은 실행 중인 복사본 수를 유지 관리합니다.</span><span class="sxs-lookup"><span data-stu-id="4e16e-142">Service Fabric maintains your desired number of running copies.</span></span>
* <span data-ttu-id="4e16e-143">**확장성** – 서비스가 특정 하드웨어에서 분리되고, 하드웨어 또는 다른 리소스의 추가 또는 제거를 통해 필요에 따라 확장 또는 축소될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="4e16e-143">**Scalability** - Services are decoupled from specific hardware, and they can grow or shrink as necessary through the addition or removal of hardware or other resources.</span></span> <span data-ttu-id="4e16e-144">서비스가 부분 오류의 크기를 조정하고 다룰 수 있도록 손쉽게 분할됩니다(특히 상태 저장 상태에서).</span><span class="sxs-lookup"><span data-stu-id="4e16e-144">Services are easily partitioned (especially in the stateful case) to ensure that the service can scale and handle partial failures.</span></span> <span data-ttu-id="4e16e-145">코드를 통해 동적으로 서비스를 만들고 삭제할 수 있으며 고객의 요청에 대한 응답 면에서 필요한 만큼 많은 인스턴스를 작동시킬 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="4e16e-145">Services can be created and deleted dynamically via code, enabling more instances to be spun up as necessary, say in response to customer requests.</span></span> <span data-ttu-id="4e16e-146">마지막으로 Service Fabric은 간단한 서비스를 권장합니다.</span><span class="sxs-lookup"><span data-stu-id="4e16e-146">Finally, Service Fabric encourages services to be lightweight.</span></span> <span data-ttu-id="4e16e-147">Service Fabric을 사용하면 전체 OS 인스턴스 또는 프로세스를 서비스의 단일 인스턴스로 요구하거나 지정하기보다 단일 프로세스 내에 수천 개의 서비스가 프로비저닝될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="4e16e-147">Service Fabric allows thousands of services to be provisioned within a single process, rather than requiring or dedicating entire OS instances or processes to a single instance of a service.</span></span>
* <span data-ttu-id="4e16e-148">**일관성** - 이 서비스에 저장된 모든 정보의 일관성을 보장할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="4e16e-148">**Consistency** - Any information stored in this service can be guaranteed to be consistent.</span></span> <span data-ttu-id="4e16e-149">서비스 내에서 여러 신뢰할 수 있는 컬렉션 간에도 적용됩니다.</span><span class="sxs-lookup"><span data-stu-id="4e16e-149">This is true even across multiple reliable collections within a service.</span></span> <span data-ttu-id="4e16e-150">서비스 내의 컬렉션을 트랜잭션 원자 방식으로 변경할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="4e16e-150">Changes across collections within a service can be made in a transactionally atomic manner.</span></span>

## <a name="service-lifecycle"></a><span data-ttu-id="4e16e-151">서비스 수명 주기</span><span class="sxs-lookup"><span data-stu-id="4e16e-151">Service lifecycle</span></span>
<span data-ttu-id="4e16e-152">서비스가 상태 저장 서비스이든, 상태 비저장 서비스이든, 신뢰할 수 있는 서비스는 신속하게 코드를 연결하고 시작할 수 있는 간단한 수명 주기를 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="4e16e-152">Whether your service is stateful or stateless, Reliable Services provide a simple lifecycle that lets you quickly plug in your code and get started.</span></span>  <span data-ttu-id="4e16e-153">서비스를 시작 및 실행하기 위해 구현해야 하는 메서드가 실제로 한두 개뿐입니다.</span><span class="sxs-lookup"><span data-stu-id="4e16e-153">There are just one or two methods that you need to implement to get your service up and running.</span></span>

* <span data-ttu-id="4e16e-154">**CreateServiceReplicaListeners/CreateServiceInstanceListeners** - 이 메서드는 서비스에서 사용할 통신 스택을 정의합니다.</span><span class="sxs-lookup"><span data-stu-id="4e16e-154">**CreateServiceReplicaListeners/CreateServiceInstanceListeners** - This method is where the service defines the communication stack(s) that it wants to use.</span></span> <span data-ttu-id="4e16e-155">[Web API](service-fabric-reliable-services-communication-webapi.md)와 같은 통신 스택은 수신 끝점 또는 서비스(클라이언트가 서비스에 도달하는 방법)에 대한 끝점을 정의합니다.</span><span class="sxs-lookup"><span data-stu-id="4e16e-155">The communication stack, such as [Web API](service-fabric-reliable-services-communication-webapi.md), is what defines the listening endpoint or endpoints for the service (how clients reach the service).</span></span> <span data-ttu-id="4e16e-156">표시된 메시지가 서비스 코드의 나머지 부분과 상호 작용하는 방법도 정의합니다.</span><span class="sxs-lookup"><span data-stu-id="4e16e-156">It also defines how the messages that appear interact with the rest of the service code.</span></span>
* <span data-ttu-id="4e16e-157">**RunAsync** - 이 메서드는 서비스가 해당 비즈니스 논리를 실행하는 위치 및 서비스의 수명 동안 실행해야 하는 모든 백그라운드 작업을 시작하는 위치입니다.</span><span class="sxs-lookup"><span data-stu-id="4e16e-157">**RunAsync** - This method is where your service runs its business logic, and where it would kick off any background tasks that should run for the lifetime of the service.</span></span> <span data-ttu-id="4e16e-158">제공되는 취소 토큰은 해당 작업이 중지되어야 하는 경우에 대한 신호입니다.</span><span class="sxs-lookup"><span data-stu-id="4e16e-158">The cancellation token that is provided is a signal for when that work should stop.</span></span> <span data-ttu-id="4e16e-159">예를 들어 서비스가 신뢰할 수 있는 큐에서 메시지를 빼내 처리해야 하는 경우 이는 해당 작업이 이뤄지는 위치입니다.</span><span class="sxs-lookup"><span data-stu-id="4e16e-159">For example, if the service needs to pull messages out of a Reliable Queue and process them, this is where that work happens.</span></span>

<span data-ttu-id="4e16e-160">처음으로 Reliable Services를 알아보는 경우 계속 읽어주세요.</span><span class="sxs-lookup"><span data-stu-id="4e16e-160">If you're learning about reliable services for the first time, read on!</span></span> <span data-ttu-id="4e16e-161">Reliable Services의 수명 주기에 대한 자세한 안내를 찾는 경우 [이 문서](service-fabric-reliable-services-lifecycle.md)로 건너뛸 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="4e16e-161">If you're looking for a detailed walkthrough of the lifecycle of reliable services, you can head over to [this article](service-fabric-reliable-services-lifecycle.md).</span></span>

## <a name="example-services"></a><span data-ttu-id="4e16e-162">예제 서비스</span><span class="sxs-lookup"><span data-stu-id="4e16e-162">Example services</span></span>
<span data-ttu-id="4e16e-163">이 프로그래밍 모델을 알았으니 두 가지 서비스를 간단히 살펴보고 어떻게 연동되는지 알아보겠습니다.</span><span class="sxs-lookup"><span data-stu-id="4e16e-163">Knowing this programming model, let's take a quick look at two different services to see how these pieces fit together.</span></span>

### <a name="stateless-reliable-services"></a><span data-ttu-id="4e16e-164">상태 비저장 신뢰할 수 있는 서비스</span><span class="sxs-lookup"><span data-stu-id="4e16e-164">Stateless Reliable Services</span></span>
<span data-ttu-id="4e16e-165">상태 비저장 서비스는 호출의 서비스 내에서 유지 관리되는 상태가 없는 위치에 있습니다.</span><span class="sxs-lookup"><span data-stu-id="4e16e-165">A stateless service is one where there is no state maintained within the service across calls.</span></span> <span data-ttu-id="4e16e-166">표시된 상태는 완전히 삭제 가능하며 동기화, 복제, 지속성 또는 고가용성이 필요하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="4e16e-166">Any state that is present is entirely disposable and doesn't require synchronization, replication, persistence, or high availability.</span></span>

<span data-ttu-id="4e16e-167">예를 들어 메모리가 없고 모든 용어 및 수행할 작업을 한 번에 수신하는 계산기를 가정해 보겠습니다.</span><span class="sxs-lookup"><span data-stu-id="4e16e-167">For example, consider a calculator that has no memory and receives all terms and operations to perform at once.</span></span>

<span data-ttu-id="4e16e-168">이 경우 서비스가 수행해야 하는 백그라운드 작업 처리가 없으므로 서비스의 `RunAsync()`(C#) 또는 `runAsync()`(Java)는 비어 있을 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="4e16e-168">In this case, the `RunAsync()` (C#) or `runAsync()` (Java) of the service can be empty, since there is no background task-processing that the service needs to do.</span></span> <span data-ttu-id="4e16e-169">계산기 서비스가 생성되면 일부 포트에서 수신 대기 끝점을 여는 `ICommunicationListener`(C#) 또는 `CommunicationListener`(Java)(예: [Web API](service-fabric-reliable-services-communication-webapi.md))를 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="4e16e-169">When the calculator service is created, it returns an `ICommunicationListener` (C#) or `CommunicationListener` (Java) (for example [Web API](service-fabric-reliable-services-communication-webapi.md)) that opens up a listening endpoint on some port.</span></span> <span data-ttu-id="4e16e-170">이 수신 대기 끝점은 계산기의 공용 API를 정의하는 다른 계산 메서드(예: "Add(n1, n2)")에 연결됩니다.</span><span class="sxs-lookup"><span data-stu-id="4e16e-170">This listening endpoint hooks up to the different calculation methods (example: "Add(n1, n2)") that define the calculator's public API.</span></span>

<span data-ttu-id="4e16e-171">클라이언트에서 호출이 수행되면 적절한 메서드가 호출되고 계산기 서비스가 제공된 데이터에 대한 작업을 수행하고 결과를 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="4e16e-171">When a call is made from a client, the appropriate method is invoked, and the calculator service performs the operations on the data provided and returns the result.</span></span> <span data-ttu-id="4e16e-172">상태를 저장하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="4e16e-172">It doesn't store any state.</span></span>

<span data-ttu-id="4e16e-173">모든 내부 상태를 저장하지 않으므로 이 계산기 예제는 간단해집니다.</span><span class="sxs-lookup"><span data-stu-id="4e16e-173">Not storing any internal state makes this example calculator simple.</span></span> <span data-ttu-id="4e16e-174">하지만 대부분의 서비스는 상태 비저장이 아닙니다.</span><span class="sxs-lookup"><span data-stu-id="4e16e-174">But most services aren't truly stateless.</span></span> <span data-ttu-id="4e16e-175">대신 다른 저장소에 상태를 외장화합니다.</span><span class="sxs-lookup"><span data-stu-id="4e16e-175">Instead, they externalize their state to some other store.</span></span> <span data-ttu-id="4e16e-176">(예를 들어 세션 상태를 백업 저장소 또는 캐시에 유지하는 모든 웹앱은 상태 비저장이 아닙니다.)</span><span class="sxs-lookup"><span data-stu-id="4e16e-176">(For example, any web app that relies on keeping session state in a backing store or cache is not stateless.)</span></span>

<span data-ttu-id="4e16e-177">서비스 패브릭에서 상태 비저장 서비스가 사용되는 방법의 일반적인 예로 웹 응용 프로그램에 대한 공용 API를 노출하는 프런트 엔드가 있습니다.</span><span class="sxs-lookup"><span data-stu-id="4e16e-177">A common example of how stateless services are used in Service Fabric is as a front-end that exposes the public-facing API for a web application.</span></span> <span data-ttu-id="4e16e-178">프런트 엔드 서비스는 상태 저장 서비스에 사용자의 요청을 완료하라고 말합니다.</span><span class="sxs-lookup"><span data-stu-id="4e16e-178">The front-end service then talks to stateful services to complete a user request.</span></span> <span data-ttu-id="4e16e-179">이 경우 상태 비저장 서비스가 수신 대기 중인 알려진 포트(예: 80)에 클라이언트의 호출이 전송됩니다.</span><span class="sxs-lookup"><span data-stu-id="4e16e-179">In this case, calls from clients are directed to a known port, such as 80, where the stateless service is listening.</span></span> <span data-ttu-id="4e16e-180">이 상태 비저장 서비스는 호출을 받고 해당 호출이 신뢰할 수 있는 대상에서 왔는지 및 어떤 서비스를 대상으로 하는지 확인합니다.</span><span class="sxs-lookup"><span data-stu-id="4e16e-180">This stateless service receives the call and determines whether the call is from a trusted party and which service it's destined for.</span></span>  <span data-ttu-id="4e16e-181">그런 다음 상태 비저장 서비스는 상태 저장 서비스의 올바른 파티션으로 호출을 전달하고 응답을 대기합니다.</span><span class="sxs-lookup"><span data-stu-id="4e16e-181">Then, the stateless service forwards the call to the correct partition of the stateful service and waits for a response.</span></span> <span data-ttu-id="4e16e-182">상태 비저장 서비스가 응답을 받으면 원래 클라이언트에 응답합니다.</span><span class="sxs-lookup"><span data-stu-id="4e16e-182">When the stateless service receives a response, it replies to the original client.</span></span> <span data-ttu-id="4e16e-183">이러한 서비스의 예제는 [C#](https://github.com/Azure-Samples/service-fabric-dotnet-getting-started) / [Java](https://github.com/Azure-Samples/service-fabric-java-getting-started/tree/master/Actors/VisualObjectActor/VisualObjectWebService) 샘플에 있습니다.</span><span class="sxs-lookup"><span data-stu-id="4e16e-183">An example of such a service is in our samples [C#](https://github.com/Azure-Samples/service-fabric-dotnet-getting-started) / [Java](https://github.com/Azure-Samples/service-fabric-java-getting-started/tree/master/Actors/VisualObjectActor/VisualObjectWebService).</span></span> <span data-ttu-id="4e16e-184">샘플에 있는 이 패턴의 한 가지 예제이며 다른 샘플에는 다른 사용자도 있습니다.</span><span class="sxs-lookup"><span data-stu-id="4e16e-184">This is only one example of this pattern in the samples, there are others in other samples as well.</span></span>

### <a name="stateful-reliable-services"></a><span data-ttu-id="4e16e-185">상태 저장 신뢰할 수 있는 서비스</span><span class="sxs-lookup"><span data-stu-id="4e16e-185">Stateful Reliable Services</span></span>
<span data-ttu-id="4e16e-186">상태 저장 서비스는 상태의 일부분이 일관적으로 유지되고 순서대로 있어야 서비스가 작동할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="4e16e-186">A stateful service is one that must have some portion of state kept consistent and present in order for the service to function.</span></span> <span data-ttu-id="4e16e-187">수신하는 업데이트에 따라 일부 값의 이동 평균을 지속적으로 계산하는 서비스를 고려할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="4e16e-187">Consider a service that constantly computes a rolling average of some value based on updates it receives.</span></span> <span data-ttu-id="4e16e-188">이 서비스를 수행하려면 처리해야 하는 수신 요청의 현재 집합과 현재 평균이 있어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="4e16e-188">To do this, it must have the current set of incoming requests it needs to process and the current average.</span></span> <span data-ttu-id="4e16e-189">정보를 검색, 처리하고 외부 저장소(예: Azure Blob 또는 현재 테이블 저장소)에 저장하는 모든 서비스는 상태 저장입니다.</span><span class="sxs-lookup"><span data-stu-id="4e16e-189">Any service that retrieves, processes, and stores information in an external store (such as an Azure blob or table store today) is stateful.</span></span> <span data-ttu-id="4e16e-190">외부 상태 저장소에 상태를 보관합니다.</span><span class="sxs-lookup"><span data-stu-id="4e16e-190">It just keeps its state in the external state store.</span></span>

<span data-ttu-id="4e16e-191">오늘날 대부분의 서비스는 외부에 상태를 저장합니다. 외부 저장소는 해당 상태에 대한 안정성, 가용성, 확장성 및 일관성을 제공하기 때문입니다.</span><span class="sxs-lookup"><span data-stu-id="4e16e-191">Most services today store their state externally, since the external store is what provides reliability, availability, scalability, and consistency for that state.</span></span> <span data-ttu-id="4e16e-192">Service Fabric에서 서비스는 해당 상태를 외부적으로 저장할 필요가 없습니다.</span><span class="sxs-lookup"><span data-stu-id="4e16e-192">In Service Fabric, services aren't required to store their state externally.</span></span> <span data-ttu-id="4e16e-193">Service Fabric은 서비스 코드와 서비스 상태 모두에 대한 이러한 요구 사항을 처리합니다.</span><span class="sxs-lookup"><span data-stu-id="4e16e-193">Service Fabric takes care of these requirements for both the service code and the service state.</span></span>

> [!NOTE]
> <span data-ttu-id="4e16e-194">아직 Linux에서는 상태 저장 Reliable Services가 지원되지 않습니다(C# 또는 Java의 경우).</span><span class="sxs-lookup"><span data-stu-id="4e16e-194">Support for Stateful Reliable Services is not available on Linux yet (for C# or Java).</span></span>
>

<span data-ttu-id="4e16e-195">이미지를 처리하는 서비스를 작성하려는 경우를 가정하겠습니다.</span><span class="sxs-lookup"><span data-stu-id="4e16e-195">Let's say we want to write a service that processes images.</span></span> <span data-ttu-id="4e16e-196">이를 위해 서비스는 이미지 및 일련의 변환을 사용하여 해당 이미지에서 수행합니다.</span><span class="sxs-lookup"><span data-stu-id="4e16e-196">To do this, the service takes in an image and the series of conversions to perform on that image.</span></span> <span data-ttu-id="4e16e-197">이 서비스는 `ConvertImage(Image i, IList<Conversion> conversions)`와 같은 API를 노출하는 통신 수신기(WebAPI라고 가정함)를 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="4e16e-197">This service returns a communication listener (let's suppose it's a WebAPI) that exposes an API like `ConvertImage(Image i, IList<Conversion> conversions)`.</span></span> <span data-ttu-id="4e16e-198">요청을 받으면 서비스는 `IReliableQueue`에 저장하고 요청을 추적할 수 있도록 클라이언트에 일부 ID를 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="4e16e-198">When it receives a request, the service stores it in a `IReliableQueue`, and returns some id to the client so it can track the request.</span></span>

<span data-ttu-id="4e16e-199">이 서비스에서는 `RunAsync()`가 더 복잡해질 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="4e16e-199">In this service, `RunAsync()` could be more complex.</span></span> <span data-ttu-id="4e16e-200">서비스에는 `IReliableQueue`에서 요청을 가져오는 해당 `RunAsync()` 내에 루프가 있어서 요청된 변환을 수행합니다.</span><span class="sxs-lookup"><span data-stu-id="4e16e-200">The service has a loop inside its `RunAsync()` that pulls requests out of `IReliableQueue` and performs the conversions requested.</span></span> <span data-ttu-id="4e16e-201">결과는 `IReliableDictionary`에 저장되므로 클라이언트가 다시 돌아오면 변환된 이미지를 가져올 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="4e16e-201">The results get stored in an `IReliableDictionary` so that when the client comes back they can get their converted images.</span></span> <span data-ttu-id="4e16e-202">어떤 오류가 발생해도 이미지가 손실되지 않도록 하기 위해 이 신뢰할 수 있는 서비스는 큐에서 요청을 가져오고, 변환을 수행하고, 단일 트랜잭션에 모든 결과를 저장합니다.</span><span class="sxs-lookup"><span data-stu-id="4e16e-202">To ensure that even if something fails the image isn't lost, this Reliable Service would pull out of the queue, perform the conversions, and store the result all in a single transaction.</span></span> <span data-ttu-id="4e16e-203">이 경우 변환이 완료되면 메시지는 큐 및 결과 사전에 저장된 결과에서만 제거됩니다.</span><span class="sxs-lookup"><span data-stu-id="4e16e-203">In this case, the message is removed from the queue and the results are stored in the result dictionary only when the conversions are complete.</span></span> <span data-ttu-id="4e16e-204">또는 서비스가 큐에서 이미지를 제거하고 즉시 원격 저장소에 저장할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="4e16e-204">Alternatively, the service could pull the image out of the queue and immediately store it in a remote store.</span></span> <span data-ttu-id="4e16e-205">그러면 서비스에서 관리해야 하는 상태의 양을 감소시키지만 서비스가 필요한 메타데이터를 유지하여 원격 저장소를 관리해야 하기 때문에 복잡성을 증가시킵니다.</span><span class="sxs-lookup"><span data-stu-id="4e16e-205">This reduces the amount of state the service has to manage, but increases complexity since the service has to keep the necessary metadata to manage the remote store.</span></span> <span data-ttu-id="4e16e-206">두 가지 방법 모두 중간에 실패했다면 처리되기를 대기하는 큐에 요청이 남게 됩니다.</span><span class="sxs-lookup"><span data-stu-id="4e16e-206">With either approach, if something failed in the middle the request remains in the queue waiting to be processed.</span></span>

<span data-ttu-id="4e16e-207">이 서비스에 대해 알아두어야 할 한 가지는 일반 .NET 서비스처럼 보인다는 것입니다.</span><span class="sxs-lookup"><span data-stu-id="4e16e-207">One thing to note about this service is that it sounds like a normal .NET service!</span></span> <span data-ttu-id="4e16e-208">유일한 차이점은 사용 중인 데이터 구조(`IReliableQueue` 및 `IReliableDictionary`)를 Service Fabric에서 제공하므로 안정성, 가용성 및 일관성이 매우 높다는 점입니다.</span><span class="sxs-lookup"><span data-stu-id="4e16e-208">The only difference is that the data structures being used (`IReliableQueue` and `IReliableDictionary`) are provided by Service Fabric, and are highly reliable, available, and consistent.</span></span>

## <a name="when-to-use-reliable-services-apis"></a><span data-ttu-id="4e16e-209">신뢰할 수 있는 서비스 API를 사용해야 하는 경우</span><span class="sxs-lookup"><span data-stu-id="4e16e-209">When to use Reliable Services APIs</span></span>
<span data-ttu-id="4e16e-210">응용 프로그램 서비스 요구 사항이 다음에 해당할 경우 신뢰할 수 있는 서비스 API를 고려해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="4e16e-210">If any of the following characterize your application service needs, then you should consider Reliable Services APIs:</span></span>

* <span data-ttu-id="4e16e-211">서비스의 코드 및 필요에 따라 상태를 항상 사용 가능하고 신뢰할 수 있도록 만들려고 합니다.</span><span class="sxs-lookup"><span data-stu-id="4e16e-211">You want your service's code (and optionally state) to be highly available and reliable</span></span>
* <span data-ttu-id="4e16e-212">여러 상태 단위(예: 주문 및 주문 품목)에 걸쳐 트랜잭션 보장이 필요합니다.</span><span class="sxs-lookup"><span data-stu-id="4e16e-212">You need transactional guarantees across multiple units of state (for example, orders and order line items).</span></span>
* <span data-ttu-id="4e16e-213">응용 프로그램의 상태를 신뢰할 수 있는 사전 및 큐로 자연스럽게 모델링할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="4e16e-213">Your application’s state can be naturally modeled as Reliable Dictionaries and Queues.</span></span>
* <span data-ttu-id="4e16e-214">응용 프로그램 코드 또는 상태는 대기 시간이 낮은 읽기 및 쓰기에서 가용성이 높아야 합니다.</span><span class="sxs-lookup"><span data-stu-id="4e16e-214">Your applications code or state needs to be highly available with low latency reads and writes.</span></span>
* <span data-ttu-id="4e16e-215">응용 프로그램이 신뢰할 수 있는 하나 이상의 컬렉션에서 동시성 또는 트랜잭션 처리 작업의 세분성을 제어해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="4e16e-215">Your application needs to control the concurrency or granularity of transacted operations across one or more Reliable Collections.</span></span>
* <span data-ttu-id="4e16e-216">서비스에 대한 통신을 제어하고 분할 체계를 제어하고자 합니다.</span><span class="sxs-lookup"><span data-stu-id="4e16e-216">You want to manage the communications or control the partitioning scheme for your service.</span></span>
* <span data-ttu-id="4e16e-217">코드에 자유 스레드된 런타임 환경이 필요합니다.</span><span class="sxs-lookup"><span data-stu-id="4e16e-217">Your code needs a free-threaded runtime environment.</span></span>
* <span data-ttu-id="4e16e-218">응용 프로그램이 런타임 시 신뢰할 수 있는 사전이나 큐 또는 전체 서비스를 동적으로 만들거나 삭제해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="4e16e-218">Your application needs to dynamically create or destroy Reliable Dictionaries or Queues or whole Services at runtime.</span></span>
* <span data-ttu-id="4e16e-219">Service Fabric에서 서비스의 상태에 대해 제공하는 백업 및 복원 기능을 프로그래밍 방식으로 제어해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="4e16e-219">You need to programmatically control Service Fabric-provided backup and restore features for your service’s state.</span></span>
* <span data-ttu-id="4e16e-220">응용 프로그램에서 상태 단위에 대한 변경 기록을 유지 관리해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="4e16e-220">Your application needs to maintain change history for its units of state.</span></span>
* <span data-ttu-id="4e16e-221">사용자 지정 상태 제공자를 직접 개발하거나 타사를 통해 개발하고자 합니다.</span><span class="sxs-lookup"><span data-stu-id="4e16e-221">You want to develop or consume third-party-developed, custom state providers.</span></span>

## <a name="next-steps"></a><span data-ttu-id="4e16e-222">다음 단계</span><span class="sxs-lookup"><span data-stu-id="4e16e-222">Next steps</span></span>
* [<span data-ttu-id="4e16e-223">Reliable Services 빠른 시작</span><span class="sxs-lookup"><span data-stu-id="4e16e-223">Reliable Services quick start</span></span>](service-fabric-reliable-services-quick-start.md)
* [<span data-ttu-id="4e16e-224">신뢰할 수 있는 서비스 고급 사용법</span><span class="sxs-lookup"><span data-stu-id="4e16e-224">Reliable Services advanced usage</span></span>](service-fabric-reliable-services-advanced-usage.md)
* [<span data-ttu-id="4e16e-225">신뢰할 수 있는 행위자 프로그래밍 모델</span><span class="sxs-lookup"><span data-stu-id="4e16e-225">The Reliable Actors programming model</span></span>](service-fabric-reliable-actors-introduction.md)
