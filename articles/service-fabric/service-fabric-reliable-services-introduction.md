---
title: "hello 서비스 패브릭 신뢰할 수 있는 서비스 프로그래밍 모델의 aaaOverview | Microsoft Docs"
description: "서비스 패브릭의 신뢰할 수 있는 서비스 프로그래밍 모델에 대해 알아보고 사용자 고유의 서비스 작성을 시작합니다."
services: Service-Fabric
documentationcenter: .net
author: masnider
manager: timlt
editor: vturecek; mani-ramaswamy
ms.assetid: 0c88a533-73f8-4ae1-a939-67d17456ac06
ms.service: Service-Fabric
ms.devlang: dotnet
ms.topic: article
ms.tgt_pltfrm: NA
ms.workload: NA
ms.date: 8/9/2017
ms.author: masnider;
ms.openlocfilehash: 41d1826df902b1f1845c4702bf2567e6b9ca1f1f
ms.sourcegitcommit: 523283cc1b3c37c428e77850964dc1c33742c5f0
ms.translationtype: MT
ms.contentlocale: ko-KR
ms.lasthandoff: 10/06/2017
---
# <a name="reliable-services-overview"></a><span data-ttu-id="526ca-103">신뢰할 수 있는 서비스 개요</span><span class="sxs-lookup"><span data-stu-id="526ca-103">Reliable Services overview</span></span>
<span data-ttu-id="526ca-104">Azure 서비스 패브릭은 상태 비저장 및 상태 저장 신뢰할 수 있는 서비스의 작성과 관리를 단순화합니다.</span><span class="sxs-lookup"><span data-stu-id="526ca-104">Azure Service Fabric simplifies writing and managing stateless and stateful Reliable Services.</span></span> <span data-ttu-id="526ca-105">이 항목은 다음에 대해 설명합니다.</span><span class="sxs-lookup"><span data-stu-id="526ca-105">This topic covers:</span></span>

* <span data-ttu-id="526ca-106">hello 상태 비저장 및 상태 저장 서비스에 대 한 프로그래밍 모델을 신뢰할 수 있는 서비스입니다.</span><span class="sxs-lookup"><span data-stu-id="526ca-106">hello Reliable Services programming model for stateless and stateful services.</span></span>
* <span data-ttu-id="526ca-107">hello 선택할 수 있는 toomake 신뢰할 수 있는 서비스를 작성할 때는 합니다.</span><span class="sxs-lookup"><span data-stu-id="526ca-107">hello choices you have toomake when writing a Reliable Service.</span></span>
* <span data-ttu-id="526ca-108">일부 시나리오와는 경우의 예 toouse 안정성 서비스를 제공 하며 작성 방법입니다.</span><span class="sxs-lookup"><span data-stu-id="526ca-108">Some scenarios and examples of when toouse Reliable Services and how they are written.</span></span>

<span data-ttu-id="526ca-109">신뢰할 수 있는 서비스 패브릭 서비스에서 사용할 수 있는 모델을 프로그래밍 하는 hello 중 하나입니다.</span><span class="sxs-lookup"><span data-stu-id="526ca-109">Reliable Services is one of hello programming models available on Service Fabric.</span></span> <span data-ttu-id="526ca-110">다른 hello는 hello Reliable Actor 프로그래밍 모델을 hello 신뢰할 수 있는 서비스 모델 위에 가상 행위자 프로그래밍 모델을 제공 합니다.</span><span class="sxs-lookup"><span data-stu-id="526ca-110">hello other is hello Reliable Actor programming model, which provides a virtual Actor programming model on top of hello Reliable Services model.</span></span> <span data-ttu-id="526ca-111">Hello Reliable Actors 프로그래밍 모델에 대 한 자세한 내용은 참조 하십시오. [소개 tooService 패브릭 Reliable Actors](service-fabric-reliable-actors-introduction.md)합니다.</span><span class="sxs-lookup"><span data-stu-id="526ca-111">For more information on hello Reliable Actors programming model, see [Introduction tooService Fabric Reliable Actors](service-fabric-reliable-actors-introduction.md).</span></span>

<span data-ttu-id="526ca-112">서비스 패브릭을 통해 프로 비전 하 고 업그레이드 및 삭제를 통해 배포에서 서비스의 hello 수명을 관리 [서비스 패브릭 응용 프로그램 관리](service-fabric-deploy-remove-applications.md)합니다.</span><span class="sxs-lookup"><span data-stu-id="526ca-112">Service Fabric manages hello lifetime of services, from provisioning and deployment through upgrade and deletion, via [Service Fabric application management](service-fabric-deploy-remove-applications.md).</span></span>

## <a name="what-are-reliable-services"></a><span data-ttu-id="526ca-113">신뢰할 수 있는 서비스는 무엇입니까?</span><span class="sxs-lookup"><span data-stu-id="526ca-113">What are Reliable Services?</span></span>
<span data-ttu-id="526ca-114">신뢰할 수 있는 서비스는 단순 하 고 강력 하 고 중요 한 tooyour 응용 프로그램 이란 express 모델 toohelp 프로그래밍 최상위을 제공 합니다.</span><span class="sxs-lookup"><span data-stu-id="526ca-114">Reliable Services gives you a simple, powerful, top-level programming model toohelp you express what is important tooyour application.</span></span> <span data-ttu-id="526ca-115">Hello 신뢰할 수 있는 서비스 프로그래밍 모델에서 가져오기:</span><span class="sxs-lookup"><span data-stu-id="526ca-115">With hello Reliable Services programming model, you get:</span></span>

* <span data-ttu-id="526ca-116">액세스 toohello rest Api를 프로그래밍 하는 서비스 패브릭 hello 합니다.</span><span class="sxs-lookup"><span data-stu-id="526ca-116">Access toohello rest of hello Service Fabric programming APIs.</span></span> <span data-ttu-id="526ca-117">서비스 패브릭 서비스도 모델링와 달리 [게스트 실행 파일](service-fabric-deploy-existing-app.md), 신뢰할 수 있는 서비스의 서비스 패브릭 Api hello toouse hello rest를 직접 가져올 합니다.</span><span class="sxs-lookup"><span data-stu-id="526ca-117">Unlike Service Fabric Services modeled as [Guest Executables](service-fabric-deploy-existing-app.md), Reliable Services get toouse hello rest of hello Service Fabric APIs directly.</span></span> <span data-ttu-id="526ca-118">그러면 서비스에서 다음을 수행할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="526ca-118">This allows services to:</span></span>
  * <span data-ttu-id="526ca-119">쿼리 hello 시스템</span><span class="sxs-lookup"><span data-stu-id="526ca-119">query hello system</span></span>
  * <span data-ttu-id="526ca-120">hello 클러스터의 엔터티에 대 한 상태 보고</span><span class="sxs-lookup"><span data-stu-id="526ca-120">report health about entities in hello cluster</span></span>
  * <span data-ttu-id="526ca-121">구성 및 코드 변경 내용에 대한 알림 수신</span><span class="sxs-lookup"><span data-stu-id="526ca-121">receive notifications about configuration and code changes</span></span>
  * <span data-ttu-id="526ca-122">다른 서비스 찾기 및 통신</span><span class="sxs-lookup"><span data-stu-id="526ca-122">find and communicate with other services,</span></span>
  * <span data-ttu-id="526ca-123">(선택 사항) hello를 사용 하 여 [신뢰할 수 있는 컬렉션](service-fabric-reliable-services-reliable-collections.md)</span><span class="sxs-lookup"><span data-stu-id="526ca-123">(optionally) use hello [Reliable Collections](service-fabric-reliable-services-reliable-collections.md)</span></span>
  * <span data-ttu-id="526ca-124">... 및 쉽게 액세스 toomany 다른 기능, 여러 프로그래밍 언어의 최고 수준의 프로그래밍 모델에서 모두 합니다.</span><span class="sxs-lookup"><span data-stu-id="526ca-124">...and giving them access toomany other capabilities, all from a first class programming model in several programming languages.</span></span>
* <span data-ttu-id="526ca-125">기존에 사용하던 프로그래밍 모델과 비슷한 사용자 고유의 코드를 실행하기 위한 간단한 모델.</span><span class="sxs-lookup"><span data-stu-id="526ca-125">A simple model for running your own code that looks like programming models you are used to.</span></span> <span data-ttu-id="526ca-126">사용자의 코드에는 잘 정의된 진입점과 쉽게 관리되는 수명 주기가 있습니다.</span><span class="sxs-lookup"><span data-stu-id="526ca-126">Your code has a well-defined entry point and easily managed lifecycle.</span></span>
* <span data-ttu-id="526ca-127">플러그형 통신 모델.</span><span class="sxs-lookup"><span data-stu-id="526ca-127">A pluggable communication model.</span></span> <span data-ttu-id="526ca-128">HTTP와 같이 선택한 hello 전송을 사용 [웹 API](service-fabric-reliable-services-communication-webapi.md), WebSockets, 사용자 지정 TCP 프로토콜 또는 기타 항목입니다.</span><span class="sxs-lookup"><span data-stu-id="526ca-128">Use hello transport of your choice, such as HTTP with [Web API](service-fabric-reliable-services-communication-webapi.md), WebSockets, custom TCP protocols, or anything else.</span></span> <span data-ttu-id="526ca-129">신뢰할 수 있는 서비스는 훌륭한 기본 옵션을 제공하거나 직접 만들 수 있게 지원합니다.</span><span class="sxs-lookup"><span data-stu-id="526ca-129">Reliable Services provide some great out-of-the-box options you can use, or you can provide your own.</span></span>
* <span data-ttu-id="526ca-130">상태 저장 서비스에 대 한 hello 신뢰할 수 있는 서비스 모델 프로그래밍 tooconsistently 있으며 안전 하 게 사용 하 여 서비스 오른쪽 내부 상태를 저장할 [신뢰할 수 있는 컬렉션](service-fabric-reliable-services-reliable-collections.md)합니다.</span><span class="sxs-lookup"><span data-stu-id="526ca-130">For stateful services, hello Reliable Services programming model allows you tooconsistently and reliably store your state right inside your service by using [Reliable Collections](service-fabric-reliable-services-reliable-collections.md).</span></span> <span data-ttu-id="526ca-131">신뢰할 수 있는 컬렉션은 간단한 집합이 컬렉션 C# 사용 경험이 친숙 한 tooanyone 수 있는 항상 사용 가능 하 고 신뢰할 수 있는 컬렉션 클래스입니다.</span><span class="sxs-lookup"><span data-stu-id="526ca-131">Reliable Collections are a simple set of highly available and reliable collection classes that will be familiar tooanyone who has used C# collections.</span></span> <span data-ttu-id="526ca-132">일반적으로 서비스는 신뢰할 수 있는 상태 관리를 위한 외부 시스템이 필요합니다.</span><span class="sxs-lookup"><span data-stu-id="526ca-132">Traditionally, services needed external systems for Reliable state management.</span></span> <span data-ttu-id="526ca-133">신뢰할 수 있는 컬렉션을 사용 하면 상태 다음 tooyour 계산 hello로 저장할 수 있습니다 같은 높은 가용성 및 안정성 돌아와 tooexpect 항상 사용 가능한 외부 저장소에서 저장 했습니다.</span><span class="sxs-lookup"><span data-stu-id="526ca-133">With Reliable Collections, you can store your state next tooyour compute with hello same high availability and reliability you've come tooexpect from highly available external stores.</span></span> <span data-ttu-id="526ca-134">또한이 모델 hello 계산 및 toofunction 필요한 상태를 공동 배치는 때문에 대기 시간을 향상 합니다.</span><span class="sxs-lookup"><span data-stu-id="526ca-134">This model also improves latency because you are co-locating hello compute and state it needs toofunction.</span></span>

<span data-ttu-id="526ca-135">Reliable Services의 개요는 다음 Microsoft Virtual Academy 비디오를 시청하세요. <center>
<a target="_blank" href="https://mva.microsoft.com/en-US/training-courses/building-microservices-applications-on-azure-service-fabric-16747?l=HhD9566yC_4106218965">
<img src="./media/service-fabric-reliable-services-introduction/ReliableServicesVid.png" WIDTH="360" HEIGHT="244" />
</a>
</center></span><span class="sxs-lookup"><span data-stu-id="526ca-135">Watch this Microsoft Virtual Academy video for an overview of Reliable services: <center>
<a target="_blank" href="https://mva.microsoft.com/en-US/training-courses/building-microservices-applications-on-azure-service-fabric-16747?l=HhD9566yC_4106218965">
<img src="./media/service-fabric-reliable-services-introduction/ReliableServicesVid.png" WIDTH="360" HEIGHT="244" />
</a>
</center></span></span>

## <a name="what-makes-reliable-services-different"></a><span data-ttu-id="526ca-136">신뢰할 수 있는 서비스가 다른 서비스와 다른 점은 무엇입니까?</span><span class="sxs-lookup"><span data-stu-id="526ca-136">What makes Reliable Services different?</span></span>
<span data-ttu-id="526ca-137">서비스 패브릭의 신뢰할 수 있는 서비스는 이전에 작성하던 서비스와 다릅니다.</span><span class="sxs-lookup"><span data-stu-id="526ca-137">Reliable Services in Service Fabric are different from services you may have written before.</span></span> <span data-ttu-id="526ca-138">서비스 패브릭은 안정성, 가용성, 일관성 및 확장성을 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="526ca-138">Service Fabric provides reliability, availability, consistency, and scalability.</span></span>

* <span data-ttu-id="526ca-139">**안정성** 프로그램-컴퓨터 실패 하거나 네트워크 문제를 적중 위치 신뢰할 수 없는 환경에서 조차 위로 유지 되며 서비스 또는 오류 및 충돌이 발생할 경우 hello 서비스 자체에 실패 합니다.</span><span class="sxs-lookup"><span data-stu-id="526ca-139">**Reliability** - Your service stays up even in unreliable environments where your machines fail or hit network issues, or in cases where hello services themselves encounter errors and crash or fail.</span></span> <span data-ttu-id="526ca-140">상태 저장 서비스에 대 한 상태는 네트워크 또는 기타 실패로 인해 hello 있는지에도 유지 됩니다.</span><span class="sxs-lookup"><span data-stu-id="526ca-140">For stateful services, your state is preserved even in hello presence of network or other failures.</span></span>
* <span data-ttu-id="526ca-141">**가용성** - 연결 가능하고 응답성이 뛰어난 서비스입니다.</span><span class="sxs-lookup"><span data-stu-id="526ca-141">**Availability** - Your service is reachable and responsive.</span></span> <span data-ttu-id="526ca-142">Service Fabric은 실행 중인 복사본 수를 유지 관리합니다.</span><span class="sxs-lookup"><span data-stu-id="526ca-142">Service Fabric maintains your desired number of running copies.</span></span>
* <span data-ttu-id="526ca-143">**확장성** -서비스는 특정 하드웨어에서 분리 되 고 늘리거나 하드웨어 또는 기타 리소스의 hello 추가 또는 제거를 통해 필요에 따라 줄일 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="526ca-143">**Scalability** - Services are decoupled from specific hardware, and they can grow or shrink as necessary through hello addition or removal of hardware or other resources.</span></span> <span data-ttu-id="526ca-144">서비스는 hello 서비스 확장할 수 있습니다 (특히 hello 안정 된 경우)에서 분할 된 쉽게 tooensure 및 핸들 부분 실패 합니다.</span><span class="sxs-lookup"><span data-stu-id="526ca-144">Services are easily partitioned (especially in hello stateful case) tooensure that hello service can scale and handle partial failures.</span></span> <span data-ttu-id="526ca-145">서비스를 만들 수 있으며 응답 toocustomer 요청에 올린 코드를 필요에 따라 생성 되는 더 많은 인스턴스 toobe 통해 동적으로 삭제 합니다.</span><span class="sxs-lookup"><span data-stu-id="526ca-145">Services can be created and deleted dynamically via code, enabling more instances toobe spun up as necessary, say in response toocustomer requests.</span></span> <span data-ttu-id="526ca-146">마지막으로, 서비스 패브릭 서비스 toobe lightweight을 권장합니다.</span><span class="sxs-lookup"><span data-stu-id="526ca-146">Finally, Service Fabric encourages services toobe lightweight.</span></span> <span data-ttu-id="526ca-147">서비스 패브릭 서비스 toobe 단일 프로세스 내에서 사용자를 프로 비전 하지 않고 요구 하거나 전체 OS 인스턴스 또는 서비스의 프로세스 tooa 단일 인스턴스 전용 수천 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="526ca-147">Service Fabric allows thousands of services toobe provisioned within a single process, rather than requiring or dedicating entire OS instances or processes tooa single instance of a service.</span></span>
* <span data-ttu-id="526ca-148">**일관성** -이 서비스에 저장 된 모든 정보 보장할 수 toobe 일치 합니다.</span><span class="sxs-lookup"><span data-stu-id="526ca-148">**Consistency** - Any information stored in this service can be guaranteed toobe consistent.</span></span> <span data-ttu-id="526ca-149">서비스 내에서 여러 신뢰할 수 있는 컬렉션 간에도 적용됩니다.</span><span class="sxs-lookup"><span data-stu-id="526ca-149">This is true even across multiple reliable collections within a service.</span></span> <span data-ttu-id="526ca-150">서비스 내의 컬렉션을 트랜잭션 원자 방식으로 변경할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="526ca-150">Changes across collections within a service can be made in a transactionally atomic manner.</span></span>

## <a name="service-lifecycle"></a><span data-ttu-id="526ca-151">서비스 수명 주기</span><span class="sxs-lookup"><span data-stu-id="526ca-151">Service lifecycle</span></span>
<span data-ttu-id="526ca-152">서비스가 상태 저장 서비스이든, 상태 비저장 서비스이든, 신뢰할 수 있는 서비스는 신속하게 코드를 연결하고 시작할 수 있는 간단한 수명 주기를 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="526ca-152">Whether your service is stateful or stateless, Reliable Services provide a simple lifecycle that lets you quickly plug in your code and get started.</span></span>  <span data-ttu-id="526ca-153">된다고 tooimplement tooget 서비스 시작 및 실행 하는 하나 또는 두 개의 메서드가 있습니다.</span><span class="sxs-lookup"><span data-stu-id="526ca-153">There are just one or two methods that you need tooimplement tooget your service up and running.</span></span>

* <span data-ttu-id="526ca-154">**CreateServiceReplicaListeners/CreateServiceInstanceListeners** -이 메서드는 hello 서비스는 hello 통신 stack(s) toouse 브로드캐스트하며를 정의 합니다.</span><span class="sxs-lookup"><span data-stu-id="526ca-154">**CreateServiceReplicaListeners/CreateServiceInstanceListeners** - This method is where hello service defines hello communication stack(s) that it wants toouse.</span></span> <span data-ttu-id="526ca-155">와 같은 통신 스택을 hello [웹 API](service-fabric-reliable-services-communication-webapi.md), 수신 대기 끝점 hello 정의 또는 대 한 끝점 hello (방법: 클라이언트 hello 서비스 연결할) 서비스입니다.</span><span class="sxs-lookup"><span data-stu-id="526ca-155">hello communication stack, such as [Web API](service-fabric-reliable-services-communication-webapi.md), is what defines hello listening endpoint or endpoints for hello service (how clients reach hello service).</span></span> <span data-ttu-id="526ca-156">또한 표시 되는 hello 메시지 hello 서비스 코드의 나머지 부분 hello 상호 작용 하는 방법을 정의 합니다.</span><span class="sxs-lookup"><span data-stu-id="526ca-156">It also defines how hello messages that appear interact with hello rest of hello service code.</span></span>
* <span data-ttu-id="526ca-157">**RunAsync** -이 방법은 서비스는 비즈니스 논리 실행 되 고 작업이 있는 hello 서비스의 수명과 hello에 대 한 실행 해야 하는 모든 백그라운드 작업 시작 되어 합니다.</span><span class="sxs-lookup"><span data-stu-id="526ca-157">**RunAsync** - This method is where your service runs its business logic, and where it would kick off any background tasks that should run for hello lifetime of hello service.</span></span> <span data-ttu-id="526ca-158">hello, 취소 토큰을 제공 되는 해당 작업을 중지 하는 것에 대 한 신호입니다.</span><span class="sxs-lookup"><span data-stu-id="526ca-158">hello cancellation token that is provided is a signal for when that work should stop.</span></span> <span data-ttu-id="526ca-159">예를 들어 hello 서비스 신뢰할 수 있는 큐에서 메시지 toopull 필요 하 고 처리 하는 경우이 작동 하는 상황이 발생 합니다.</span><span class="sxs-lookup"><span data-stu-id="526ca-159">For example, if hello service needs toopull messages out of a Reliable Queue and process them, this is where that work happens.</span></span>

<span data-ttu-id="526ca-160">처음으로 hello에 대 한 신뢰할 수 있는 서비스에 대 한 학습 하는, 경우 기대해 주세요!</span><span class="sxs-lookup"><span data-stu-id="526ca-160">If you're learning about reliable services for hello first time, read on!</span></span> <span data-ttu-id="526ca-161">신뢰할 수 있는 서비스의 수명 주기 hello의 자세한 연습 과정을 찾고 있는 경우 수을 향해 위로 너무[이 여기서](service-fabric-reliable-services-lifecycle.md)합니다.</span><span class="sxs-lookup"><span data-stu-id="526ca-161">If you're looking for a detailed walkthrough of hello lifecycle of reliable services, you can head over too[this article](service-fabric-reliable-services-lifecycle.md).</span></span>

## <a name="example-services"></a><span data-ttu-id="526ca-162">예제 서비스</span><span class="sxs-lookup"><span data-stu-id="526ca-162">Example services</span></span>
<span data-ttu-id="526ca-163">이 프로그래밍 모델을 알고 있으면 하면 이러한 개념이 서로 어떻게 연결 하는 두 개의 서로 다른 서비스 toosee 개요를 보겠습니다.</span><span class="sxs-lookup"><span data-stu-id="526ca-163">Knowing this programming model, let's take a quick look at two different services toosee how these pieces fit together.</span></span>

### <a name="stateless-reliable-services"></a><span data-ttu-id="526ca-164">상태 비저장 신뢰할 수 있는 서비스</span><span class="sxs-lookup"><span data-stu-id="526ca-164">Stateless Reliable Services</span></span>
<span data-ttu-id="526ca-165">상태 비저장 서비스에는 하나의 호출 간에 hello 서비스 내에서 유지 관리 하는 상태가 되지 않았습니다.</span><span class="sxs-lookup"><span data-stu-id="526ca-165">A stateless service is one where there is no state maintained within hello service across calls.</span></span> <span data-ttu-id="526ca-166">표시된 상태는 완전히 삭제 가능하며 동기화, 복제, 지속성 또는 고가용성이 필요하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="526ca-166">Any state that is present is entirely disposable and doesn't require synchronization, replication, persistence, or high availability.</span></span>

<span data-ttu-id="526ca-167">예를 들어 메모리가 없습니다. 수신 하는 모든 조건 및 작업 tooperform 한 번에 하는 계산기를 것이 좋습니다.</span><span class="sxs-lookup"><span data-stu-id="526ca-167">For example, consider a calculator that has no memory and receives all terms and operations tooperform at once.</span></span>

<span data-ttu-id="526ca-168">이 경우 hello `RunAsync()` (C#) 또는 `runAsync()` (Java)의 hello 서비스 비어 있을 수 있습니다, 태스크 처리 해당 hello 서비스 toodo 필요 없는 백그라운드 있기 때문입니다.</span><span class="sxs-lookup"><span data-stu-id="526ca-168">In this case, hello `RunAsync()` (C#) or `runAsync()` (Java) of hello service can be empty, since there is no background task-processing that hello service needs toodo.</span></span> <span data-ttu-id="526ca-169">반환 hello 계산기 서비스를 만드는 경우는 `ICommunicationListener` (C#) 또는 `CommunicationListener` (Java) (예를 들어 [웹 API](service-fabric-reliable-services-communication-webapi.md)) 하는 일부 포트에서 수신 대기 끝점을 엽니다.</span><span class="sxs-lookup"><span data-stu-id="526ca-169">When hello calculator service is created, it returns an `ICommunicationListener` (C#) or `CommunicationListener` (Java) (for example [Web API](service-fabric-reliable-services-communication-webapi.md)) that opens up a listening endpoint on some port.</span></span> <span data-ttu-id="526ca-170">이 수신 대기 끝점 연결 하는 toohello 다른 계산 방법 (예: "Add (n1, n2)") hello 계산기 공용 API를 정의 하는 합니다.</span><span class="sxs-lookup"><span data-stu-id="526ca-170">This listening endpoint hooks up toohello different calculation methods (example: "Add(n1, n2)") that define hello calculator's public API.</span></span>

<span data-ttu-id="526ca-171">클라이언트에서 호출 되 면 hello 적절 한 메서드를 호출 하 고 hello 계산기 서비스 데이터 제공 되 고 hello 결과 반환 하는 hello에 hello 작업을 수행 합니다.</span><span class="sxs-lookup"><span data-stu-id="526ca-171">When a call is made from a client, hello appropriate method is invoked, and hello calculator service performs hello operations on hello data provided and returns hello result.</span></span> <span data-ttu-id="526ca-172">상태를 저장하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="526ca-172">It doesn't store any state.</span></span>

<span data-ttu-id="526ca-173">모든 내부 상태를 저장하지 않으므로 이 계산기 예제는 간단해집니다.</span><span class="sxs-lookup"><span data-stu-id="526ca-173">Not storing any internal state makes this example calculator simple.</span></span> <span data-ttu-id="526ca-174">하지만 대부분의 서비스는 상태 비저장이 아닙니다.</span><span class="sxs-lookup"><span data-stu-id="526ca-174">But most services aren't truly stateless.</span></span> <span data-ttu-id="526ca-175">해당 상태 toosome 다른 저장소 외부화 하는 대신.</span><span class="sxs-lookup"><span data-stu-id="526ca-175">Instead, they externalize their state toosome other store.</span></span> <span data-ttu-id="526ca-176">(예를 들어 세션 상태를 백업 저장소 또는 캐시에 유지하는 모든 웹앱은 상태 비저장이 아닙니다.)</span><span class="sxs-lookup"><span data-stu-id="526ca-176">(For example, any web app that relies on keeping session state in a backing store or cache is not stateless.)</span></span>

<span data-ttu-id="526ca-177">어떻게 상태 비저장 서비스의 일반적인 예로 서비스 패브릭에서 사용 되는 프런트 엔드로 hello 웹 응용 프로그램에 대 한 공용 API를 노출 하 합니다.</span><span class="sxs-lookup"><span data-stu-id="526ca-177">A common example of how stateless services are used in Service Fabric is as a front-end that exposes hello public-facing API for a web application.</span></span> <span data-ttu-id="526ca-178">hello 프런트 엔드 서비스는 다음 toostateful 서비스 toocomplete 사용자 요청을 설명 합니다.</span><span class="sxs-lookup"><span data-stu-id="526ca-178">hello front-end service then talks toostateful services toocomplete a user request.</span></span> <span data-ttu-id="526ca-179">이 경우 클라이언트의 호출에는 방향이 지정 된 tooa 알려진 같은 포트 80, hello 상태 비저장 서비스 수신 대기 됩니다.</span><span class="sxs-lookup"><span data-stu-id="526ca-179">In this case, calls from clients are directed tooa known port, such as 80, where hello stateless service is listening.</span></span> <span data-ttu-id="526ca-180">이 상태 비저장 서비스 hello 전화를 받 및 hello 호출에서 신뢰할 수 있는 당사자 인지 여부와 어떤가 서비스에 대 한 대상입니다.</span><span class="sxs-lookup"><span data-stu-id="526ca-180">This stateless service receives hello call and determines whether hello call is from a trusted party and which service it's destined for.</span></span>  <span data-ttu-id="526ca-181">그런 다음 hello 상태 비저장 서비스 hello 호출 toohello hello 상태 저장 서비스의 올바른 파티션을 전달 하 고 응답을 받기 위해 대기 합니다.</span><span class="sxs-lookup"><span data-stu-id="526ca-181">Then, hello stateless service forwards hello call toohello correct partition of hello stateful service and waits for a response.</span></span> <span data-ttu-id="526ca-182">Hello 상태 비저장 서비스 응답을 받으면 toohello 원래 클라이언트를 회신 합니다.</span><span class="sxs-lookup"><span data-stu-id="526ca-182">When hello stateless service receives a response, it replies toohello original client.</span></span> <span data-ttu-id="526ca-183">이러한 서비스의 예제는 [C#](https://github.com/Azure-Samples/service-fabric-dotnet-getting-started) / [Java](https://github.com/Azure-Samples/service-fabric-java-getting-started/tree/master/Actors/VisualObjectActor/VisualObjectWebService) 샘플에 있습니다.</span><span class="sxs-lookup"><span data-stu-id="526ca-183">An example of such a service is in our samples [C#](https://github.com/Azure-Samples/service-fabric-dotnet-getting-started) / [Java](https://github.com/Azure-Samples/service-fabric-java-getting-started/tree/master/Actors/VisualObjectActor/VisualObjectWebService).</span></span> <span data-ttu-id="526ca-184">이 hello 샘플에서이 패턴의 한 예도 다른 샘플에도 키워드가, 합니다.</span><span class="sxs-lookup"><span data-stu-id="526ca-184">This is only one example of this pattern in hello samples, there are others in other samples as well.</span></span>

### <a name="stateful-reliable-services"></a><span data-ttu-id="526ca-185">상태 저장 신뢰할 수 있는 서비스</span><span class="sxs-lookup"><span data-stu-id="526ca-185">Stateful Reliable Services</span></span>
<span data-ttu-id="526ca-186">상태 저장 서비스는 일관 되 고 hello 서비스 toofunction 하기 위해 존재 유지 상태의 일부 있어야입니다.</span><span class="sxs-lookup"><span data-stu-id="526ca-186">A stateful service is one that must have some portion of state kept consistent and present in order for hello service toofunction.</span></span> <span data-ttu-id="526ca-187">수신하는 업데이트에 따라 일부 값의 이동 평균을 지속적으로 계산하는 서비스를 고려할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="526ca-187">Consider a service that constantly computes a rolling average of some value based on updates it receives.</span></span> <span data-ttu-id="526ca-188">toodo이를 현재 평균 hello 및 tooprocess 필요한 들어오는 요청의 hello 현재 설정 되어 있어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="526ca-188">toodo this, it must have hello current set of incoming requests it needs tooprocess and hello current average.</span></span> <span data-ttu-id="526ca-189">정보를 검색, 처리하고 외부 저장소(예: Azure Blob 또는 현재 테이블 저장소)에 저장하는 모든 서비스는 상태 저장입니다.</span><span class="sxs-lookup"><span data-stu-id="526ca-189">Any service that retrieves, processes, and stores information in an external store (such as an Azure blob or table store today) is stateful.</span></span> <span data-ttu-id="526ca-190">방금 hello 외부 상태 저장소에 해당 상태를 유지합니다.</span><span class="sxs-lookup"><span data-stu-id="526ca-190">It just keeps its state in hello external state store.</span></span>

<span data-ttu-id="526ca-191">대부분의 서비스는 hello 외부 저장소는 해당 상태에 대 한 안정성, 가용성, 확장성 및 일관성 제공 하므로 오늘 외부적으로 상태를 저장 합니다.</span><span class="sxs-lookup"><span data-stu-id="526ca-191">Most services today store their state externally, since hello external store is what provides reliability, availability, scalability, and consistency for that state.</span></span> <span data-ttu-id="526ca-192">서비스 패브릭에서 서비스 필요한 toostore 자신의 상태를 외부적으로 되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="526ca-192">In Service Fabric, services aren't required toostore their state externally.</span></span> <span data-ttu-id="526ca-193">서비스 패브릭 서비스 코드 hello와 hello 서비스 상태에 대 한 이러한 요구 사항을 처리합니다.</span><span class="sxs-lookup"><span data-stu-id="526ca-193">Service Fabric takes care of these requirements for both hello service code and hello service state.</span></span>

> [!NOTE]
> <span data-ttu-id="526ca-194">아직 Linux에서는 상태 저장 Reliable Services가 지원되지 않습니다(C# 또는 Java의 경우).</span><span class="sxs-lookup"><span data-stu-id="526ca-194">Support for Stateful Reliable Services is not available on Linux yet (for C# or Java).</span></span>
>

<span data-ttu-id="526ca-195">이미지를 처리 하는 서비스 toowrite 원하는 경우를 가정해 봅니다.</span><span class="sxs-lookup"><span data-stu-id="526ca-195">Let's say we want toowrite a service that processes images.</span></span> <span data-ttu-id="526ca-196">toodo이 변환 tooperform 해당 이미지에는 이미지와 hello 계열의에서 hello 서비스 사용 합니다.</span><span class="sxs-lookup"><span data-stu-id="526ca-196">toodo this, hello service takes in an image and hello series of conversions tooperform on that image.</span></span> <span data-ttu-id="526ca-197">이 서비스는 `ConvertImage(Image i, IList<Conversion> conversions)`와 같은 API를 노출하는 통신 수신기(WebAPI라고 가정함)를 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="526ca-197">This service returns a communication listener (let's suppose it's a WebAPI) that exposes an API like `ConvertImage(Image i, IList<Conversion> conversions)`.</span></span> <span data-ttu-id="526ca-198">요청을 받으면 hello 서비스에 저장 한 `IReliableQueue`, hello 요청을 추적할 수 있도록 일부 id toohello 클라이언트를 반환 합니다.</span><span class="sxs-lookup"><span data-stu-id="526ca-198">When it receives a request, hello service stores it in a `IReliableQueue`, and returns some id toohello client so it can track hello request.</span></span>

<span data-ttu-id="526ca-199">이 서비스에서는 `RunAsync()`가 더 복잡해질 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="526ca-199">In this service, `RunAsync()` could be more complex.</span></span> <span data-ttu-id="526ca-200">hello 서비스 내부 루프에 해당 `RunAsync()` 의 요청을 끌어오는 `IReliableQueue` 요청 hello 변환을 수행 하 고 있습니다.</span><span class="sxs-lookup"><span data-stu-id="526ca-200">hello service has a loop inside its `RunAsync()` that pulls requests out of `IReliableQueue` and performs hello conversions requested.</span></span> <span data-ttu-id="526ca-201">hello 결과에 저장 된 가져오기는 `IReliableDictionary` hello 클라이언트 다시 시작 하는 경우 있도록가 변환 된 이미지를 가져올 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="526ca-201">hello results get stored in an `IReliableDictionary` so that when hello client comes back they can get their converted images.</span></span> <span data-ttu-id="526ca-202">tooensure hello 이미지 오류가 있으면 즉도 손실 되지 않습니다, 그리고 신뢰할 수 있는이 서비스는 hello 큐에서 꺼냅니다, hello 변환을 수행 및 단일 트랜잭션 내에서 모든 hello 결과 저장 합니다.</span><span class="sxs-lookup"><span data-stu-id="526ca-202">tooensure that even if something fails hello image isn't lost, this Reliable Service would pull out of hello queue, perform hello conversions, and store hello result all in a single transaction.</span></span> <span data-ttu-id="526ca-203">이 경우 hello 메시지 hello 큐에서 제거 되 고 hello 변환 작업이 완료 된 경우에 hello 결과 hello 결과 사전에 저장 됩니다.</span><span class="sxs-lookup"><span data-stu-id="526ca-203">In this case, hello message is removed from hello queue and hello results are stored in hello result dictionary only when hello conversions are complete.</span></span> <span data-ttu-id="526ca-204">또는 hello 서비스는 hello 이미지 hello 큐에서 끌어오도록 하 고 즉시 원격 저장소에 저장 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="526ca-204">Alternatively, hello service could pull hello image out of hello queue and immediately store it in a remote store.</span></span> <span data-ttu-id="526ca-205">이렇게 하면 줄어듭니다 hello 상태 hello 서비스 양을 toomanage를 갖지만 hello 서비스 tookeep hello 필요한 메타 데이터가 toomanage hello 원격 저장소에 있기 때문에 복잡성을 증가 합니다.</span><span class="sxs-lookup"><span data-stu-id="526ca-205">This reduces hello amount of state hello service has toomanage, but increases complexity since hello service has tookeep hello necessary metadata toomanage hello remote store.</span></span> <span data-ttu-id="526ca-206">각 접근 방법에 작업에 실패 한 경우 hello 중간 hello 요청 처리 hello 큐 대기 toobe에 남아 있습니다.</span><span class="sxs-lookup"><span data-stu-id="526ca-206">With either approach, if something failed in hello middle hello request remains in hello queue waiting toobe processed.</span></span>

<span data-ttu-id="526ca-207">이 서비스에 대 한 한 가지 toonote 일반.NET 서비스 말 하는!</span><span class="sxs-lookup"><span data-stu-id="526ca-207">One thing toonote about this service is that it sounds like a normal .NET service!</span></span> <span data-ttu-id="526ca-208">hello 유일한 차이점은 hello 데이터를 사용 하 고 구조는 (`IReliableQueue` 및 `IReliableDictionary`) 서비스 패브릭에서 제공 되 고 매우 안정적이 고, 사용할 수 있는 일관 됩니다.</span><span class="sxs-lookup"><span data-stu-id="526ca-208">hello only difference is that hello data structures being used (`IReliableQueue` and `IReliableDictionary`) are provided by Service Fabric, and are highly reliable, available, and consistent.</span></span>

## <a name="when-toouse-reliable-services-apis"></a><span data-ttu-id="526ca-209">때 toouse 신뢰할 수 있는 서비스 Api</span><span class="sxs-lookup"><span data-stu-id="526ca-209">When toouse Reliable Services APIs</span></span>
<span data-ttu-id="526ca-210">응용 프로그램 서비스에 필요한 특징을 결정 hello 다음 신뢰할 수 있는 서비스 Api 고려해 야 합니다.</span><span class="sxs-lookup"><span data-stu-id="526ca-210">If any of hello following characterize your application service needs, then you should consider Reliable Services APIs:</span></span>

* <span data-ttu-id="526ca-211">서비스의 코드 (및 필요에 따라 상태) 항상 사용 가능 하 고 신뢰할 수 있는 toobe</span><span class="sxs-lookup"><span data-stu-id="526ca-211">You want your service's code (and optionally state) toobe highly available and reliable</span></span>
* <span data-ttu-id="526ca-212">여러 상태 단위(예: 주문 및 주문 품목)에 걸쳐 트랜잭션 보장이 필요합니다.</span><span class="sxs-lookup"><span data-stu-id="526ca-212">You need transactional guarantees across multiple units of state (for example, orders and order line items).</span></span>
* <span data-ttu-id="526ca-213">응용 프로그램의 상태를 신뢰할 수 있는 사전 및 큐로 자연스럽게 모델링할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="526ca-213">Your application’s state can be naturally modeled as Reliable Dictionaries and Queues.</span></span>
* <span data-ttu-id="526ca-214">응용 프로그램 코드 또는 상태로 대기 시간이 짧은 읽기 및 쓰기를 항상 사용 가능한 toobe가 필요합니다.</span><span class="sxs-lookup"><span data-stu-id="526ca-214">Your applications code or state needs toobe highly available with low latency reads and writes.</span></span>
* <span data-ttu-id="526ca-215">응용 프로그램 하나 이상의 신뢰할 수 있는 컬렉션에서 toocontrol hello 동시성 또는 트랜잭션 처리 작업의 세분성에 필요 합니다.</span><span class="sxs-lookup"><span data-stu-id="526ca-215">Your application needs toocontrol hello concurrency or granularity of transacted operations across one or more Reliable Collections.</span></span>
* <span data-ttu-id="526ca-216">Toomanage hello 통신 또는 파티션 구성표 서비스에 대 한 제어 hello 원합니다.</span><span class="sxs-lookup"><span data-stu-id="526ca-216">You want toomanage hello communications or control hello partitioning scheme for your service.</span></span>
* <span data-ttu-id="526ca-217">코드에 자유 스레드된 런타임 환경이 필요합니다.</span><span class="sxs-lookup"><span data-stu-id="526ca-217">Your code needs a free-threaded runtime environment.</span></span>
* <span data-ttu-id="526ca-218">응용 프로그램에 필요한 toodynamically 만들거나 신뢰할 수 있는 사전 또는 큐 또는 런타임 시 전체 서비스를 삭제 합니다.</span><span class="sxs-lookup"><span data-stu-id="526ca-218">Your application needs toodynamically create or destroy Reliable Dictionaries or Queues or whole Services at runtime.</span></span>
* <span data-ttu-id="526ca-219">Tooprogrammatically 제어 서비스 패브릭 제공 백업 및 복원 기능이 필요한 서비스의 상태에 대 한 합니다.</span><span class="sxs-lookup"><span data-stu-id="526ca-219">You need tooprogrammatically control Service Fabric-provided backup and restore features for your service’s state.</span></span>
* <span data-ttu-id="526ca-220">응용 프로그램 상태의 해당 장치에 대 한 toomaintain 변경 내용에 필요 합니다.</span><span class="sxs-lookup"><span data-stu-id="526ca-220">Your application needs toomaintain change history for its units of state.</span></span>
* <span data-ttu-id="526ca-221">원하는 toodevelop 또는 파티 개발, 사용자 지정 상태 공급자를 사용 합니다.</span><span class="sxs-lookup"><span data-stu-id="526ca-221">You want toodevelop or consume third-party-developed, custom state providers.</span></span>

## <a name="next-steps"></a><span data-ttu-id="526ca-222">다음 단계</span><span class="sxs-lookup"><span data-stu-id="526ca-222">Next steps</span></span>
* [<span data-ttu-id="526ca-223">Reliable Services 빠른 시작</span><span class="sxs-lookup"><span data-stu-id="526ca-223">Reliable Services quick start</span></span>](service-fabric-reliable-services-quick-start.md)
* [<span data-ttu-id="526ca-224">신뢰할 수 있는 서비스 고급 사용법</span><span class="sxs-lookup"><span data-stu-id="526ca-224">Reliable Services advanced usage</span></span>](service-fabric-reliable-services-advanced-usage.md)
* [<span data-ttu-id="526ca-225">hello Reliable Actors 프로그래밍 모델</span><span class="sxs-lookup"><span data-stu-id="526ca-225">hello Reliable Actors programming model</span></span>](service-fabric-reliable-actors-introduction.md)
