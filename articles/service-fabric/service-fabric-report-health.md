---
title: "서비스 패브릭 상태 보고서를 사용자 지정 하는 aaaAdd | Microsoft Docs"
description: "사용자 지정 상태 toosend tooAzure 서비스 패브릭 상태 엔터티를 보고 하는 방법을 설명 합니다. 고품질 상태 보고서 설계 및 구현에 대한 권장 사항을 제공합니다."
services: service-fabric
documentationcenter: .net
author: oanapl
manager: timlt
editor: 
ms.assetid: 0a00a7d2-510e-47d0-8aa8-24c851ea847f
ms.service: service-fabric
ms.devlang: dotnet
ms.topic: article
ms.tgt_pltfrm: na
ms.workload: na
ms.date: 07/19/2017
ms.author: oanapl
ms.openlocfilehash: 12c9f664e2a457b4e1e8f340873ca60ebcefb097
ms.sourcegitcommit: 523283cc1b3c37c428e77850964dc1c33742c5f0
ms.translationtype: MT
ms.contentlocale: ko-KR
ms.lasthandoff: 10/06/2017
---
# <a name="add-custom-service-fabric-health-reports"></a><span data-ttu-id="05be7-104">사용자 지정 서비스 패브릭 상태 보고서 추가</span><span class="sxs-lookup"><span data-stu-id="05be7-104">Add custom Service Fabric health reports</span></span>
<span data-ttu-id="05be7-105">Azure 서비스 패브릭 소개는 [상태 모델](service-fabric-health-introduction.md) tooflag 비정상 클러스터 및 특정 엔터티에 대 한 응용 프로그램 조건 설계 되었습니다.</span><span class="sxs-lookup"><span data-stu-id="05be7-105">Azure Service Fabric introduces a [health model](service-fabric-health-introduction.md) designed tooflag unhealthy cluster and application conditions on specific entities.</span></span> <span data-ttu-id="05be7-106">사용 하 여 hello 상태 모델 **상태 reporters** (시스템 구성 요소 및 watchdogs).</span><span class="sxs-lookup"><span data-stu-id="05be7-106">hello health model uses **health reporters** (system components and watchdogs).</span></span> <span data-ttu-id="05be7-107">hello ´ ֲ 쉽고 빠르게 진단 및 복구 합니다.</span><span class="sxs-lookup"><span data-stu-id="05be7-107">hello goal is easy and fast diagnosis and repair.</span></span> <span data-ttu-id="05be7-108">서비스 작성자 상태에 대 한 현상을 toothink이 필요합니다.</span><span class="sxs-lookup"><span data-stu-id="05be7-108">Service writers need toothink upfront about health.</span></span> <span data-ttu-id="05be7-109">특히 toohello 루트 닫기 플래그 문제를 손쉽게 경우 상태에 영향을 줄 수 있는 모든 조건, 보고 됩니다.</span><span class="sxs-lookup"><span data-stu-id="05be7-109">Any condition that can impact health should be reported on, especially if it can help flag problems close toohello root.</span></span> <span data-ttu-id="05be7-110">hello 상태 정보는 디버깅 및 조사에 시간과 노력 저장할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="05be7-110">hello health information can save time and effort on debugging and investigation.</span></span> <span data-ttu-id="05be7-111">hello 사용할 필요는 특히 hello 서비스가 실행 되 고 hello 클라우드에서 대규모 되 면 (개인 또는 Azure).</span><span class="sxs-lookup"><span data-stu-id="05be7-111">hello usefulness is especially clear once hello service is up and running at scale in hello cloud (private or Azure).</span></span>

<span data-ttu-id="05be7-112">hello 서비스 패브릭 reporters 모니터의 관심 조건에서 식별 합니다.</span><span class="sxs-lookup"><span data-stu-id="05be7-112">hello Service Fabric reporters monitor identified conditions of interest.</span></span> <span data-ttu-id="05be7-113">보고자는 각자 로컬 보기를 기반으로 이러한 조건에 대한 정보를 보고합니다.</span><span class="sxs-lookup"><span data-stu-id="05be7-113">They report on those conditions based on their local view.</span></span> <span data-ttu-id="05be7-114">hello [상태 저장소](service-fabric-health-introduction.md#health-store) 엔터티는 전역적으로 정상 여부 모든 reporters toodetermine에서 보낸 상태 데이터를 집계 합니다.</span><span class="sxs-lookup"><span data-stu-id="05be7-114">hello [health store](service-fabric-health-introduction.md#health-store) aggregates health data sent by all reporters toodetermine whether entities are globally healthy.</span></span> <span data-ttu-id="05be7-115">hello 모델은 의도 한 toobe 풍부한 유연 하며 쉽게 toouse입니다.</span><span class="sxs-lookup"><span data-stu-id="05be7-115">hello model is intended toobe rich, flexible, and easy toouse.</span></span> <span data-ttu-id="05be7-116">hello 상태 보고서의 hello 품질 hello 클러스터의 hello 상태 보기의 hello 정확도 결정합니다.</span><span class="sxs-lookup"><span data-stu-id="05be7-116">hello quality of hello health reports determines hello accuracy of hello health view of hello cluster.</span></span> <span data-ttu-id="05be7-117">비정상 이슈를 잘못 표시하는 거짓 긍정은 상태 데이터를 사용하는 업그레이드 또는 기타 서비스에 부정적인 영향을 미칠 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="05be7-117">False positives that wrongly show unhealthy issues can negatively impact upgrades or other services that use health data.</span></span> <span data-ttu-id="05be7-118">이러한 서비스의 예로는 복구 서비스 및 경고 메커니즘이 있습니다.</span><span class="sxs-lookup"><span data-stu-id="05be7-118">Examples of such services are repair services and alerting mechanisms.</span></span> <span data-ttu-id="05be7-119">따라서 일부 생각은 필요한 tooprovide 보고서 hello에 대 한 관심의 조건에는 최상의 가능한 방법을 합니다.</span><span class="sxs-lookup"><span data-stu-id="05be7-119">Therefore, some thought is needed tooprovide reports that capture conditions of interest in hello best possible way.</span></span>

<span data-ttu-id="05be7-120">상태 보고, watchdogs 및 시스템 구성 toodesign 및 구현 해야합니다.</span><span class="sxs-lookup"><span data-stu-id="05be7-120">toodesign and implement health reporting, watchdogs and system components must:</span></span>

* <span data-ttu-id="05be7-121">Hello 상태 판단 기준 정의 관심이 있는, hello 클러스터 또는 응용 프로그램 기능에 영향을 hello 및 hello 방법은 모니터링 됩니다.</span><span class="sxs-lookup"><span data-stu-id="05be7-121">Define hello condition they are interested in, hello way it is monitored, and hello impact on hello cluster or application functionality.</span></span> <span data-ttu-id="05be7-122">이 정보에 따라, hello 보고서 속성 및 상태 상태에서 결정 하 게 합니다.</span><span class="sxs-lookup"><span data-stu-id="05be7-122">Based on this information, decide on hello health report property and health state.</span></span>
* <span data-ttu-id="05be7-123">Hello 결정 [엔터티](service-fabric-health-introduction.md#health-entities-and-hierarchy) hello 보고서에 적용 되도록 합니다.</span><span class="sxs-lookup"><span data-stu-id="05be7-123">Determine hello [entity](service-fabric-health-introduction.md#health-entities-and-hierarchy) that hello report applies to.</span></span>
* <span data-ttu-id="05be7-124">Hello 보고를 수행할지 위치를 확인 하 고, 내에서 서비스는 내부 또는 외부 watchdog hello 합니다.</span><span class="sxs-lookup"><span data-stu-id="05be7-124">Determine where hello reporting is done, from within hello service or from an internal or external watchdog.</span></span>
* <span data-ttu-id="05be7-125">사용 되는 소스 tooidentify hello 보고자를 정의 합니다.</span><span class="sxs-lookup"><span data-stu-id="05be7-125">Define a source used tooidentify hello reporter.</span></span>
* <span data-ttu-id="05be7-126">주기적 또는 전환기 중에서 보고 전략을 선택합니다.</span><span class="sxs-lookup"><span data-stu-id="05be7-126">Choose a reporting strategy, either periodically or on transitions.</span></span> <span data-ttu-id="05be7-127">hello 방법 보다 간단한 코드 필요 하며 발생할 가능성이 적으므로 tooerrors 대로 정기적으로, 하는 것이 좋습니다.</span><span class="sxs-lookup"><span data-stu-id="05be7-127">hello recommended way is periodically, as it requires simpler code and is less prone tooerrors.</span></span>
* <span data-ttu-id="05be7-128">선택 취소 해야 하는 방법 및 비정상 조건 hello health store에서 상태를 유지 해야에 대 한 hello 보고서 기간을 결정 합니다.</span><span class="sxs-lookup"><span data-stu-id="05be7-128">Determine how long hello report for unhealthy conditions should stay in hello health store and how it should be cleared.</span></span> <span data-ttu-id="05be7-129">이 정보를 사용 하 여 hello 보고서 시간 toolive 및 만료에 제거 동작을 결정 합니다.</span><span class="sxs-lookup"><span data-stu-id="05be7-129">Using this information, decide hello report's time toolive and remove-on-expiration behavior.</span></span>

<span data-ttu-id="05be7-130">언급된 바와 같이, 보고가 가능한 위치는 다음과 같습니다.</span><span class="sxs-lookup"><span data-stu-id="05be7-130">As mentioned, reporting can be done from:</span></span>

* <span data-ttu-id="05be7-131">hello는 서비스 패브릭 서비스 복제본을 모니터링합니다.</span><span class="sxs-lookup"><span data-stu-id="05be7-131">hello monitored Service Fabric service replica.</span></span>
* <span data-ttu-id="05be7-132">Service Fabric 서비스로 배포되는 내부 Watchdog(예: 조건 및 문제 보고서를 모니터링하는 Service Fabric 상태 비저장 서비스).</span><span class="sxs-lookup"><span data-stu-id="05be7-132">Internal watchdogs deployed as a Service Fabric service (for example, a Service Fabric stateless service that monitors conditions and issues reports).</span></span> <span data-ttu-id="05be7-133">hello watchdogs 수 있습니다. 모든 노드를 배포 하거나 모니터링 하는 선호도 지정 된 toohello 서비스 일 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="05be7-133">hello watchdogs can be deployed an all nodes or can be affinitized toohello monitored service.</span></span>
* <span data-ttu-id="05be7-134">Hello 서비스 패브릭에서를 실행 하지만 내부 watchdogs *하지* 서비스 패브릭 서비스도 구현 합니다.</span><span class="sxs-lookup"><span data-stu-id="05be7-134">Internal watchdogs that run on hello Service Fabric nodes but are *not* implemented as Service Fabric services.</span></span>
* <span data-ttu-id="05be7-135">외부에서 프로브 hello 리소스를 watchdogs *외부* hello 서비스 패브릭 클러스터 (예를 들어 Gomez 같은 모니터링 서비스).</span><span class="sxs-lookup"><span data-stu-id="05be7-135">External watchdogs that probe hello resource from *outside* hello Service Fabric cluster (for example, monitoring service like Gomez).</span></span>

> [!NOTE]
> <span data-ttu-id="05be7-136">Hello 초기 hello 클러스터 hello 시스템 구성 요소에서 보낸 상태 보고서로 채워집니다.</span><span class="sxs-lookup"><span data-stu-id="05be7-136">Out of hello box, hello cluster is populated with health reports sent by hello system components.</span></span> <span data-ttu-id="05be7-137">추가 정보는 [시스템 상태 보고서를 사용하여 문제 해결](service-fabric-understand-and-troubleshoot-with-system-health-reports.md)을 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="05be7-137">Read more at [Using system health reports for troubleshooting](service-fabric-understand-and-troubleshoot-with-system-health-reports.md).</span></span> <span data-ttu-id="05be7-138">hello 사용자 보고서에서 전송 되어야 합니다 [상태 엔터티](service-fabric-health-introduction.md#health-entities-and-hierarchy) 있는 hello 시스템에서 이미 만들어진 것입니다.</span><span class="sxs-lookup"><span data-stu-id="05be7-138">hello user reports must be sent on [health entities](service-fabric-health-introduction.md#health-entities-and-hierarchy) that have already been created by hello system.</span></span>
> 
> 

<span data-ttu-id="05be7-139">한 번 hello 상태 보고 디자인 선택이 취소 되어 상태 보고서를 쉽게 보낼 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="05be7-139">Once hello health reporting design is clear, health reports can be sent easily.</span></span> <span data-ttu-id="05be7-140">사용할 수 있습니다 [FabricClient](https://docs.microsoft.com/dotnet/api/system.fabric.fabricclient) tooreport 상태 hello 클러스터 없으면 [보안](service-fabric-cluster-security.md) 또는 hello 패브릭 클라이언트는 관리자 권한이 있는 경우.</span><span class="sxs-lookup"><span data-stu-id="05be7-140">You can use [FabricClient](https://docs.microsoft.com/dotnet/api/system.fabric.fabricclient) tooreport health if hello cluster is not [secure](service-fabric-cluster-security.md) or if hello fabric client has admin privileges.</span></span> <span data-ttu-id="05be7-141">보고 통해 수행할 수 있습니다 하 여 hello API 사용 하 여 [FabricClient.HealthManager.ReportHealth](https://docs.microsoft.com/dotnet/api/system.fabric.fabricclient.healthclient.reporthealth), PowerShell 또는 REST를 통해.</span><span class="sxs-lookup"><span data-stu-id="05be7-141">Reporting can be done through hello API by using [FabricClient.HealthManager.ReportHealth](https://docs.microsoft.com/dotnet/api/system.fabric.fabricclient.healthclient.reporthealth), through PowerShell, or through REST.</span></span> <span data-ttu-id="05be7-142">성능 향상을 위한 구성 노브 배치 보고서가 있습니다.</span><span class="sxs-lookup"><span data-stu-id="05be7-142">Configuration knobs batch reports for improved performance.</span></span>

> [!NOTE]
> <span data-ttu-id="05be7-143">상태 보고 동기적 이므로 hello 클라이언트 쪽에서 작업만 hello 유효성 검사 작업을 나타냅니다.</span><span class="sxs-lookup"><span data-stu-id="05be7-143">Report health is synchronous, and it represents only hello validation work on hello client side.</span></span> <span data-ttu-id="05be7-144">hello 보고서 hello 팩트 수락한 경우 hello 상태 클라이언트 또는 hello `Partition` 또는 `CodePackageActivationContext` 개체는 hello 저장소에 적용 되는 것은 아닙니다.</span><span class="sxs-lookup"><span data-stu-id="05be7-144">hello fact that hello report is accepted by hello health client or hello `Partition` or `CodePackageActivationContext` objects doesn't mean that it is applied in hello store.</span></span> <span data-ttu-id="05be7-145">비동기적으로 전송되며 다른 보고서와 함께 일괄 처리될 수도 있습니다.</span><span class="sxs-lookup"><span data-stu-id="05be7-145">It is sent asynchronously and possibly batched with other reports.</span></span> <span data-ttu-id="05be7-146">hello 서버에서 처리 하는 hello 실패할 수 있습니다: hello 시퀀스 번호는 유효 하지 않은 수, 보고서를 적용 해야 합니다는 hello에 hello 엔터티 되었습니다 등, 삭제 합니다.</span><span class="sxs-lookup"><span data-stu-id="05be7-146">hello processing on hello server may still fail: hello sequence number could be stale, hello entity on which hello report must be applied has been deleted, etc.</span></span>
> 
> 

## <a name="health-client"></a><span data-ttu-id="05be7-147">상태 클라이언트</span><span class="sxs-lookup"><span data-stu-id="05be7-147">Health client</span></span>
<span data-ttu-id="05be7-148">hello 상태 보고서 toohello 상태 저장소 패브릭 클라이언트 hello 안에 있는 상태 클라이언트를 통해 전송 됩니다.</span><span class="sxs-lookup"><span data-stu-id="05be7-148">hello health reports are sent toohello health store through a health client, which lives inside hello fabric client.</span></span> <span data-ttu-id="05be7-149">hello 상태 클라이언트 설정에 따라 hello로 구성할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="05be7-149">hello health client can be configured with hello following settings:</span></span>

* <span data-ttu-id="05be7-150">**HealthReportSendInterval**: hello 시간 hello 보고서 간에 hello 지연은 추가 toohello 클라이언트와 hello 시간 toohello 상태 저장소를 전송 합니다.</span><span class="sxs-lookup"><span data-stu-id="05be7-150">**HealthReportSendInterval**: hello delay between hello time hello report is added toohello client and hello time it is sent toohello health store.</span></span> <span data-ttu-id="05be7-151">각 보고서에 대 한 메시지를 보내는 대신 단일 메시지에 사용 되는 toobatch 보고 합니다.</span><span class="sxs-lookup"><span data-stu-id="05be7-151">Used toobatch reports into a single message, rather than sending one message for each report.</span></span> <span data-ttu-id="05be7-152">hello 일괄 처리 성능이 향상 됩니다.</span><span class="sxs-lookup"><span data-stu-id="05be7-152">hello batching improves performance.</span></span> <span data-ttu-id="05be7-153">기본값: 30초.</span><span class="sxs-lookup"><span data-stu-id="05be7-153">Default: 30 seconds.</span></span>
* <span data-ttu-id="05be7-154">**HealthReportRetrySendInterval**: toohello 상태 저장소를 보고 하는 hello 간격 상태 클라이언트는 hello에 누적 된 상태를 다시 보냅니다.</span><span class="sxs-lookup"><span data-stu-id="05be7-154">**HealthReportRetrySendInterval**: hello interval at which hello health client resends accumulated health reports toohello health store.</span></span> <span data-ttu-id="05be7-155">기본값: 30초.</span><span class="sxs-lookup"><span data-stu-id="05be7-155">Default: 30 seconds.</span></span>
* <span data-ttu-id="05be7-156">**HealthOperationTimeout**: 보고 메시지에 대 한 시간 제한을 hello toohello 상태 저장소를 전송 합니다.</span><span class="sxs-lookup"><span data-stu-id="05be7-156">**HealthOperationTimeout**: hello timeout period for a report message sent toohello health store.</span></span> <span data-ttu-id="05be7-157">메시지 제한 시간이 초과, hello 상태 클라이언트 다시 시도 것까지 hello 상태 저장소 hello 보고서가 처리 되었는지 확인 합니다.</span><span class="sxs-lookup"><span data-stu-id="05be7-157">If a message times out, hello health client retries it until hello health store confirms that hello report has been processed.</span></span> <span data-ttu-id="05be7-158">기본값: 2분.</span><span class="sxs-lookup"><span data-stu-id="05be7-158">Default: two minutes.</span></span>

> [!NOTE]
> <span data-ttu-id="05be7-159">Hello 보고서 내용이 일괄 처리 하는 경우 패브릭 클라이언트 hello 활성화 되어 있어야에 대 한 보내기 HealthReportSendInterval tooensure 이상 hello 합니다.</span><span class="sxs-lookup"><span data-stu-id="05be7-159">When hello reports are batched, hello fabric client must be kept alive for at least hello HealthReportSendInterval tooensure that they are sent.</span></span> <span data-ttu-id="05be7-160">Hello 패브릭 클라이언트 hello 메시지는 손실 hello 상태 저장소 tootransient 오류 인해 적용할 수 없습니다, 활성 상태로 오래 toogive에서 유지 되어야 합니다 것 기회 tooretry 합니다.</span><span class="sxs-lookup"><span data-stu-id="05be7-160">If hello message is lost or hello health store cannot apply them due tootransient errors, hello fabric client must be kept alive longer toogive it a chance tooretry.</span></span>
> 
> 

<span data-ttu-id="05be7-161">고려 hello 보고서의 hello 고유성은 hello hello 클라이언트에 버퍼링 합니다.</span><span class="sxs-lookup"><span data-stu-id="05be7-161">hello buffering on hello client takes hello uniqueness of hello reports into consideration.</span></span> <span data-ttu-id="05be7-162">예를 들어 특정 불량 보고자 100 보고 하는 경우를 보고 초당 hello 동일 hello의 속성이 같은 엔터티 hello 보고서 hello 마지막 버전으로 대체 됩니다.</span><span class="sxs-lookup"><span data-stu-id="05be7-162">For example, if a particular bad reporter is reporting 100 reports per second on hello same property of hello same entity, hello reports are replaced with hello last version.</span></span> <span data-ttu-id="05be7-163">최대 하나의 이러한 보고서는 hello 클라이언트 큐에 존재합니다.</span><span class="sxs-lookup"><span data-stu-id="05be7-163">At most one such report exists in hello client queue.</span></span> <span data-ttu-id="05be7-164">일괄 처리를 구성 하는 경우 송신 간격 마다 하나만 toohello 상태 저장소는 보낸 hello 보고서 수입니다.</span><span class="sxs-lookup"><span data-stu-id="05be7-164">If batching is configured, hello number of reports sent toohello health store is just one per send interval.</span></span> <span data-ttu-id="05be7-165">이 보고서는 hello 마지막 추가 된 보고서, hello 엔터티의 hello 최신 상태를 반영 합니다.</span><span class="sxs-lookup"><span data-stu-id="05be7-165">This report is hello last added report, which reflects hello most current state of hello entity.</span></span>
<span data-ttu-id="05be7-166">구성 매개 변수를 지정할 때 `FabricClient` 전달 하 여 만든 [FabricClientSettings](https://docs.microsoft.com/dotnet/api/system.fabric.fabricclientsettings) hello로 상태와 관련 된 항목에 대 한 값을 원하는 합니다.</span><span class="sxs-lookup"><span data-stu-id="05be7-166">Specify configuration parameters when `FabricClient` is created by passing [FabricClientSettings](https://docs.microsoft.com/dotnet/api/system.fabric.fabricclientsettings) with hello desired values for health-related entries.</span></span>

<span data-ttu-id="05be7-167">hello 다음 예제에서는 패브릭 클라이언트 만들고 추가 될 때 hello 보고서를 보내야 한다고 지정 합니다.</span><span class="sxs-lookup"><span data-stu-id="05be7-167">hello following example creates a fabric client and specifies that hello reports should be sent when they are added.</span></span> <span data-ttu-id="05be7-168">시간이 초과되거나 재시도 가능한 오류가 발생할 경우 40초마다 재시도가 이뤄집니다.</span><span class="sxs-lookup"><span data-stu-id="05be7-168">On timeouts and errors that can be retried, retries happen every 40 seconds.</span></span>

```csharp
var clientSettings = new FabricClientSettings()
{
    HealthOperationTimeout = TimeSpan.FromSeconds(120),
    HealthReportSendInterval = TimeSpan.FromSeconds(0),
    HealthReportRetrySendInterval = TimeSpan.FromSeconds(40),
};
var fabricClient = new FabricClient(clientSettings);
```

<span data-ttu-id="05be7-169">Hello 기본 패브릭 설정 하는 클라이언트 설정을 유지 하는 것이 좋습니다 `HealthReportSendInterval` too30 초입니다.</span><span class="sxs-lookup"><span data-stu-id="05be7-169">We recommend keeping hello default fabric client settings, which set `HealthReportSendInterval` too30 seconds.</span></span> <span data-ttu-id="05be7-170">이 설정은 최적의 성능을 보장 due toobatching 합니다.</span><span class="sxs-lookup"><span data-stu-id="05be7-170">This setting ensures optimal performance due toobatching.</span></span> <span data-ttu-id="05be7-171">가능한 즉시 내보내야 하는 중요 보고서의 경우 [FabricClient.HealthClient.ReportHealth](https://docs.microsoft.com/dotnet/api/system.fabric.fabricclient.healthclient.reporthealth) API에서 Immediate `true`와 함께 `HealthReportSendOptions`를 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="05be7-171">For critical reports that must be sent as soon as possible, use `HealthReportSendOptions` with Immediate `true` in [FabricClient.HealthClient.ReportHealth](https://docs.microsoft.com/dotnet/api/system.fabric.fabricclient.healthclient.reporthealth) API.</span></span> <span data-ttu-id="05be7-172">즉시 보고서를 일괄 처리 간격 hello를 무시 합니다.</span><span class="sxs-lookup"><span data-stu-id="05be7-172">Immediate reports bypass hello batching interval.</span></span> <span data-ttu-id="05be7-173">이 플래그를 사용 하 여 주의; 가능 하면 항상 일괄 처리 하는 hello 상태 클라이언트 tootake 활용을 주시기 바랍니다.</span><span class="sxs-lookup"><span data-stu-id="05be7-173">Use this flag with care; we want tootake advantage of hello health client batching whenever possible.</span></span> <span data-ttu-id="05be7-174">Fabric 클라이언트 hello 닫힐 때 즉시 송신 도움이 됩니다 (예를 들어 hello 프로세스 확인 했습니다. 잘못 된 상태 및 의도 하지 않은 tooprevent 아래로 tooshut 필요).</span><span class="sxs-lookup"><span data-stu-id="05be7-174">Immediate send is also useful when hello fabric client is closing (for example, hello process has determined invalid state and needs tooshut down tooprevent side effects).</span></span> <span data-ttu-id="05be7-175">누적 된 hello 보고서는 최상의 노력 송신이 되도록 조정 합니다.</span><span class="sxs-lookup"><span data-stu-id="05be7-175">It ensures a best-effort send of hello accumulated reports.</span></span> <span data-ttu-id="05be7-176">하나의 보고서 즉시 플래그를 추가 하는 hello 상태 클라이언트 마지막 보내기 이후 모든 누적 hello 보고서 일괄 처리.</span><span class="sxs-lookup"><span data-stu-id="05be7-176">When one report is added with Immediate flag, hello health client batches all hello accumulated reports since last send.</span></span>

<span data-ttu-id="05be7-177">PowerShell을 통해 연결 tooa 클러스터를 만들 때 동일한 매개 변수를 지정할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="05be7-177">Same parameters can be specified when a connection tooa cluster is created through PowerShell.</span></span> <span data-ttu-id="05be7-178">다음 예제는 hello 연결 tooa 로컬 클러스터를 시작 합니다.</span><span class="sxs-lookup"><span data-stu-id="05be7-178">hello following example starts a connection tooa local cluster:</span></span>

```powershell
PS C:\> Connect-ServiceFabricCluster -HealthOperationTimeoutInSec 120 -HealthReportSendIntervalInSec 0 -HealthReportRetrySendIntervalInSec 40
True

ConnectionEndpoint   :
FabricClientSettings : {
                       ClientFriendlyName                   : PowerShell-1944858a-4c6d-465f-89c7-9021c12ac0bb
                       PartitionLocationCacheLimit          : 100000
                       PartitionLocationCacheBucketCount    : 1024
                       ServiceChangePollInterval            : 00:02:00
                       ConnectionInitializationTimeout      : 00:00:02
                       KeepAliveInterval                    : 00:00:20
                       HealthOperationTimeout               : 00:02:00
                       HealthReportSendInterval             : 00:00:00
                       HealthReportRetrySendInterval        : 00:00:40
                       NotificationGatewayConnectionTimeout : 00:00:00
                       NotificationCacheUpdateTimeout       : 00:00:00
                       }
GatewayInformation   : {
                       NodeAddress                          : localhost:19000
                       NodeId                               : 1880ec88a3187766a6da323399721f53
                       NodeInstanceId                       : 130729063464981219
                       NodeName                             : Node.1
                       }
```

<span data-ttu-id="05be7-179">마찬가지로, tooAPI 보고서 보낼 수 있습니다를 사용 하 여 `-Immediate` hello에 관계 없이 바로 전송 toobe 전환 `HealthReportSendInterval` 값입니다.</span><span class="sxs-lookup"><span data-stu-id="05be7-179">Similarly tooAPI, reports can be sent using `-Immediate` switch toobe sent immediately, regardless of hello `HealthReportSendInterval` value.</span></span>

<span data-ttu-id="05be7-180">REST에 대 한 hello 보고서 toohello 서비스 패브릭 게이트웨이 내부 패브릭 클라이언트에 전송 됩니다.</span><span class="sxs-lookup"><span data-stu-id="05be7-180">For REST, hello reports are sent toohello Service Fabric gateway, which has an internal fabric client.</span></span> <span data-ttu-id="05be7-181">기본적으로이 클라이언트는 30 초 마다 일괄 처리 하는 구성 된 toosend reports입니다.</span><span class="sxs-lookup"><span data-stu-id="05be7-181">By default, this client is configured toosend reports batched every 30 seconds.</span></span> <span data-ttu-id="05be7-182">Hello 클러스터 구성 설정으로 hello 일괄 처리 간격을 변경할 수 있습니다 `HttpGatewayHealthReportSendInterval` 에 `HttpGateway`합니다.</span><span class="sxs-lookup"><span data-stu-id="05be7-182">You can change hello batch interval with hello cluster configuration setting `HttpGatewayHealthReportSendInterval` on `HttpGateway`.</span></span> <span data-ttu-id="05be7-183">더 나은 옵션을 사용 하 여 toosend hello 보고서는 언급 했 듯이 `Immediate` true입니다.</span><span class="sxs-lookup"><span data-stu-id="05be7-183">As mentioned, a better option is toosend hello reports with `Immediate` true.</span></span> 

> [!NOTE]
> <span data-ttu-id="05be7-184">권한이 없는 서비스 tooensure 상태를 보고할 수 없으며 hello 클러스터의 엔터티 hello에 대 한 보안된 클라이언트 에서만에서 hello 서버 tooaccept 요청을 구성 합니다.</span><span class="sxs-lookup"><span data-stu-id="05be7-184">tooensure that unauthorized services can't report health against hello entities in hello cluster, configure hello server tooaccept requests only from secured clients.</span></span> <span data-ttu-id="05be7-185">hello `FabricClient` 보안 설정한 상태 여야 (Kerberos 또는 인증서 인증)과 같이 hello 클러스터와 toobe 수 toocommunicate 보고에 사용 됩니다.</span><span class="sxs-lookup"><span data-stu-id="05be7-185">hello `FabricClient` used for reporting must have security enabled toobe able toocommunicate with hello cluster (for example, with Kerberos or certificate authentication).</span></span> <span data-ttu-id="05be7-186">[클러스터 보안](service-fabric-cluster-security.md)에 대해 자세히 알아봅니다.</span><span class="sxs-lookup"><span data-stu-id="05be7-186">Read more about [cluster security](service-fabric-cluster-security.md).</span></span>
> 
> 

## <a name="report-from-within-low-privilege-services"></a><span data-ttu-id="05be7-187">권한이 낮은 서비스 내에서 보고</span><span class="sxs-lookup"><span data-stu-id="05be7-187">Report from within low privilege services</span></span>
<span data-ttu-id="05be7-188">서비스 패브릭 서비스 관리자 액세스 toohello 클러스터 없으면 보고할 수 있습니다 상태를 통해 hello 현재 컨텍스트에서 엔터티 `Partition` 또는 `CodePackageActivationContext`합니다.</span><span class="sxs-lookup"><span data-stu-id="05be7-188">If Service Fabric services do not have admin access toohello cluster, you can report health on entities from hello current context through `Partition` or `CodePackageActivationContext`.</span></span>

* <span data-ttu-id="05be7-189">상태 비저장 서비스에 대 한 사용 하 여 [IStatelessServicePartition.ReportInstanceHealth](https://docs.microsoft.com/dotnet/api/system.fabric.istatelessservicepartition.reportinstancehealth) hello 현재 서비스 인스턴스에서 tooreport 합니다.</span><span class="sxs-lookup"><span data-stu-id="05be7-189">For stateless services, use [IStatelessServicePartition.ReportInstanceHealth](https://docs.microsoft.com/dotnet/api/system.fabric.istatelessservicepartition.reportinstancehealth) tooreport on hello current service instance.</span></span>
* <span data-ttu-id="05be7-190">상태 저장 서비스에 대 한 사용 하 여 [IStatefulServicePartition.ReportReplicaHealth](https://docs.microsoft.com/dotnet/api/system.fabric.istatefulservicepartition.reportreplicahealth) tooreport 현재 복제 데이터베이스에 있습니다.</span><span class="sxs-lookup"><span data-stu-id="05be7-190">For stateful services, use [IStatefulServicePartition.ReportReplicaHealth](https://docs.microsoft.com/dotnet/api/system.fabric.istatefulservicepartition.reportreplicahealth) tooreport on current replica.</span></span>
* <span data-ttu-id="05be7-191">사용 하 여 [IServicePartition.ReportPartitionHealth](https://docs.microsoft.com/dotnet/api/system.fabric.iservicepartition.reportpartitionhealth) hello 현재 파티션 엔터티에 tooreport 합니다.</span><span class="sxs-lookup"><span data-stu-id="05be7-191">Use [IServicePartition.ReportPartitionHealth](https://docs.microsoft.com/dotnet/api/system.fabric.iservicepartition.reportpartitionhealth) tooreport on hello current partition entity.</span></span>
* <span data-ttu-id="05be7-192">사용 하 여 [CodePackageActivationContext.ReportApplicationHealth](https://docs.microsoft.com/dotnet/api/system.fabric.codepackageactivationcontext.reportapplicationhealth) tooreport 현재 응용 프로그램에 있습니다.</span><span class="sxs-lookup"><span data-stu-id="05be7-192">Use [CodePackageActivationContext.ReportApplicationHealth](https://docs.microsoft.com/dotnet/api/system.fabric.codepackageactivationcontext.reportapplicationhealth) tooreport on current application.</span></span>
* <span data-ttu-id="05be7-193">사용 하 여 [CodePackageActivationContext.ReportDeployedApplicationHealth](https://docs.microsoft.com/dotnet/api/system.fabric.codepackageactivationcontext.reportdeployedapplicationhealth) tooreport hello 현재 노드에서 배포 된 hello 현재 응용 프로그램에 있습니다.</span><span class="sxs-lookup"><span data-stu-id="05be7-193">Use [CodePackageActivationContext.ReportDeployedApplicationHealth](https://docs.microsoft.com/dotnet/api/system.fabric.codepackageactivationcontext.reportdeployedapplicationhealth) tooreport on hello current application deployed on hello current node.</span></span>
* <span data-ttu-id="05be7-194">사용 하 여 [CodePackageActivationContext.ReportDeployedServicePackageHealth](https://docs.microsoft.com/dotnet/api/system.fabric.codepackageactivationcontext.reportdeployedservicepackagehealth) tooreport hello 현재 노드에서 배포 된 hello 응용 프로그램에 대 한 서비스 패키지에 있습니다.</span><span class="sxs-lookup"><span data-stu-id="05be7-194">Use [CodePackageActivationContext.ReportDeployedServicePackageHealth](https://docs.microsoft.com/dotnet/api/system.fabric.codepackageactivationcontext.reportdeployedservicepackagehealth) tooreport on a service package for hello application deployed on hello current node.</span></span>

> [!NOTE]
> <span data-ttu-id="05be7-195">내부적으로 hello `Partition` 및 hello `CodePackageActivationContext` 기본 설정으로 구성 된 클라이언트 상태를 유지 합니다.</span><span class="sxs-lookup"><span data-stu-id="05be7-195">Internally, hello `Partition` and hello `CodePackageActivationContext` hold a health client configured with default settings.</span></span> <span data-ttu-id="05be7-196">Hello에 대 한 설명 된 대로 [상태 클라이언트](service-fabric-report-health.md#health-client), 보고서는 일괄 처리 되 고 타이머를 전송 합니다.</span><span class="sxs-lookup"><span data-stu-id="05be7-196">As explained for hello [health client](service-fabric-report-health.md#health-client), reports are batched and sent on a timer.</span></span> <span data-ttu-id="05be7-197">hello 개체 해야 기회 toosend hello 보고서 toohave 활성 상태로 유지 합니다.</span><span class="sxs-lookup"><span data-stu-id="05be7-197">hello objects should be kept alive toohave a chance toosend hello report.</span></span>
> 
> 

<span data-ttu-id="05be7-198">`Partition` 및 `CodePackageActivationContext` 상태 API를 통해 보고서를 보낼 때 `HealthReportSendOptions`를 지정할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="05be7-198">You can specify `HealthReportSendOptions` when sending reports through `Partition` and `CodePackageActivationContext` health APIs.</span></span> <span data-ttu-id="05be7-199">가능한 빨리 전송되어야 하는 중요 보고서의 경우 Immediate `true`와 함께 `HealthReportSendOptions`를 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="05be7-199">If you have critical reports that must be sent as soon as possible, use `HealthReportSendOptions` with Immediate `true`.</span></span> <span data-ttu-id="05be7-200">즉시 보고서를 일괄 처리 간격 hello 내부 상태 클라이언트 hello를 무시 합니다.</span><span class="sxs-lookup"><span data-stu-id="05be7-200">Immediate reports bypass hello batching interval of hello internal health client.</span></span> <span data-ttu-id="05be7-201">앞서 언급 했 듯이; 주의 하 여이 플래그를 사용 가능 하면 항상 일괄 처리 하는 hello 상태 클라이언트 tootake 활용을 주시기 바랍니다.</span><span class="sxs-lookup"><span data-stu-id="05be7-201">As mentioned before, use this flag with care; we want tootake advantage of hello health client batching whenever possible.</span></span>

## <a name="design-health-reporting"></a><span data-ttu-id="05be7-202">상태 보고 설계</span><span class="sxs-lookup"><span data-stu-id="05be7-202">Design health reporting</span></span>
<span data-ttu-id="05be7-203">hello 고품질 보고서 생성의 첫 번째 단계 확인 hello 서비스의 hello 상태에 영향을 줄 수 있는 hello 조건입니다.</span><span class="sxs-lookup"><span data-stu-id="05be7-203">hello first step in generating high-quality reports is identifying hello conditions that can impact hello health of hello service.</span></span> <span data-ttu-id="05be7-204">Hello 서비스 또는 클러스터의 플래그 문제-시작 하거나 더 좋은 전에 동기화 되지 않은 문제일 수 있습니다 때 도움이 될 수 있는 모든 조건 10 억 달러를 저장 합니다.</span><span class="sxs-lookup"><span data-stu-id="05be7-204">Any condition that can help flag problems in hello service or cluster when it starts--or even better, before a problem happens--can potentially save billions of dollars.</span></span> <span data-ttu-id="05be7-205">hello 이점 작동 중단이 포함, 더 적은 밤 시간을 조사 하 고 문제 및 고객 만족도 복구.</span><span class="sxs-lookup"><span data-stu-id="05be7-205">hello benefits include less down time, fewer night hours spent investigating and repairing issues, and higher customer satisfaction.</span></span>

<span data-ttu-id="05be7-206">Hello 조건 식별 되 면 watchdog 기록기 hello 가장 좋은 방법은 toomonitor 오버 헤드와 유용성 간의 균형을 유지 하도록 아웃 toofigure가 필요 합니다.</span><span class="sxs-lookup"><span data-stu-id="05be7-206">Once hello conditions are identified, watchdog writers need toofigure out hello best way toomonitor them for balance between overhead and usefulness.</span></span> <span data-ttu-id="05be7-207">예를 들어 공유 위치에서 임시 파일을 사용하여 복잡한 계산을 수행하는 서비스가 있다고 가정하겠습니다.</span><span class="sxs-lookup"><span data-stu-id="05be7-207">For example, consider a service that does complex calculations that use some temporary files on a share.</span></span> <span data-ttu-id="05be7-208">watchdog hello 공유 tooensure 충분 한 공간이 사용할 수 있는지를 모니터링할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="05be7-208">A watchdog could monitor hello share tooensure that enough space is available.</span></span> <span data-ttu-id="05be7-209">파일/디렉토리 변경에 대한 알림을 수신할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="05be7-209">It could listen for notifications of file or directory changes.</span></span> <span data-ttu-id="05be7-210">업 프런트 임계값에 도달 하 고 hello 공유 꽉 오류를 보고 하는 경우 경고를 보고할 수 것입니다.</span><span class="sxs-lookup"><span data-stu-id="05be7-210">It could report a warning if an upfront threshold is reached, and report an error if hello share is full.</span></span> <span data-ttu-id="05be7-211">경고를 복구 시스템 hello 공유에서 오래 된 파일을 정리를 시작할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="05be7-211">On a warning, a repair system could start cleaning up older files on hello share.</span></span> <span data-ttu-id="05be7-212">오류 발생 시 복구 시스템 hello 서비스 복제본 tooanother 노드를 바뀔 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="05be7-212">On an error, a repair system could move hello service replica tooanother node.</span></span> <span data-ttu-id="05be7-213">상태에 따라 hello 조건 상태는 설명 하는 방법을 확인: hello hello 라고 할 수 있는 정상 (ok) 조건 또는 비정상 (경고 또는 오류)의 상태입니다.</span><span class="sxs-lookup"><span data-stu-id="05be7-213">Note how hello condition states are described in terms of health: hello state of hello condition that can be considered healthy (ok) or unhealthy (warning or error).</span></span>

<span data-ttu-id="05be7-214">Hello 모니터링 세부 정보를 설정 방법을 tooimplement hello watchdog 아웃 toofigure watchdog 기록기에 필요 합니다.</span><span class="sxs-lookup"><span data-stu-id="05be7-214">Once hello monitoring details are set, a watchdog writer needs toofigure out how tooimplement hello watchdog.</span></span> <span data-ttu-id="05be7-215">Hello 조건 hello 서비스 내에서 확인할 수 있는, hello watchdog hello 모니터링 서비스 자체의 일부를 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="05be7-215">If hello conditions can be determined from within hello service, hello watchdog can be part of hello monitored service itself.</span></span> <span data-ttu-id="05be7-216">예를 들어 hello 서비스 코드 hello 공유 사용을 확인 하 고 toowrite 파일을 열려고 할 때마다 보고서 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="05be7-216">For example, hello service code can check hello share usage, and then report every time it tries toowrite a file.</span></span> <span data-ttu-id="05be7-217">이 방법의 장점은 hello 보고 단순 된다는 점입니다.</span><span class="sxs-lookup"><span data-stu-id="05be7-217">hello advantage of this approach is that reporting is simple.</span></span> <span data-ttu-id="05be7-218">주의 해야 hello 서비스 기능에 영향을 주는 tooprevent watchdog 버그입니다.</span><span class="sxs-lookup"><span data-stu-id="05be7-218">Care must be taken tooprevent watchdog bugs from impacting hello service functionality.</span></span>

<span data-ttu-id="05be7-219">보고 기능 모니터링 hello 서비스 내에서 항상 한 옵션이 아닙니다.</span><span class="sxs-lookup"><span data-stu-id="05be7-219">Reporting from within hello monitored service is not always an option.</span></span> <span data-ttu-id="05be7-220">Hello 서비스 내에서 감시 수 toodetect hello 조건 아닐 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="05be7-220">A watchdog within hello service may not be able toodetect hello conditions.</span></span> <span data-ttu-id="05be7-221">Hello 논리 또는 데이터 toomake hello 결정이 없을 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="05be7-221">It may not have hello logic or data toomake hello determination.</span></span> <span data-ttu-id="05be7-222">hello 조건 모니터링의 오버 헤드 hello 높은 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="05be7-222">hello overhead of monitoring hello conditions may be high.</span></span> <span data-ttu-id="05be7-223">hello 조건도 될 수 있습니다 특정 tooa 서비스 아니지만 대신 서비스 간의 상호 작용에 영향을 줍니다.</span><span class="sxs-lookup"><span data-stu-id="05be7-223">hello conditions also may not be specific tooa service, but instead affect interactions between services.</span></span> <span data-ttu-id="05be7-224">두 번째 방법은 toohave watchdogs hello 클러스터에서 별도 프로세스로 합니다.</span><span class="sxs-lookup"><span data-stu-id="05be7-224">Another option is toohave watchdogs in hello cluster as separate processes.</span></span> <span data-ttu-id="05be7-225">hello watchdogs 어떤 방식으로든에서 hello 주 서비스 영향을 주지 않고 hello 조건 및 보고서를 모니터링 합니다.</span><span class="sxs-lookup"><span data-stu-id="05be7-225">hello watchdogs monitor hello conditions and report, without affecting hello main services in any way.</span></span> <span data-ttu-id="05be7-226">예를 들어 hello에 상태 비저장 서비스와 이러한 watchdogs를 구현할 수 있습니다 hello 또는 모든 노드에 배포 된 동일한 응용 프로그램 hello 서비스와 같은 노드.</span><span class="sxs-lookup"><span data-stu-id="05be7-226">For example, these watchdogs could be implemented as stateless services in hello same application, deployed on all nodes or on hello same nodes as hello service.</span></span>

<span data-ttu-id="05be7-227">경우에 따라 hello 클러스터에서 실행 되는 watchdog이 불가능 하거나 합니다.</span><span class="sxs-lookup"><span data-stu-id="05be7-227">Sometimes, a watchdog running in hello cluster is not an option either.</span></span> <span data-ttu-id="05be7-228">모니터링 하는 hello 조건이 hello 가용성 또는 hello 서비스의 기능을 사용자가 볼 것 이면 경우 동일한 배치 hello 사용자 클라이언트 hello에 최상의 toohave hello watchdogs입니다.</span><span class="sxs-lookup"><span data-stu-id="05be7-228">If hello monitored condition is hello availability or functionality of hello service as users see it, it's best toohave hello watchdogs in hello same place as hello user clients.</span></span> <span data-ttu-id="05be7-229">Hello 작동을 테스트 수, hello에 동일한 방식으로 사용자가 호출 합니다.</span><span class="sxs-lookup"><span data-stu-id="05be7-229">There, they can test hello operations in hello same way users call them.</span></span> <span data-ttu-id="05be7-230">예를 들어 hello 클러스터 외부 toohello 서비스 요청을 실행 하 고 hello 대기 시간 및 hello 결과의 정확성을 확인 하는 watchdog이 있을 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="05be7-230">For example, you can have a watchdog that lives outside hello cluster, issues requests toohello service, and checks hello latency and correctness of hello result.</span></span> <span data-ttu-id="05be7-231">(예: 계산기 서비스의 경우 2+2가 합당한 시간 내에 4를 반환합니까?)</span><span class="sxs-lookup"><span data-stu-id="05be7-231">(For a calculator service, for example, does 2+2 return 4 in a reasonable amount of time?)</span></span>

<span data-ttu-id="05be7-232">Hello watchdog 세부 정보 완료 되 면 고유 하 게 식별 하는 소스 ID를 결정 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="05be7-232">Once hello watchdog details have been finalized, you should decide on a source ID that uniquely identifies it.</span></span> <span data-ttu-id="05be7-233">Hello에 살고 있는 같은 종류의 여러 watchdogs hello 클러스터, 하는 경우 서로 다른 엔터티 보고 하거나 동일한 엔터티, 사용 하 여 다른 소스 ID 또는 속성에 대해 보고 하는 경우 hello 해야 있습니다.</span><span class="sxs-lookup"><span data-stu-id="05be7-233">If multiple watchdogs of hello same type are living in hello cluster, they must report on different entities, or, if they report on hello same entity, use different source ID or property.</span></span> <span data-ttu-id="05be7-234">그래야만 보고서가 공존할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="05be7-234">This way, their reports can coexist.</span></span> <span data-ttu-id="05be7-235">hello 상태 보고서의 hello 속성 모니터링 hello 조건을 사항의 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="05be7-235">hello property of hello health report should capture hello monitored condition.</span></span> <span data-ttu-id="05be7-236">(예: hello 위의 hello 속성 수 **ShareSize**.) 여러 보고서 toohello 적용 하는 경우 동일한 조건을 hello 속성 보고서 toocoexist 수 있는 몇 가지 동적 정보를 포함 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="05be7-236">(For hello example above, hello property could be **ShareSize**.) If multiple reports apply toohello same condition, hello property should contain some dynamic information that allows reports toocoexist.</span></span> <span data-ttu-id="05be7-237">예를 들어 경우 여러 공유 toobe 모니터링할 필요한 hello 속성 이름은 수 **ShareSize sharename**합니다.</span><span class="sxs-lookup"><span data-stu-id="05be7-237">For example, if multiple shares need toobe monitored, hello property name can be **ShareSize-sharename**.</span></span>

> [!NOTE]
> <span data-ttu-id="05be7-238">수행 *하지* hello 저장소 tookeep 상태 정보를 사용 합니다.</span><span class="sxs-lookup"><span data-stu-id="05be7-238">Do *not* use hello health store tookeep status information.</span></span> <span data-ttu-id="05be7-239">상태 관련 정보만 엔터티의이 정보에 영향을 미칩니다 hello 상태 평가로 상태를 성공으로 보고 됩니다.</span><span class="sxs-lookup"><span data-stu-id="05be7-239">Only health-related information should be reported as health, as this information impacts hello health evaluation of an entity.</span></span> <span data-ttu-id="05be7-240">범용 저장소로 hello 상태 저장소 설계 되지 않았습니다.</span><span class="sxs-lookup"><span data-stu-id="05be7-240">hello health store was not designed as a general-purpose store.</span></span> <span data-ttu-id="05be7-241">사용 하 여 상태 평가 논리 tooaggregate 모든 데이터 hello 성능 상태에 있습니다.</span><span class="sxs-lookup"><span data-stu-id="05be7-241">It uses health evaluation logic tooaggregate all data into hello health state.</span></span> <span data-ttu-id="05be7-242">성능 상태를 집계 보내는 정보 (예: 확인의 상태와 상태 보고) 관련이 없는 toohealth hello 영향을 주지 않습니다. 그러나 hello 상태 저장소의 hello 성능을 저하 될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="05be7-242">Sending information unrelated toohealth (like reporting status with a health state of OK) doesn't impact hello aggregated health state, but it can negatively affect hello performance of hello health store.</span></span>
> 
> 

<span data-ttu-id="05be7-243">다음 의사 결정 지점 hello 어떤 엔터티 tooreport를 켜져 있습니다.</span><span class="sxs-lookup"><span data-stu-id="05be7-243">hello next decision point is which entity tooreport on.</span></span> <span data-ttu-id="05be7-244">명확 하 게 대부분의 hello hello 조건 idetifies 엔터티를 hello 합니다.</span><span class="sxs-lookup"><span data-stu-id="05be7-244">Most of hello time, hello condition clearly idetifies hello entity.</span></span> <span data-ttu-id="05be7-245">최상의 가능한 세분성 hello 엔터티를 선택 합니다.</span><span class="sxs-lookup"><span data-stu-id="05be7-245">Choose hello entity with best possible granularity.</span></span> <span data-ttu-id="05be7-246">조건에 파티션에 있는 모든 복제본이 영향을 줍니다 hello 서비스에 없는 hello 파티션에 보고 합니다.</span><span class="sxs-lookup"><span data-stu-id="05be7-246">If a condition impacts all replicas in a partition, report on hello partition, not on hello service.</span></span> <span data-ttu-id="05be7-247">그런데 세심한 주의가 필요한 사각 지대가 있습니다.</span><span class="sxs-lookup"><span data-stu-id="05be7-247">There are corner cases where more thought is needed, though.</span></span> <span data-ttu-id="05be7-248">Hello 조건에는 복제본이 같은 엔터티에 영향을 줍니다. 하지만 hello desire은 복제본 수명 hello 기간 보다 그 이상 플래그가 지정 toohave hello 조건 hello 파티션에 보고 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="05be7-248">If hello condition impacts an entity, such as a replica, but hello desire is toohave hello condition flagged for more than hello duration of replica life, then it should be reported on hello partition.</span></span> <span data-ttu-id="05be7-249">그렇지 않으면 hello 복제본이 삭제 되 면 hello 상태 저장소의 모든 보고서를 정리 합니다.</span><span class="sxs-lookup"><span data-stu-id="05be7-249">Otherwise, when hello replica is deleted, hello health store cleans up all its reports.</span></span> <span data-ttu-id="05be7-250">Hello 엔터티 및 hello 보고서 hello 수명에 대 한 감시 작성기 고려해 야 합니다.</span><span class="sxs-lookup"><span data-stu-id="05be7-250">Watchdog writers must think about hello lifetimes of hello entity and hello report.</span></span> <span data-ttu-id="05be7-251">저장소에서 보고서가 삭제되는 시점(예: 한 엔터티에 대해 보고된 오류가 더 이상 적용되는 않는 시점)도 명확해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="05be7-251">It must be clear when a report should be cleaned up from a store (for example, when an error reported on an entity no longer applies).</span></span>

<span data-ttu-id="05be7-252">앞서 설명한 hello 포인트 묶어 하는 예제를 살펴 보겠습니다.</span><span class="sxs-lookup"><span data-stu-id="05be7-252">Let's look at an example that puts together hello points I described.</span></span> <span data-ttu-id="05be7-253">모든 노드에 배포된 마스터 상태 저장 지속 서비스 및 보조 상태 비저장 서비스로 구성된 서비스 패브릭 응용 프로그램이 있습니다(각 태스크 유형에 대한 한 가지 보조 서비스 유형).</span><span class="sxs-lookup"><span data-stu-id="05be7-253">Consider a Service Fabric application composed of a master stateful persistent service and secondary stateless services deployed on all nodes (one secondary service type for each type of task).</span></span> <span data-ttu-id="05be7-254">hello 마스터 보조 복제본에서 실행할 명령을 toobe를 포함 하는 처리 큐를 있습니다.</span><span class="sxs-lookup"><span data-stu-id="05be7-254">hello master has a processing queue that contains commands toobe executed by secondaries.</span></span> <span data-ttu-id="05be7-255">hello 보조 hello 들어오는 요청을 실행 하 고 백 승인을 신호를 보냅니다.</span><span class="sxs-lookup"><span data-stu-id="05be7-255">hello secondaries execute hello incoming requests and send back acknowledgement signals.</span></span> <span data-ttu-id="05be7-256">모니터링 될 수 있는 한 가지 조건을 hello 마스터 처리 큐의 hello 길이입니다.</span><span class="sxs-lookup"><span data-stu-id="05be7-256">One condition that could be monitored is hello length of hello master processing queue.</span></span> <span data-ttu-id="05be7-257">Hello 마스터 큐 길이 임계값에 도달 하면 경고가 보고 됩니다.</span><span class="sxs-lookup"><span data-stu-id="05be7-257">If hello master queue length reaches a threshold, a warning is reported.</span></span> <span data-ttu-id="05be7-258">hello 경고 hello 보조 hello 부하를 처리할 수 없는 것을 나타냅니다.</span><span class="sxs-lookup"><span data-stu-id="05be7-258">hello warning indicates that hello secondaries can't handle hello load.</span></span> <span data-ttu-id="05be7-259">Hello 큐 hello 최대 길이 도달 하는 경우 명령을 삭제 됩니다 오류가 보고 되, 서비스는 hello로 복구할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="05be7-259">If hello queue reaches hello maximum length and commands are dropped, an error is reported, as hello service can't recover.</span></span> <span data-ttu-id="05be7-260">hello 보고서에 있을 수 있습니다 hello 속성 **QueueStatus**합니다.</span><span class="sxs-lookup"><span data-stu-id="05be7-260">hello reports can be on hello property **QueueStatus**.</span></span> <span data-ttu-id="05be7-261">hello watchdog hello 서비스 내부 거주 하 고 hello 마스터 주 복제본에서 주기적으로 전송 됩니다.</span><span class="sxs-lookup"><span data-stu-id="05be7-261">hello watchdog lives inside hello service, and it's sent periodically on hello master primary replica.</span></span> <span data-ttu-id="05be7-262">toolive hello 시간이 2 분 이며 주기적으로 30 초 마다 전송 됩니다.</span><span class="sxs-lookup"><span data-stu-id="05be7-262">hello time toolive is two minutes, and it's sent periodically every 30 seconds.</span></span> <span data-ttu-id="05be7-263">기본 hello 다운 되 면 hello 보고서가 자동으로 정리 저장소에서.</span><span class="sxs-lookup"><span data-stu-id="05be7-263">If hello primary goes down, hello report is cleaned up automatically from store.</span></span> <span data-ttu-id="05be7-264">Hello 서비스 복제본 중일 하지만 교착 상태가 또는 hello 다른 문제가 발생 하는 경우 보고서 hello health store에서 만료 됩니다.</span><span class="sxs-lookup"><span data-stu-id="05be7-264">If hello service replica is up, but it is deadlocked or having other issues, hello report expires in hello health store.</span></span> <span data-ttu-id="05be7-265">이 경우 hello 엔터티 오류에서 평가 됩니다.</span><span class="sxs-lookup"><span data-stu-id="05be7-265">In this case, hello entity is evaluated at error.</span></span>

<span data-ttu-id="05be7-266">모니터링할 수 있는 또 다른 조건은 작업 수행 시간입니다.</span><span class="sxs-lookup"><span data-stu-id="05be7-266">Another condition that can be monitored is task execution time.</span></span> <span data-ttu-id="05be7-267">hello 마스터 작업을 분산 시키는 hello 작업 종류에 따라 toohello 보조 합니다.</span><span class="sxs-lookup"><span data-stu-id="05be7-267">hello master distributes tasks toohello secondaries based on hello task type.</span></span> <span data-ttu-id="05be7-268">Hello 디자인에 따라 hello 마스터 작업 상태에 대 한 hello 보조 복제본을 폴링할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="05be7-268">Depending on hello design, hello master could poll hello secondaries for task status.</span></span> <span data-ttu-id="05be7-269">끝날 때 보조 복제본 toosend 백 승인 신호는 않을 수도 없습니다.</span><span class="sxs-lookup"><span data-stu-id="05be7-269">It could also wait for secondaries toosend back acknowledgement signals when they are done.</span></span> <span data-ttu-id="05be7-270">Hello 두 번째 경우에 주의 해야 toodetect 상황 메시지 또는 보조 복제본이 손실된 됩니다.</span><span class="sxs-lookup"><span data-stu-id="05be7-270">In hello second case, care must be taken toodetect situations where secondaries die or messages are lost.</span></span> <span data-ttu-id="05be7-271">한 가지 방법은 hello 마스터 toosend ping 요청 toohello에 대 한 동일한 보조의 상태를 다시 전송 하는 합니다.</span><span class="sxs-lookup"><span data-stu-id="05be7-271">One option is for hello master toosend a ping request toohello same secondary, which sends back its status.</span></span> <span data-ttu-id="05be7-272">상태가 수신 되 면 hello 마스터 오류가 간주 하 고 hello 작업을 다시 예약 합니다.</span><span class="sxs-lookup"><span data-stu-id="05be7-272">If no status is received, hello master considers it a failure and reschedules hello task.</span></span> <span data-ttu-id="05be7-273">이 동작은 hello 작업 idempotent으로 간주 합니다.</span><span class="sxs-lookup"><span data-stu-id="05be7-273">This behavior assumes that hello tasks are idempotent.</span></span>

<span data-ttu-id="05be7-274">모니터링 하는 hello 조건 hello 작업은 특정 시간에 수행 되지 않을 경우 경고로 변환 될 수 있는 (**t1**, 예를 들어 10 분)입니다.</span><span class="sxs-lookup"><span data-stu-id="05be7-274">hello monitored condition can be translated as a warning if hello task is not done in a certain time (**t1**, for example 10 minutes).</span></span> <span data-ttu-id="05be7-275">Hello 작업 시간에 완료 되지 않은 경우 (**t2**, 예를 들어 20 분)을 모니터링 하는 hello 조건 오류로 변환 될 수 있는 합니다.</span><span class="sxs-lookup"><span data-stu-id="05be7-275">If hello task is not completed in time (**t2**, for example 20 minutes), hello monitored condition can be translated as Error.</span></span> <span data-ttu-id="05be7-276">이러한 보고는 여러 가지 방법으로 수행될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="05be7-276">This reporting can be done in multiple ways:</span></span>

* <span data-ttu-id="05be7-277">hello 마스터 주 복제본 자체에서 주기적으로 보고합니다.</span><span class="sxs-lookup"><span data-stu-id="05be7-277">hello master primary replica reports on itself periodically.</span></span> <span data-ttu-id="05be7-278">Hello 큐에 보류 중인 모든 작업에 대해 하나의 속성을 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="05be7-278">You can have one property for all pending tasks in hello queue.</span></span> <span data-ttu-id="05be7-279">더 많은 시간이 소요, hello hello 속성에서 상태를 보고 작업 하나 이상 경우 **PendingTasks** 경고 또는 오류를 적절 하 게 됩니다.</span><span class="sxs-lookup"><span data-stu-id="05be7-279">If at least one task takes longer, hello report status on hello property **PendingTasks** is a warning or error, as appropriate.</span></span> <span data-ttu-id="05be7-280">보류 중인 작업이 없습니다. 실행을 시작 하는 모든 작업, 상태를 보고 하는 hello 괜찮습니다.</span><span class="sxs-lookup"><span data-stu-id="05be7-280">If there are no pending tasks or all tasks started execution, hello report status is OK.</span></span> <span data-ttu-id="05be7-281">hello 작업은 영구적입니다.</span><span class="sxs-lookup"><span data-stu-id="05be7-281">hello tasks are persistent.</span></span> <span data-ttu-id="05be7-282">기본 hello 다운 되 면 새로 승격 hello 기본 tooreport 제대로 계속 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="05be7-282">If hello primary goes down, hello newly promoted primary can continue tooreport properly.</span></span>
* <span data-ttu-id="05be7-283">(Hello 클라우드 또는 외부)에 다른 watchdog 프로세스 hello 작업 확인 (에서 외부에 따라 필요한 hello 작업 결과) toosee 완료 될 경우.</span><span class="sxs-lookup"><span data-stu-id="05be7-283">Another watchdog process (in hello cloud or external) checks hello tasks (from outside, based on hello desired task result) toosee if they are completed.</span></span> <span data-ttu-id="05be7-284">또한 hello 임계값을 고려 하지 않는, 보고서 hello 마스터 서비스에 전송 됩니다.</span><span class="sxs-lookup"><span data-stu-id="05be7-284">If they do not respect hello thresholds, a report is sent on hello master service.</span></span> <span data-ttu-id="05be7-285">보고서가 같은 hello 작업 식별자를 포함 하는 각 작업에도 보내집니다 **PendingTask + taskId**합니다.</span><span class="sxs-lookup"><span data-stu-id="05be7-285">A report is also sent on each task that includes hello task identifier, like **PendingTask+taskId**.</span></span> <span data-ttu-id="05be7-286">비정상 상태에 대한 보고서만 전송되어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="05be7-286">Reports should be sent only on unhealthy states.</span></span> <span data-ttu-id="05be7-287">몇 분 정도 시간 toolive tooa를 설정 하 고 hello 보고서 toobe tooensure 정리 만료 시에 제거를 표시 합니다.</span><span class="sxs-lookup"><span data-stu-id="05be7-287">Set time toolive tooa few minutes, and mark hello reports toobe removed when they expire tooensure cleanup.</span></span>
* <span data-ttu-id="05be7-288">작업을 실행 하는 보조 hello 하기 시작 하면 예상된 toorun 보다 긴 것을 보고 합니다.</span><span class="sxs-lookup"><span data-stu-id="05be7-288">hello secondary that is executing a task reports when it takes longer than expected toorun it.</span></span> <span data-ttu-id="05be7-289">Hello 속성에 대 한 hello 서비스 인스턴스에서 보고 **PendingTasks**합니다.</span><span class="sxs-lookup"><span data-stu-id="05be7-289">It reports on hello service instance on hello property **PendingTasks**.</span></span> <span data-ttu-id="05be7-290">hello 보고서 정확히에 문제가 hello 서비스 인스턴스를 지정 하지만 여기서 hello 인스턴스 끊어질 hello 상황을 캡처하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="05be7-290">hello report pinpoints hello service instance that has issues, but it doesn't capture hello situation where hello instance dies.</span></span> <span data-ttu-id="05be7-291">hello 보고서 후 정리 됩니다.</span><span class="sxs-lookup"><span data-stu-id="05be7-291">hello reports are cleaned up then.</span></span> <span data-ttu-id="05be7-292">이 hello 보조 서비스에 보고할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="05be7-292">It could report on hello secondary service.</span></span> <span data-ttu-id="05be7-293">보조 hello hello 작업을 완료 하는 경우 hello 보조 인스턴스로 hello 저장소에서 hello 보고서를 지웁니다.</span><span class="sxs-lookup"><span data-stu-id="05be7-293">If hello secondary completes hello task, hello secondary instance clears hello report from hello store.</span></span> <span data-ttu-id="05be7-294">hello 보고서 hello 승인 메시지가 손실 되 고 hello 마스터의 관점에서 hello 작업이 끝나지 않으면 hello 상황이 캡처하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="05be7-294">hello report doesn't capture hello situation where hello acknowledgement message is lost and hello task is not finished from hello master's point of view.</span></span>

<span data-ttu-id="05be7-295">하지만 위에서 설명한 hello 경우 hello 보고 완료 된 상태를 계산할 때 hello 보고서 응용 프로그램 상태에 캡처됩니다.</span><span class="sxs-lookup"><span data-stu-id="05be7-295">However hello reporting is done in hello cases described above, hello reports are captured in application health when health is evaluated.</span></span>

## <a name="report-periodically-vs-on-transition"></a><span data-ttu-id="05be7-296">주기적 보고 대 전환기 보고</span><span class="sxs-lookup"><span data-stu-id="05be7-296">Report periodically vs. on transition</span></span>
<span data-ttu-id="05be7-297">Hello 상태 보고 모델을 사용 하 여 watchdogs 정기적으로 또는 전환에 보고서를 보낼 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="05be7-297">By using hello health reporting model, watchdogs can send reports periodically or on transitions.</span></span> <span data-ttu-id="05be7-298">hello는 hello 코드에 훨씬 더 간단 하 고 발생할 가능성이 적으므로 tooerrors 이므로 보고 watchdog 방법은 정기적으로 좋습니다.</span><span class="sxs-lookup"><span data-stu-id="05be7-298">hello recommended way for watchdog reporting is periodically, because hello code is much simpler and less prone tooerrors.</span></span> <span data-ttu-id="05be7-299">hello watchdogs toobe 잘못 된 보고서를 트리거하는 가능한 tooavoid 버그 단순하게 하기 위해 노력 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="05be7-299">hello watchdogs must strive toobe as simple as possible tooavoid bugs that trigger incorrect reports.</span></span> <span data-ttu-id="05be7-300">잘못된 *비정상* 보고서는 상태 평가에 영향을 미치고 업그레이드를 비롯한 상태 기반 시나리오에도 영향을 미칩니다.</span><span class="sxs-lookup"><span data-stu-id="05be7-300">Incorrect *unhealthy* reports impact health evaluations and scenarios based on health, including upgrades.</span></span> <span data-ttu-id="05be7-301">잘못 된 *정상* 보고서 원하지 않는 hello 클러스터의 문제를 숨깁니다.</span><span class="sxs-lookup"><span data-stu-id="05be7-301">Incorrect *healthy* reports hide issues in hello cluster, which is not desired.</span></span>

<span data-ttu-id="05be7-302">정기적으로 보고에 대 한 hello watchdog 타이머와 함께 구현할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="05be7-302">For periodic reporting, hello watchdog can be implemented with a timer.</span></span> <span data-ttu-id="05be7-303">타이머 콜백 hello watchdog hello 상태를 확인 하 고 hello 현재 상태에 따라 보고서를 보낼 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="05be7-303">On a timer callback, hello watchdog can check hello state and send a report based on hello current state.</span></span> <span data-ttu-id="05be7-304">보고서를 이전에 보낸 또는 메시징 관점에서 모든 최적화할 필요가 toosee 없습니다 있습니다.</span><span class="sxs-lookup"><span data-stu-id="05be7-304">There is no need toosee which report was sent previously or make any optimizations in terms of messaging.</span></span> <span data-ttu-id="05be7-305">hello 상태 클라이언트 성능으로 논리 toohelp 일괄 처리에 있습니다.</span><span class="sxs-lookup"><span data-stu-id="05be7-305">hello health client has batching logic toohelp with performance.</span></span> <span data-ttu-id="05be7-306">Hello 상태 클라이언트는 유지 하는 동안 다시 시도 하기 내부적으로 hello watchdog hello 사용 하 여 새 보고서를 생성 하거나 hello health store에서 hello 보고서를 승인할 때까지 동일한 엔터티, 속성 및 소스입니다.</span><span class="sxs-lookup"><span data-stu-id="05be7-306">While hello health client is kept alive, it retries internally until hello report is acknowledged by hello health store or hello watchdog generates a newer report with hello same entity, property, and source.</span></span>

<span data-ttu-id="05be7-307">전환기 보고는 꼼꼼한 상태 처리가 필요합니다.</span><span class="sxs-lookup"><span data-stu-id="05be7-307">Reporting on transitions requires careful handling of state.</span></span> <span data-ttu-id="05be7-308">hello watchdog는 몇 가지 조건을 모니터링 하 고 hello 조건이 변경 될 때에 보고 합니다.</span><span class="sxs-lookup"><span data-stu-id="05be7-308">hello watchdog monitors some conditions and reports only when hello conditions change.</span></span> <span data-ttu-id="05be7-309">이 방식의 거꾸로 hello 적은 보고서가 필요한입니다.</span><span class="sxs-lookup"><span data-stu-id="05be7-309">hello upside of this approach is that fewer reports are needed.</span></span> <span data-ttu-id="05be7-310">hello 단점은 hello watchdog의 hello 논리는 복잡 합니다.</span><span class="sxs-lookup"><span data-stu-id="05be7-310">hello downside is that hello logic of hello watchdog is complex.</span></span> <span data-ttu-id="05be7-311">hello watchdog 검사 toodetermine 상태가 변경 될 수 있도록 hello 조건 또는 hello 보고서를 유지 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="05be7-311">hello watchdog must maintain hello conditions or hello reports, so that they can be inspected toodetermine state changes.</span></span> <span data-ttu-id="05be7-312">장애 조치 시 주의 해야 보고서 추가 되었지만 아직 toohello 상태 저장소를 전송 합니다.</span><span class="sxs-lookup"><span data-stu-id="05be7-312">On failover, care must be taken with reports added, but not yet sent toohello health store.</span></span> <span data-ttu-id="05be7-313">hello 시퀀스 번호에는 계속 해 서 증가 사용 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="05be7-313">hello sequence number must be ever-increasing.</span></span> <span data-ttu-id="05be7-314">그렇지 않은 경우 hello 보고서 부실으로 거부 됩니다.</span><span class="sxs-lookup"><span data-stu-id="05be7-314">If not, hello reports are rejected as stale.</span></span> <span data-ttu-id="05be7-315">Hello 드문 경우 지만 데이터 손실이 발생 하는 hello 보고자의 hello 상태와 hello 상태 저장소의 hello 상태 간의 동기화를 필요할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="05be7-315">In hello rare cases where data loss is incurred, synchronization may be needed between hello state of hello reporter and hello state of hello health store.</span></span>

<span data-ttu-id="05be7-316">전환에 대한 보고는 `Partition` 또는 `CodePackageActivationContext`를 통한 자체에 대한 서비스 보고에 적합합니다.</span><span class="sxs-lookup"><span data-stu-id="05be7-316">Reporting on transitions makes sense for services reporting on themselves, through `Partition` or `CodePackageActivationContext`.</span></span> <span data-ttu-id="05be7-317">경우 로컬 개체를 hello (복제 또는 배포 된 서비스 패키지 응용 프로그램 배포 /)가 제거 모든 보고서도 제거 됩니다.</span><span class="sxs-lookup"><span data-stu-id="05be7-317">When hello local object (replica or deployed service package / deployed application) is removed, all its reports are also removed.</span></span> <span data-ttu-id="05be7-318">이 자동 정리 보고자와 상태 저장소 간의 동기화에 대 한 hello 필요성은 완화합니다.</span><span class="sxs-lookup"><span data-stu-id="05be7-318">This automatic cleanup relaxes hello need for synchronization between reporter and health store.</span></span> <span data-ttu-id="05be7-319">Hello 보고서 부모 파티션 또는 부모 응용 프로그램에 대 한 경우 주의 해야 hello health store에서 장애 조치 tooavoid 오래 된 보고서에 있습니다.</span><span class="sxs-lookup"><span data-stu-id="05be7-319">If hello report is for parent partition or parent application, care must be taken on failover tooavoid stale reports in hello health store.</span></span> <span data-ttu-id="05be7-320">논리는 더 이상 필요 하지 않은 경우 저장소에서 toomaintain hello에 대 한 올바른 상태 및 지우기 hello 보고서 추가 되어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="05be7-320">Logic must be added toomaintain hello correct state and clear hello report from store when not needed anymore.</span></span>

## <a name="implement-health-reporting"></a><span data-ttu-id="05be7-321">상태 보고 구현</span><span class="sxs-lookup"><span data-stu-id="05be7-321">Implement health reporting</span></span>
<span data-ttu-id="05be7-322">Hello 엔터티 및 보고서 세부 정보를 분명히 되 면 상태 보고서를 보내는 통해 수행할 수 있습니다 hello API, PowerShell 또는 REST 합니다.</span><span class="sxs-lookup"><span data-stu-id="05be7-322">Once hello entity and report details are clear, sending health reports can be done through hello API, PowerShell, or REST.</span></span>

### <a name="api"></a><span data-ttu-id="05be7-323">API</span><span class="sxs-lookup"><span data-stu-id="05be7-323">API</span></span>
<span data-ttu-id="05be7-324">hello API 통해 tooreport, toocreate tooreport에서 원하는 상태 보고서 특정 toohello 엔터티 형식이 필요 합니다.</span><span class="sxs-lookup"><span data-stu-id="05be7-324">tooreport through hello API, you need toocreate a health report specific toohello entity type they want tooreport on.</span></span> <span data-ttu-id="05be7-325">Hello 보고서 tooa 상태 클라이언트를 지정 합니다.</span><span class="sxs-lookup"><span data-stu-id="05be7-325">Give hello report tooa health client.</span></span> <span data-ttu-id="05be7-326">또는 상태 정보를 만들고 전달에 보고 하는 방법을 toocorrect `Partition` 또는 `CodePackageActivationContext` 현재 엔터티에 대해 tooreport 합니다.</span><span class="sxs-lookup"><span data-stu-id="05be7-326">Alternatively, create a health information and pass it toocorrect reporting methods on `Partition` or `CodePackageActivationContext` tooreport on current entities.</span></span>

<span data-ttu-id="05be7-327">hello 다음 예제에서는 hello 클러스터 내에서 감시에서 보고 주기</span><span class="sxs-lookup"><span data-stu-id="05be7-327">hello following example shows periodic reporting from a watchdog within hello cluster.</span></span> <span data-ttu-id="05be7-328">hello watchdog 노드 내에서 외부 리소스를 액세스할 수 있는지 여부를 확인 합니다.</span><span class="sxs-lookup"><span data-stu-id="05be7-328">hello watchdog checks whether an external resource can be accessed from within a node.</span></span> <span data-ttu-id="05be7-329">hello 응용 프로그램 내에서 서비스 매니페스트에서 hello 리소스가 필요 합니다.</span><span class="sxs-lookup"><span data-stu-id="05be7-329">hello resource is needed by a service manifest within hello application.</span></span> <span data-ttu-id="05be7-330">Hello 리소스를 사용할 수 없는 경우 hello hello 응용 프로그램 내에서 다른 서비스 수 계속 적절히 기능 합니다.</span><span class="sxs-lookup"><span data-stu-id="05be7-330">If hello resource is unavailable, hello other services within hello application can still function properly.</span></span> <span data-ttu-id="05be7-331">따라서 30 초 마다 hello 보고서 배포 된 hello 서비스 패키지 엔터티에 전송 됩니다.</span><span class="sxs-lookup"><span data-stu-id="05be7-331">Therefore, hello report is sent on hello deployed service package entity every 30 seconds.</span></span>

```csharp
private static Uri ApplicationName = new Uri("fabric:/WordCount");
private static string ServiceManifestName = "WordCount.Service";
private static string NodeName = FabricRuntime.GetNodeContext().NodeName;
private static Timer ReportTimer = new Timer(new TimerCallback(SendReport), null, 30 * 1000, 30 * 1000);
private static FabricClient Client = new FabricClient(new FabricClientSettings() { HealthReportSendInterval = TimeSpan.FromSeconds(0) });

public static void SendReport(object obj)
{
    // Test whether hello resource can be accessed from hello node
    HealthState healthState = this.TestConnectivityToExternalResource();

    // Send report on deployed service package, as hello connectivity is needed by hello specific service manifest
    // and can be different on different nodes
    var deployedServicePackageHealthReport = new DeployedServicePackageHealthReport(
        ApplicationName,
        ServiceManifestName,
        NodeName,
        new HealthInformation("ExternalSourceWatcher", "Connectivity", healthState));

    // TODO: handle exception. Code omitted for snippet brevity.
    // Possible exceptions: FabricException with error codes
    // FabricHealthStaleReport (non-retryable, hello report is already queued on hello health client),
    // FabricHealthMaxReportsReached (retryable; user should retry with exponential delay until hello report is accepted).
    Client.HealthManager.ReportHealth(deployedServicePackageHealthReport);
}
```

### <a name="powershell"></a><span data-ttu-id="05be7-332">PowerShell</span><span class="sxs-lookup"><span data-stu-id="05be7-332">PowerShell</span></span>
<span data-ttu-id="05be7-333">**Send-ServiceFabric*EntityType*HealthReport**를 사용하여 상태 보고서를 보냅니다.</span><span class="sxs-lookup"><span data-stu-id="05be7-333">Send health reports with **Send-ServiceFabric*EntityType*HealthReport**.</span></span>

<span data-ttu-id="05be7-334">hello 다음 예제에서는 노드의 CPU 값에 대 한 보고 주기</span><span class="sxs-lookup"><span data-stu-id="05be7-334">hello following example shows periodic reporting on CPU values on a node.</span></span> <span data-ttu-id="05be7-335">hello 보고서에 30 초 마다 전송 해야 하 고 한 번 2 분 toolive를 갖습니다.</span><span class="sxs-lookup"><span data-stu-id="05be7-335">hello reports should be sent every 30 seconds, and they have a time toolive of two minutes.</span></span> <span data-ttu-id="05be7-336">만료 될 경우 hello 보고자에 있으므로 hello 노드 오류에서 평가 되 문제.</span><span class="sxs-lookup"><span data-stu-id="05be7-336">If they expire, hello reporter has issues, so hello node is evaluated at error.</span></span> <span data-ttu-id="05be7-337">Hello CPU 임계값 보다 크면 때 hello 보고서 경고의 성능 상태를 있습니다.</span><span class="sxs-lookup"><span data-stu-id="05be7-337">When hello CPU is above a threshold, hello report has a health state of warning.</span></span> <span data-ttu-id="05be7-338">Hello 구성 된 시간 보다 나중에 대 한 hello CPU 임계값 보다 높게 유지 되는 오류로 보고 됩니다.</span><span class="sxs-lookup"><span data-stu-id="05be7-338">When hello CPU remains above a threshold for more than hello configured time, it's reported as an error.</span></span> <span data-ttu-id="05be7-339">그렇지 않으면 hello 보고자 확인의 성능 상태를 보냅니다.</span><span class="sxs-lookup"><span data-stu-id="05be7-339">Otherwise, hello reporter sends a health state of OK.</span></span>

```powershell
PS C:\> Send-ServiceFabricNodeHealthReport -NodeName Node.1 -HealthState Warning -SourceId PowershellWatcher -HealthProperty CPU -Description "CPU is above 80% threshold" -TimeToLiveSec 120

PS C:\> Get-ServiceFabricNodeHealth -NodeName Node.1
NodeName              : Node.1
AggregatedHealthState : Warning
UnhealthyEvaluations  :
                        Unhealthy event: SourceId='PowershellWatcher', Property='CPU', HealthState='Warning', ConsiderWarningAsError=false.

HealthEvents          :
                        SourceId              : System.FM
                        Property              : State
                        HealthState           : Ok
                        SequenceNumber        : 5
                        SentAt                : 4/21/2015 8:01:17 AM
                        ReceivedAt            : 4/21/2015 8:02:12 AM
                        TTL                   : Infinite
                        Description           : Fabric node is up.
                        RemoveWhenExpired     : False
                        IsExpired             : False
                        Transitions           : ->Ok = 4/21/2015 8:02:12 AM

                        SourceId              : PowershellWatcher
                        Property              : CPU
                        HealthState           : Warning
                        SequenceNumber        : 130741236814913394
                        SentAt                : 4/21/2015 9:01:21 PM
                        ReceivedAt            : 4/21/2015 9:01:21 PM
                        TTL                   : 00:02:00
                        Description           : CPU is above 80% threshold
                        RemoveWhenExpired     : False
                        IsExpired             : False
                        Transitions           : ->Warning = 4/21/2015 9:01:21 PM
```

<span data-ttu-id="05be7-340">hello 다음 예제에서는 경고를 보고 일시적인 복제 합니다.</span><span class="sxs-lookup"><span data-stu-id="05be7-340">hello following example reports a transient warning on a replica.</span></span> <span data-ttu-id="05be7-341">먼저 hello 파티션 ID를 가져오고에 관심 있는 hello 서비스에 대 한 복제 ID를 hello 합니다.</span><span class="sxs-lookup"><span data-stu-id="05be7-341">It first gets hello partition ID and then hello replica ID for hello service it is interested in.</span></span> <span data-ttu-id="05be7-342">다음에서 보고서를 보내기 **PowershellWatcher** hello 속성에 **ResourceDependency**합니다.</span><span class="sxs-lookup"><span data-stu-id="05be7-342">It then sends a report from **PowershellWatcher** on hello property **ResourceDependency**.</span></span> <span data-ttu-id="05be7-343">hello 보고서 2 분만에 대 한 관심 있는 하 고 hello 저장소에서 자동으로 제거 됩니다.</span><span class="sxs-lookup"><span data-stu-id="05be7-343">hello report is of interest for only two minutes, and it is removed from hello store automatically.</span></span>

```powershell
PS C:\> $partitionId = (Get-ServiceFabricPartition -ServiceName fabric:/WordCount/WordCount.Service).PartitionId

PS C:\> $replicaId = (Get-ServiceFabricReplica -PartitionId $partitionId | where {$_.ReplicaRole -eq "Primary"}).ReplicaId

PS C:\> Send-ServiceFabricReplicaHealthReport -PartitionId $partitionId -ReplicaId $replicaId -HealthState Warning -SourceId PowershellWatcher -HealthProperty ResourceDependency -Description "hello external resource that hello primary is using has been rebooted at 4/21/2015 9:01:21 PM. Expect processing delays for a few minutes." -TimeToLiveSec 120 -RemoveWhenExpired

PS C:\> Get-ServiceFabricReplicaHealth  -PartitionId $partitionId -ReplicaOrInstanceId $replicaId


PartitionId           : 8f82daff-eb68-4fd9-b631-7a37629e08c0
ReplicaId             : 130740415594605869
AggregatedHealthState : Warning
UnhealthyEvaluations  :
                        Unhealthy event: SourceId='PowershellWatcher', Property='ResourceDependency', HealthState='Warning', ConsiderWarningAsError=false.

HealthEvents          :
                        SourceId              : System.RA
                        Property              : State
                        HealthState           : Ok
                        SequenceNumber        : 130740768777734943
                        SentAt                : 4/21/2015 8:01:17 AM
                        ReceivedAt            : 4/21/2015 8:02:12 AM
                        TTL                   : Infinite
                        Description           : Replica has been created.
                        RemoveWhenExpired     : False
                        IsExpired             : False
                        Transitions           : ->Ok = 4/21/2015 8:02:12 AM

                        SourceId              : PowershellWatcher
                        Property              : ResourceDependency
                        HealthState           : Warning
                        SequenceNumber        : 130741243777723555
                        SentAt                : 4/21/2015 9:12:57 PM
                        ReceivedAt            : 4/21/2015 9:12:57 PM
                        TTL                   : 00:02:00
                        Description           : hello external resource that hello primary is using has been rebooted at 4/21/2015 9:01:21 PM. Expect processing delays for a few minutes.
                        RemoveWhenExpired     : True
                        IsExpired             : False
                        Transitions           : ->Warning = 4/21/2015 9:12:32 PM
```

### <a name="rest"></a><span data-ttu-id="05be7-344">REST (영문)</span><span class="sxs-lookup"><span data-stu-id="05be7-344">REST</span></span>
<span data-ttu-id="05be7-345">REST를 사용 하 여 원하는 toohello 엔터티를 이동 하 고 hello 본문 hello 상태 보고서 설명 하는 POST 요청에 상태 보고서를 보냅니다.</span><span class="sxs-lookup"><span data-stu-id="05be7-345">Send health reports using REST with POST requests that go toohello desired entity and have in hello body hello health report description.</span></span> <span data-ttu-id="05be7-346">예를 들어 toosend 놓으면 방법을 참조 [상태 보고서 클러스터](https://docs.microsoft.com/rest/api/servicefabric/report-the-health-of-a-cluster) 또는 [서비스 상태 보고서](https://docs.microsoft.com/rest/api/servicefabric/report-the-health-of-a-service)합니다.</span><span class="sxs-lookup"><span data-stu-id="05be7-346">For example, see how toosend REST [cluster health reports](https://docs.microsoft.com/rest/api/servicefabric/report-the-health-of-a-cluster) or [service health reports](https://docs.microsoft.com/rest/api/servicefabric/report-the-health-of-a-service).</span></span> <span data-ttu-id="05be7-347">모든 엔터티가 지원됩니다.</span><span class="sxs-lookup"><span data-stu-id="05be7-347">All entities are supported.</span></span>

## <a name="next-steps"></a><span data-ttu-id="05be7-348">다음 단계</span><span class="sxs-lookup"><span data-stu-id="05be7-348">Next steps</span></span>
<span data-ttu-id="05be7-349">Hello 상태 데이터에 따라 서비스 작성자와 클러스터/응용 프로그램 관리자 방법으로 tooconsume hello 정보의 생각할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="05be7-349">Based on hello health data, service writers and cluster/application administrators can think of ways tooconsume hello information.</span></span> <span data-ttu-id="05be7-350">예를 들어 중단을 유도 하기 전에 상태 상태 toocatch 심각한 문제에 따라 경고를 설정할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="05be7-350">For example, they can set up alerts based on health status toocatch severe issues before they provoke outages.</span></span> <span data-ttu-id="05be7-351">관리자 자동으로 복구 시스템 toofix 문제를 설정할 수도 있습니다.</span><span class="sxs-lookup"><span data-stu-id="05be7-351">Administrators can also set up repair systems toofix issues automatically.</span></span>

[<span data-ttu-id="05be7-352">소개 tooService 패브릭 상태 모니터링</span><span class="sxs-lookup"><span data-stu-id="05be7-352">Introduction tooService Fabric health Monitoring</span></span>](service-fabric-health-introduction.md)

[<span data-ttu-id="05be7-353">서비스 패브릭 상태 보고서 보기</span><span class="sxs-lookup"><span data-stu-id="05be7-353">View Service Fabric health reports</span></span>](service-fabric-view-entities-aggregated-health.md)

[<span data-ttu-id="05be7-354">어떻게 tooreport 및 확인 서비스 상태</span><span class="sxs-lookup"><span data-stu-id="05be7-354">How tooreport and check service health</span></span>](service-fabric-diagnostics-how-to-report-and-check-service-health.md)

[<span data-ttu-id="05be7-355">시스템 상태 보고서를 문제 해결에 사용</span><span class="sxs-lookup"><span data-stu-id="05be7-355">Use system health reports for troubleshooting</span></span>](service-fabric-understand-and-troubleshoot-with-system-health-reports.md)

[<span data-ttu-id="05be7-356">로컬로 서비스 모니터링 및 진단</span><span class="sxs-lookup"><span data-stu-id="05be7-356">Monitor and diagnose services locally</span></span>](service-fabric-diagnostics-how-to-monitor-and-diagnose-services-locally.md)

[<span data-ttu-id="05be7-357">서비스 패브릭 응용 프로그램 업그레이드</span><span class="sxs-lookup"><span data-stu-id="05be7-357">Service Fabric application upgrade</span></span>](service-fabric-application-upgrade.md)

