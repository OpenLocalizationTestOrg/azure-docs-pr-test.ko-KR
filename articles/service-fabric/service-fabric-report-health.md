---
title: "사용자 지정 Service Fabric 상태 보고서 추가 | Microsoft Docs"
description: "Azure 서비스 패브릭 상태 엔터티에 사용자 지정 상태 보고서를 보내는 방법을 설명합니다. 고품질 상태 보고서 설계 및 구현에 대한 권장 사항을 제공합니다."
services: service-fabric
documentationcenter: .net
author: oanapl
manager: timlt
editor: 
ms.assetid: 0a00a7d2-510e-47d0-8aa8-24c851ea847f
ms.service: service-fabric
ms.devlang: dotnet
ms.topic: article
ms.tgt_pltfrm: na
ms.workload: na
ms.date: 07/19/2017
ms.author: oanapl
ms.openlocfilehash: ed10eef347d4d93012078456b3a145589e66d30e
ms.sourcegitcommit: 50e23e8d3b1148ae2d36dad3167936b4e52c8a23
ms.translationtype: MT
ms.contentlocale: ko-KR
ms.lasthandoff: 08/18/2017
---
# <a name="add-custom-service-fabric-health-reports"></a><span data-ttu-id="460d6-104">사용자 지정 서비스 패브릭 상태 보고서 추가</span><span class="sxs-lookup"><span data-stu-id="460d6-104">Add custom Service Fabric health reports</span></span>
<span data-ttu-id="460d6-105">Azure 서비스 패브릭은 특정 엔터티의 비정상 클러스터 및 응용 프로그램 상태에 플래그를 적용하도록 설계된 [상태 모델](service-fabric-health-introduction.md)을 도입했습니다.</span><span class="sxs-lookup"><span data-stu-id="460d6-105">Azure Service Fabric introduces a [health model](service-fabric-health-introduction.md) designed to flag unhealthy cluster and application conditions on specific entities.</span></span> <span data-ttu-id="460d6-106">상태 모델은 **Health 보고서** (시스템 구성 요소 및 Watchdog)를 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="460d6-106">The health model uses **health reporters** (system components and watchdogs).</span></span> <span data-ttu-id="460d6-107">쉽고 빠른 진단을 목표로 합니다.</span><span class="sxs-lookup"><span data-stu-id="460d6-107">The goal is easy and fast diagnosis and repair.</span></span> <span data-ttu-id="460d6-108">서비스 작성자는 상태를 미리 고려해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="460d6-108">Service writers need to think upfront about health.</span></span> <span data-ttu-id="460d6-109">상태에 영향을 줄 수 있는 모든 조건이 보고되어야 하며, 특히 근본 원인에 가까운 문제를 플래깅하는 데 도움이 되는 경우에는 반드시 보고가 이루어져야 합니다.</span><span class="sxs-lookup"><span data-stu-id="460d6-109">Any condition that can impact health should be reported on, especially if it can help flag problems close to the root.</span></span> <span data-ttu-id="460d6-110">상태 정보는 디버깅 및 조사에 소요되는 시간과 노력을 절감할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="460d6-110">The health information can save time and effort on debugging and investigation.</span></span> <span data-ttu-id="460d6-111">특히 서비스가 클라우드에서 대용량으로 가동 및 실행될 때 확실히 유용합니다(사설 또는 Azure).</span><span class="sxs-lookup"><span data-stu-id="460d6-111">The usefulness is especially clear once the service is up and running at scale in the cloud (private or Azure).</span></span>

<span data-ttu-id="460d6-112">서비스 패브릭 보고자는 식별된 관심 조건을 모니터링합니다.</span><span class="sxs-lookup"><span data-stu-id="460d6-112">The Service Fabric reporters monitor identified conditions of interest.</span></span> <span data-ttu-id="460d6-113">보고자는 각자 로컬 보기를 기반으로 이러한 조건에 대한 정보를 보고합니다.</span><span class="sxs-lookup"><span data-stu-id="460d6-113">They report on those conditions based on their local view.</span></span> <span data-ttu-id="460d6-114">[Health 스토어](service-fabric-health-introduction.md#health-store) 는 엔터티가 전체적으로 정상인지를 판단하기 위하여 모든 보고자가 보낸 상태 데이터를 수집합니다.</span><span class="sxs-lookup"><span data-stu-id="460d6-114">The [health store](service-fabric-health-introduction.md#health-store) aggregates health data sent by all reporters to determine whether entities are globally healthy.</span></span> <span data-ttu-id="460d6-115">모델은 다양하고 유연하며 사용이 쉽도록 계획됩니다.</span><span class="sxs-lookup"><span data-stu-id="460d6-115">The model is intended to be rich, flexible, and easy to use.</span></span> <span data-ttu-id="460d6-116">상태 보고서의 품질은 클러스터 상태 보기의 정확성을 결정합니다.</span><span class="sxs-lookup"><span data-stu-id="460d6-116">The quality of the health reports determines the accuracy of the health view of the cluster.</span></span> <span data-ttu-id="460d6-117">비정상 이슈를 잘못 표시하는 거짓 긍정은 상태 데이터를 사용하는 업그레이드 또는 기타 서비스에 부정적인 영향을 미칠 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="460d6-117">False positives that wrongly show unhealthy issues can negatively impact upgrades or other services that use health data.</span></span> <span data-ttu-id="460d6-118">이러한 서비스의 예로는 복구 서비스 및 경고 메커니즘이 있습니다.</span><span class="sxs-lookup"><span data-stu-id="460d6-118">Examples of such services are repair services and alerting mechanisms.</span></span> <span data-ttu-id="460d6-119">따라서 최선의 방식으로 관심 조건을 포착하는 보고서를 제공하기 위해서는 몇 가지를 고려해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="460d6-119">Therefore, some thought is needed to provide reports that capture conditions of interest in the best possible way.</span></span>

<span data-ttu-id="460d6-120">상태 보고를 설계하고 구현하기 위하여 Watchdog 및 시스템 구성 요소는 다음을 수행해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="460d6-120">To design and implement health reporting, watchdogs and system components must:</span></span>

* <span data-ttu-id="460d6-121">관심 있는 조건, 해당 조건을 모니터링하는 방식, 클러스터 또는 응용 프로그램 기능에 미치는 영향을 정의합니다.</span><span class="sxs-lookup"><span data-stu-id="460d6-121">Define the condition they are interested in, the way it is monitored, and the impact on the cluster or application functionality.</span></span> <span data-ttu-id="460d6-122">이 정보를 기반으로 상태 보고서 속성 및 상태를 판단합니다.</span><span class="sxs-lookup"><span data-stu-id="460d6-122">Based on this information, decide on the health report property and health state.</span></span>
* <span data-ttu-id="460d6-123">보고서가 적용되는 [엔터티](service-fabric-health-introduction.md#health-entities-and-hierarchy) 를 정의합니다.</span><span class="sxs-lookup"><span data-stu-id="460d6-123">Determine the [entity](service-fabric-health-introduction.md#health-entities-and-hierarchy) that the report applies to.</span></span>
* <span data-ttu-id="460d6-124">보고를 서비스 내에서 수행할 것인지 아니면 내부 또는 외부 Watchdog에서 수행할 것인지 보고 위치를 정의합니다.</span><span class="sxs-lookup"><span data-stu-id="460d6-124">Determine where the reporting is done, from within the service or from an internal or external watchdog.</span></span>
* <span data-ttu-id="460d6-125">보고자를 식별하는데 사용할 소스를 정의합니다.</span><span class="sxs-lookup"><span data-stu-id="460d6-125">Define a source used to identify the reporter.</span></span>
* <span data-ttu-id="460d6-126">주기적 또는 전환기 중에서 보고 전략을 선택합니다.</span><span class="sxs-lookup"><span data-stu-id="460d6-126">Choose a reporting strategy, either periodically or on transitions.</span></span> <span data-ttu-id="460d6-127">주기적 방식을 선택하면 코드가 더 간단하고 오류가 발생할 가능성이 적기 때문에 주기적 방식을 권장합니다.</span><span class="sxs-lookup"><span data-stu-id="460d6-127">The recommended way is periodically, as it requires simpler code and is less prone to errors.</span></span>
* <span data-ttu-id="460d6-128">비정상 조건에 대한 보고서를 Health 스토어에 보관할 기간과 보고서를 지우는 방식을 결정합니다.</span><span class="sxs-lookup"><span data-stu-id="460d6-128">Determine how long the report for unhealthy conditions should stay in the health store and how it should be cleared.</span></span> <span data-ttu-id="460d6-129">이 정보를 사용하여 보고서의 지속 시간 및 만료 시 제거 동작을 결정합니다.</span><span class="sxs-lookup"><span data-stu-id="460d6-129">Using this information, decide the report's time to live and remove-on-expiration behavior.</span></span>

<span data-ttu-id="460d6-130">언급된 바와 같이, 보고가 가능한 위치는 다음과 같습니다.</span><span class="sxs-lookup"><span data-stu-id="460d6-130">As mentioned, reporting can be done from:</span></span>

* <span data-ttu-id="460d6-131">모니터링되는 서비스 패브릭 서비스 복제본.</span><span class="sxs-lookup"><span data-stu-id="460d6-131">The monitored Service Fabric service replica.</span></span>
* <span data-ttu-id="460d6-132">Service Fabric 서비스로 배포되는 내부 Watchdog(예: 조건 및 문제 보고서를 모니터링하는 Service Fabric 상태 비저장 서비스).</span><span class="sxs-lookup"><span data-stu-id="460d6-132">Internal watchdogs deployed as a Service Fabric service (for example, a Service Fabric stateless service that monitors conditions and issues reports).</span></span> <span data-ttu-id="460d6-133">Watchdog는 모든 노드에 배포되거나 모니터링되는 서비스로 규합될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="460d6-133">The watchdogs can be deployed an all nodes or can be affinitized to the monitored service.</span></span>
* <span data-ttu-id="460d6-134">서비스 패브릭 노드에서 실행되지만 서비스 패브릭 서비스로 구현되지 *않는* 내부 watchdog.</span><span class="sxs-lookup"><span data-stu-id="460d6-134">Internal watchdogs that run on the Service Fabric nodes but are *not* implemented as Service Fabric services.</span></span>
* <span data-ttu-id="460d6-135">Service Fabric 클러스터 *외부* 의 리소스를 조사하는 외부 Watchdog(예: Gomez와 같은 모니터링 서비스).</span><span class="sxs-lookup"><span data-stu-id="460d6-135">External watchdogs that probe the resource from *outside* the Service Fabric cluster (for example, monitoring service like Gomez).</span></span>

> [!NOTE]
> <span data-ttu-id="460d6-136">기본적으로, 클러스터는 시스템 구성 요소에 의해 전송되는 상태 보고서로 채워집니다.</span><span class="sxs-lookup"><span data-stu-id="460d6-136">Out of the box, the cluster is populated with health reports sent by the system components.</span></span> <span data-ttu-id="460d6-137">추가 정보는 [시스템 상태 보고서를 사용하여 문제 해결](service-fabric-understand-and-troubleshoot-with-system-health-reports.md)을 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="460d6-137">Read more at [Using system health reports for troubleshooting](service-fabric-understand-and-troubleshoot-with-system-health-reports.md).</span></span> <span data-ttu-id="460d6-138">사용자 보고서는 시스템에 의해 이미 생성된 [상태 엔터티](service-fabric-health-introduction.md#health-entities-and-hierarchy) 로 보내야 합니다.</span><span class="sxs-lookup"><span data-stu-id="460d6-138">The user reports must be sent on [health entities](service-fabric-health-introduction.md#health-entities-and-hierarchy) that have already been created by the system.</span></span>
> 
> 

<span data-ttu-id="460d6-139">상태 보고 설계가 명확하면 상태 보고서를 간편하게 보낼 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="460d6-139">Once the health reporting design is clear, health reports can be sent easily.</span></span> <span data-ttu-id="460d6-140">클러스터가 [보안](service-fabric-cluster-security.md) 상태가 아니거나 패브릭 클라이언트에 관리자 권한이 있는 경우 [FabricClient](https://docs.microsoft.com/dotnet/api/system.fabric.fabricclient)를 사용하여 상태를 보고할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="460d6-140">You can use [FabricClient](https://docs.microsoft.com/dotnet/api/system.fabric.fabricclient) to report health if the cluster is not [secure](service-fabric-cluster-security.md) or if the fabric client has admin privileges.</span></span> <span data-ttu-id="460d6-141">보고는 PowerShell 또는 REST를 통해 [FabricClient.HealthManager.ReportHealth](https://docs.microsoft.com/dotnet/api/system.fabric.fabricclient.healthclient.reporthealth)를 사용하여 API를 통해 수행할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="460d6-141">Reporting can be done through the API by using [FabricClient.HealthManager.ReportHealth](https://docs.microsoft.com/dotnet/api/system.fabric.fabricclient.healthclient.reporthealth), through PowerShell, or through REST.</span></span> <span data-ttu-id="460d6-142">성능 향상을 위한 구성 노브 배치 보고서가 있습니다.</span><span class="sxs-lookup"><span data-stu-id="460d6-142">Configuration knobs batch reports for improved performance.</span></span>

> [!NOTE]
> <span data-ttu-id="460d6-143">상태 보고서는 동기화되며 클라이언트 쪽의 유효성 검사 작업만 표시합니다.</span><span class="sxs-lookup"><span data-stu-id="460d6-143">Report health is synchronous, and it represents only the validation work on the client side.</span></span> <span data-ttu-id="460d6-144">상태 클라이언트나 `Partition` 또는 `CodePackageActivationContext` 개체에서 보고서를 수용한다고 해서 저장소에 적용된다는 의미는 아닙니다.</span><span class="sxs-lookup"><span data-stu-id="460d6-144">The fact that the report is accepted by the health client or the `Partition` or `CodePackageActivationContext` objects doesn't mean that it is applied in the store.</span></span> <span data-ttu-id="460d6-145">비동기적으로 전송되며 다른 보고서와 함께 일괄 처리될 수도 있습니다.</span><span class="sxs-lookup"><span data-stu-id="460d6-145">It is sent asynchronously and possibly batched with other reports.</span></span> <span data-ttu-id="460d6-146">시퀀스 번호가 오래되었거나 보고서가 적용되어야 하는 엔터티가 삭제되는 등의 이유로 서버 쪽에서의 처리가 실패할 수도 있습니다.</span><span class="sxs-lookup"><span data-stu-id="460d6-146">The processing on the server may still fail: the sequence number could be stale, the entity on which the report must be applied has been deleted, etc.</span></span>
> 
> 

## <a name="health-client"></a><span data-ttu-id="460d6-147">상태 클라이언트</span><span class="sxs-lookup"><span data-stu-id="460d6-147">Health client</span></span>
<span data-ttu-id="460d6-148">상태 보고서는 패브릭 클라이언트 내에 있는 상태 클라이언트를 통해 Health 스토어로 전송됩니다.</span><span class="sxs-lookup"><span data-stu-id="460d6-148">The health reports are sent to the health store through a health client, which lives inside the fabric client.</span></span> <span data-ttu-id="460d6-149">상태 클라이언트는 다음 설정으로 구성될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="460d6-149">The health client can be configured with the following settings:</span></span>

* <span data-ttu-id="460d6-150">**HealthReportSendInterval**: 보고서가 클라이언트에 추가되는 시간과 보고서가 Health 스토어로 전송되는 시간 사이의 지연 간격입니다.</span><span class="sxs-lookup"><span data-stu-id="460d6-150">**HealthReportSendInterval**: The delay between the time the report is added to the client and the time it is sent to the health store.</span></span> <span data-ttu-id="460d6-151">각 보고서에 메시지를 하나씩 전송하는 대신 보고서를 하나의 메시지로 일괄 처리하는데 사용됩니다.</span><span class="sxs-lookup"><span data-stu-id="460d6-151">Used to batch reports into a single message, rather than sending one message for each report.</span></span> <span data-ttu-id="460d6-152">일괄 처리를 하면 성능이 향상됩니다.</span><span class="sxs-lookup"><span data-stu-id="460d6-152">The batching improves performance.</span></span> <span data-ttu-id="460d6-153">기본값: 30초.</span><span class="sxs-lookup"><span data-stu-id="460d6-153">Default: 30 seconds.</span></span>
* <span data-ttu-id="460d6-154">**HealthReportRetrySendInterval**: 상태 클라이언트가 축적된 상태 보고서를 Health 스토어에 재전송하는 간격입니다.</span><span class="sxs-lookup"><span data-stu-id="460d6-154">**HealthReportRetrySendInterval**: The interval at which the health client resends accumulated health reports to the health store.</span></span> <span data-ttu-id="460d6-155">기본값: 30초.</span><span class="sxs-lookup"><span data-stu-id="460d6-155">Default: 30 seconds.</span></span>
* <span data-ttu-id="460d6-156">**HealthOperationTimeout**: Health 스토어로 전송된 보고서 메시지의 제한 시간입니다.</span><span class="sxs-lookup"><span data-stu-id="460d6-156">**HealthOperationTimeout**: The timeout period for a report message sent to the health store.</span></span> <span data-ttu-id="460d6-157">메시지 시간이 초과되면 상태 클라이언트는 Health 스토어에서 보고서 처리를 확인할 때까지 재시도합니다.</span><span class="sxs-lookup"><span data-stu-id="460d6-157">If a message times out, the health client retries it until the health store confirms that the report has been processed.</span></span> <span data-ttu-id="460d6-158">기본값: 2분.</span><span class="sxs-lookup"><span data-stu-id="460d6-158">Default: two minutes.</span></span>

> [!NOTE]
> <span data-ttu-id="460d6-159">보고서가 일괄 처리되는 경우 보고서가 전송될 수 있도록 적어도 HealthReportSendInterval 동안 패브릭 클라이언트가 유지되어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="460d6-159">When the reports are batched, the fabric client must be kept alive for at least the HealthReportSendInterval to ensure that they are sent.</span></span> <span data-ttu-id="460d6-160">일시적인 오류로 인하여 메시지가 손실되거나 Health 스토어가 메시지를 적용할 수 없는 경우 작업을 다시 시도할 수 있도록 패브릭 클라이언트가 더 오래 유지되어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="460d6-160">If the message is lost or the health store cannot apply them due to transient errors, the fabric client must be kept alive longer to give it a chance to retry.</span></span>
> 
> 

<span data-ttu-id="460d6-161">클라이언트에서의 버퍼링은 보고서의 고유성을 고려합니다.</span><span class="sxs-lookup"><span data-stu-id="460d6-161">The buffering on the client takes the uniqueness of the reports into consideration.</span></span> <span data-ttu-id="460d6-162">예를 들어 어떤 악성 보고자가 동일한 엔터티의 동일한 속성에 대해 초당 100개의 보고서를 보내는 경우 해당 보고서는 최신 버전으로 교체됩니다.</span><span class="sxs-lookup"><span data-stu-id="460d6-162">For example, if a particular bad reporter is reporting 100 reports per second on the same property of the same entity, the reports are replaced with the last version.</span></span> <span data-ttu-id="460d6-163">이러한 보고서는 기껏해야 클라이언트 큐에 하나 존재합니다.</span><span class="sxs-lookup"><span data-stu-id="460d6-163">At most one such report exists in the client queue.</span></span> <span data-ttu-id="460d6-164">일괄 작업이 구성되면 Health 스토어에 전송되는 보고서의 개수는 전송 간격당 하나뿐이며,</span><span class="sxs-lookup"><span data-stu-id="460d6-164">If batching is configured, the number of reports sent to the health store is just one per send interval.</span></span> <span data-ttu-id="460d6-165">이 보고서가 엔터티의 최신 상태를 반영하는 맨 마지막으로 추가된 보고서입니다.</span><span class="sxs-lookup"><span data-stu-id="460d6-165">This report is the last added report, which reflects the most current state of the entity.</span></span>
<span data-ttu-id="460d6-166">상태 관련 항목에 원하는 값을 포함한 [FabricClientSettings](https://docs.microsoft.com/dotnet/api/system.fabric.fabricclientsettings)를 전달하여 `FabricClient`를 만들 때 구성 매개 변수를 지정합니다.</span><span class="sxs-lookup"><span data-stu-id="460d6-166">Specify configuration parameters when `FabricClient` is created by passing [FabricClientSettings](https://docs.microsoft.com/dotnet/api/system.fabric.fabricclientsettings) with the desired values for health-related entries.</span></span>

<span data-ttu-id="460d6-167">다음 코드 예제에서는 패브릭 클라이언트를 생성하고 보고서가 추가되면 전송되도록 지정합니다.</span><span class="sxs-lookup"><span data-stu-id="460d6-167">The following example creates a fabric client and specifies that the reports should be sent when they are added.</span></span> <span data-ttu-id="460d6-168">시간이 초과되거나 재시도 가능한 오류가 발생할 경우 40초마다 재시도가 이뤄집니다.</span><span class="sxs-lookup"><span data-stu-id="460d6-168">On timeouts and errors that can be retried, retries happen every 40 seconds.</span></span>

```csharp
var clientSettings = new FabricClientSettings()
{
    HealthOperationTimeout = TimeSpan.FromSeconds(120),
    HealthReportSendInterval = TimeSpan.FromSeconds(0),
    HealthReportRetrySendInterval = TimeSpan.FromSeconds(40),
};
var fabricClient = new FabricClient(clientSettings);
```

<span data-ttu-id="460d6-169">`HealthReportSendInterval`을 30초로 설정하는 기본 패브릭 클라이언트 설정을 유지하는 것이 좋습니다. </span><span class="sxs-lookup"><span data-stu-id="460d6-169">We recommend keeping the default fabric client settings, which set `HealthReportSendInterval` to 30 seconds.</span></span> <span data-ttu-id="460d6-170">이 설정은 일괄 처리 때문에 최적 성능을 보장합니다.</span><span class="sxs-lookup"><span data-stu-id="460d6-170">This setting ensures optimal performance due to batching.</span></span> <span data-ttu-id="460d6-171">가능한 즉시 내보내야 하는 중요 보고서의 경우 [FabricClient.HealthClient.ReportHealth](https://docs.microsoft.com/dotnet/api/system.fabric.fabricclient.healthclient.reporthealth) API에서 Immediate `true`와 함께 `HealthReportSendOptions`를 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="460d6-171">For critical reports that must be sent as soon as possible, use `HealthReportSendOptions` with Immediate `true` in [FabricClient.HealthClient.ReportHealth](https://docs.microsoft.com/dotnet/api/system.fabric.fabricclient.healthclient.reporthealth) API.</span></span> <span data-ttu-id="460d6-172">즉시 보고서는 일괄 처리 간격을 무시합니다.</span><span class="sxs-lookup"><span data-stu-id="460d6-172">Immediate reports bypass the batching interval.</span></span> <span data-ttu-id="460d6-173">가능할 때마다 상태 클라이언트 일괄 처리의 장점을 활용하고자 하므로 이 플래그는 주의하여 사용합니다. </span><span class="sxs-lookup"><span data-stu-id="460d6-173">Use this flag with care; we want to take advantage of the health client batching whenever possible.</span></span> <span data-ttu-id="460d6-174">패브릭 클라이언트를 닫을 때(예: 프로세스에서 잘못된 상태를 확인했고 부작용을 막기 위해 종료해야 하는 경우)도 즉시 보내기가 도움이 됩니다.</span><span class="sxs-lookup"><span data-stu-id="460d6-174">Immediate send is also useful when the fabric client is closing (for example, the process has determined invalid state and needs to shut down to prevent side effects).</span></span> <span data-ttu-id="460d6-175">누적 보고서는 최적의 보내기 작업입니다.</span><span class="sxs-lookup"><span data-stu-id="460d6-175">It ensures a best-effort send of the accumulated reports.</span></span> <span data-ttu-id="460d6-176">한 보고서에 Immediate 플래그가 추가되면 상태 클라이언트가 지난 번 전송 이후 모든 누적된 보고서를 일괄 처리합니다.</span><span class="sxs-lookup"><span data-stu-id="460d6-176">When one report is added with Immediate flag, the health client batches all the accumulated reports since last send.</span></span>

<span data-ttu-id="460d6-177">PowerShell을 통해 클러스터에 대한 연결을 생성할 때 동일한 매개 변수를 지정할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="460d6-177">Same parameters can be specified when a connection to a cluster is created through PowerShell.</span></span> <span data-ttu-id="460d6-178">다음 예제에서는 로컬 클러스터에 대한 연결을 시작합니다.</span><span class="sxs-lookup"><span data-stu-id="460d6-178">The following example starts a connection to a local cluster:</span></span>

```powershell
PS C:\> Connect-ServiceFabricCluster -HealthOperationTimeoutInSec 120 -HealthReportSendIntervalInSec 0 -HealthReportRetrySendIntervalInSec 40
True

ConnectionEndpoint   :
FabricClientSettings : {
                       ClientFriendlyName                   : PowerShell-1944858a-4c6d-465f-89c7-9021c12ac0bb
                       PartitionLocationCacheLimit          : 100000
                       PartitionLocationCacheBucketCount    : 1024
                       ServiceChangePollInterval            : 00:02:00
                       ConnectionInitializationTimeout      : 00:00:02
                       KeepAliveInterval                    : 00:00:20
                       HealthOperationTimeout               : 00:02:00
                       HealthReportSendInterval             : 00:00:00
                       HealthReportRetrySendInterval        : 00:00:40
                       NotificationGatewayConnectionTimeout : 00:00:00
                       NotificationCacheUpdateTimeout       : 00:00:00
                       }
GatewayInformation   : {
                       NodeAddress                          : localhost:19000
                       NodeId                               : 1880ec88a3187766a6da323399721f53
                       NodeInstanceId                       : 130729063464981219
                       NodeName                             : Node.1
                       }
```

<span data-ttu-id="460d6-179">API와 마찬가지로 `HealthReportSendInterval` 값에 관계없이 `-Immediate` 스위치를 사용하여 보고서를 즉시 보낼 수 있습니다. </span><span class="sxs-lookup"><span data-stu-id="460d6-179">Similarly to API, reports can be sent using `-Immediate` switch to be sent immediately, regardless of the `HealthReportSendInterval` value.</span></span>

<span data-ttu-id="460d6-180">REST의 경우 보고서를 내부 패브릭 클라이언트가 있는 Service Fabric 게이트웨이로 보냅니다.</span><span class="sxs-lookup"><span data-stu-id="460d6-180">For REST, the reports are sent to the Service Fabric gateway, which has an internal fabric client.</span></span> <span data-ttu-id="460d6-181">기본적으로 이 클라이언트는 30초마다 일괄 처리된 보고서를 보내도록 구성됩니다.</span><span class="sxs-lookup"><span data-stu-id="460d6-181">By default, this client is configured to send reports batched every 30 seconds.</span></span> <span data-ttu-id="460d6-182">`HttpGateway`에서 클러스터 구성 설정 `HttpGatewayHealthReportSendInterval`을 사용하여 일괄 처리 간격을 변경할 수 있습니다. </span><span class="sxs-lookup"><span data-stu-id="460d6-182">You can change the batch interval with the cluster configuration setting `HttpGatewayHealthReportSendInterval` on `HttpGateway`.</span></span> <span data-ttu-id="460d6-183">설명한 것처럼 `Immediate` true로 보고서를 보내는 옵션이 더 낫습니다.</span><span class="sxs-lookup"><span data-stu-id="460d6-183">As mentioned, a better option is to send the reports with `Immediate` true.</span></span> 

> [!NOTE]
> <span data-ttu-id="460d6-184">권한이 없는 서비스가 클러스터 내의 엔터티에 대한 상태를 보고할 수 없도록 하려면 보안이 확인된 클라이언트에서 보내는 요청만을 받아들이도록 서버를 구성합니다.</span><span class="sxs-lookup"><span data-stu-id="460d6-184">To ensure that unauthorized services can't report health against the entities in the cluster, configure the server to accept requests only from secured clients.</span></span> <span data-ttu-id="460d6-185">보고에 사용되는 `FabricClient` 는 클러스터와 통신할 수 있도록 보안이 활성화되어야 합니다(예: Kerberos 또는 인증서 인증).</span><span class="sxs-lookup"><span data-stu-id="460d6-185">The `FabricClient` used for reporting must have security enabled to be able to communicate with the cluster (for example, with Kerberos or certificate authentication).</span></span> <span data-ttu-id="460d6-186">[클러스터 보안](service-fabric-cluster-security.md)에 대해 자세히 알아봅니다.</span><span class="sxs-lookup"><span data-stu-id="460d6-186">Read more about [cluster security](service-fabric-cluster-security.md).</span></span>
> 
> 

## <a name="report-from-within-low-privilege-services"></a><span data-ttu-id="460d6-187">권한이 낮은 서비스 내에서 보고</span><span class="sxs-lookup"><span data-stu-id="460d6-187">Report from within low privilege services</span></span>
<span data-ttu-id="460d6-188">Service Fabric 서비스에 클러스터에 대한 관리 액세스 권한이 없는 경우 `Partition` 또는 `CodePackageActivationContext`를 통해 현재 컨텍스트에서 엔터티에 대한 상태를 보고할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="460d6-188">If Service Fabric services do not have admin access to the cluster, you can report health on entities from the current context through `Partition` or `CodePackageActivationContext`.</span></span>

* <span data-ttu-id="460d6-189">상태 비저장 서비스의 경우에는 [IStatelessServicePartition.ReportInstanceHealth](https://docs.microsoft.com/dotnet/api/system.fabric.istatelessservicepartition.reportinstancehealth) 를 사용하여 현재 서비스 인스턴스에 대해 보고합니다.</span><span class="sxs-lookup"><span data-stu-id="460d6-189">For stateless services, use [IStatelessServicePartition.ReportInstanceHealth](https://docs.microsoft.com/dotnet/api/system.fabric.istatelessservicepartition.reportinstancehealth) to report on the current service instance.</span></span>
* <span data-ttu-id="460d6-190">상태 저장 서비스의 경우에는 [IStatefulServicePartition.ReportReplicaHealth](https://docs.microsoft.com/dotnet/api/system.fabric.istatefulservicepartition.reportreplicahealth) 를 사용하여 현재 복제본에 대해 보고합니다.</span><span class="sxs-lookup"><span data-stu-id="460d6-190">For stateful services, use [IStatefulServicePartition.ReportReplicaHealth](https://docs.microsoft.com/dotnet/api/system.fabric.istatefulservicepartition.reportreplicahealth) to report on current replica.</span></span>
* <span data-ttu-id="460d6-191">현재 파티션 엔터티에 대해 보고하려면 [IServicePartition.ReportPartitionHealth](https://docs.microsoft.com/dotnet/api/system.fabric.iservicepartition.reportpartitionhealth) 를 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="460d6-191">Use [IServicePartition.ReportPartitionHealth](https://docs.microsoft.com/dotnet/api/system.fabric.iservicepartition.reportpartitionhealth) to report on the current partition entity.</span></span>
* <span data-ttu-id="460d6-192">현재 응용 프로그램에 대해 보고하려면 [CodePackageActivationContext.ReportApplicationHealth](https://docs.microsoft.com/dotnet/api/system.fabric.codepackageactivationcontext.reportapplicationhealth) 를 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="460d6-192">Use [CodePackageActivationContext.ReportApplicationHealth](https://docs.microsoft.com/dotnet/api/system.fabric.codepackageactivationcontext.reportapplicationhealth) to report on current application.</span></span>
* <span data-ttu-id="460d6-193">현재 노드에 배포된 현재 응용 프로그램에 대해 보고하려면 [CodePackageActivationContext.ReportDeployedApplicationHealth](https://docs.microsoft.com/dotnet/api/system.fabric.codepackageactivationcontext.reportdeployedapplicationhealth) 를 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="460d6-193">Use [CodePackageActivationContext.ReportDeployedApplicationHealth](https://docs.microsoft.com/dotnet/api/system.fabric.codepackageactivationcontext.reportdeployedapplicationhealth) to report on the current application deployed on the current node.</span></span>
* <span data-ttu-id="460d6-194">현재 노드에 배포된 응용 프로그램의 서비스 패키지에 대해 보고하려면 [CodePackageActivationContext.ReportDeployedServicePackageHealth](https://docs.microsoft.com/dotnet/api/system.fabric.codepackageactivationcontext.reportdeployedservicepackagehealth) 를 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="460d6-194">Use [CodePackageActivationContext.ReportDeployedServicePackageHealth](https://docs.microsoft.com/dotnet/api/system.fabric.codepackageactivationcontext.reportdeployedservicepackagehealth) to report on a service package for the application deployed on the current node.</span></span>

> [!NOTE]
> <span data-ttu-id="460d6-195">내부적으로 `Partition` 및 `CodePackageActivationContext`는 기본 설정으로 구성된 상태 클라이언트를 포함합니다.</span><span class="sxs-lookup"><span data-stu-id="460d6-195">Internally, the `Partition` and the `CodePackageActivationContext` hold a health client configured with default settings.</span></span> <span data-ttu-id="460d6-196">[상태 클라이언트](service-fabric-report-health.md#health-client)에서 설명한 것처럼 보고서는 타이머에서 일괄 처리 및 전송됩니다.</span><span class="sxs-lookup"><span data-stu-id="460d6-196">As explained for the [health client](service-fabric-report-health.md#health-client), reports are batched and sent on a timer.</span></span> <span data-ttu-id="460d6-197">보고서를 보낼 수 있게 개체는 활성 상태로 유지되어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="460d6-197">The objects should be kept alive to have a chance to send the report.</span></span>
> 
> 

<span data-ttu-id="460d6-198">`Partition` 및 `CodePackageActivationContext` 상태 API를 통해 보고서를 보낼 때 `HealthReportSendOptions`를 지정할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="460d6-198">You can specify `HealthReportSendOptions` when sending reports through `Partition` and `CodePackageActivationContext` health APIs.</span></span> <span data-ttu-id="460d6-199">가능한 빨리 전송되어야 하는 중요 보고서의 경우 Immediate `true`와 함께 `HealthReportSendOptions`를 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="460d6-199">If you have critical reports that must be sent as soon as possible, use `HealthReportSendOptions` with Immediate `true`.</span></span> <span data-ttu-id="460d6-200">즉시 보고서는 내부 상태 클라이언트의 일괄 처리 간격을 무시합니다.</span><span class="sxs-lookup"><span data-stu-id="460d6-200">Immediate reports bypass the batching interval of the internal health client.</span></span> <span data-ttu-id="460d6-201">앞서 설명한 것처럼 가능할 때마다 상태 클라이언트 일괄 처리의 장점을 활용하고자 하므로 이 플래그는 주의하여 사용합니다. </span><span class="sxs-lookup"><span data-stu-id="460d6-201">As mentioned before, use this flag with care; we want to take advantage of the health client batching whenever possible.</span></span>

## <a name="design-health-reporting"></a><span data-ttu-id="460d6-202">상태 보고 설계</span><span class="sxs-lookup"><span data-stu-id="460d6-202">Design health reporting</span></span>
<span data-ttu-id="460d6-203">고품질 보고서를 생성하는 첫 단계는 서비스 상태에 영향을 미칠 수 있는 조건을 파악하는 것입니다.</span><span class="sxs-lookup"><span data-stu-id="460d6-203">The first step in generating high-quality reports is identifying the conditions that can impact the health of the service.</span></span> <span data-ttu-id="460d6-204">문제가 시작될 때 또는 가장 이상적으로 문제가 발생하기 전에 서비스 또는 클러스터의 문제를 플래깅하는 데 도움이 되는 모든 조건을 파악하면 잠재적으로 수십억 달러를 절약할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="460d6-204">Any condition that can help flag problems in the service or cluster when it starts--or even better, before a problem happens--can potentially save billions of dollars.</span></span> <span data-ttu-id="460d6-205">그러면 중지 시간을 줄이고, 문제 조사와 복구에 소요되는 야간 시간을 절약하고, 고객 만족도를 높일 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="460d6-205">The benefits include less down time, fewer night hours spent investigating and repairing issues, and higher customer satisfaction.</span></span>

<span data-ttu-id="460d6-206">조건이 확인되면 Watchdog 작성자는 오버헤드와 유효성 사이에서 적절한 균형을 잡기 위한 최선의 모니터링 방법을 알아내야 합니다.</span><span class="sxs-lookup"><span data-stu-id="460d6-206">Once the conditions are identified, watchdog writers need to figure out the best way to monitor them for balance between overhead and usefulness.</span></span> <span data-ttu-id="460d6-207">예를 들어 공유 위치에서 임시 파일을 사용하여 복잡한 계산을 수행하는 서비스가 있다고 가정하겠습니다.</span><span class="sxs-lookup"><span data-stu-id="460d6-207">For example, consider a service that does complex calculations that use some temporary files on a share.</span></span> <span data-ttu-id="460d6-208">Watchdog는 공유 위치의 공간을 충분히 확보하기 위하여 공유 위치를 모니터링할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="460d6-208">A watchdog could monitor the share to ensure that enough space is available.</span></span> <span data-ttu-id="460d6-209">파일/디렉토리 변경에 대한 알림을 수신할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="460d6-209">It could listen for notifications of file or directory changes.</span></span> <span data-ttu-id="460d6-210">중요한 임계값에 도달하면 경고를, 공유 공간이 꽉 차면 오류를 보고할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="460d6-210">It could report a warning if an upfront threshold is reached, and report an error if the share is full.</span></span> <span data-ttu-id="460d6-211">경고가 보고되면 복구 시스템이 공유 공간에서 오래된 파일 정리를 시작할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="460d6-211">On a warning, a repair system could start cleaning up older files on the share.</span></span> <span data-ttu-id="460d6-212">오류가 보고되면 복구 시스템이 서비스 복제본을 다른 노드로 이동할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="460d6-212">On an error, a repair system could move the service replica to another node.</span></span> <span data-ttu-id="460d6-213">조건을 상태와 관련 지어 설명하는 방식, 다시 말해서 정상(양호) 또는 비정상(경고 또는 오류)으로 간주할 수 있는 조건의 상태에 유의해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="460d6-213">Note how the condition states are described in terms of health: the state of the condition that can be considered healthy (ok) or unhealthy (warning or error).</span></span>

<span data-ttu-id="460d6-214">모니터링 세부 정보가 설정되면 Watchdog 작성자는 Watchdog 구현 방법을 생각해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="460d6-214">Once the monitoring details are set, a watchdog writer needs to figure out how to implement the watchdog.</span></span> <span data-ttu-id="460d6-215">서비스 내에서 조건을 결정할 수 있으면 Watchdog는 모니터링되는 서비스의 일부가 될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="460d6-215">If the conditions can be determined from within the service, the watchdog can be part of the monitored service itself.</span></span> <span data-ttu-id="460d6-216">예를 들어 서비스 코드는 공유 사용을 확인한 다음 파일 쓰기를 시도할 때마다 보고할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="460d6-216">For example, the service code can check the share usage, and then report every time it tries to write a file.</span></span> <span data-ttu-id="460d6-217">이러한 접근의 이점은 보고가 간단하다는 것입니다.</span><span class="sxs-lookup"><span data-stu-id="460d6-217">The advantage of this approach is that reporting is simple.</span></span> <span data-ttu-id="460d6-218">Watchdog 버그가 서비스 기능에 영향을 미치지 않도록 주의를 기울여야 합니다.</span><span class="sxs-lookup"><span data-stu-id="460d6-218">Care must be taken to prevent watchdog bugs from impacting the service functionality.</span></span>

<span data-ttu-id="460d6-219">모니터링되는 서비스 내에서의 보고를 선택할 수 없는 경우도 있습니다.</span><span class="sxs-lookup"><span data-stu-id="460d6-219">Reporting from within the monitored service is not always an option.</span></span> <span data-ttu-id="460d6-220">서비스 내의 watchdog가 조건을 감지하지 못할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="460d6-220">A watchdog within the service may not be able to detect the conditions.</span></span> <span data-ttu-id="460d6-221">결정에 필요한 논리 또는 데이터가 없을 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="460d6-221">It may not have the logic or data to make the determination.</span></span> <span data-ttu-id="460d6-222">조건 모니터링의 오버헤드가 높을 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="460d6-222">The overhead of monitoring the conditions may be high.</span></span> <span data-ttu-id="460d6-223">조건이 서비스에 한정되지는 않지만 그 대신 서비스 간의 상호 작용에 영향을 미칠 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="460d6-223">The conditions also may not be specific to a service, but instead affect interactions between services.</span></span> <span data-ttu-id="460d6-224">클러스터에 Watchdog를 별개의 프로세스로 두는 방법도 있습니다.</span><span class="sxs-lookup"><span data-stu-id="460d6-224">Another option is to have watchdogs in the cluster as separate processes.</span></span> <span data-ttu-id="460d6-225">Watchdog는 주 서비스에 전혀 영향을 미치지 않고 조건과 보고서 모니터링만 합니다.</span><span class="sxs-lookup"><span data-stu-id="460d6-225">The watchdogs monitor the conditions and report, without affecting the main services in any way.</span></span> <span data-ttu-id="460d6-226">예를 들어 이러한 Watchdog는 동일한 응용 프로그램 내에서 상태 비저장 서비스로 구현되어 모든 노드에 배포되거나 서비스와 같은 노드에 배포될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="460d6-226">For example, these watchdogs could be implemented as stateless services in the same application, deployed on all nodes or on the same nodes as the service.</span></span>

<span data-ttu-id="460d6-227">클러스터에서 실행되는 Watchdog를 사용할 수 없는 경우가 종종 있습니다.</span><span class="sxs-lookup"><span data-stu-id="460d6-227">Sometimes, a watchdog running in the cluster is not an option either.</span></span> <span data-ttu-id="460d6-228">사용자가 서비스를 보는 동안 모니터링되는 조건이 서비스의 가용성 또는 기능인 경우 Watchdog를 사용자 클라이언트와 동일한 위치에 두는 것이 가장 좋습니다.</span><span class="sxs-lookup"><span data-stu-id="460d6-228">If the monitored condition is the availability or functionality of the service as users see it, it's best to have the watchdogs in the same place as the user clients.</span></span> <span data-ttu-id="460d6-229">사용자가 서비스를 호출하는 것과 같은 방법으로 작업을 테스트할 수 있기 때문입니다.</span><span class="sxs-lookup"><span data-stu-id="460d6-229">There, they can test the operations in the same way users call them.</span></span> <span data-ttu-id="460d6-230">예를 들어 클러스터 외부에 상주하면서 서비스에 요청을 보낸 후 대기 시간 및 결과의 정확성을 확인하는 watchdog를 둘 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="460d6-230">For example, you can have a watchdog that lives outside the cluster, issues requests to the service, and checks the latency and correctness of the result.</span></span> <span data-ttu-id="460d6-231">(예: 계산기 서비스의 경우 2+2가 합당한 시간 내에 4를 반환합니까?)</span><span class="sxs-lookup"><span data-stu-id="460d6-231">(For a calculator service, for example, does 2+2 return 4 in a reasonable amount of time?)</span></span>

<span data-ttu-id="460d6-232">Watchdog 세부 정보가 마무리되면 Watchdog를 고유하게 식별하는 소스 ID를 결정해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="460d6-232">Once the watchdog details have been finalized, you should decide on a source ID that uniquely identifies it.</span></span> <span data-ttu-id="460d6-233">클러스터에 동일한 유형의 Watchdog가 여러 개 있는 경우 서로 다른 엔터티에 대해 보고하거나, 동일한 엔터티에 보고한다면 다른 소스 ID나 속성을 사용해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="460d6-233">If multiple watchdogs of the same type are living in the cluster, they must report on different entities, or, if they report on the same entity, use different source ID or property.</span></span> <span data-ttu-id="460d6-234">그래야만 보고서가 공존할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="460d6-234">This way, their reports can coexist.</span></span> <span data-ttu-id="460d6-235">상태 보고서 속성은 모니터링되는 조건을 포착해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="460d6-235">The property of the health report should capture the monitored condition.</span></span> <span data-ttu-id="460d6-236">위의 예제에서 속성은 **ShareSize**일 수 있습니다. 같은 조건에 여러 보고서가 적용되는 경우 보고서가 공존할 수 있도록 속성에 동적 정보가 포함되어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="460d6-236">(For the example above, the property could be **ShareSize**.) If multiple reports apply to the same condition, the property should contain some dynamic information that allows reports to coexist.</span></span> <span data-ttu-id="460d6-237">예를 들어 여러 개의 공유를 모니터링해야 하는 경우 속성 이름으로 **ShareSize-sharename**을 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="460d6-237">For example, if multiple shares need to be monitored, the property name can be **ShareSize-sharename**.</span></span>

> [!NOTE]
> <span data-ttu-id="460d6-238">상태 저장소는 상태 정보를 보관하는 데 사용되지 *않아야* 합니다.</span><span class="sxs-lookup"><span data-stu-id="460d6-238">Do *not* use the health store to keep status information.</span></span> <span data-ttu-id="460d6-239">상태와 관련된 정보만 보고되어야 합니다. 이 정보는 엔터티 상태 평가에 영향을 미치기 때문입니다.</span><span class="sxs-lookup"><span data-stu-id="460d6-239">Only health-related information should be reported as health, as this information impacts the health evaluation of an entity.</span></span> <span data-ttu-id="460d6-240">Health 스토어는 범용 저장소로 설계되지 않았습니다.</span><span class="sxs-lookup"><span data-stu-id="460d6-240">The health store was not designed as a general-purpose store.</span></span> <span data-ttu-id="460d6-241">Health 스토어는 상태 평가 논리를 사용하여 모든 데이터를 성능 상태로 집계합니다.</span><span class="sxs-lookup"><span data-stu-id="460d6-241">It uses health evaluation logic to aggregate all data into the health state.</span></span> <span data-ttu-id="460d6-242">상태와 무관한 정보(예: 정상 상태 보고)를 전송해도 집계된 성능 상태에는 영향을 미치지 않지만 Health 스토어의 성능에 부정적인 영향을 미칠 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="460d6-242">Sending information unrelated to health (like reporting status with a health state of OK) doesn't impact the aggregated health state, but it can negatively affect the performance of the health store.</span></span>
> 
> 

<span data-ttu-id="460d6-243">다음으로 결정할 내용은 보고할 엔터티를 결정하는 것입니다.</span><span class="sxs-lookup"><span data-stu-id="460d6-243">The next decision point is which entity to report on.</span></span> <span data-ttu-id="460d6-244">대부분 조건은 엔터티를 명확히 식별합니다.</span><span class="sxs-lookup"><span data-stu-id="460d6-244">Most of the time, the condition clearly idetifies the entity.</span></span> <span data-ttu-id="460d6-245">최대한 세분화하여 엔터티를 선택해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="460d6-245">Choose the entity with best possible granularity.</span></span> <span data-ttu-id="460d6-246">조건이 파티션 내의 모든 복제본에 영향을 미치는 경우에는 서비스가 아닌 파티션에 대해 보고합니다.</span><span class="sxs-lookup"><span data-stu-id="460d6-246">If a condition impacts all replicas in a partition, report on the partition, not on the service.</span></span> <span data-ttu-id="460d6-247">그런데 세심한 주의가 필요한 사각 지대가 있습니다.</span><span class="sxs-lookup"><span data-stu-id="460d6-247">There are corner cases where more thought is needed, though.</span></span> <span data-ttu-id="460d6-248">조건이 복제본 같은 하나의 엔터티에만 영향을 미치지만 복제본 수명 기간이 지난 후에도 조건에 플래그를 달고자 한다면 파티션에 대해 보고해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="460d6-248">If the condition impacts an entity, such as a replica, but the desire is to have the condition flagged for more than the duration of replica life, then it should be reported on the partition.</span></span> <span data-ttu-id="460d6-249">그렇지 않은 경우 복제본이 삭제되었을 때 상태 저장소의 모든 보고서가 정리됩니다.</span><span class="sxs-lookup"><span data-stu-id="460d6-249">Otherwise, when the replica is deleted, the health store cleans up all its reports.</span></span> <span data-ttu-id="460d6-250">Watchdog 작성자는 엔터티 및 보고서의 수명을 고려해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="460d6-250">Watchdog writers must think about the lifetimes of the entity and the report.</span></span> <span data-ttu-id="460d6-251">저장소에서 보고서가 삭제되는 시점(예: 한 엔터티에 대해 보고된 오류가 더 이상 적용되는 않는 시점)도 명확해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="460d6-251">It must be clear when a report should be cleaned up from a store (for example, when an error reported on an entity no longer applies).</span></span>

<span data-ttu-id="460d6-252">설명한 요점을 모아놓은 예를 살펴보겠습니다.</span><span class="sxs-lookup"><span data-stu-id="460d6-252">Let's look at an example that puts together the points I described.</span></span> <span data-ttu-id="460d6-253">모든 노드에 배포된 마스터 상태 저장 지속 서비스 및 보조 상태 비저장 서비스로 구성된 서비스 패브릭 응용 프로그램이 있습니다(각 태스크 유형에 대한 한 가지 보조 서비스 유형).</span><span class="sxs-lookup"><span data-stu-id="460d6-253">Consider a Service Fabric application composed of a master stateful persistent service and secondary stateless services deployed on all nodes (one secondary service type for each type of task).</span></span> <span data-ttu-id="460d6-254">마스터에는 보조에서 실행할 명령이 포함된 처리 큐가 있습니다.</span><span class="sxs-lookup"><span data-stu-id="460d6-254">The master has a processing queue that contains commands to be executed by secondaries.</span></span> <span data-ttu-id="460d6-255">보조는 들어오는 요청을 실행하고 승인 신호를 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="460d6-255">The secondaries execute the incoming requests and send back acknowledgement signals.</span></span> <span data-ttu-id="460d6-256">모니터링이 가능한 한 가지 조건은 마스터 처리 큐의 길이입니다.</span><span class="sxs-lookup"><span data-stu-id="460d6-256">One condition that could be monitored is the length of the master processing queue.</span></span> <span data-ttu-id="460d6-257">마스터 큐 길이가 임계값에 도달하면 경고가 보고됩니다.</span><span class="sxs-lookup"><span data-stu-id="460d6-257">If the master queue length reaches a threshold, a warning is reported.</span></span> <span data-ttu-id="460d6-258">경고는 보조가 부하를 처리할 수 없다는 뜻입니다.</span><span class="sxs-lookup"><span data-stu-id="460d6-258">The warning indicates that the secondaries can't handle the load.</span></span> <span data-ttu-id="460d6-259">큐가 최대 길이에 도달하고 명령이 삭제되면 서비스를 복구할 수 없으므로 오류가 보고됩니다.</span><span class="sxs-lookup"><span data-stu-id="460d6-259">If the queue reaches the maximum length and commands are dropped, an error is reported, as the service can't recover.</span></span> <span data-ttu-id="460d6-260">**QueueStatus**속성에 대한 보고서일 수도 있습니다.</span><span class="sxs-lookup"><span data-stu-id="460d6-260">The reports can be on the property **QueueStatus**.</span></span> <span data-ttu-id="460d6-261">Watchdog는 서비스 내에 있으며 마스터 주 복제본에서 주기적으로 전송됩니다.</span><span class="sxs-lookup"><span data-stu-id="460d6-261">The watchdog lives inside the service, and it's sent periodically on the master primary replica.</span></span> <span data-ttu-id="460d6-262">TTL이 2분이며 30초마다 주기적으로 전송됩니다.</span><span class="sxs-lookup"><span data-stu-id="460d6-262">The time to live is two minutes, and it's sent periodically every 30 seconds.</span></span> <span data-ttu-id="460d6-263">주 복제본이 다운되면, 보고서는 저장소에서 자동으로 삭제됩니다.</span><span class="sxs-lookup"><span data-stu-id="460d6-263">If the primary goes down, the report is cleaned up automatically from store.</span></span> <span data-ttu-id="460d6-264">서비스 복제본이 실행 중이지만 교착 상태에 있거나 다른 문제가 있으면 보고서는 Health 스토어에서 만료됩니다.</span><span class="sxs-lookup"><span data-stu-id="460d6-264">If the service replica is up, but it is deadlocked or having other issues, the report expires in the health store.</span></span> <span data-ttu-id="460d6-265">이 경우 엔터티는 오류 상황에서 평가됩니다.</span><span class="sxs-lookup"><span data-stu-id="460d6-265">In this case, the entity is evaluated at error.</span></span>

<span data-ttu-id="460d6-266">모니터링할 수 있는 또 다른 조건은 작업 수행 시간입니다.</span><span class="sxs-lookup"><span data-stu-id="460d6-266">Another condition that can be monitored is task execution time.</span></span> <span data-ttu-id="460d6-267">마스터는 작업 유형을 기반으로 보조에 작업을 분배합니다.</span><span class="sxs-lookup"><span data-stu-id="460d6-267">The master distributes tasks to the secondaries based on the task type.</span></span> <span data-ttu-id="460d6-268">설계 내용에 따라서 마스터는 작업 상태를 보조에 폴링하거나 작업 완료 후 보조가 승인 신호를 반환할 때까지 기다릴 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="460d6-268">Depending on the design, the master could poll the secondaries for task status.</span></span> <span data-ttu-id="460d6-269">후자의 경우 보조가 종료되거나 메시지가 손실되는 상황을 감지할 수 있도록 주의를 기울여야 합니다.</span><span class="sxs-lookup"><span data-stu-id="460d6-269">It could also wait for secondaries to send back acknowledgement signals when they are done.</span></span> <span data-ttu-id="460d6-270">한 가지 방법은 마스터가 동일한 보조에 ping 요청을 보내는 것입니다.</span><span class="sxs-lookup"><span data-stu-id="460d6-270">In the second case, care must be taken to detect situations where secondaries die or messages are lost.</span></span> <span data-ttu-id="460d6-271">그러면 보조가 상태를 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="460d6-271">One option is for the master to send a ping request to the same secondary, which sends back its status.</span></span> <span data-ttu-id="460d6-272">상태가 수신되지 않으면 마스터는 실패로 간주하고 작업 일정을 다시 세웁니다.</span><span class="sxs-lookup"><span data-stu-id="460d6-272">If no status is received, the master considers it a failure and reschedules the task.</span></span> <span data-ttu-id="460d6-273">이러한 동작은 작업을 멱등 상태로 가정합니다.</span><span class="sxs-lookup"><span data-stu-id="460d6-273">This behavior assumes that the tasks are idempotent.</span></span>

<span data-ttu-id="460d6-274">모니터링된 조건은 일정 시간(**t1**, 예를 들어 10분) 내에 작업이 완료되지 않으면 경고로 해석될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="460d6-274">The monitored condition can be translated as a warning if the task is not done in a certain time (**t1**, for example 10 minutes).</span></span> <span data-ttu-id="460d6-275">작업이 시간(**t2**, 예를 들어 20분) 내에 완료되지 않으면 모니터링된 조건이 오류로 해석될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="460d6-275">If the task is not completed in time (**t2**, for example 20 minutes), the monitored condition can be translated as Error.</span></span> <span data-ttu-id="460d6-276">이러한 보고는 여러 가지 방법으로 수행될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="460d6-276">This reporting can be done in multiple ways:</span></span>

* <span data-ttu-id="460d6-277">마스터 주 복제본은 주기적으로 자체 보고합니다.</span><span class="sxs-lookup"><span data-stu-id="460d6-277">The master primary replica reports on itself periodically.</span></span> <span data-ttu-id="460d6-278">큐에 있는 모든 보류 중인 작업에 대해 하나의 속성을 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="460d6-278">You can have one property for all pending tasks in the queue.</span></span> <span data-ttu-id="460d6-279">하나 이상의 작업이 더 오래 걸리면 **PendingTasks** 속성에 대한 상태가 상황에 따라 경고 또는 오류로 보고됩니다.</span><span class="sxs-lookup"><span data-stu-id="460d6-279">If at least one task takes longer, the report status on the property **PendingTasks** is a warning or error, as appropriate.</span></span> <span data-ttu-id="460d6-280">보류 중인 작업이 없거나 모든 작업이 실행을 시작한 경우에는 보고서 상태가 정상입니다.</span><span class="sxs-lookup"><span data-stu-id="460d6-280">If there are no pending tasks or all tasks started execution, the report status is OK.</span></span> <span data-ttu-id="460d6-281">작업은 지속됩니다.</span><span class="sxs-lookup"><span data-stu-id="460d6-281">The tasks are persistent.</span></span> <span data-ttu-id="460d6-282">주 복제본이 다운되면 새로 승격된 주 복제본이 계속해서 제대로 보고할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="460d6-282">If the primary goes down, the newly promoted primary can continue to report properly.</span></span>
* <span data-ttu-id="460d6-283">(클라우드 또는 외부에 존재하는) 다른 Watchdog 프로세스는 작업 완료 여부를 보기 위하여 (원하는 작업 결과를 기반으로 외부에서) 작업을 확인합니다.</span><span class="sxs-lookup"><span data-stu-id="460d6-283">Another watchdog process (in the cloud or external) checks the tasks (from outside, based on the desired task result) to see if they are completed.</span></span> <span data-ttu-id="460d6-284">이러한 프로세스가 임계값을 준수하지 않으면 마스터 서비스에 대한 보고서가 전송됩니다.</span><span class="sxs-lookup"><span data-stu-id="460d6-284">If they do not respect the thresholds, a report is sent on the master service.</span></span> <span data-ttu-id="460d6-285">작업 식별자(예: **PendingTask + taskId**)가 들어 있는 각 작업에 대한 보고서도 전송됩니다.</span><span class="sxs-lookup"><span data-stu-id="460d6-285">A report is also sent on each task that includes the task identifier, like **PendingTask+taskId**.</span></span> <span data-ttu-id="460d6-286">비정상 상태에 대한 보고서만 전송되어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="460d6-286">Reports should be sent only on unhealthy states.</span></span> <span data-ttu-id="460d6-287">TTL(Time To Live)을 몇 분 정도로 설정하고 만료되면 보고서가 제거되도록 표시해 두어, 확실히 제거되도록 합니다.</span><span class="sxs-lookup"><span data-stu-id="460d6-287">Set time to live to a few minutes, and mark the reports to be removed when they expire to ensure cleanup.</span></span>
* <span data-ttu-id="460d6-288">작업을 수행하는 보조는 작업 수행에 예상보다 긴 시간이 소요되면 보고합니다.</span><span class="sxs-lookup"><span data-stu-id="460d6-288">The secondary that is executing a task reports when it takes longer than expected to run it.</span></span> <span data-ttu-id="460d6-289">**PendingTasks**속성의 서비스 인스턴스를 보고합니다.</span><span class="sxs-lookup"><span data-stu-id="460d6-289">It reports on the service instance on the property **PendingTasks**.</span></span> <span data-ttu-id="460d6-290">보고서는 문제가 있는 서비스 인스턴스를 정확히 찾아내지만 인스턴스가 사라지는 상황을 포착하지는 않습니다.</span><span class="sxs-lookup"><span data-stu-id="460d6-290">The report pinpoints the service instance that has issues, but it doesn't capture the situation where the instance dies.</span></span> <span data-ttu-id="460d6-291">보고서는 그때 삭제됩니다.</span><span class="sxs-lookup"><span data-stu-id="460d6-291">The reports are cleaned up then.</span></span> <span data-ttu-id="460d6-292">보조 서비스를 보고할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="460d6-292">It could report on the secondary service.</span></span> <span data-ttu-id="460d6-293">보조가 작업을 완료하면 보조 인스턴스가 저장소에서 보고서를 삭제합니다.</span><span class="sxs-lookup"><span data-stu-id="460d6-293">If the secondary completes the task, the secondary instance clears the report from the store.</span></span> <span data-ttu-id="460d6-294">보고서는 인증 메시지가 손실되고 마스터의 관점에서 작업이 마무리되지 않은 상황을 포착하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="460d6-294">The report doesn't capture the situation where the acknowledgement message is lost and the task is not finished from the master's point of view.</span></span>

<span data-ttu-id="460d6-295">하지만 위에 설명된 상황에서 보고가 수행되며, 상태를 평가할 때 응용 프로그램 상태에서 보고서가 포착됩니다.</span><span class="sxs-lookup"><span data-stu-id="460d6-295">However the reporting is done in the cases described above, the reports are captured in application health when health is evaluated.</span></span>

## <a name="report-periodically-vs-on-transition"></a><span data-ttu-id="460d6-296">주기적 보고 대 전환기 보고</span><span class="sxs-lookup"><span data-stu-id="460d6-296">Report periodically vs. on transition</span></span>
<span data-ttu-id="460d6-297">상태 보고 모델을 사용하면 Watchdog에서 주기적으로 또는 전환기에 보고서를 보낼 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="460d6-297">By using the health reporting model, watchdogs can send reports periodically or on transitions.</span></span> <span data-ttu-id="460d6-298">코드가 훨씬 간단하고 오류 가능성이 적으므로 Watchdog 보고에는 주기적 보고를 권장합니다.</span><span class="sxs-lookup"><span data-stu-id="460d6-298">The recommended way for watchdog reporting is periodically, because the code is much simpler and less prone to errors.</span></span> <span data-ttu-id="460d6-299">잘못된 보고서를 트리거하는 버그를 방지할 수 있도록 Watchdog는 최대한 간단해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="460d6-299">The watchdogs must strive to be as simple as possible to avoid bugs that trigger incorrect reports.</span></span> <span data-ttu-id="460d6-300">잘못된 *비정상* 보고서는 상태 평가에 영향을 미치고 업그레이드를 비롯한 상태 기반 시나리오에도 영향을 미칩니다.</span><span class="sxs-lookup"><span data-stu-id="460d6-300">Incorrect *unhealthy* reports impact health evaluations and scenarios based on health, including upgrades.</span></span> <span data-ttu-id="460d6-301">잘못된 *정상* 보고서는 클러스터의 문제를 숨기는데, 이것은 바람직하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="460d6-301">Incorrect *healthy* reports hide issues in the cluster, which is not desired.</span></span>

<span data-ttu-id="460d6-302">주기적인 보고를 위해 Watchdog를 타이머와 함께 구현할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="460d6-302">For periodic reporting, the watchdog can be implemented with a timer.</span></span> <span data-ttu-id="460d6-303">타이머 콜백이 발생하면 Watchdog는 상태를 확인하고 현재 상태를 기반으로 보고서를 보냅니다.</span><span class="sxs-lookup"><span data-stu-id="460d6-303">On a timer callback, the watchdog can check the state and send a report based on the current state.</span></span> <span data-ttu-id="460d6-304">이전에 어떤 보고서를 전송했는지 확인하거나 메시지 전송과 관련한 최적화를 수행할 필요가 없습니다.</span><span class="sxs-lookup"><span data-stu-id="460d6-304">There is no need to see which report was sent previously or make any optimizations in terms of messaging.</span></span> <span data-ttu-id="460d6-305">상태 클라이언트에는 성능을 돕기 위한 일괄 처리 논리가 있습니다.</span><span class="sxs-lookup"><span data-stu-id="460d6-305">The health client has batching logic to help with performance.</span></span> <span data-ttu-id="460d6-306">상태 클라이언트가 유지되는 동안 Health 스토어에서 보고서가 ACK될 때까지 또는 Watchdog가 동일한 엔터티, 속성 및 소스에 대한 새 보고서를 생성할 때가지 내부적으로 재시도합니다.</span><span class="sxs-lookup"><span data-stu-id="460d6-306">While the health client is kept alive, it retries internally until the report is acknowledged by the health store or the watchdog generates a newer report with the same entity, property, and source.</span></span>

<span data-ttu-id="460d6-307">전환기 보고는 꼼꼼한 상태 처리가 필요합니다.</span><span class="sxs-lookup"><span data-stu-id="460d6-307">Reporting on transitions requires careful handling of state.</span></span> <span data-ttu-id="460d6-308">Watchdog는 조건을 모니터링하면서 조건이 변경된 경우에만 보고합니다.</span><span class="sxs-lookup"><span data-stu-id="460d6-308">The watchdog monitors some conditions and reports only when the conditions change.</span></span> <span data-ttu-id="460d6-309">이 방식은 필요한 보고서의 수가 적다는 장점이 있지만</span><span class="sxs-lookup"><span data-stu-id="460d6-309">The upside of this approach is that fewer reports are needed.</span></span> <span data-ttu-id="460d6-310">Watchdog의 논리가 복잡하다는 단점이 있습니다.</span><span class="sxs-lookup"><span data-stu-id="460d6-310">The downside is that the logic of the watchdog is complex.</span></span> <span data-ttu-id="460d6-311">Watchdog는 상태 변화를 판단하기 위해 조건이나 보고서를 검사할 수 있도록 조건이나 보고서를 유지해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="460d6-311">The watchdog must maintain the conditions or the reports, so that they can be inspected to determine state changes.</span></span> <span data-ttu-id="460d6-312">장애 조치의 경우 추가되었으나 아직 상태 저장소로 보내지 않은 보고서에 대해 주의가 필요합니다.</span><span class="sxs-lookup"><span data-stu-id="460d6-312">On failover, care must be taken with reports added, but not yet sent to the health store.</span></span> <span data-ttu-id="460d6-313">시퀀스 번호는 계속 증가해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="460d6-313">The sequence number must be ever-increasing.</span></span> <span data-ttu-id="460d6-314">그렇지 않으면 시퀀스 번호가 오래되어 보고서가 거부됩니다.</span><span class="sxs-lookup"><span data-stu-id="460d6-314">If not, the reports are rejected as stale.</span></span> <span data-ttu-id="460d6-315">드물지만 데이터 손실이 발생하는 경우에는 보고자의 상태와 Health 스토어의 상태 사이에 동기화가 필요할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="460d6-315">In the rare cases where data loss is incurred, synchronization may be needed between the state of the reporter and the state of the health store.</span></span>

<span data-ttu-id="460d6-316">전환에 대한 보고는 `Partition` 또는 `CodePackageActivationContext`를 통한 자체에 대한 서비스 보고에 적합합니다.</span><span class="sxs-lookup"><span data-stu-id="460d6-316">Reporting on transitions makes sense for services reporting on themselves, through `Partition` or `CodePackageActivationContext`.</span></span> <span data-ttu-id="460d6-317">로컬 개체(복제본 또는 배포된 서비스 패키지/배포된 응용 프로그램)가 제거되면 해당 보고서도 모두 제거됩니다.</span><span class="sxs-lookup"><span data-stu-id="460d6-317">When the local object (replica or deployed service package / deployed application) is removed, all its reports are also removed.</span></span> <span data-ttu-id="460d6-318">이러한 자동 정리는 보고자와 Health 스토어 간을 동기화할 필요가 없도록 합니다.</span><span class="sxs-lookup"><span data-stu-id="460d6-318">This automatic cleanup relaxes the need for synchronization between reporter and health store.</span></span> <span data-ttu-id="460d6-319">부모 파티션 또는 부모 응용 프로그램에 대한 보고에서는 Health 스토어에 사용되지 않는 보고서가 생성되지 않도록 주의해서 장애 조치(failover)가 진행되어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="460d6-319">If the report is for parent partition or parent application, care must be taken on failover to avoid stale reports in the health store.</span></span> <span data-ttu-id="460d6-320">올바른 상태를 유지하고 더 이상 필요하지 않은 경우 스토어에서 보고서를 지우는 논리를 추가해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="460d6-320">Logic must be added to maintain the correct state and clear the report from store when not needed anymore.</span></span>

## <a name="implement-health-reporting"></a><span data-ttu-id="460d6-321">상태 보고 구현</span><span class="sxs-lookup"><span data-stu-id="460d6-321">Implement health reporting</span></span>
<span data-ttu-id="460d6-322">엔터티와 보고서 세부 사항이 명확해지면 API, PowerShell 또는 REST를 통해 상태 보고서를 보낼 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="460d6-322">Once the entity and report details are clear, sending health reports can be done through the API, PowerShell, or REST.</span></span>

### <a name="api"></a><span data-ttu-id="460d6-323">API</span><span class="sxs-lookup"><span data-stu-id="460d6-323">API</span></span>
<span data-ttu-id="460d6-324">API를 통해 보고하려면 보고하려는 엔터티 유형에 맞는 상태 보고서를 만들어서</span><span class="sxs-lookup"><span data-stu-id="460d6-324">To report through the API, you need to create a health report specific to the entity type they want to report on.</span></span> <span data-ttu-id="460d6-325">상태 클라이언트에 보고서를 제공해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="460d6-325">Give the report to a health client.</span></span> <span data-ttu-id="460d6-326">또는 상태 정보를 만들고 `Partition` 또는 `CodePackageActivationContext`에 대한 올바른 보고 메서드에 전달하여 현재 엔터티에 대해 보고합니다.</span><span class="sxs-lookup"><span data-stu-id="460d6-326">Alternatively, create a health information and pass it to correct reporting methods on `Partition` or `CodePackageActivationContext` to report on current entities.</span></span>

<span data-ttu-id="460d6-327">다음은 클러스터 내의 Watchdog에서 보내는 주기적 보고서의 예입니다.</span><span class="sxs-lookup"><span data-stu-id="460d6-327">The following example shows periodic reporting from a watchdog within the cluster.</span></span> <span data-ttu-id="460d6-328">Watchdog는 노드 내에서 외부 리소스를 액세스할 수 있는지 여부를 확인합니다.</span><span class="sxs-lookup"><span data-stu-id="460d6-328">The watchdog checks whether an external resource can be accessed from within a node.</span></span> <span data-ttu-id="460d6-329">리소스는 응용 프로그램 내의 서비스 매니페스트에 필요합니다.</span><span class="sxs-lookup"><span data-stu-id="460d6-329">The resource is needed by a service manifest within the application.</span></span> <span data-ttu-id="460d6-330">리소스를 사용할 수 없더라도 응용 프로그램 내의 다른 서비스는 여전히 정상적으로 작동할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="460d6-330">If the resource is unavailable, the other services within the application can still function properly.</span></span> <span data-ttu-id="460d6-331">따라서 배포된 서비스 패키지 엔터티에 대한 보고서가 주기적으로 30초마다 전송됩니다.</span><span class="sxs-lookup"><span data-stu-id="460d6-331">Therefore, the report is sent on the deployed service package entity every 30 seconds.</span></span>

```csharp
private static Uri ApplicationName = new Uri("fabric:/WordCount");
private static string ServiceManifestName = "WordCount.Service";
private static string NodeName = FabricRuntime.GetNodeContext().NodeName;
private static Timer ReportTimer = new Timer(new TimerCallback(SendReport), null, 30 * 1000, 30 * 1000);
private static FabricClient Client = new FabricClient(new FabricClientSettings() { HealthReportSendInterval = TimeSpan.FromSeconds(0) });

public static void SendReport(object obj)
{
    // Test whether the resource can be accessed from the node
    HealthState healthState = this.TestConnectivityToExternalResource();

    // Send report on deployed service package, as the connectivity is needed by the specific service manifest
    // and can be different on different nodes
    var deployedServicePackageHealthReport = new DeployedServicePackageHealthReport(
        ApplicationName,
        ServiceManifestName,
        NodeName,
        new HealthInformation("ExternalSourceWatcher", "Connectivity", healthState));

    // TODO: handle exception. Code omitted for snippet brevity.
    // Possible exceptions: FabricException with error codes
    // FabricHealthStaleReport (non-retryable, the report is already queued on the health client),
    // FabricHealthMaxReportsReached (retryable; user should retry with exponential delay until the report is accepted).
    Client.HealthManager.ReportHealth(deployedServicePackageHealthReport);
}
```

### <a name="powershell"></a><span data-ttu-id="460d6-332">PowerShell</span><span class="sxs-lookup"><span data-stu-id="460d6-332">PowerShell</span></span>
<span data-ttu-id="460d6-333">**Send-ServiceFabric*EntityType*HealthReport**를 사용하여 상태 보고서를 보냅니다.</span><span class="sxs-lookup"><span data-stu-id="460d6-333">Send health reports with **Send-ServiceFabric*EntityType*HealthReport**.</span></span>

<span data-ttu-id="460d6-334">다음은 노드의 CPU 값에 대한 주기적인 보고의 사례입니다.</span><span class="sxs-lookup"><span data-stu-id="460d6-334">The following example shows periodic reporting on CPU values on a node.</span></span> <span data-ttu-id="460d6-335">보고서는 30초마다 전송되어야 하며, 보고서의 TTL은 2분입니다.</span><span class="sxs-lookup"><span data-stu-id="460d6-335">The reports should be sent every 30 seconds, and they have a time to live of two minutes.</span></span> <span data-ttu-id="460d6-336">보고서가 만료되면 보고자에게 문제가 있다는 뜻이므로 노드가 오류로 평가됩니다.</span><span class="sxs-lookup"><span data-stu-id="460d6-336">If they expire, the reporter has issues, so the node is evaluated at error.</span></span> <span data-ttu-id="460d6-337">CPU가 임계값을 초과하면 보고서의 성능 상태는 경고가 됩니다.</span><span class="sxs-lookup"><span data-stu-id="460d6-337">When the CPU is above a threshold, the report has a health state of warning.</span></span> <span data-ttu-id="460d6-338">CPU가 구성된 시간보다 더 긴 시간 동안 임계값을 초과하면 오류로 보고합니다.</span><span class="sxs-lookup"><span data-stu-id="460d6-338">When the CPU remains above a threshold for more than the configured time, it's reported as an error.</span></span> <span data-ttu-id="460d6-339">그렇지 않으면 보고자가 정상 상태로 보고합니다.</span><span class="sxs-lookup"><span data-stu-id="460d6-339">Otherwise, the reporter sends a health state of OK.</span></span>

```powershell
PS C:\> Send-ServiceFabricNodeHealthReport -NodeName Node.1 -HealthState Warning -SourceId PowershellWatcher -HealthProperty CPU -Description "CPU is above 80% threshold" -TimeToLiveSec 120

PS C:\> Get-ServiceFabricNodeHealth -NodeName Node.1
NodeName              : Node.1
AggregatedHealthState : Warning
UnhealthyEvaluations  :
                        Unhealthy event: SourceId='PowershellWatcher', Property='CPU', HealthState='Warning', ConsiderWarningAsError=false.

HealthEvents          :
                        SourceId              : System.FM
                        Property              : State
                        HealthState           : Ok
                        SequenceNumber        : 5
                        SentAt                : 4/21/2015 8:01:17 AM
                        ReceivedAt            : 4/21/2015 8:02:12 AM
                        TTL                   : Infinite
                        Description           : Fabric node is up.
                        RemoveWhenExpired     : False
                        IsExpired             : False
                        Transitions           : ->Ok = 4/21/2015 8:02:12 AM

                        SourceId              : PowershellWatcher
                        Property              : CPU
                        HealthState           : Warning
                        SequenceNumber        : 130741236814913394
                        SentAt                : 4/21/2015 9:01:21 PM
                        ReceivedAt            : 4/21/2015 9:01:21 PM
                        TTL                   : 00:02:00
                        Description           : CPU is above 80% threshold
                        RemoveWhenExpired     : False
                        IsExpired             : False
                        Transitions           : ->Warning = 4/21/2015 9:01:21 PM
```

<span data-ttu-id="460d6-340">다음 예는 복제본에 대한 일시적인 경고를 보고합니다.</span><span class="sxs-lookup"><span data-stu-id="460d6-340">The following example reports a transient warning on a replica.</span></span> <span data-ttu-id="460d6-341">우선 파티션 ID를 가져온 다음 알고 싶은 서비스의 복제본 ID를 가져옵니다.</span><span class="sxs-lookup"><span data-stu-id="460d6-341">It first gets the partition ID and then the replica ID for the service it is interested in.</span></span> <span data-ttu-id="460d6-342">그런 다음 **PowershellWatcher**에서 **ResourceDependency** 속성에 대한 보고서를 보냅니다.</span><span class="sxs-lookup"><span data-stu-id="460d6-342">It then sends a report from **PowershellWatcher** on the property **ResourceDependency**.</span></span> <span data-ttu-id="460d6-343">보고서는 2분 동안 지속된 후 저장소에서 자동으로 삭제됩니다.</span><span class="sxs-lookup"><span data-stu-id="460d6-343">The report is of interest for only two minutes, and it is removed from the store automatically.</span></span>

```powershell
PS C:\> $partitionId = (Get-ServiceFabricPartition -ServiceName fabric:/WordCount/WordCount.Service).PartitionId

PS C:\> $replicaId = (Get-ServiceFabricReplica -PartitionId $partitionId | where {$_.ReplicaRole -eq "Primary"}).ReplicaId

PS C:\> Send-ServiceFabricReplicaHealthReport -PartitionId $partitionId -ReplicaId $replicaId -HealthState Warning -SourceId PowershellWatcher -HealthProperty ResourceDependency -Description "The external resource that the primary is using has been rebooted at 4/21/2015 9:01:21 PM. Expect processing delays for a few minutes." -TimeToLiveSec 120 -RemoveWhenExpired

PS C:\> Get-ServiceFabricReplicaHealth  -PartitionId $partitionId -ReplicaOrInstanceId $replicaId


PartitionId           : 8f82daff-eb68-4fd9-b631-7a37629e08c0
ReplicaId             : 130740415594605869
AggregatedHealthState : Warning
UnhealthyEvaluations  :
                        Unhealthy event: SourceId='PowershellWatcher', Property='ResourceDependency', HealthState='Warning', ConsiderWarningAsError=false.

HealthEvents          :
                        SourceId              : System.RA
                        Property              : State
                        HealthState           : Ok
                        SequenceNumber        : 130740768777734943
                        SentAt                : 4/21/2015 8:01:17 AM
                        ReceivedAt            : 4/21/2015 8:02:12 AM
                        TTL                   : Infinite
                        Description           : Replica has been created.
                        RemoveWhenExpired     : False
                        IsExpired             : False
                        Transitions           : ->Ok = 4/21/2015 8:02:12 AM

                        SourceId              : PowershellWatcher
                        Property              : ResourceDependency
                        HealthState           : Warning
                        SequenceNumber        : 130741243777723555
                        SentAt                : 4/21/2015 9:12:57 PM
                        ReceivedAt            : 4/21/2015 9:12:57 PM
                        TTL                   : 00:02:00
                        Description           : The external resource that the primary is using has been rebooted at 4/21/2015 9:01:21 PM. Expect processing delays for a few minutes.
                        RemoveWhenExpired     : True
                        IsExpired             : False
                        Transitions           : ->Warning = 4/21/2015 9:12:32 PM
```

### <a name="rest"></a><span data-ttu-id="460d6-344">REST (영문)</span><span class="sxs-lookup"><span data-stu-id="460d6-344">REST</span></span>
<span data-ttu-id="460d6-345">원하는 엔터티로 이동하는 POST 요청과 REST를 사용하고 본문에 상태 보고서 설명을 넣어서 상태 보고서를 보냅니다.</span><span class="sxs-lookup"><span data-stu-id="460d6-345">Send health reports using REST with POST requests that go to the desired entity and have in the body the health report description.</span></span> <span data-ttu-id="460d6-346">예를 들어, REST [클러스터 상태 보고서](https://docs.microsoft.com/rest/api/servicefabric/report-the-health-of-a-cluster) 또는 [서비스 상태 보고서](https://docs.microsoft.com/rest/api/servicefabric/report-the-health-of-a-service)를 보내는 방법을 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="460d6-346">For example, see how to send REST [cluster health reports](https://docs.microsoft.com/rest/api/servicefabric/report-the-health-of-a-cluster) or [service health reports](https://docs.microsoft.com/rest/api/servicefabric/report-the-health-of-a-service).</span></span> <span data-ttu-id="460d6-347">모든 엔터티가 지원됩니다.</span><span class="sxs-lookup"><span data-stu-id="460d6-347">All entities are supported.</span></span>

## <a name="next-steps"></a><span data-ttu-id="460d6-348">다음 단계</span><span class="sxs-lookup"><span data-stu-id="460d6-348">Next steps</span></span>
<span data-ttu-id="460d6-349">상태 데이터를 기반으로 서비스 작성자 및 클러스터/응용 프로그램 관리자는 정보를 소비하는 방식에 대해 생각할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="460d6-349">Based on the health data, service writers and cluster/application administrators can think of ways to consume the information.</span></span> <span data-ttu-id="460d6-350">예를 들어 성능 상태를 기반으로 경고를 설정하면 서비스가 중단되기 전에 심각한 문제를 포착할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="460d6-350">For example, they can set up alerts based on health status to catch severe issues before they provoke outages.</span></span> <span data-ttu-id="460d6-351">또한 관리자는 자동으로 문제를 해결하는 복구 시스템을 설정할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="460d6-351">Administrators can also set up repair systems to fix issues automatically.</span></span>

[<span data-ttu-id="460d6-352">서비스 패브릭 상태 모니터링 소개</span><span class="sxs-lookup"><span data-stu-id="460d6-352">Introduction to Service Fabric health Monitoring</span></span>](service-fabric-health-introduction.md)

[<span data-ttu-id="460d6-353">서비스 패브릭 상태 보고서 보기</span><span class="sxs-lookup"><span data-stu-id="460d6-353">View Service Fabric health reports</span></span>](service-fabric-view-entities-aggregated-health.md)

[<span data-ttu-id="460d6-354">서비스 상태를 보고 및 확인하는 방법</span><span class="sxs-lookup"><span data-stu-id="460d6-354">How to report and check service health</span></span>](service-fabric-diagnostics-how-to-report-and-check-service-health.md)

[<span data-ttu-id="460d6-355">시스템 상태 보고서를 문제 해결에 사용</span><span class="sxs-lookup"><span data-stu-id="460d6-355">Use system health reports for troubleshooting</span></span>](service-fabric-understand-and-troubleshoot-with-system-health-reports.md)

[<span data-ttu-id="460d6-356">로컬로 서비스 모니터링 및 진단</span><span class="sxs-lookup"><span data-stu-id="460d6-356">Monitor and diagnose services locally</span></span>](service-fabric-diagnostics-how-to-monitor-and-diagnose-services-locally.md)

[<span data-ttu-id="460d6-357">서비스 패브릭 응용 프로그램 업그레이드</span><span class="sxs-lookup"><span data-stu-id="460d6-357">Service Fabric application upgrade</span></span>](service-fabric-application-upgrade.md)

