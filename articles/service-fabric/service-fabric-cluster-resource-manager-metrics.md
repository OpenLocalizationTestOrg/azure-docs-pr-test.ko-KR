---
title: "메트릭을 사용하여 Azure 마이크로 서비스 부하 관리 | Microsoft Docs"
description: "서비스 리소스 소비를 관리하기 위해 Service Fabric에서 메트릭을 구성하고 사용하는 방법에 대해 알아봅니다."
services: service-fabric
documentationcenter: .net
author: masnider
manager: timlt
editor: 
ms.assetid: 0d622ea6-a7c7-4bef-886b-06e6b85a97fb
ms.service: Service-Fabric
ms.devlang: dotnet
ms.topic: article
ms.tgt_pltfrm: NA
ms.workload: NA
ms.date: 08/18/2017
ms.author: masnider
ms.openlocfilehash: 7e020bb6c02c80127e4225ba695017dff9b5a168
ms.sourcegitcommit: 50e23e8d3b1148ae2d36dad3167936b4e52c8a23
ms.translationtype: MT
ms.contentlocale: ko-KR
ms.lasthandoff: 08/18/2017
---
# <a name="managing-resource-consumption-and-load-in-service-fabric-with-metrics"></a><span data-ttu-id="9fb75-103">메트릭을 사용하여 Service Fabric에서 리소스 부하 및 소비 관리</span><span class="sxs-lookup"><span data-stu-id="9fb75-103">Managing resource consumption and load in Service Fabric with metrics</span></span>
<span data-ttu-id="9fb75-104">*메트릭*은 서비스에서 관심을 갖고 클러스터의 노드에서 제공하는 리소스입니다.</span><span class="sxs-lookup"><span data-stu-id="9fb75-104">*Metrics* are the resources that your services care about and which are provided by the nodes in the cluster.</span></span> <span data-ttu-id="9fb75-105">메트릭은 서비스 성능을 향상시키거나 모니터링하기 위해 관리하려는 모든 항목입니다.</span><span class="sxs-lookup"><span data-stu-id="9fb75-105">A metric is anything that you want to manage in order to improve or monitor the performance of your services.</span></span> <span data-ttu-id="9fb75-106">예를 들어 메모리 사용량을 조사하여 서비스가 오버로드 상태인지 여부를 확인할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="9fb75-106">For example, you might watch memory consumption to know if your service is overloaded.</span></span> <span data-ttu-id="9fb75-107">또 다른 용도는 더 나은 성능을 얻기 위해 메모리 제약이 심하지 않은 위치로 서비스를 이동할 수 있는지 여부를 파악하는 것입니다.</span><span class="sxs-lookup"><span data-stu-id="9fb75-107">Another use is to figure out whether the service could move elsewhere where memory is less constrained in order to get better performance.</span></span>

<span data-ttu-id="9fb75-108">메모리, 디스크, CPU 사용량 등이 모두 메트릭의 예입니다.</span><span class="sxs-lookup"><span data-stu-id="9fb75-108">Things like Memory, Disk, and CPU usage are examples of metrics.</span></span> <span data-ttu-id="9fb75-109">이러한 메트릭은 노드에서 관리해야 하는 물리적 리소스에 해당하는 물리적 메트릭입니다.</span><span class="sxs-lookup"><span data-stu-id="9fb75-109">These metrics are physical metrics, resources that correspond to physical resources on the node that need to be managed.</span></span> <span data-ttu-id="9fb75-110">메트릭은 논리 메트릭이 될 수도 있으며 이것이 일반적인 경우이기도 합니다.</span><span class="sxs-lookup"><span data-stu-id="9fb75-110">Metrics can also be (and commonly are) logical metrics.</span></span> <span data-ttu-id="9fb75-111">“MyWorkQueueDepth”, "MessagesToProcess" 또는 "TotalRecords" 등이 논리 메트릭입니다.</span><span class="sxs-lookup"><span data-stu-id="9fb75-111">Logical metrics are things like “MyWorkQueueDepth” or "MessagesToProcess" or "TotalRecords".</span></span> <span data-ttu-id="9fb75-112">논리 메트릭은 응용 프로그램에서 정의하며 간접적으로 일부 물리적 리소스 사용량에 해당합니다.</span><span class="sxs-lookup"><span data-stu-id="9fb75-112">Logical metrics are application-defined and indirectly correspond to some physical resource consumption.</span></span> <span data-ttu-id="9fb75-113">서비스별로 물리적 리소스 사용량을 측정하고 보고하는 것이 어려울 수 있기 때문에 논리 메트릭이 일반적입니다.</span><span class="sxs-lookup"><span data-stu-id="9fb75-113">Logical metrics are common because it can be hard to measure and report consumption of physical resources on a per-service basis.</span></span> <span data-ttu-id="9fb75-114">사용자 고유의 메트릭을 측정하고 보고하는 복잡성은 Service Fabric에서 몇 가지 기본 메트릭을 제공하는 이유이기도 합니다.</span><span class="sxs-lookup"><span data-stu-id="9fb75-114">The complexity of measuring and reporting your own physical metrics is also why Service Fabric provides some default metrics.</span></span>

## <a name="default-metrics"></a><span data-ttu-id="9fb75-115">기본 메트릭</span><span class="sxs-lookup"><span data-stu-id="9fb75-115">Default metrics</span></span>
<span data-ttu-id="9fb75-116">서비스를 작성하고 배포하기 시작한다고 가정해 보겠습니다.</span><span class="sxs-lookup"><span data-stu-id="9fb75-116">Let’s say that you want to get started writing and deploying your service.</span></span> <span data-ttu-id="9fb75-117">이 시점에서는 어떤 물리적 또는 논리적 리소스를 사용하는지 알 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="9fb75-117">At this point you don’t know what physical or logical resources it consumes.</span></span> <span data-ttu-id="9fb75-118">이것으로 끝입니다.</span><span class="sxs-lookup"><span data-stu-id="9fb75-118">That’s fine!</span></span> <span data-ttu-id="9fb75-119">다른 메트릭이 지정되지 않은 경우 Service Fabric 클러스터 리소스 관리자에서는 일부 기본 메트릭을 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="9fb75-119">The Service Fabric Cluster Resource Manager uses some default metrics when no other metrics are specified.</span></span> <span data-ttu-id="9fb75-120">아래에 이 계정과 키의 예제가 나와 있습니다.</span><span class="sxs-lookup"><span data-stu-id="9fb75-120">They are:</span></span>

  - <span data-ttu-id="9fb75-121">PrimaryCount - 노드의 주 복제본 수</span><span class="sxs-lookup"><span data-stu-id="9fb75-121">PrimaryCount - count of Primary replicas on the node</span></span> 
  - <span data-ttu-id="9fb75-122">ReplicaCount - 노드의 총 상태 저장 복제본 수</span><span class="sxs-lookup"><span data-stu-id="9fb75-122">ReplicaCount - count of total stateful replicas on the node</span></span>
  - <span data-ttu-id="9fb75-123">Count - 노드의 모든 서비스 개체(상태 비저장 및 상태 저장) 수</span><span class="sxs-lookup"><span data-stu-id="9fb75-123">Count - count of all service objects (stateless and stateful) on the node</span></span>

| <span data-ttu-id="9fb75-124">메트릭</span><span class="sxs-lookup"><span data-stu-id="9fb75-124">Metric</span></span> | <span data-ttu-id="9fb75-125">상태 비저장 인스턴스 부하</span><span class="sxs-lookup"><span data-stu-id="9fb75-125">Stateless Instance Load</span></span> | <span data-ttu-id="9fb75-126">상태 저장 보조 부하</span><span class="sxs-lookup"><span data-stu-id="9fb75-126">Stateful Secondary Load</span></span> | <span data-ttu-id="9fb75-127">상태 저장 기본 부하</span><span class="sxs-lookup"><span data-stu-id="9fb75-127">Stateful Primary Load</span></span> |
| --- | --- | --- | --- |
| <span data-ttu-id="9fb75-128">PrimaryCount</span><span class="sxs-lookup"><span data-stu-id="9fb75-128">PrimaryCount</span></span> |<span data-ttu-id="9fb75-129">0</span><span class="sxs-lookup"><span data-stu-id="9fb75-129">0</span></span> |<span data-ttu-id="9fb75-130">0</span><span class="sxs-lookup"><span data-stu-id="9fb75-130">0</span></span> |<span data-ttu-id="9fb75-131">1</span><span class="sxs-lookup"><span data-stu-id="9fb75-131">1</span></span> |
| <span data-ttu-id="9fb75-132">ReplicaCount</span><span class="sxs-lookup"><span data-stu-id="9fb75-132">ReplicaCount</span></span> |<span data-ttu-id="9fb75-133">0</span><span class="sxs-lookup"><span data-stu-id="9fb75-133">0</span></span> |<span data-ttu-id="9fb75-134">1</span><span class="sxs-lookup"><span data-stu-id="9fb75-134">1</span></span> |<span data-ttu-id="9fb75-135">1</span><span class="sxs-lookup"><span data-stu-id="9fb75-135">1</span></span> |
| <span data-ttu-id="9fb75-136">개수</span><span class="sxs-lookup"><span data-stu-id="9fb75-136">Count</span></span> |<span data-ttu-id="9fb75-137">1</span><span class="sxs-lookup"><span data-stu-id="9fb75-137">1</span></span> |<span data-ttu-id="9fb75-138">1</span><span class="sxs-lookup"><span data-stu-id="9fb75-138">1</span></span> |<span data-ttu-id="9fb75-139">1</span><span class="sxs-lookup"><span data-stu-id="9fb75-139">1</span></span> |

<span data-ttu-id="9fb75-140">기본 워크로드의 경우 기본 메트릭은 클러스터에서 적절한 작업 분산을 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="9fb75-140">For basic workloads, the default metrics provide a decent distribution of work in the cluster.</span></span> <span data-ttu-id="9fb75-141">다음 예에서는 두 서비스를 만들고 분산에 대해 기본 메트릭을 사용할 때 어떤 상황이 발생하는지 확인해 보겠습니다.</span><span class="sxs-lookup"><span data-stu-id="9fb75-141">In the following example, let’s see what happens when we create two services and rely on the default metrics for balancing.</span></span> <span data-ttu-id="9fb75-142">첫 번째 서비스는 3개의 파티션과 3개의 대상 복제본 세트 크기가 있는 상태 저장 서비스입니다.</span><span class="sxs-lookup"><span data-stu-id="9fb75-142">The first service is a stateful service with three partitions and a target replica set size of three.</span></span> <span data-ttu-id="9fb75-143">두 번째는 하나의 파티션과 3개의 인스턴스 수가 있는 상태 비저장 서비스입니다.</span><span class="sxs-lookup"><span data-stu-id="9fb75-143">The second service is a stateless service with one partition and an instance count of three.</span></span>

<span data-ttu-id="9fb75-144">다음을 알 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="9fb75-144">Here's what you get:</span></span>

<span data-ttu-id="9fb75-145"><center>
![기본 메트릭으로 클러스터 레이아웃][Image1]
</center></span><span class="sxs-lookup"><span data-stu-id="9fb75-145"><center>
![Cluster Layout with Default Metrics][Image1]
</center></span></span>

<span data-ttu-id="9fb75-146">유의해야 할 몇 가지 사항은 다음과 같습니다.</span><span class="sxs-lookup"><span data-stu-id="9fb75-146">Some things to note:</span></span>
  - <span data-ttu-id="9fb75-147">상태 저장 서비스에 대한 주 복제본은 여러 노드에 분산됩니다.</span><span class="sxs-lookup"><span data-stu-id="9fb75-147">Primary replicas for the stateful service are distributed across several nodes</span></span>
  - <span data-ttu-id="9fb75-148">동일한 파티션에 대한 복제본은 다른 노드에 있습니다</span><span class="sxs-lookup"><span data-stu-id="9fb75-148">Replicas for the same partition are on different nodes</span></span>
  - <span data-ttu-id="9fb75-149">기본 복제본 및 보조 복제본의 총 수는 클러스터에 배포됩니다</span><span class="sxs-lookup"><span data-stu-id="9fb75-149">The total number of primaries and secondaries is distributed in the cluster</span></span>
  - <span data-ttu-id="9fb75-150">서비스 개체의 총 수는 각 노드에 균등하게 할당됩니다.</span><span class="sxs-lookup"><span data-stu-id="9fb75-150">The total number of service objects are evenly allocated on each node</span></span>

<span data-ttu-id="9fb75-151">좋습니다.</span><span class="sxs-lookup"><span data-stu-id="9fb75-151">Good!</span></span>

<span data-ttu-id="9fb75-152">기본 메트릭은 처음부터 잘 작동하지만</span><span class="sxs-lookup"><span data-stu-id="9fb75-152">The default metrics work great as a start.</span></span> <span data-ttu-id="9fb75-153">지금까지만 수행됩니다.</span><span class="sxs-lookup"><span data-stu-id="9fb75-153">However, the default metrics will only carry you so far.</span></span> <span data-ttu-id="9fb75-154">예를 들어 선택한 파티션 구성표가 모든 파티션에서 완벽하게 활용되는 결과는 어떻게 될까요?</span><span class="sxs-lookup"><span data-stu-id="9fb75-154">For example: What's the likelihood that the partitioning scheme you picked results in perfectly even utilization by all partitions?</span></span> <span data-ttu-id="9fb75-155">시간이 지남에 따라 지정된 서비스에 대한 로드가 일정하거나 심지어 여러 파티션에서 지금 동일하게 나타날 가능성은 얼마나 될까요?</span><span class="sxs-lookup"><span data-stu-id="9fb75-155">What’s the chance that the load for a given service is constant over time, or even just the same across multiple partitions right now?</span></span>

<span data-ttu-id="9fb75-156">기본 메트릭만으로 실행할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="9fb75-156">You could run with just the default metrics.</span></span> <span data-ttu-id="9fb75-157">그러나 이렇게 하면 일반적으로 클러스터 사용률이 원하는 것보다 낮고 균등하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="9fb75-157">However, doing so usually means that your cluster utilization is lower and more uneven than you’d like.</span></span> <span data-ttu-id="9fb75-158">이는 기본 메트릭이 적응되지 않으며 모든 것이 동등하다고 가정하기 때문입니다.</span><span class="sxs-lookup"><span data-stu-id="9fb75-158">This is because the default metrics aren't adaptive and presume everything is equivalent.</span></span> <span data-ttu-id="9fb75-159">예를 들어 사용 중인 주 복제본과 사용되지 않는 복제본이 있으며, 둘 다 PrimaryCount 메트릭에 "1"을 제공하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="9fb75-159">For example, a Primary that is busy and one that is not both contribute "1" to the PrimaryCount metric.</span></span> <span data-ttu-id="9fb75-160">최악의 경우 기본 메트릭만 사용하면 노드를 과도하게 예약하여 성능 문제가 발생할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="9fb75-160">In the worst case, using only the default metrics can also result in overscheduled nodes resulting in performance issues.</span></span> <span data-ttu-id="9fb75-161">클러스터를 최대한 활용하고 성능 문제를 방지하는 데 관심이 있는 경우 사용자 지정 메트릭 및 동적 로드 보고를 사용해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="9fb75-161">If you're interested in getting the most out of your cluster and avoiding performance issues, you need to use custom metrics and dynamic load reporting.</span></span>

## <a name="custom-metrics"></a><span data-ttu-id="9fb75-162">사용자 지정 메트릭</span><span class="sxs-lookup"><span data-stu-id="9fb75-162">Custom metrics</span></span>
<span data-ttu-id="9fb75-163">메트릭은 서비스를 만들 때 지정된 서비스 인스턴스별로 구성됩니다.</span><span class="sxs-lookup"><span data-stu-id="9fb75-163">Metrics are configured on a per-named-service-instance basis when you’re creating the service.</span></span>

<span data-ttu-id="9fb75-164">모든 메트릭에는 자체에 대해 설명하는 이름,가중치 및 기본 로드와 같은 몇 가지 속성이 있습니다.</span><span class="sxs-lookup"><span data-stu-id="9fb75-164">Any metric has some properties that describe it: a name, a weight, and a default load.</span></span>

* <span data-ttu-id="9fb75-165">메트릭 이름: 메트릭의 이름입니다.</span><span class="sxs-lookup"><span data-stu-id="9fb75-165">Metric Name: The name of the metric.</span></span> <span data-ttu-id="9fb75-166">메트릭 이름은 Resource Manager의 관점에서 클러스터 내의 메트릭에 대한 고유한 식별자입니다.</span><span class="sxs-lookup"><span data-stu-id="9fb75-166">The metric name is a unique identifier for the metric within the cluster from the Resource Manager’s perspective.</span></span>
* <span data-ttu-id="9fb75-167">Weight: 메트릭 가중치는 이 서비스에 대한 다른 메트릭에 상대적으로 이 메트릭이 갖는 중요도를 정의합니다.</span><span class="sxs-lookup"><span data-stu-id="9fb75-167">Weight: Metric weight defines how important this metric is relative to the other metrics for this service.</span></span>
* <span data-ttu-id="9fb75-168">기본 부하: 기본 부하는 서비스가 상태 비저장 서비스인지 또는 상태 저장 서비스인지에 따라 다르게 표현됩니다.</span><span class="sxs-lookup"><span data-stu-id="9fb75-168">Default Load: The default load is represented differently depending on whether the service is stateless or stateful.</span></span>
  * <span data-ttu-id="9fb75-169">상태 비저장 서비스의 경우 각 메트릭에는 DefaultLoad라는 단일 속성만 있습니다.</span><span class="sxs-lookup"><span data-stu-id="9fb75-169">For stateless services, each metric has a single property named DefaultLoad</span></span>
  * <span data-ttu-id="9fb75-170">상태 저장 서비스의 경우 다음과 같이 정의합니다.</span><span class="sxs-lookup"><span data-stu-id="9fb75-170">For stateful services you define:</span></span>
    * <span data-ttu-id="9fb75-171">PrimaryDefaultLoad: 이 서비스가 기본일 때 소비하는 이 메트릭의 기본 크기입니다.</span><span class="sxs-lookup"><span data-stu-id="9fb75-171">PrimaryDefaultLoad: The default amount of this metric this service consumes when it is a Primary</span></span>
    * <span data-ttu-id="9fb75-172">SecondaryDefaultLoad: 이 서비스가 보조일 때 소비하는 이 메트릭의 기본 크기입니다.</span><span class="sxs-lookup"><span data-stu-id="9fb75-172">SecondaryDefaultLoad: The default amount of this metric this service consumes when it is a Secondary</span></span>

> [!NOTE]
> <span data-ttu-id="9fb75-173">사용자 지정 메트릭을 정의하고 _기본 메트릭도_ 사용하려면 해당 기본 메트릭을 _명시적으로_ 다시 추가하고 이에 대한 가중치와 값을 정의해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="9fb75-173">If you define custom metrics and you want to _also_ use the default metrics, you need to _explicitly_ add the default metrics back and define weights and values for them.</span></span> <span data-ttu-id="9fb75-174">이는 기본 메트릭과 사용자 지정 메트릭 간의 관계를 정의해야 하기 때문입니다.</span><span class="sxs-lookup"><span data-stu-id="9fb75-174">This is because you must define the relationship between the default metrics and your custom metrics.</span></span> <span data-ttu-id="9fb75-175">예를 들어 ConnectionCount 또는 WorkQueueDepth에 대한 관심이 기본 배포 이상일 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="9fb75-175">For example, maybe you care about ConnectionCount or WorkQueueDepth more than Primary distribution.</span></span> <span data-ttu-id="9fb75-176">기본적으로 PrimaryCount 메트릭의 가중치는 높음이므로 다른 메트릭을 추가할 때 이를 우선적으로 사용하기 위해 중간으로 낮추려고 합니다.</span><span class="sxs-lookup"><span data-stu-id="9fb75-176">By default the weight of the PrimaryCount metric is High, so you want to reduce it to Medium when you add your other metrics to ensure they take precedence.</span></span>
>

### <a name="defining-metrics-for-your-service---an-example"></a><span data-ttu-id="9fb75-177">서비스에 대한 메트릭 정의 - 예</span><span class="sxs-lookup"><span data-stu-id="9fb75-177">Defining metrics for your service - an example</span></span>
<span data-ttu-id="9fb75-178">다음 구성을 원한다고 가정해 보겠습니다.</span><span class="sxs-lookup"><span data-stu-id="9fb75-178">Let’s say you want the following configuration:</span></span>

  - <span data-ttu-id="9fb75-179">서비스에서 "ConnectionCount"라는 메트릭을 보고합니다.</span><span class="sxs-lookup"><span data-stu-id="9fb75-179">Your service reports a metric named "ConnectionCount”</span></span>
  - <span data-ttu-id="9fb75-180">기본 메트릭도 사용하려고 합니다.</span><span class="sxs-lookup"><span data-stu-id="9fb75-180">You also want to use the default metrics</span></span> 
  - <span data-ttu-id="9fb75-181">몇 가지 측정을 수행했으며 일반적으로 해당 서비스의 주 복제본에서 20단위의 "ConnectionCount"를 차지한다는 것을 알고 있습니다.</span><span class="sxs-lookup"><span data-stu-id="9fb75-181">You’ve done some measurements and know that normally a Primary replica of that service takes up 20 units of "ConnectionCount"</span></span>
  - <span data-ttu-id="9fb75-182">보조 복제본에서 5단위의 "ConnectionCount"를 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="9fb75-182">Secondaries use 5 units of "ConnectionCount"</span></span>
  - <span data-ttu-id="9fb75-183">"ConnectionCount"가 이러한 특정 서비스의 성능 관리 측면에서 가장 중요한 메트릭입니다.</span><span class="sxs-lookup"><span data-stu-id="9fb75-183">You know that "ConnectionCount" is the most important metric in terms of managing the performance of this particular service</span></span>
  - <span data-ttu-id="9fb75-184">여전히 분산된 주 복제본을 원합니다.</span><span class="sxs-lookup"><span data-stu-id="9fb75-184">You still want Primary replicas balanced.</span></span> <span data-ttu-id="9fb75-185">주 복제본의 분산이 무엇이든 간에 일반적으로 좋은 아이디어입니다.</span><span class="sxs-lookup"><span data-stu-id="9fb75-185">Balancing primary replicas is generally a good idea no matter what.</span></span> <span data-ttu-id="9fb75-186">이렇게 하면 일부 노드 또는 장애 도메인의 손실로 인해 대다수의 주 복제본이 영향을 받지 않도록 방지할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="9fb75-186">This helps prevent the loss of some node or fault domain from impacting a majority of primary replicas along with it.</span></span> 
  - <span data-ttu-id="9fb75-187">그렇지 않으면 기본 메트릭이 좋습니다.</span><span class="sxs-lookup"><span data-stu-id="9fb75-187">Otherwise, the default metrics are fine</span></span>

<span data-ttu-id="9fb75-188">이러한 메트릭 구성이 있는 서비스를 만들기 위한 코드는 다음과 같습니다.</span><span class="sxs-lookup"><span data-stu-id="9fb75-188">Here’s the code that you would write to create a service with that metric configuration:</span></span>

<span data-ttu-id="9fb75-189">코드:</span><span class="sxs-lookup"><span data-stu-id="9fb75-189">Code:</span></span>

```csharp
StatefulServiceDescription serviceDescription = new StatefulServiceDescription();
StatefulServiceLoadMetricDescription connectionMetric = new StatefulServiceLoadMetricDescription();
connectionMetric.Name = "ConnectionCount";
connectionMetric.PrimaryDefaultLoad = 20;
connectionMetric.SecondaryDefaultLoad = 5;
connectionMetric.Weight = ServiceLoadMetricWeight.High;

StatefulServiceLoadMetricDescription primaryCountMetric = new StatefulServiceLoadMetricDescription();
primaryCountMetric.Name = "PrimaryCount";
primaryCountMetric.PrimaryDefaultLoad = 1;
primaryCountMetric.SecondaryDefaultLoad = 0;
primaryCountMetric.Weight = ServiceLoadMetricWeight.Medium;

StatefulServiceLoadMetricDescription replicaCountMetric = new StatefulServiceLoadMetricDescription();
replicaCountMetric.Name = "ReplicaCount";
replicaCountMetric.PrimaryDefaultLoad = 1;
replicaCountMetric.SecondaryDefaultLoad = 1;
replicaCountMetric.Weight = ServiceLoadMetricWeight.Low;

StatefulServiceLoadMetricDescription totalCountMetric = new StatefulServiceLoadMetricDescription();
totalCountMetric.Name = "Count";
totalCountMetric.PrimaryDefaultLoad = 1;
totalCountMetric.SecondaryDefaultLoad = 1;
totalCountMetric.Weight = ServiceLoadMetricWeight.Low;

serviceDescription.Metrics.Add(connectionMetric);
serviceDescription.Metrics.Add(primaryCountMetric);
serviceDescription.Metrics.Add(replicaCountMetric);
serviceDescription.Metrics.Add(totalCountMetric);

await fabricClient.ServiceManager.CreateServiceAsync(serviceDescription);
```

<span data-ttu-id="9fb75-190">Powershell:</span><span class="sxs-lookup"><span data-stu-id="9fb75-190">Powershell:</span></span>

```posh
New-ServiceFabricService -ApplicationName $applicationName -ServiceName $serviceName -ServiceTypeName $serviceTypeName –Stateful -MinReplicaSetSize 3 -TargetReplicaSetSize 3 -PartitionSchemeSingleton –Metric @("ConnectionCount,High,20,5”,"PrimaryCount,Medium,1,0”,"ReplicaCount,Low,1,1”,"Count,Low,1,1”)
```

> [!NOTE]
> <span data-ttu-id="9fb75-191">위의 예제와 이 문서의 나머지 부분에서는 명명된 서비스별로 메트릭을 관리하는 방법에 대해 설명합니다.</span><span class="sxs-lookup"><span data-stu-id="9fb75-191">The above examples and the rest of this document describe managing metrics on a per-named-service basis.</span></span> <span data-ttu-id="9fb75-192">서비스 _유형_ 수준에서 서비스에 대한 메트릭을 정의할 수도 있습니다.</span><span class="sxs-lookup"><span data-stu-id="9fb75-192">It is also possible to define metrics for your services at the service _type_ level.</span></span> <span data-ttu-id="9fb75-193">이는 서비스 매니페스트에 지정하여 수행됩니다.</span><span class="sxs-lookup"><span data-stu-id="9fb75-193">This is accomplished by specifying them in your service manifests.</span></span> <span data-ttu-id="9fb75-194">유형 수준 메트릭을 정의하는 것은 여러 가지 이유로 권장되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="9fb75-194">Defining type level metrics is not recommended for several reasons.</span></span> <span data-ttu-id="9fb75-195">첫 번째 이유는 메트릭 이름이 자주 환경별로 지정된다는 것입니다.</span><span class="sxs-lookup"><span data-stu-id="9fb75-195">The first reason is that metric names are frequently environment-specific.</span></span> <span data-ttu-id="9fb75-196">확실한 계약이 체결되지 않는 한, 한 환경의 "Cores" 메트릭이 다른 환경의 "MiliCores" 또는 "CoReS"가 아님을 확신할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="9fb75-196">Unless there is a firm contract in place, you cannot be sure that the metric "Cores" in one environment isn't "MiliCores" or "CoReS" in others.</span></span> <span data-ttu-id="9fb75-197">메트릭이 매니페스트에 정의된 경우 환경별로 새 매니페스트를 만들어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="9fb75-197">If your metrics are defined in your manifest you need to create new manifests per environment.</span></span> <span data-ttu-id="9fb75-198">이렇게 하면 일반적으로 관리상의 어려움을 초래할 수 있는 사소한 차이만 있는 다양한 매니페스트의 확산으로 이어집니다.</span><span class="sxs-lookup"><span data-stu-id="9fb75-198">This usually leads to a proliferation of different manifests with only minor differences, which can lead to management difficulties.</span></span>  
>
> <span data-ttu-id="9fb75-199">메트릭 로드는 일반적으로 명명된 서비스 인스턴스별로 할당됩니다.</span><span class="sxs-lookup"><span data-stu-id="9fb75-199">Metric loads are commonly assigned on a per-named-service-instance basis.</span></span> <span data-ttu-id="9fb75-200">예를 들어 가끔씩 사용하려고 하는 CustomerA에 대해 하나의 서비스 인스턴스를 만든다고 가정해 보겠습니다.</span><span class="sxs-lookup"><span data-stu-id="9fb75-200">For example, let's say you create one instance of the service for CustomerA who plans to use it only lightly.</span></span> <span data-ttu-id="9fb75-201">더 큰 워크로드를 가지고 있는 CustomerB에 대해서도 다른 하나의 서비스 인스턴스를 만든다고 가정해 보겠습니다.</span><span class="sxs-lookup"><span data-stu-id="9fb75-201">Let's also say you create another for CustomerB who has a larger workload.</span></span> <span data-ttu-id="9fb75-202">이 경우 이러한 서비스에 대한 기본 로드를 조정할 수도 있습니다.</span><span class="sxs-lookup"><span data-stu-id="9fb75-202">In this case, you'd probably want to tweak the default loads for those services.</span></span> <span data-ttu-id="9fb75-203">매니페스트를 통해 정의된 메트릭과 로드가 있고 이 시나리오를 지원하려는 경우 각 고객마다 다른 응용 프로그램 및 서비스 유형이 필요합니다.</span><span class="sxs-lookup"><span data-stu-id="9fb75-203">If you have metrics and loads defined via manifests and you want to support this scenario, it requires different application and service types for each customer.</span></span> <span data-ttu-id="9fb75-204">서비스를 만들 때 정의된 값은 매니페스트에 정의된 값을 재정의하므로 이러한 값을 사용하여 특정 기본값을 설정할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="9fb75-204">The values defined at service creation time override those defined in the manifest, so you could use that to set the specific defaults.</span></span> <span data-ttu-id="9fb75-205">그러나 이렇게 하면 매니페스트에 선언된 값이 실제로 서비스가 실행되는 값과 일치하지 않게 됩니다.</span><span class="sxs-lookup"><span data-stu-id="9fb75-205">However, doing that causes the values declared in the manifests to not match those the service actually runs with.</span></span> <span data-ttu-id="9fb75-206">이 경우 혼란이 발생할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="9fb75-206">This can lead to confusion.</span></span> 
>

<span data-ttu-id="9fb75-207">참고로 기본 메트릭만 사용하려는 경우 서비스를 만들 때 메트릭 컬렉션을 사용하거나 특별한 작업을 수행할 필요가 전혀 없습니다.</span><span class="sxs-lookup"><span data-stu-id="9fb75-207">As a reminder: if you just want to use the default metrics, you don’t need to touch the metrics collection at all or do anything special when creating your service.</span></span> <span data-ttu-id="9fb75-208">다른 메트릭이 정의되지 않은 경우 기본 메트릭이 자동으로 사용됩니다.</span><span class="sxs-lookup"><span data-stu-id="9fb75-208">The default metrics get used automatically when no others are defined.</span></span> 

<span data-ttu-id="9fb75-209">이제 각각의 설정을 자세히 살펴보고 영향을 받는 동작에 대해 설명하겠습니다.</span><span class="sxs-lookup"><span data-stu-id="9fb75-209">Now, let's go through each of these settings in more detail and talk about the behavior that it influences.</span></span>

## <a name="load"></a><span data-ttu-id="9fb75-210">로드</span><span class="sxs-lookup"><span data-stu-id="9fb75-210">Load</span></span>
<span data-ttu-id="9fb75-211">메트릭 정의의 핵심은 일부 부하에 관한 것입니다.</span><span class="sxs-lookup"><span data-stu-id="9fb75-211">The whole point of defining metrics is to represent some load.</span></span> <span data-ttu-id="9fb75-212">*로드*는 지정된 노드의 일부 서비스 인스턴스 또는 복제본에서 지정된 메트릭을 사용하는 양입니다.</span><span class="sxs-lookup"><span data-stu-id="9fb75-212">*Load* is how much of a given metric is consumed by some service instance or replica on a given node.</span></span> <span data-ttu-id="9fb75-213">로드는 거의 모든 지점에서 구성될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="9fb75-213">Load can be configured at almost any point.</span></span> <span data-ttu-id="9fb75-214">예:</span><span class="sxs-lookup"><span data-stu-id="9fb75-214">For example:</span></span>

  - <span data-ttu-id="9fb75-215">서비스를 만들 때 로드를 정의할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="9fb75-215">Load can be defined when a service is created.</span></span> <span data-ttu-id="9fb75-216">이를 _기본 로드_라고 합니다.</span><span class="sxs-lookup"><span data-stu-id="9fb75-216">This is called _default load_.</span></span>
  - <span data-ttu-id="9fb75-217">기본 로드를 포함하여 서비스에 대한 메트릭 정보는 서비스를 만든 후에 업데이트될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="9fb75-217">The metric information, including default loads, for a service can updated after the service is created.</span></span> <span data-ttu-id="9fb75-218">이를 _서비스 업데이트_라고 합니다.</span><span class="sxs-lookup"><span data-stu-id="9fb75-218">This is called _updating a service_.</span></span> 
  - <span data-ttu-id="9fb75-219">지정된 파티션에 대한 로드는 해당 서비스의 기본값으로 다시 설정될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="9fb75-219">The loads for a given partition can be reset to the default values for that service.</span></span> <span data-ttu-id="9fb75-220">이를 _파티션 로드 다시 설정_이라고 합니다.</span><span class="sxs-lookup"><span data-stu-id="9fb75-220">This is called _resetting partition load_.</span></span>
  - <span data-ttu-id="9fb75-221">로드는 런타임에 동적으로 서비스 개체별로 보고될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="9fb75-221">Load can be reported on a per service object basis dynamically during runtime.</span></span> <span data-ttu-id="9fb75-222">이를 _로드 보고_라고 합니다.</span><span class="sxs-lookup"><span data-stu-id="9fb75-222">This is called _reporting load_.</span></span> 
  
<span data-ttu-id="9fb75-223">이러한 모든 전략은 해당 수명 동안 동일한 서비스 내에서 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="9fb75-223">All of these strategies can be used within the same service over its lifetime.</span></span> 

## <a name="default-load"></a><span data-ttu-id="9fb75-224">기본 부하</span><span class="sxs-lookup"><span data-stu-id="9fb75-224">Default load</span></span>
<span data-ttu-id="9fb75-225">*기본 로드*는 이 서비스의 각 서비스 개체(상태 비저장 인스턴스 또는 상태 저장 복제본)에서 사용하는 메트릭의 양입니다.</span><span class="sxs-lookup"><span data-stu-id="9fb75-225">*Default load* is how much of the metric each service object (stateless instance or stateful replica) of this service consumes.</span></span> <span data-ttu-id="9fb75-226">클러스터 리소스 관리자는 동적 로드 보고서와 같은 다른 정보를 받을 때까지 서비스 개체의 로드에 이 숫자를 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="9fb75-226">The Cluster Resource Manager uses this number for the load of the service object until it receives other information, such as a dynamic load report.</span></span> <span data-ttu-id="9fb75-227">간단한 서비스의 경우 기본 로드는 정적 정의입니다.</span><span class="sxs-lookup"><span data-stu-id="9fb75-227">For simpler services, the default load is a static definition.</span></span> <span data-ttu-id="9fb75-228">기본 로드는 전혀 업데이트되지 않으며 서비스 수명 동안 사용됩니다.</span><span class="sxs-lookup"><span data-stu-id="9fb75-228">The default load is never updated and is used for the lifetime of the service.</span></span> <span data-ttu-id="9fb75-229">기본 로드는 여러 워크로드에서 특정 양의 리소스를 전적으로 사용하고 변경하지 않는 간단한 용량 계획 시나리오에 적합합니다.</span><span class="sxs-lookup"><span data-stu-id="9fb75-229">Default loads works great for simple capacity planning scenarios where certain amounts of resources are dedicated to different workloads and do not change.</span></span>

> [!NOTE]
> <span data-ttu-id="9fb75-230">클러스터의 노드에 대한 용량 관리 및 정의에 대한 자세한 내용은 [이 문서](service-fabric-cluster-resource-manager-cluster-description.md#capacity)를 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="9fb75-230">For more information on capacity management and defining capacities for the nodes in your cluster, please see [this article](service-fabric-cluster-resource-manager-cluster-description.md#capacity).</span></span>
> 

<span data-ttu-id="9fb75-231">클러스터 리소스 관리자를 사용하면 상태 저장 서비스에서 주 복제본 및 보조 복제본 모두에 서로 다른 기본 로드를 지정할 수 있지만,</span><span class="sxs-lookup"><span data-stu-id="9fb75-231">The Cluster Resource Manager allows stateful services to specify a different default load for their Primaries and Secondaries.</span></span> <span data-ttu-id="9fb75-232">상태 비저장 서비스에서는 모든 인스턴스에 적용되는 하나의 값만 지정할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="9fb75-232">Stateless services can only specify one value that applies to all instances.</span></span> <span data-ttu-id="9fb75-233">상태 저장 서비스의 경우 복제본이 각 역할에서 다른 종류의 작업을 수행하기 때문에 일반적으로 주 복제본 및 보조 복제본에 대한 기본 로드는 서로 다릅니다.</span><span class="sxs-lookup"><span data-stu-id="9fb75-233">For stateful services, the default load for Primary and Secondary replicas are typically different since replicas do different kinds of work in each role.</span></span> <span data-ttu-id="9fb75-234">예를 들어 주 복제본은 대개 읽기와 쓰기를 모두 수행하며 대부분의 계산 작업을 처리하지만, 보조 복제본은 그렇지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="9fb75-234">For example, Primaries usually serve both reads and writes, and handle most of the computational burden, while secondaries do not.</span></span> <span data-ttu-id="9fb75-235">일반적으로 주 복제본의 기본 로드는 보조 복제본의 기본 로드보다 높습니다.</span><span class="sxs-lookup"><span data-stu-id="9fb75-235">Usually the default load for a primary replica is higher than the default load for secondary replicas.</span></span> <span data-ttu-id="9fb75-236">실제의 크기(수)는 사용자 고유의 측정값에 따라 달라집니다.</span><span class="sxs-lookup"><span data-stu-id="9fb75-236">The real numbers should depend on your own measurements.</span></span>

## <a name="dynamic-load"></a><span data-ttu-id="9fb75-237">동적 부하</span><span class="sxs-lookup"><span data-stu-id="9fb75-237">Dynamic load</span></span>
<span data-ttu-id="9fb75-238">한동안 서비스를 실행했다고 가정해 보겠습니다.</span><span class="sxs-lookup"><span data-stu-id="9fb75-238">Let’s say that you’ve been running your service for a while.</span></span> <span data-ttu-id="9fb75-239">일부 모니터링에서 다음을 확인했습니다.</span><span class="sxs-lookup"><span data-stu-id="9fb75-239">With some monitoring, you’ve noticed that:</span></span>

1. <span data-ttu-id="9fb75-240">일부 파티션 또는 특정 서비스의 인스턴스가 다른 항목보다 더 많은 리소스를 소비합니다.</span><span class="sxs-lookup"><span data-stu-id="9fb75-240">Some partitions or instances of a given service consume more resources than others</span></span>
2. <span data-ttu-id="9fb75-241">일부 서비스에 시간 경과에 따라 달라지는 부하가 있습니다.</span><span class="sxs-lookup"><span data-stu-id="9fb75-241">Some services have load that varies over time.</span></span>

<span data-ttu-id="9fb75-242">많은 요소가 이러한 유형의 부하 변동을 야기할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="9fb75-242">There's lots of things that could cause these types of load fluctuations.</span></span> <span data-ttu-id="9fb75-243">예를 들어 서비스 또는 파티션마다 별도의 요구 사항을 가진 서로 다른 고객과 연관됩니다.</span><span class="sxs-lookup"><span data-stu-id="9fb75-243">For example, different services or partitions are associated with different customers with different requirements.</span></span> <span data-ttu-id="9fb75-244">하루 종일 서비스에서 수행하는 작업량이 달라지므로 로드가 변경될 수도 있습니다.</span><span class="sxs-lookup"><span data-stu-id="9fb75-244">Load could also change because the amount of work the service does varies over the course of the day.</span></span> <span data-ttu-id="9fb75-245">대개의 경우 어떤 이유로든 기본 로드에 사용할 수 있는 하나의 수치는 없습니다.</span><span class="sxs-lookup"><span data-stu-id="9fb75-245">Regardless of the reason, there’s usually no single number that you can use for default.</span></span> <span data-ttu-id="9fb75-246">이는 클러스터에서 최대한의 사용률을 얻으려는 경우에 특히 유용합니다.</span><span class="sxs-lookup"><span data-stu-id="9fb75-246">This is especially true if you want to get the most utilization out of the cluster.</span></span> <span data-ttu-id="9fb75-247">기본 부하에 선택한 값은 어느 시점에는 맞지 않게 됩니다.</span><span class="sxs-lookup"><span data-stu-id="9fb75-247">Any value you pick for default load is wrong some of the time.</span></span> <span data-ttu-id="9fb75-248">잘못된 기본 로드로 인해 클러스터 리소스 관리자에서 리소스를 너무 많거나 적게 할당하게 됩니다.</span><span class="sxs-lookup"><span data-stu-id="9fb75-248">Incorrect default loads result in the Cluster Resource Manager either over or under allocating resources.</span></span> <span data-ttu-id="9fb75-249">결과적으로 클러스터 리소스 관리자에서 클러스터의 로드가 분산된다고 인식하더라도 노드가 너무 많거나 적게 사용됩니다.</span><span class="sxs-lookup"><span data-stu-id="9fb75-249">As a result, you have nodes that are over or under utilized even though the Cluster Resource Manager thinks the cluster is balanced.</span></span> <span data-ttu-id="9fb75-250">기본 로드는 초기 배치에 대한 일부 정보를 제공하기 때문에 여전히 유용하지만 실제 워크로드에 대해 완전하게 알려주지는 않습니다.</span><span class="sxs-lookup"><span data-stu-id="9fb75-250">Default loads are still good since they provide some information for initial placement, but they're not a complete story for real workloads.</span></span> <span data-ttu-id="9fb75-251">변화하는 리소스 요구 사항을 정확하게 캡처하기 위해 런타임에 각 서비스 개체에서 클러스터 리소스 관리자를 통해 자체의 로드를 업데이트할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="9fb75-251">To accurately capture changing resource requirements, the Cluster Resource Manager allows each service object to update its own load during runtime.</span></span> <span data-ttu-id="9fb75-252">이를 동적 부하 보고라 합니다.</span><span class="sxs-lookup"><span data-stu-id="9fb75-252">This is called dynamic load reporting.</span></span>

<span data-ttu-id="9fb75-253">동적 부하 보고서를 사용하면 복제본 또는 인스턴스가 자신의 수명 동안 메트릭의 할당/보고된 부하를 조정할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="9fb75-253">Dynamic load reports allow replicas or instances to adjust their allocation/reported load of metrics over their lifetime.</span></span> <span data-ttu-id="9fb75-254">콜드 상태이며 아무 작업도 수행하지 않는 서비스 복제본 또는 인스턴스는 보통 특정 메트릭을 적게 사용했다고 보고합니다.</span><span class="sxs-lookup"><span data-stu-id="9fb75-254">A service replica or instance that was cold and not doing any work would usually report that it was using low amounts of a given metric.</span></span> <span data-ttu-id="9fb75-255">사용 중인 복제본 또는 인스턴스는 더 많은 양을 사용 중이라 보고할 것입니다.</span><span class="sxs-lookup"><span data-stu-id="9fb75-255">A busy replica or instance would report that they are using more.</span></span>

<span data-ttu-id="9fb75-256">복제본 또는 인스턴스별로 로드를 보고하면 클러스터 리소스 관리자에서 클러스터의 개별 서비스 개체를 다시 구성할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="9fb75-256">Reporting load per replica or instance allows the Cluster Resource Manager to reorganize the individual service objects in the cluster.</span></span> <span data-ttu-id="9fb75-257">서비스를 다시 구성하면 필요한 리소스를 얻을 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="9fb75-257">Reorganizing the services helps ensure that they get the resources they require.</span></span> <span data-ttu-id="9fb75-258">사용 중인 서비스는 현재 콜드 상태이거나 작업이 적은 다른 복제본 또는 인스턴스로부터 리소스를 효과적으로 "회수"할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="9fb75-258">Busy services effectively get to "reclaim" resources from other replicas or instances that are currently cold or doing less work.</span></span>

<span data-ttu-id="9fb75-259">Reliable Services 내에서 로드를 동적으로 보고하는 코드는 다음과 같습니다.</span><span class="sxs-lookup"><span data-stu-id="9fb75-259">Within Reliable Services, the code to report load dynamically looks like this:</span></span>

<span data-ttu-id="9fb75-260">코드:</span><span class="sxs-lookup"><span data-stu-id="9fb75-260">Code:</span></span>

```csharp
this.Partition.ReportLoad(new List<LoadMetric> { new LoadMetric("CurrentConnectionCount", 1234), new LoadMetric("metric1", 42) });
```

<span data-ttu-id="9fb75-261">서비스는 생성 시 정의된 메트릭에 대해 보고할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="9fb75-261">A service can report on any of the metrics defined for it at creation time.</span></span> <span data-ttu-id="9fb75-262">서비스에서 사용하도록 구성되지 않은 메트릭에 대한 로드를 보고하는 경우 Service Fabric에서는 해당 보고서를 무시합니다.</span><span class="sxs-lookup"><span data-stu-id="9fb75-262">If a service reports load for a metric that it is not configured to use, Service Fabric ignores that report.</span></span> <span data-ttu-id="9fb75-263">유효한 다른 메트릭이 동시에 보고되는 경우 해당 보고서가 수락됩니다.</span><span class="sxs-lookup"><span data-stu-id="9fb75-263">If there are other metrics reported at the same time that are valid, those reports are accepted.</span></span> <span data-ttu-id="9fb75-264">서비스 코드는 사용 방법을 인식하고 있는 모든 메트릭을 측정하여 보고할 수 있으며, 작업자는 서비스 코드를 변경하지 않고도 사용할 메트릭 구성을 지정할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="9fb75-264">Service code can measure and report all the metrics it knows how to, and operators can specify the metric configuration to use without having to change the service code.</span></span> 

### <a name="updating-a-services-metric-configuration"></a><span data-ttu-id="9fb75-265">서비스의 메트릭 구성 업데이트</span><span class="sxs-lookup"><span data-stu-id="9fb75-265">Updating a service's metric configuration</span></span>
<span data-ttu-id="9fb75-266">서비스와 관련된 메트릭 목록과 해당 메트릭의 속성은 서비스가 라이브 상태로 있는 동안 동적으로 업데이트될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="9fb75-266">The list of metrics associated with the service, and the properties of those metrics can be updated dynamically while the service is live.</span></span> <span data-ttu-id="9fb75-267">이렇게 하면 실험과 유연성을 허용합니다.</span><span class="sxs-lookup"><span data-stu-id="9fb75-267">This allows for experimentation and flexibility.</span></span> <span data-ttu-id="9fb75-268">유용한 경우의 몇 가지 예는 다음과 같습니다.</span><span class="sxs-lookup"><span data-stu-id="9fb75-268">Some examples of when this is useful are:</span></span>

  - <span data-ttu-id="9fb75-269">특정 서비스에 대한 버그가 포함된 보고서로 메트릭 비활성화</span><span class="sxs-lookup"><span data-stu-id="9fb75-269">disabling a metric with a buggy report for a particular service</span></span>
  - <span data-ttu-id="9fb75-270">원하는 동작을 기반으로 하여 메트릭의 가중치 재구성</span><span class="sxs-lookup"><span data-stu-id="9fb75-270">reconfiguring the weights of metrics based on desired behavior</span></span>
  - <span data-ttu-id="9fb75-271">코드가 이미 배포되고 다른 메커니즘을 통해 유효성이 검사된 후에만 새 메트릭 활성화</span><span class="sxs-lookup"><span data-stu-id="9fb75-271">enabling a new metric only after the code has already been deployed and validated via other mechanisms</span></span>
  - <span data-ttu-id="9fb75-272">관찰된 동작 및 사용량을 기반으로 하여 서비스에 대한 기본 로드 변경</span><span class="sxs-lookup"><span data-stu-id="9fb75-272">changing the default load for a service based on observed behavior and consumption</span></span>

<span data-ttu-id="9fb75-273">메트릭 구성을 변경하기 위한 주요 API는 C#의 경우 `FabricClient.ServiceManagementClient.UpdateServiceAsync`이고, PowerShell의 경우 `Update-ServiceFabricService`입니다.</span><span class="sxs-lookup"><span data-stu-id="9fb75-273">The main APIs for changing metric configuration are `FabricClient.ServiceManagementClient.UpdateServiceAsync` in C# and `Update-ServiceFabricService` in PowerShell.</span></span> <span data-ttu-id="9fb75-274">이러한 API로 지정한 모든 정보는 서비스의 기존 메트릭 정보를 즉시 바꿉니다.</span><span class="sxs-lookup"><span data-stu-id="9fb75-274">Whatever information you specify with these APIs replaces the existing metric information for the service immediately.</span></span> 

## <a name="mixing-default-load-values-and-dynamic-load-reports"></a><span data-ttu-id="9fb75-275">기본 부하 값 및 동적 부하 보고서 혼합</span><span class="sxs-lookup"><span data-stu-id="9fb75-275">Mixing default load values and dynamic load reports</span></span>
<span data-ttu-id="9fb75-276">기본 로드 및 동적 로드는 동일한 서비스에 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="9fb75-276">Default load and dynamic loads can be used for the same service.</span></span> <span data-ttu-id="9fb75-277">서비스에서 기본 로드 및 동적 로드 보고서를 모두 사용하는 경우 동적 보고서가 표시될 때까지 기본 로드가 추정값으로 사용됩니다.</span><span class="sxs-lookup"><span data-stu-id="9fb75-277">When a service utilizes both default load and dynamic load reports, default load serves as an estimate until dynamic reports show up.</span></span> <span data-ttu-id="9fb75-278">기본 로드는 클러스터 리소스 관리자에 사용할 항목을 제공하므로 유용합니다.</span><span class="sxs-lookup"><span data-stu-id="9fb75-278">Default load is good because it gives the Cluster Resource Manager something to work with.</span></span> <span data-ttu-id="9fb75-279">기본 로드를 사용하면 클러스터 리소스 관리자에서 서비스 개체를 만들 때 적절한 위치에 배치할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="9fb75-279">The default load allows the Cluster Resource Manager to place the service objects in good locations when they are created.</span></span> <span data-ttu-id="9fb75-280">기본 로드 정보를 제공하지 않으면 서비스 배치가 사실상 무작위로 수행됩니다.</span><span class="sxs-lookup"><span data-stu-id="9fb75-280">If no default load information is provided, placement of services is effectively random.</span></span> <span data-ttu-id="9fb75-281">나중에 로드 보고서가 도착하면 종종 초기 무작위 배치가 잘못되어 클러스터 리소스 관리자에서 서비스를 이동해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="9fb75-281">When load reports arrive later the initial random placement is often wrong and the Cluster Resource Manager has to move services.</span></span>

<span data-ttu-id="9fb75-282">이전 예제에서 몇 가지 사용자 지정 메트릭과 동적 부하 보고를 추가하면 어떻게 되는지 살펴보겠습니다.</span><span class="sxs-lookup"><span data-stu-id="9fb75-282">Let’s take our previous example and see what happens when we add some custom metrics and dynamic load reporting.</span></span> <span data-ttu-id="9fb75-283">이 예제에서는 "MemoryInMb"를 예제 메트릭으로 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="9fb75-283">In this example, we use “MemoryInMb” as an example metric.</span></span>

> [!NOTE]
> <span data-ttu-id="9fb75-284">Memory는 Service Fabric에서 [리소스 관리](service-fabric-resource-governance.md)를 수행할 수 있는 시스템 메트릭 중 하나이며 일반적으로 자신에 대해 보고하는 것이 어렵습니다.</span><span class="sxs-lookup"><span data-stu-id="9fb75-284">Memory is one of the system metrics that Service Fabric can [resource govern](service-fabric-resource-governance.md), and reporting it yourself is typically difficult.</span></span> <span data-ttu-id="9fb75-285">실제로 사용자가 메모리 사용량에 대해 보고할 것이라고 기대하지 않으며, 여기서 Memory는 클러스터 리소스 관리자의 기능을 학습하기 위한 보조 수단으로 사용됩니다.</span><span class="sxs-lookup"><span data-stu-id="9fb75-285">We don't actually expect you to report on Memory consumption; Memory is used here as an aid to learning about the capabilities of the Cluster Resource Manager.</span></span>
>

<span data-ttu-id="9fb75-286">다음 명령을 사용하여 상태 저장 서비스를 처음 만들었다고 가정하겠습니다.</span><span class="sxs-lookup"><span data-stu-id="9fb75-286">Let’s presume that we initially created the stateful service with the following command:</span></span>

<span data-ttu-id="9fb75-287">Powershell:</span><span class="sxs-lookup"><span data-stu-id="9fb75-287">Powershell:</span></span>

```posh
New-ServiceFabricService -ApplicationName $applicationName -ServiceName $serviceName -ServiceTypeName $serviceTypeName –Stateful -MinReplicaSetSize 3 -TargetReplicaSetSize 3 -PartitionSchemeSingleton –Metric @("MemoryInMb,High,21,11”,"PrimaryCount,Medium,1,0”,"ReplicaCount,Low,1,1”,"Count,Low,1,1”)
```

<span data-ttu-id="9fb75-288">참고로, 이 구문은 ("MetricName, MetricWeight, PrimaryDefaultLoad, SecondaryDefaultLoad")입니다.</span><span class="sxs-lookup"><span data-stu-id="9fb75-288">As a reminder, this syntax is ("MetricName, MetricWeight, PrimaryDefaultLoad, SecondaryDefaultLoad").</span></span>

<span data-ttu-id="9fb75-289">가능한 클러스터 레이아웃의 모양을 살펴보겠습니다.</span><span class="sxs-lookup"><span data-stu-id="9fb75-289">Let's see what one possible cluster layout could look like:</span></span>

<span data-ttu-id="9fb75-290"><center>
![기본 및 사용자 지정 메트릭으로 클러스터 부하 분산][Image2]
</center></span><span class="sxs-lookup"><span data-stu-id="9fb75-290"><center>
![Cluster Balanced with both Default and Custom metrics][Image2]
</center></span></span>

<span data-ttu-id="9fb75-291">주목할 만한 몇 가지가 있습니다.</span><span class="sxs-lookup"><span data-stu-id="9fb75-291">Some things that are worth noting:</span></span>

* <span data-ttu-id="9fb75-292">파티션 내의 보조 복제본은 각각 고유한 로드를 가질 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="9fb75-292">Secondary replicas within a partition can each have their own load</span></span>
* <span data-ttu-id="9fb75-293">전반적으로 메트릭은 분산된 것처럼 보입니다.</span><span class="sxs-lookup"><span data-stu-id="9fb75-293">Overall the metrics look balanced.</span></span> <span data-ttu-id="9fb75-294">Memory의 경우 최대 로드와 최소 로드 사이의 비율은 1.75입니다(로드가 가장 많은 노드는 N3이고, 가장 적은 노드는 N2이므로 28/16 = 1.75).</span><span class="sxs-lookup"><span data-stu-id="9fb75-294">For Memory, the ratio between the maximum and minimum load is 1.75 (the node with the most load is N3, the least is N2, and 28/16 = 1.75).</span></span>

<span data-ttu-id="9fb75-295">다음과 같은 몇 가지에 대한 설명이 필요합니다.</span><span class="sxs-lookup"><span data-stu-id="9fb75-295">There are some things that we still need to explain:</span></span>

* <span data-ttu-id="9fb75-296">1.75의 비율이 합리적인지를 무엇이 결정했나요?</span><span class="sxs-lookup"><span data-stu-id="9fb75-296">What determined whether a ratio of 1.75 was reasonable or not?</span></span> <span data-ttu-id="9fb75-297">Cluster Resource Manager는 충분한지 또는 추가 작업이 필요한지를 어떻게 확인하나요?</span><span class="sxs-lookup"><span data-stu-id="9fb75-297">How does the Cluster Resource Manager know if that’s good enough or if there is more work to do?</span></span>
* <span data-ttu-id="9fb75-298">언제 부하가 분산되나요?</span><span class="sxs-lookup"><span data-stu-id="9fb75-298">When does balancing happen?</span></span>
* <span data-ttu-id="9fb75-299">메모리의 가중치가 "높음"은 무슨 의미인가요?</span><span class="sxs-lookup"><span data-stu-id="9fb75-299">What does it mean that Memory was weighted “High”?</span></span>

## <a name="metric-weights"></a><span data-ttu-id="9fb75-300">메트릭 가중치</span><span class="sxs-lookup"><span data-stu-id="9fb75-300">Metric weights</span></span>
<span data-ttu-id="9fb75-301">여러 서비스에서 동일한 메트릭을 추적하는 것이 중요합니다.</span><span class="sxs-lookup"><span data-stu-id="9fb75-301">Tracking the same metrics across different services is important.</span></span> <span data-ttu-id="9fb75-302">이 전역 보기를 통해 클러스터 리소스 관리자에서 클러스터의 사용량을 추적하고, 노드 간에 사용량을 분산하며, 노드에서 용량을 초과하지 않도록 보장할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="9fb75-302">That global view is what allows the Cluster Resource Manager to track consumption in the cluster, balance consumption across nodes, and ensure that nodes don’t go over capacity.</span></span> <span data-ttu-id="9fb75-303">그러나 서비스에서 동일한 메트릭의 중요도에 따라 서로 다른 보기가 있을 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="9fb75-303">However, services may have different views as to the importance of the same metric.</span></span> <span data-ttu-id="9fb75-304">또한 메트릭과 서비스가 많은 클러스터에서는 모든 메트릭에 대해 완벽하게 분산된 솔루션이 없을 수도 있습니다.</span><span class="sxs-lookup"><span data-stu-id="9fb75-304">Also, in a cluster with many metrics and lots of services, perfectly balanced solutions may not exist for all metrics.</span></span> <span data-ttu-id="9fb75-305">Cluster Resource Manager는 이러한 상황을 어떻게 처리해야 할까요?</span><span class="sxs-lookup"><span data-stu-id="9fb75-305">How should the Cluster Resource Manager handle these situations?</span></span>

<span data-ttu-id="9fb75-306">메트릭 가중치를 통해 Cluster Resource Manager는 완벽한 답이 없을 때 클러스터를 분산하는 방법을 결정할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="9fb75-306">Metric weights allow the Cluster Resource Manager to decide how to balance the cluster when there’s no perfect answer.</span></span> <span data-ttu-id="9fb75-307">메트릭 가중치를 통해 Cluster Resource Manager가 특정 서비스를 다르게 분산할 수도 있습니다.</span><span class="sxs-lookup"><span data-stu-id="9fb75-307">Metric weights also allow the Cluster Resource Manager to balance specific services differently.</span></span> <span data-ttu-id="9fb75-308">메트릭은 0, 낮음, 보통, 높음 등 네 가지 가중치 수준을 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="9fb75-308">Metrics can have four different weight levels: Zero, Low, Medium, and High.</span></span> <span data-ttu-id="9fb75-309">작업이 분산되는지 여부를 고려할 때 가중치가 0인 메트릭은 작업에 아무런 영향을 주지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="9fb75-309">A metric with a weight of Zero contributes nothing when considering whether things are balanced or not.</span></span> <span data-ttu-id="9fb75-310">그러나 로드는 용량 관리에 여전히 영향을 줍니다.</span><span class="sxs-lookup"><span data-stu-id="9fb75-310">However, its load does still contribute to capacity management.</span></span> <span data-ttu-id="9fb75-311">가중치가 0인 메트릭은 여전히 유용하며, 서비스 동작 및 성능 모니터링의 일부로 자주 사용됩니다.</span><span class="sxs-lookup"><span data-stu-id="9fb75-311">Metrics with Zero weight are still useful and are frequently used as a part of service behavior and performance monitoring.</span></span> <span data-ttu-id="9fb75-312">[이 문서](service-fabric-diagnostics-event-generation-infra.md)에서는 서비스 모니터링 및 진단을 위해 메트릭을 사용하는 방법에 대해 자세히 설명합니다.</span><span class="sxs-lookup"><span data-stu-id="9fb75-312">[This article](service-fabric-diagnostics-event-generation-infra.md) provides more information on the use of metrics for monitoring and diagnostics of your services.</span></span> 

<span data-ttu-id="9fb75-313">클러스터에서 서로 다른 메트릭 가중치의 실제 영향은 Cluster Resource Manager가 서로 다른 솔루션을 생성한다는 것입니다.</span><span class="sxs-lookup"><span data-stu-id="9fb75-313">The real impact of different metric weights in the cluster is that the Cluster Resource Manager generates different solutions.</span></span> <span data-ttu-id="9fb75-314">메트릭 가중치는 Cluster Resource Manager에게 특정 메트릭이 다른 메트릭보다 더 중요함을 알려 줍니다.</span><span class="sxs-lookup"><span data-stu-id="9fb75-314">Metric weights tell the Cluster Resource Manager that certain metrics are more important than others.</span></span> <span data-ttu-id="9fb75-315">완벽한 솔루션이 없으면 Cluster Resource Manager는 가중치가 더 높은 메트릭을 더 잘 분산하는 솔루션을 선호합니다.</span><span class="sxs-lookup"><span data-stu-id="9fb75-315">When there's no perfect solution the Cluster Resource Manager can prefer solutions which balance the higher weighted metrics better.</span></span> <span data-ttu-id="9fb75-316">서비스에서 특정 메트릭이 중요하지 않다고 인식하면 해당 메트릭의 사용이 분산되지 않았다고 확인할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="9fb75-316">If a service thinks a particular metric is unimportant, it may find their use of that metric imbalanced.</span></span> <span data-ttu-id="9fb75-317">이렇게 하면 다른 서비스에서 중요한 메트릭을 균등하게 분산할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="9fb75-317">This allows another service to get an even distribution of some metric that is important to it.</span></span>

<span data-ttu-id="9fb75-318">일부 로드 보고서의 예와 다른 메트릭 가중치에 따라 클러스터에서 다른 할당을 수행하게 되는 방식을 살펴보겠습니다.</span><span class="sxs-lookup"><span data-stu-id="9fb75-318">Let’s look at an example of some load reports and how different metric weights results in different allocations in the cluster.</span></span> <span data-ttu-id="9fb75-319">이 예에서 메트릭의 상대 가중치를 전환하면 클러스터 리소스 관리자에서 서비스의 다른 정렬을 만들게 됩니다.</span><span class="sxs-lookup"><span data-stu-id="9fb75-319">In this example, we see that switching the relative weight of the metrics causes the Cluster Resource Manager to create different arrangements of services.</span></span>

<span data-ttu-id="9fb75-320"><center>
![메트릭 가중치 예제 및 부하 분산 솔루션에 미치는 영향][Image3]
</center></span><span class="sxs-lookup"><span data-stu-id="9fb75-320"><center>
![Metric Weight Example and Its Impact on Balancing Solutions][Image3]
</center></span></span>

<span data-ttu-id="9fb75-321">이 예에서는 별도의 두 메트릭인 메트릭 A 및 메트릭 B에 대해 모두 서로 다른 값을 보고하는 별도의 4가지 서비스가 있습니다.</span><span class="sxs-lookup"><span data-stu-id="9fb75-321">In this example, there are four different services, all reporting different values for two different metrics, MetricA and MetricB.</span></span> <span data-ttu-id="9fb75-322">한 경우에는 서비스에서 메트릭 A가 가장 중요한 것(가중치 = 높음)이고, 메트릭 B는 중요하지 않은 것(가중치 = 낮음)으로 정의합니다.</span><span class="sxs-lookup"><span data-stu-id="9fb75-322">In one case, all the services define MetricA is the most important one (Weight = High) and MetricB as unimportant (Weight = Low).</span></span> <span data-ttu-id="9fb75-323">결과적으로 클러스터 리소스 관리자에서 메트릭 A가 메트릭 B보다 더 잘 분산되도록 서비스를 배치합니다.</span><span class="sxs-lookup"><span data-stu-id="9fb75-323">As a result, we see that the Cluster Resource Manager places the services so that MetricA is better balanced than MetricB.</span></span> <span data-ttu-id="9fb75-324">"더 잘 분산됨"은 메트릭 B보다 낮은 표준 편차가 메트릭 A에 있음을 의미합니다.</span><span class="sxs-lookup"><span data-stu-id="9fb75-324">"Better balanced" means that MetricA has a lower has a lower standard deviation than MetricB.</span></span> <span data-ttu-id="9fb75-325">두 번째 경우는 메트릭 가중치를 반대로 합니다.</span><span class="sxs-lookup"><span data-stu-id="9fb75-325">In the second case, we reverse the metric weights.</span></span> <span data-ttu-id="9fb75-326">결과적으로 클러스터 리소스 관리자에서 서비스 A와 서비스 B를 교환하여 메트릭 B가 메트릭 A보다 더 잘 분산되는 할당을 만들게 됩니다.</span><span class="sxs-lookup"><span data-stu-id="9fb75-326">As a result, the Cluster Resource Manager swaps services A and B to come up with an allocation where MetricB is better balanced than MetricA.</span></span>

> [!NOTE]
> <span data-ttu-id="9fb75-327">메트릭 가중치는 클러스터 리소스 관리자에서 분산이 발생하는 경우가 아니라 분산하는 방법을 결정합니다.</span><span class="sxs-lookup"><span data-stu-id="9fb75-327">Metric weights determine how the Cluster Resource Manager should balance, but not when balancing should happen.</span></span> <span data-ttu-id="9fb75-328">분산에 대한 자세한 내용은 [이 문서](service-fabric-cluster-resource-manager-balancing.md)를 확인하세요.</span><span class="sxs-lookup"><span data-stu-id="9fb75-328">For more information on balancing, check out [this article](service-fabric-cluster-resource-manager-balancing.md)</span></span>
>

### <a name="global-metric-weights"></a><span data-ttu-id="9fb75-329">전역 메트릭 가중치</span><span class="sxs-lookup"><span data-stu-id="9fb75-329">Global metric weights</span></span>
<span data-ttu-id="9fb75-330">서비스 A에서 메트릭 A를 가중치 높음으로 정의하고, 서비스 B에서 메트릭 A의 가중치를 낮음 또는 영(0)으로 설정한다고 가정해 보겠습니다.</span><span class="sxs-lookup"><span data-stu-id="9fb75-330">Let's say ServiceA defines MetricA as weight High, and ServiceB sets the weight for MetricA to Low or Zero.</span></span> <span data-ttu-id="9fb75-331">사용하게 되는 실제 가중치는 무엇일까요?</span><span class="sxs-lookup"><span data-stu-id="9fb75-331">What’s the actual weight that ends up getting used?</span></span>

<span data-ttu-id="9fb75-332">모든 메트릭에 대해 추적되는 여러 가중치가 있습니다.</span><span class="sxs-lookup"><span data-stu-id="9fb75-332">There are multiple weights that are tracked for every metric.</span></span> <span data-ttu-id="9fb75-333">첫 번째 가중치는 서비스를 만들 때 메트릭에 대해 정의된 가중치입니다.</span><span class="sxs-lookup"><span data-stu-id="9fb75-333">The first weight is the one defined for the metric when the service is created.</span></span> <span data-ttu-id="9fb75-334">다른 가중치는 자동으로 계산되는 전역 가중치입니다.</span><span class="sxs-lookup"><span data-stu-id="9fb75-334">The other weight is a global weight, which is computed automatically.</span></span> <span data-ttu-id="9fb75-335">클러스터 리소스 관리자는 솔루션의 점수를 매길 때 이러한 두 가중치를 모두 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="9fb75-335">The Cluster Resource Manager uses both these weights when scoring solutions.</span></span> <span data-ttu-id="9fb75-336">두 가중치를 모두 고려해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="9fb75-336">Taking both weights into account is important.</span></span> <span data-ttu-id="9fb75-337">이렇게 하면 클러스터 리소스 관리자에서 자체의 우선 순위에 따라 각 서비스를 분산하고 클러스터 전체가 올바르게 할당될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="9fb75-337">This allows the Cluster Resource Manager to balance each service according to its own priorities, and also ensure that the cluster as a whole is allocated correctly.</span></span>

<span data-ttu-id="9fb75-338">Cluster Resource Manager가 전역 및 로컬 분산에 대해 고려하지 않는다면 어떤 상황이 발생하나요?</span><span class="sxs-lookup"><span data-stu-id="9fb75-338">What would happen if the Cluster Resource Manager didn’t care about both global and local balance?</span></span> <span data-ttu-id="9fb75-339">전역적으로 분산된 솔루션을 구축하는 것은 쉽지만 개별 서비스에 대한 리소스 분산이 제대로 수행되지 않을 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="9fb75-339">Well, it’s easy to construct solutions that are globally balanced, but which result in poor resource balance for individual services.</span></span> <span data-ttu-id="9fb75-340">다음 예에서는 기본 메트릭만으로 구성된 서비스를 살펴보고, 전역 분산만 고려할 때 어떤 상황이 발생하는지 알아보겠습니다.</span><span class="sxs-lookup"><span data-stu-id="9fb75-340">In the following example, let’s look at a service configured with just the default metrics, and see what happens when only global balance is considered:</span></span>

<span data-ttu-id="9fb75-341"><center>
![전역에만 해당하는 솔루션의 영향][Image4]
</center></span><span class="sxs-lookup"><span data-stu-id="9fb75-341"><center>
![The Impact of a Global Only Solution][Image4]
</center></span></span>

<span data-ttu-id="9fb75-342">전역 분산에만 기반한 위 예제에서는 실제로 클러스터 전체가 분산되었습니다.</span><span class="sxs-lookup"><span data-stu-id="9fb75-342">In the top example based only on global balance, the cluster as a whole is indeed balanced.</span></span> <span data-ttu-id="9fb75-343">모든 노드에서 기본 복제본의 수와 총 복제본의 수가 동일합니다.</span><span class="sxs-lookup"><span data-stu-id="9fb75-343">All nodes have the same count of primaries and the same number total replicas.</span></span> <span data-ttu-id="9fb75-344">그러나 이 할당의 실제 영향은 그렇게 좋지 않습니다. 모든 주 복제본을 제거하기 때문에 어떤 노드의 손실이 특정 워크로드에 불균형적으로 영향을 미칩니다.</span><span class="sxs-lookup"><span data-stu-id="9fb75-344">However, if you look at the actual impact of this allocation it’s not so good: the loss of any node impacts a particular workload disproportionately, because it takes out all of its primaries.</span></span> <span data-ttu-id="9fb75-345">예를 들어, 첫 번째 노드가 실패할 경우 원형 서비스의 3가지 파티션에 대한 3가지 기본 복제본이 모두 손실될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="9fb75-345">For example, if the first node fails the three primaries for the three different partitions of the Circle service would all be lost.</span></span> <span data-ttu-id="9fb75-346">반대로 삼각형 서비스와 육각형 서비스의 파티션에서 복제본을 잃게 됩니다.</span><span class="sxs-lookup"><span data-stu-id="9fb75-346">Conversely, the Triangle and Hexagon services have their partitions lose a replica.</span></span> <span data-ttu-id="9fb75-347">가동 중지된 복제본을 복구해야 하는 것 외에는 이로 인해 중단이 발생하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="9fb75-347">This causes no disruption, other than having to recover the down replica.</span></span>

<span data-ttu-id="9fb75-348">아래쪽 예제에서는 Cluster Resource Manager가 전역 및 서비스별 부하 분산에 따라 복제본을 배포했습니다.</span><span class="sxs-lookup"><span data-stu-id="9fb75-348">In the bottom example, the Cluster Resource Manager has distributed the replicas based on both the global and per-service balance.</span></span> <span data-ttu-id="9fb75-349">솔루션의 점수를 계산할 때 대부분의 가중치를 전역 솔루션에 부여했고 (구성 가능한) 일부를 개별 서비스에 할당했습니다.</span><span class="sxs-lookup"><span data-stu-id="9fb75-349">When calculating the score of the solution it gives most of the weight to the global solution, and a (configurable) portion to individual services.</span></span> <span data-ttu-id="9fb75-350">메트릭에 대한 전역 분산은 각 서비스의 메트릭 가중치의 평균에 따라 계산됩니다.</span><span class="sxs-lookup"><span data-stu-id="9fb75-350">Global balance for a metric is calculated based on the average of the metric weights from each service.</span></span> <span data-ttu-id="9fb75-351">각 서비스는 자체 정의된 메트릭 가중치에 따라 분산됩니다.</span><span class="sxs-lookup"><span data-stu-id="9fb75-351">Each service is balanced according to its own defined metric weights.</span></span> <span data-ttu-id="9fb75-352">이렇게 하면 서비스가 자체의 필요에 따라 자체 내에서 분산됩니다.</span><span class="sxs-lookup"><span data-stu-id="9fb75-352">This ensures that the services are balanced within themselves according to their own needs.</span></span> <span data-ttu-id="9fb75-353">결과적으로 동일한 첫 번째 노드가 실패하면 오류가 모든 서비스의 모든 파티션에 분산됩니다.</span><span class="sxs-lookup"><span data-stu-id="9fb75-353">As a result, if the same first node fails the failure is distributed across all partitions of all services.</span></span> <span data-ttu-id="9fb75-354">각각에 대한 영향이 같습니다.</span><span class="sxs-lookup"><span data-stu-id="9fb75-354">The impact to each is the same.</span></span>

## <a name="next-steps"></a><span data-ttu-id="9fb75-355">다음 단계</span><span class="sxs-lookup"><span data-stu-id="9fb75-355">Next steps</span></span>
- <span data-ttu-id="9fb75-356">서비스 구성에 대한 자세한 내용은 [서비스 구성](service-fabric-cluster-resource-manager-configure-services.md)(service-fabric-cluster-resource-manager-configure-services.md)에서 알아봅니다.</span><span class="sxs-lookup"><span data-stu-id="9fb75-356">For more information on configuring services, [Learn about configuring Services](service-fabric-cluster-resource-manager-configure-services.md)(service-fabric-cluster-resource-manager-configure-services.md)</span></span>
- <span data-ttu-id="9fb75-357">조각 모음 메트릭 정의는 노드의 부하를 분배하는 대신 통합하는 한 가지 방법입니다. 조각 모음을 구성하는 방법에 대해 알아보려면 [이 문서](service-fabric-cluster-resource-manager-defragmentation-metrics.md)</span><span class="sxs-lookup"><span data-stu-id="9fb75-357">Defining Defragmentation Metrics is one way to consolidate load on nodes instead of spreading it out. To learn how to configure defragmentation, refer to [this article](service-fabric-cluster-resource-manager-defragmentation-metrics.md)</span></span>
- <span data-ttu-id="9fb75-358">클러스터 Resource Manager가 클러스터의 부하를 관리하고 분산하는 방법을 알아보려면 [부하 분산](service-fabric-cluster-resource-manager-balancing.md)</span><span class="sxs-lookup"><span data-stu-id="9fb75-358">To find out about how the Cluster Resource Manager manages and balances load in the cluster, check out the article on [balancing load](service-fabric-cluster-resource-manager-balancing.md)</span></span>
- <span data-ttu-id="9fb75-359">처음부터 시작 및 [서비스 패브릭 클러스터 Resource Manager 소개](service-fabric-cluster-resource-manager-introduction.md)</span><span class="sxs-lookup"><span data-stu-id="9fb75-359">Start from the beginning and [get an Introduction to the Service Fabric Cluster Resource Manager](service-fabric-cluster-resource-manager-introduction.md)</span></span>
- <span data-ttu-id="9fb75-360">이동 비용은 특정 서비스가 다른 서비스에 비해 이동하는 데 비용이 더 많이 드는 것을 클러스터 리소스 관리자에게 알리는 한 가지 방법입니다.</span><span class="sxs-lookup"><span data-stu-id="9fb75-360">Movement Cost is one way of signaling to the Cluster Resource Manager that certain services are more expensive to move than others.</span></span> <span data-ttu-id="9fb75-361">이동 비용에 대한 자세한 내용은 [이 문서](service-fabric-cluster-resource-manager-movement-cost.md)</span><span class="sxs-lookup"><span data-stu-id="9fb75-361">To learn more about movement cost, refer to [this article](service-fabric-cluster-resource-manager-movement-cost.md)</span></span>

[Image1]:./media/service-fabric-cluster-resource-manager-metrics/cluster-resource-manager-cluster-layout-with-default-metrics.png
[Image2]:./media/service-fabric-cluster-resource-manager-metrics/Service-Fabric-Resource-Manager-Dynamic-Load-Reports.png
[Image3]:./media/service-fabric-cluster-resource-manager-metrics/cluster-resource-manager-metric-weights-impact.png
[Image4]:./media/service-fabric-cluster-resource-manager-metrics/cluster-resource-manager-global-vs-local-balancing.png
