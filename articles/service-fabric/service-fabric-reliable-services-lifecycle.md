---
title: "Azure 서비스 패브릭 신뢰할 수 있는 서비스의 수명 주기 hello aaaOverview | Microsoft Docs"
description: "서비스 패브릭 신뢰할 수 있는 서비스의 hello 다른 수명 주기 이벤트에 알아보기"
services: Service-Fabric
documentationcenter: .net
author: masnider
manager: timlt
editor: vturecek;
ms.assetid: 
ms.service: Service-Fabric
ms.devlang: dotnet
ms.topic: article
ms.tgt_pltfrm: NA
ms.workload: NA
ms.date: 08/18/2017
ms.author: masnider
ms.openlocfilehash: 0d75ed5ee7cda85ac9af6a02e160727277804a2b
ms.sourcegitcommit: 523283cc1b3c37c428e77850964dc1c33742c5f0
ms.translationtype: MT
ms.contentlocale: ko-KR
ms.lasthandoff: 10/06/2017
---
# <a name="reliable-services-lifecycle-overview"></a><span data-ttu-id="b39f6-103">Reliable Services 수명 주기 개요</span><span class="sxs-lookup"><span data-stu-id="b39f6-103">Reliable services lifecycle overview</span></span>
> [!div class="op_single_selector"]
> * [<span data-ttu-id="b39f6-104">Windows에서 C#</span><span class="sxs-lookup"><span data-stu-id="b39f6-104">C# on Windows</span></span>](service-fabric-reliable-services-lifecycle.md)
> * [<span data-ttu-id="b39f6-105">Linux에서 Java</span><span class="sxs-lookup"><span data-stu-id="b39f6-105">Java on Linux</span></span>](service-fabric-reliable-services-lifecycle-java.md)
>
>

<span data-ttu-id="b39f6-106">신뢰할 수 있는 서비스의 hello 주기를 고려할 때는 hello 수명 주기의 hello 기본 사항 가장 중요 한 hello 됩니다.</span><span class="sxs-lookup"><span data-stu-id="b39f6-106">When thinking about hello lifecycles of Reliable Services, hello basics of hello lifecycle are hello most important.</span></span> <span data-ttu-id="b39f6-107">일반적으로:</span><span class="sxs-lookup"><span data-stu-id="b39f6-107">In general:</span></span>

- <span data-ttu-id="b39f6-108">시작 중</span><span class="sxs-lookup"><span data-stu-id="b39f6-108">During Startup</span></span>
  - <span data-ttu-id="b39f6-109">서비스가 생성됩니다.</span><span class="sxs-lookup"><span data-stu-id="b39f6-109">Services are constructed</span></span>
  - <span data-ttu-id="b39f6-110">기회 tooconstruct 변수와 0 개 이상의 수신기를 반환 합니다.</span><span class="sxs-lookup"><span data-stu-id="b39f6-110">They have an opportunity tooconstruct and return zero or more listeners</span></span>
  - <span data-ttu-id="b39f6-111">반환 된 모든 수신기 열려 hello 서비스와의 통신을 허용 합니다.</span><span class="sxs-lookup"><span data-stu-id="b39f6-111">Any returned listeners are opened, allowing communication with hello service</span></span>
  - <span data-ttu-id="b39f6-112">메서드를 호출 하는 hello 서비스 RunAsync를 장기 실행 toodo 서비스 hello를 허용 하거나 백그라운드 작업</span><span class="sxs-lookup"><span data-stu-id="b39f6-112">hello Service's RunAsync method is called, allowing hello service toodo long running or background work</span></span>
- <span data-ttu-id="b39f6-113">종료 중</span><span class="sxs-lookup"><span data-stu-id="b39f6-113">During shutdown</span></span>
  - <span data-ttu-id="b39f6-114">hello 취소 토큰 전달된 tooRunAsync 취소 되 고 hello 수신기 닫혀 있습니다.</span><span class="sxs-lookup"><span data-stu-id="b39f6-114">hello cancellation token passed tooRunAsync is canceled, and hello listeners are closed</span></span>
  - <span data-ttu-id="b39f6-115">완료 되 면 hello 서비스 개체 자체은 이벤트 소멸</span><span class="sxs-lookup"><span data-stu-id="b39f6-115">Once that is complete, hello service object itself is destructed</span></span>

<span data-ttu-id="b39f6-116">이러한 이벤트의 순서 지정 정확한 hello 자세한 내용은 있습니다.</span><span class="sxs-lookup"><span data-stu-id="b39f6-116">There are details around hello exact ordering of these events.</span></span> <span data-ttu-id="b39f6-117">특히 이벤트 hello 순서 Stateless 또는 상태 저장 hello 신뢰할 수 있는 서비스 인지에 따라 약간 변경 될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="b39f6-117">In particular, hello order of events may change slightly depending on whether hello Reliable Service is Stateless or Stateful.</span></span> <span data-ttu-id="b39f6-118">또한 상태 저장 서비스에 대 한 주 스왑 시나리오 hello와 toodeal이 있는 합니다.</span><span class="sxs-lookup"><span data-stu-id="b39f6-118">In addition, for stateful services, we have toodeal with hello Primary swap scenario.</span></span> <span data-ttu-id="b39f6-119">이 시퀀스 하는 동안 주 hello 역할은 전송 된 tooanother 복제 (또는 다시 시작) hello 서비스를 종료 하지 않고 있습니다.</span><span class="sxs-lookup"><span data-stu-id="b39f6-119">During this sequence, hello role of Primary is transferred tooanother replica (or comes back) without hello service shutting down.</span></span> <span data-ttu-id="b39f6-120">마지막으로, 오류나 오류 조건에 대 한 toothink을 했습니다.</span><span class="sxs-lookup"><span data-stu-id="b39f6-120">Finally, we have toothink about error or failure conditions.</span></span>

## <a name="stateless-service-startup"></a><span data-ttu-id="b39f6-121">상태 비저장 서비스 시작</span><span class="sxs-lookup"><span data-stu-id="b39f6-121">Stateless service startup</span></span>
<span data-ttu-id="b39f6-122">상태 비저장 서비스의 hello 수명 주기는 매우 간단 합니다.</span><span class="sxs-lookup"><span data-stu-id="b39f6-122">hello lifecycle of a stateless service is fairly straightforward.</span></span> <span data-ttu-id="b39f6-123">이벤트의 hello 순서는 다음과 같습니다.</span><span class="sxs-lookup"><span data-stu-id="b39f6-123">Here's hello order of events:</span></span>

1. <span data-ttu-id="b39f6-124">hello 서비스가 생성 되</span><span class="sxs-lookup"><span data-stu-id="b39f6-124">hello Service is constructed</span></span>
2. <span data-ttu-id="b39f6-125">그런 다음 두 가지 작업이 병렬로 수행됩니다.</span><span class="sxs-lookup"><span data-stu-id="b39f6-125">Then, in parallel two things happen:</span></span>
    - <span data-ttu-id="b39f6-126">`StatelessService.CreateServiceInstanceListeners()`가 호출되고 반환된 모든 수신기가 열립니다.</span><span class="sxs-lookup"><span data-stu-id="b39f6-126">`StatelessService.CreateServiceInstanceListeners()` is invoked and any returned listeners are Opened.</span></span> <span data-ttu-id="b39f6-127">`ICommunicationListener.OpenAsync()`가 각 수신기에서 호출됩니다.</span><span class="sxs-lookup"><span data-stu-id="b39f6-127">`ICommunicationListener.OpenAsync()` is called on each listener</span></span>
    - <span data-ttu-id="b39f6-128">서비스의 hello `StatelessService.RunAsync()` 메서드는</span><span class="sxs-lookup"><span data-stu-id="b39f6-128">hello service's `StatelessService.RunAsync()` method is called</span></span>
3. <span data-ttu-id="b39f6-129">있는 경우 서비스의 hello `StatelessService.OnOpenAsync()` 메서드를 호출 합니다.</span><span class="sxs-lookup"><span data-stu-id="b39f6-129">If present, hello service's `StatelessService.OnOpenAsync()` method is called.</span></span> <span data-ttu-id="b39f6-130">이는 일반적이지 않은 재정의이지만 사용 가능합니다.</span><span class="sxs-lookup"><span data-stu-id="b39f6-130">This is an uncommon override, but it is available.</span></span>

<span data-ttu-id="b39f6-131">것이 중요 한 toonote 한지 hello 호출 toocreate 및 열기 hello 수신기 및 RunAsync 간 순서가 없습니다.</span><span class="sxs-lookup"><span data-stu-id="b39f6-131">It is important toonote that there is no ordering between hello calls toocreate and open hello listeners and RunAsync.</span></span> <span data-ttu-id="b39f6-132">hello 수신기 RunAsync를 시작 하기 전에 열릴 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="b39f6-132">hello listeners may open before RunAsync is started.</span></span> <span data-ttu-id="b39f6-133">마찬가지로, RunAsync 될 수 hello 통신 수신기 열려 있거나도 생성 되기 전에 호출 됩니다.</span><span class="sxs-lookup"><span data-stu-id="b39f6-133">Similarly, RunAsync may end up invoked before hello communication listeners are open or have even been constructed.</span></span> <span data-ttu-id="b39f6-134">동기화가 필요한 경우 연습 toohello 구현자로 유지 됩니다.</span><span class="sxs-lookup"><span data-stu-id="b39f6-134">If any synchronization is required, it is left as an exercise toohello implementer.</span></span> <span data-ttu-id="b39f6-135">일반적인 솔루션:</span><span class="sxs-lookup"><span data-stu-id="b39f6-135">Common solutions:</span></span>

  - <span data-ttu-id="b39f6-136">경우에 따라 다른 정보를 만들거나 수행할 때까지 수신기는 작동할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="b39f6-136">Sometimes listeners can't function until some other information is created or work done.</span></span> <span data-ttu-id="b39f6-137">상태 비저장 서비스의 경우 해당 작업은 일반적으로 다음과 같은 다른 위치에서 수행할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="b39f6-137">For stateless services that work can usually be done in other locations, such as:</span></span> 
    - <span data-ttu-id="b39f6-138">hello 서비스의 생성자에서</span><span class="sxs-lookup"><span data-stu-id="b39f6-138">in hello service's constructor</span></span>
    - <span data-ttu-id="b39f6-139">hello 동안 `CreateServiceInstanceListeners()` 호출</span><span class="sxs-lookup"><span data-stu-id="b39f6-139">during hello `CreateServiceInstanceListeners()` call</span></span>
    - <span data-ttu-id="b39f6-140">자체 hello 수신기의 hello 생성의 일부로</span><span class="sxs-lookup"><span data-stu-id="b39f6-140">as a part of hello construction of hello listener itself</span></span>
  - <span data-ttu-id="b39f6-141">경우에 따라 hello RunAsync의 코드를 원하지 않습니다 toostart hello 수신기 열려 있는 될 때까지.</span><span class="sxs-lookup"><span data-stu-id="b39f6-141">Sometimes hello code in RunAsync does not want toostart until hello listeners are open.</span></span> <span data-ttu-id="b39f6-142">이 경우에 추가 조정이 필요합니다.</span><span class="sxs-lookup"><span data-stu-id="b39f6-142">In this case additional coordination is necessary.</span></span> <span data-ttu-id="b39f6-143">일반적인 솔루션은 완료 될 때를 나타내는 hello 수신기 내에서 일부 플래그입니다.</span><span class="sxs-lookup"><span data-stu-id="b39f6-143">One common solution is some flag within hello listeners indicating when they have completed.</span></span> <span data-ttu-id="b39f6-144">이 플래그의 RunAsync tooactual 작업을 계속 하기 전에 확인 합니다.</span><span class="sxs-lookup"><span data-stu-id="b39f6-144">This flag is then checked in RunAsync before continuing tooactual work.</span></span>

## <a name="stateless-service-shutdown"></a><span data-ttu-id="b39f6-145">상태 비저장 서비스 종료</span><span class="sxs-lookup"><span data-stu-id="b39f6-145">Stateless service shutdown</span></span>
<span data-ttu-id="b39f6-146">상태 비저장 서비스를 종료할 때 hello 동일한 패턴 뒤, 반대 방향으로 바로:</span><span class="sxs-lookup"><span data-stu-id="b39f6-146">When shutting down a stateless service, hello same pattern is followed, just in reverse:</span></span>

1. <span data-ttu-id="b39f6-147">병렬로</span><span class="sxs-lookup"><span data-stu-id="b39f6-147">In parallel</span></span>
    - <span data-ttu-id="b39f6-148">열려 있는 수신기가 닫힙니다.</span><span class="sxs-lookup"><span data-stu-id="b39f6-148">Any open listeners are Closed.</span></span> <span data-ttu-id="b39f6-149">`ICommunicationListener.CloseAsync()`가 각 수신기에서 호출됩니다.</span><span class="sxs-lookup"><span data-stu-id="b39f6-149">`ICommunicationListener.CloseAsync()` is called on each listener.</span></span>
    - <span data-ttu-id="b39f6-150">hello 취소 토큰이 전달 너무`RunAsync()` 취소 됩니다.</span><span class="sxs-lookup"><span data-stu-id="b39f6-150">hello cancellation token passed too`RunAsync()` is canceled.</span></span> <span data-ttu-id="b39f6-151">검사의 hello 취소 토큰 `IsCancellationRequested` 속성 true를 반환 및 hello 토큰의 메서드를 호출 하면 `ThrowIfCancellationRequested` 메서드가 throw는 `OperationCanceledException`합니다.</span><span class="sxs-lookup"><span data-stu-id="b39f6-151">Checking hello cancellation token's `IsCancellationRequested` property returns true, and if called hello token's `ThrowIfCancellationRequested` method throws an `OperationCanceledException`.</span></span>
2. <span data-ttu-id="b39f6-152">한 번 `CloseAsync()` 각 수신기에서 완료 되 고 `RunAsync()` 도 완료 되 면 hello 서비스의 `StatelessService.OnCloseAsync()` 있는 경우 메서드가 호출 됩니다.</span><span class="sxs-lookup"><span data-stu-id="b39f6-152">Once `CloseAsync()` completes on each listener and `RunAsync()` also completes, hello service's `StatelessService.OnCloseAsync()` method is called, if present.</span></span> <span data-ttu-id="b39f6-153">일반적이 지 않은 toooverride `StatelessService.OnCloseAsync()`합니다.</span><span class="sxs-lookup"><span data-stu-id="b39f6-153">It is uncommon toooverride `StatelessService.OnCloseAsync()`.</span></span>
3. <span data-ttu-id="b39f6-154">후 `StatelessService.OnCloseAsync()` 완료 되 면 서비스 개체 hello은 이벤트 소멸</span><span class="sxs-lookup"><span data-stu-id="b39f6-154">After `StatelessService.OnCloseAsync()` completes, hello service object is destructed</span></span>

## <a name="stateful-service-startup"></a><span data-ttu-id="b39f6-155">상태 저장 서비스 시작</span><span class="sxs-lookup"><span data-stu-id="b39f6-155">Stateful service Startup</span></span>
<span data-ttu-id="b39f6-156">상태 저장 서비스에는 몇 가지 변경 내용과 비슷한 패턴 toostateless 서비스를 가지고합니다.</span><span class="sxs-lookup"><span data-stu-id="b39f6-156">Stateful services have a similar pattern toostateless services, with a few changes.</span></span> <span data-ttu-id="b39f6-157">상태 저장 서비스를 시작할 때 hello 이벤트 순서는 다음과 같습니다.</span><span class="sxs-lookup"><span data-stu-id="b39f6-157">When starting up a stateful service, hello order of events is as follows:</span></span>

1. <span data-ttu-id="b39f6-158">hello 서비스가 생성 되</span><span class="sxs-lookup"><span data-stu-id="b39f6-158">hello Service is constructed</span></span>
2. <span data-ttu-id="b39f6-159">`StatefulServiceBase.OnOpenAsync()`을 호출합니다.</span><span class="sxs-lookup"><span data-stu-id="b39f6-159">`StatefulServiceBase.OnOpenAsync()` is called.</span></span> <span data-ttu-id="b39f6-160">이것은 정말 hello 서비스에서 무시 됩니다.</span><span class="sxs-lookup"><span data-stu-id="b39f6-160">This is uncommonly overridden in hello service.</span></span>
3. <span data-ttu-id="b39f6-161">hello 다음 작업이 수행 병렬로</span><span class="sxs-lookup"><span data-stu-id="b39f6-161">hello following things happen in parallel</span></span>
    - <span data-ttu-id="b39f6-162">`StatefulServiceBase.CreateServiceReplicaListeners()`가 호출됩니다.</span><span class="sxs-lookup"><span data-stu-id="b39f6-162">`StatefulServiceBase.CreateServiceReplicaListeners()` is invoked</span></span> 
      - <span data-ttu-id="b39f6-163">Hello 서비스는 기본 반환 되는 모든 수신기는 열립니다.</span><span class="sxs-lookup"><span data-stu-id="b39f6-163">If hello service is a Primary all returned listeners are Opened.</span></span> <span data-ttu-id="b39f6-164">`ICommunicationListener.OpenAsync()`가 각 수신기에서 호출됩니다.</span><span class="sxs-lookup"><span data-stu-id="b39f6-164">`ICommunicationListener.OpenAsync()` is called on each listener.</span></span>
      - <span data-ttu-id="b39f6-165">이러한 수신기만로 표시 hello 서비스가 보조 복제본 인 경우 `ListenOnSecondary = true` 열립니다.</span><span class="sxs-lookup"><span data-stu-id="b39f6-165">If hello service is a Secondary, only those listeners marked as `ListenOnSecondary = true` are opened.</span></span> <span data-ttu-id="b39f6-166">보조 복제본에서 수신기가 열려 있는 경우는 일반적이지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="b39f6-166">Having listeners that are open on Secondaries is less common.</span></span>
    - <span data-ttu-id="b39f6-167">hello 서비스는 현재 주 영역 hello 서비스의 경우 hello `StatefulServiceBase.RunAsync()` 메서드는</span><span class="sxs-lookup"><span data-stu-id="b39f6-167">hello if hello Service is currently a Primary, hello service's `StatefulServiceBase.RunAsync()` method is called</span></span>
4. <span data-ttu-id="b39f6-168">복제 수신기의 hello 모든 면 `OpenAsync()` 호출이 완료 및 `RunAsync()` 를 호출할 `StatefulServiceBase.OnChangeRoleAsync()` 호출 됩니다.</span><span class="sxs-lookup"><span data-stu-id="b39f6-168">Once all hello replica listener's `OpenAsync()` calls complete and `RunAsync()` is called, `StatefulServiceBase.OnChangeRoleAsync()` is called.</span></span> <span data-ttu-id="b39f6-169">이것은 정말 hello 서비스에서 무시 됩니다.</span><span class="sxs-lookup"><span data-stu-id="b39f6-169">This is uncommonly overridden in hello service.</span></span>

<span data-ttu-id="b39f6-170">마찬가지로 toostateless 서비스는 hello 수신기는 생성 하 고 열 hello 순서 없는 게이트웨이 않으며 RunAsync를 호출할 때입니다.</span><span class="sxs-lookup"><span data-stu-id="b39f6-170">Similarly toostateless services, there's no coordination between hello order in which hello listeners are created and opened and when RunAsync is called.</span></span> <span data-ttu-id="b39f6-171">조정 해야 할 경우 hello 솔루션은 동일한 hello 훨씬 합니다.</span><span class="sxs-lookup"><span data-stu-id="b39f6-171">If you need coordination, hello solutions are much hello same.</span></span> <span data-ttu-id="b39f6-172">추가 경우 하나의: hello 통신 수신기에 도착 하는 hello 호출 몇몇 내부 보관 된 정보는 말 [신뢰할 수 있는 컬렉션](service-fabric-reliable-services-reliable-collections.md)합니다.</span><span class="sxs-lookup"><span data-stu-id="b39f6-172">THere is one additional case: say that hello calls arriving at hello communication listeners require information kept inside some [Reliable Collections](service-fabric-reliable-services-reliable-collections.md).</span></span> <span data-ttu-id="b39f6-173">Hello 신뢰할 수 있는 컬렉션은 읽기 가능 인지 또는 쓰기 가능 하도록 하기 전에 hello 통신 수신기를 열 수 있고 RunAsync를 시작할 수 전에, 몇 가지 추가 조정이 필요 합니다.</span><span class="sxs-lookup"><span data-stu-id="b39f6-173">Because hello communication listeners could open before hello reliable collections are readable or writeable, and before RunAsync could start, some additional coordination is necessary.</span></span> <span data-ttu-id="b39f6-174">hello 단순 하 고 가장 일반적인 솔루션은 통신 수신기 tooreturn hello에 대 한 hello 클라이언트 사용 하 여 tooknow tooretry hello 요청 하는 일부 오류 코드입니다.</span><span class="sxs-lookup"><span data-stu-id="b39f6-174">hello simplest and most common solution is for hello communication listeners tooreturn some error code that hello client uses tooknow tooretry hello request.</span></span>

## <a name="stateful-service-shutdown"></a><span data-ttu-id="b39f6-175">상태 저장 서비스 종료</span><span class="sxs-lookup"><span data-stu-id="b39f6-175">Stateful service Shutdown</span></span>
<span data-ttu-id="b39f6-176">마찬가지로 tooStateless 서비스 종료 하는 동안 hello 수명 주기 이벤트 시작 하는 동안 대로 동일 hello는 하지만 반대로 변경 합니다.</span><span class="sxs-lookup"><span data-stu-id="b39f6-176">Similarly tooStateless services, hello lifecycle events during shutdown are hello same as during startup, but reversed.</span></span> <span data-ttu-id="b39f6-177">상태 저장 서비스를 종료 하 고, hello 다음 이벤트가 발생 합니다.</span><span class="sxs-lookup"><span data-stu-id="b39f6-177">When a stateful service is being shut down, hello following events occur:</span></span>

1. <span data-ttu-id="b39f6-178">병렬로</span><span class="sxs-lookup"><span data-stu-id="b39f6-178">In parallel</span></span>
    - <span data-ttu-id="b39f6-179">열려 있는 수신기가 닫힙니다.</span><span class="sxs-lookup"><span data-stu-id="b39f6-179">Any open listeners are Closed.</span></span> <span data-ttu-id="b39f6-180">`ICommunicationListener.CloseAsync()`가 각 수신기에서 호출됩니다.</span><span class="sxs-lookup"><span data-stu-id="b39f6-180">`ICommunicationListener.CloseAsync()` is called on each listener.</span></span>
    - <span data-ttu-id="b39f6-181">hello 취소 토큰이 전달 너무`RunAsync()` 취소 됩니다.</span><span class="sxs-lookup"><span data-stu-id="b39f6-181">hello cancellation token passed too`RunAsync()` is canceled.</span></span> <span data-ttu-id="b39f6-182">검사의 hello 취소 토큰 `IsCancellationRequested` 속성 true를 반환 및 hello 토큰의 메서드를 호출 하면 `ThrowIfCancellationRequested` 메서드가 throw는 `OperationCanceledException`합니다.</span><span class="sxs-lookup"><span data-stu-id="b39f6-182">Checking hello cancellation token's `IsCancellationRequested` property returns true, and if called hello token's `ThrowIfCancellationRequested` method throws an `OperationCanceledException`.</span></span>
2. <span data-ttu-id="b39f6-183">한 번 `CloseAsync()` 각 수신기에서 완료 되 고 `RunAsync()` 도 완료 되 면 hello 서비스 `StatefulServiceBase.OnChangeRoleAsync()` 호출 됩니다.</span><span class="sxs-lookup"><span data-stu-id="b39f6-183">Once `CloseAsync()` completes on each listener and `RunAsync()` also completes, hello service's `StatefulServiceBase.OnChangeRoleAsync()` is called.</span></span> <span data-ttu-id="b39f6-184">(이 프로토콜과에서 재정의 되 hello 서비스입니다.)</span><span class="sxs-lookup"><span data-stu-id="b39f6-184">(This is uncommonly overridden in hello service.)</span></span>
    - <span data-ttu-id="b39f6-185">RunAsync를 기다리는 toocomplete를만이 서비스 복제본은 주 합니다.</span><span class="sxs-lookup"><span data-stu-id="b39f6-185">Waiting for RunAsync toocomplete is only necessary if this service replica was a Primary.</span></span>
3. <span data-ttu-id="b39f6-186">한 번 hello `StatefulServiceBase.OnChangeRoleAsync()` 메서드가 완료 되 면 hello `StatefulServiceBase.OnCloseAsync()` 메서드를 호출 합니다.</span><span class="sxs-lookup"><span data-stu-id="b39f6-186">Once hello `StatefulServiceBase.OnChangeRoleAsync()` method completes, hello `StatefulServiceBase.OnCloseAsync()` method is called.</span></span> <span data-ttu-id="b39f6-187">이는 일반적이지 않은 재정의이지만 사용 가능합니다.</span><span class="sxs-lookup"><span data-stu-id="b39f6-187">This is an uncommon override, but it is available.</span></span>
3. <span data-ttu-id="b39f6-188">후 `StatefulServiceBase.OnCloseAsync()` 완료 되 면 서비스 개체 hello은 이벤트 소멸 합니다.</span><span class="sxs-lookup"><span data-stu-id="b39f6-188">After `StatefulServiceBase.OnCloseAsync()` completes, hello service object is destructed.</span></span>

## <a name="stateful-service-primary-swaps"></a><span data-ttu-id="b39f6-189">상태 저장 서비스 주 교환</span><span class="sxs-lookup"><span data-stu-id="b39f6-189">Stateful service primary swaps</span></span>
<span data-ttu-id="b39f6-190">상태 저장 서비스 실행 되는 동안 hello 해당 상태 저장 서비스의 주 복제본을 하나만 열려 해당 통신 수신기 및 해당 RunAsync 메서드.</span><span class="sxs-lookup"><span data-stu-id="b39f6-190">While a stateful service is running, only hello Primary replicas of that stateful services have their communication listeners opened and their RunAsync method called.</span></span> <span data-ttu-id="b39f6-191">보조 복제본을 생성하지만 더 이상 호출하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="b39f6-191">Secondary are constructed but see no further calls.</span></span> <span data-ttu-id="b39f6-192">하지만 상태 저장 서비스 실행 되는 동안 복제본은 현재 주 hello를 변경할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="b39f6-192">While a stateful service is running however, which replica is currently hello Primary can change.</span></span> <span data-ttu-id="b39f6-193">그 복제본 볼 수 있는 hello 수명 주기 이벤트의 측면에서? hello 동작 hello 상태 저장 복제본에 게 표시 hello 복제본 강등 또는 hello 스왑 하는 동안 승격 되 고 인지에 따라 달라 집니다.</span><span class="sxs-lookup"><span data-stu-id="b39f6-193">What does this mean in terms of hello lifecycle events that a replica can see? hello behavior hello stateful replica sees depends on whether it is hello replica being demoted or promoted during hello swap.</span></span>

### <a name="for-hello-primary-being-demoted"></a><span data-ttu-id="b39f6-194">수준을 내리고 기본 hello에 대 한</span><span class="sxs-lookup"><span data-stu-id="b39f6-194">For hello primary being demoted</span></span>
<span data-ttu-id="b39f6-195">서비스 패브릭이 복제본 toostop 메시지를 처리 하 고 수행 하는 백그라운드 작업을 종료 합니다.</span><span class="sxs-lookup"><span data-stu-id="b39f6-195">Service Fabric needs this replica toostop processing messages and quit any background work it is doing.</span></span> <span data-ttu-id="b39f6-196">결과적으로,이 단계 다음과 유사한 toowhen hello 서비스를 종료 하 고 있습니다.</span><span class="sxs-lookup"><span data-stu-id="b39f6-196">As a result, this step looks similar toowhen hello service is being shut down.</span></span> <span data-ttu-id="b39f6-197">한 가지 차이점은 해당 hello 서비스 이벤트 소멸 또는 보조로 그대로 남아 있으므로 종료 되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="b39f6-197">One difference is that hello Service isn't destructed or closed since it remains as a Secondary.</span></span> <span data-ttu-id="b39f6-198">다음 Api hello 호출 됩니다.</span><span class="sxs-lookup"><span data-stu-id="b39f6-198">hello following APIs are called:</span></span>

1. <span data-ttu-id="b39f6-199">병렬로</span><span class="sxs-lookup"><span data-stu-id="b39f6-199">In parallel</span></span>
    - <span data-ttu-id="b39f6-200">열려 있는 수신기가 닫힙니다.</span><span class="sxs-lookup"><span data-stu-id="b39f6-200">Any open listeners are Closed.</span></span> <span data-ttu-id="b39f6-201">`ICommunicationListener.CloseAsync()`가 각 수신기에서 호출됩니다.</span><span class="sxs-lookup"><span data-stu-id="b39f6-201">`ICommunicationListener.CloseAsync()` is called on each listener.</span></span>
    - <span data-ttu-id="b39f6-202">hello 취소 토큰이 전달 너무`RunAsync()` 취소 됩니다.</span><span class="sxs-lookup"><span data-stu-id="b39f6-202">hello cancellation token passed too`RunAsync()` is canceled.</span></span> <span data-ttu-id="b39f6-203">검사의 hello 취소 토큰 `IsCancellationRequested` 속성 true를 반환 및 hello 토큰의 메서드를 호출 하면 `ThrowIfCancellationRequested` 메서드가 throw는 `OperationCanceledException`합니다.</span><span class="sxs-lookup"><span data-stu-id="b39f6-203">Checking hello cancellation token's `IsCancellationRequested` property returns true, and if called hello token's `ThrowIfCancellationRequested` method throws an `OperationCanceledException`.</span></span>
2. <span data-ttu-id="b39f6-204">한 번 `CloseAsync()` 각 수신기에서 완료 되 고 `RunAsync()` 도 완료 되 면 hello 서비스 `StatefulServiceBase.OnChangeRoleAsync()` 호출 됩니다.</span><span class="sxs-lookup"><span data-stu-id="b39f6-204">Once `CloseAsync()` completes on each listener and `RunAsync()` also completes, hello service's `StatefulServiceBase.OnChangeRoleAsync()` is called.</span></span> <span data-ttu-id="b39f6-205">이것은 정말 hello 서비스에서 무시 됩니다.</span><span class="sxs-lookup"><span data-stu-id="b39f6-205">This is uncommonly overridden in hello service.</span></span>

### <a name="for-hello-secondary-being-promoted"></a><span data-ttu-id="b39f6-206">승격 중인 보조 hello에 대 한</span><span class="sxs-lookup"><span data-stu-id="b39f6-206">For hello secondary being promoted</span></span>
<span data-ttu-id="b39f6-207">마찬가지로, 서비스 패브릭이 복제본 toostart hello 통신 중에 메시지를 수신 대기 하며 모든 백그라운드 작업에 대 한 관심이 있는 시작 합니다.</span><span class="sxs-lookup"><span data-stu-id="b39f6-207">Similarly, Service Fabric needs this replica toostart listening for messages on hello wire and start any background tasks it cares about.</span></span> <span data-ttu-id="b39f6-208">결과적으로이 프로세스 다음과 비슷한 toowhen hello 서비스를 만들면 해당 hello 복제본 제외 하 고 자체 이미 있습니다.</span><span class="sxs-lookup"><span data-stu-id="b39f6-208">As a result, this process looks similar toowhen hello service is created, except that hello replica itself already exists.</span></span> <span data-ttu-id="b39f6-209">다음 Api hello 호출 됩니다.</span><span class="sxs-lookup"><span data-stu-id="b39f6-209">hello following APIs are called:</span></span>

1. <span data-ttu-id="b39f6-210">병렬로</span><span class="sxs-lookup"><span data-stu-id="b39f6-210">In parallel</span></span>
    - <span data-ttu-id="b39f6-211">`StatefulServiceBase.CreateServiceReplicaListeners()`가 호출되고 반환된 모든 수신기가 열립니다.</span><span class="sxs-lookup"><span data-stu-id="b39f6-211">`StatefulServiceBase.CreateServiceReplicaListeners()` is invoked and any returned listeners are Opened.</span></span> <span data-ttu-id="b39f6-212">`ICommunicationListener.OpenAsync()`가 각 수신기에서 호출됩니다.</span><span class="sxs-lookup"><span data-stu-id="b39f6-212">`ICommunicationListener.OpenAsync()` is called on each listener.</span></span>
    - <span data-ttu-id="b39f6-213">서비스의 hello `StatefulServiceBase.RunAsync()` 메서드는</span><span class="sxs-lookup"><span data-stu-id="b39f6-213">hello service's `StatefulServiceBase.RunAsync()` method is called</span></span>
2. <span data-ttu-id="b39f6-214">복제 수신기의 hello 모든 면 `OpenAsync()` 호출이 완료 및 `RunAsync()` 가 호출 된 `StatefulServiceBase.OnChangeRoleAsync()` 호출 됩니다.</span><span class="sxs-lookup"><span data-stu-id="b39f6-214">Once all hello replica listener's `OpenAsync()` calls complete and `RunAsync()` has been called,  `StatefulServiceBase.OnChangeRoleAsync()` is called.</span></span> <span data-ttu-id="b39f6-215">이것은 정말 hello 서비스에서 무시 됩니다.</span><span class="sxs-lookup"><span data-stu-id="b39f6-215">This is uncommonly overridden in hello service.</span></span>

### <a name="common-issues-during-stateful-service-shutdown-and-primary-demotion"></a><span data-ttu-id="b39f6-216">상태 저장 서비스 종료 및 기본 수준 내리기 동안의 일반적인 문제</span><span class="sxs-lookup"><span data-stu-id="b39f6-216">Common issues during stateful service shutdown and primary demotion</span></span>
<span data-ttu-id="b39f6-217">서비스 패브릭 변경 hello 다양 한 이유 때문에 대 한 상태 저장 서비스의 주입니다.</span><span class="sxs-lookup"><span data-stu-id="b39f6-217">Service Fabric changes hello Primary of a stateful service for a variety of reasons.</span></span> <span data-ttu-id="b39f6-218">hello 가장 일반적으로는 [균형 조정 클러스터](service-fabric-cluster-resource-manager-balancing.md) 및 [응용 프로그램 업그레이드](service-fabric-application-upgrade.md)합니다.</span><span class="sxs-lookup"><span data-stu-id="b39f6-218">hello most common are [cluster rebalancing](service-fabric-cluster-resource-manager-balancing.md) and [application upgrade](service-fabric-application-upgrade.md).</span></span> <span data-ttu-id="b39f6-219">이러한 작업 중 (뿐만 아니라 hello 서비스가 삭제 된 경우 표시와 같은 일반 서비스 종료 하는 동안), 반드시 해당 hello 서비스 관련 hello `CancellationToken`합니다.</span><span class="sxs-lookup"><span data-stu-id="b39f6-219">During these operations (as well as during normal service shutdown, like you'd see if hello service was deleted), it is important that hello service respect hello `CancellationToken`.</span></span> <span data-ttu-id="b39f6-220">취소를 완전히 처리하지 않는 서비스에는 몇 가지 문제가 발생합니다.</span><span class="sxs-lookup"><span data-stu-id="b39f6-220">Services that do not handle cancellation cleanly will experience several issues.</span></span> <span data-ttu-id="b39f6-221">특히, 정상적으로 서비스 패브릭 서비스 toostop hello에 대 한 대기 하므로 이러한 작업은 저하 됩니다.</span><span class="sxs-lookup"><span data-stu-id="b39f6-221">In particular, these operations will be slow since Service Fabric waits for hello services toostop gracefully.</span></span> <span data-ttu-id="b39f6-222">이 궁극적으로 toofailed 업그레이드 시간 초과 되는 및 롤백합니다.</span><span class="sxs-lookup"><span data-stu-id="b39f6-222">This can ultimately lead toofailed upgrades that time out and roll back.</span></span> <span data-ttu-id="b39f6-223">노드 핫 가져오지만 hello 서비스 toomove 너무 오래 걸리므로 균형 조정 없습니다 때문에 오류 toohonor hello 취소 토큰 불균형 클러스터 발생할 수 있습니다 다른 위치에 있습니다.</span><span class="sxs-lookup"><span data-stu-id="b39f6-223">Failure toohonor hello cancellation token can also cause imbalanced clusters because nodes get hot but hello services can't be rebalanced since it takes too long toomove them elsewhere.</span></span> 

<span data-ttu-id="b39f6-224">Hello 서비스와 상태 저장 되므로 이기도 hello 사용 하 고 있는지 [신뢰할 수 있는 컬렉션](service-fabric-reliable-services-reliable-collections.md)합니다.</span><span class="sxs-lookup"><span data-stu-id="b39f6-224">Since hello services are stateful, it is also likely that they are using hello [Reliable Collections](service-fabric-reliable-services-reliable-collections.md).</span></span> <span data-ttu-id="b39f6-225">서비스 패브릭에서 기본 강등 될 때 중 하나가 hello 중요 한 정보에서 발생 하는 경우 쓰기 액세스 toohello 기본 상태가 취소 됩니다.</span><span class="sxs-lookup"><span data-stu-id="b39f6-225">In Service Fabric, when a Primary is demoted, one of hello first things that happens is that write access toohello underlying state is revoked.</span></span> <span data-ttu-id="b39f6-226">이 두 번째 집합이 hello 서비스 수명 주기 영향을 줄 수 있는 문제를 tooa 이어집니다.</span><span class="sxs-lookup"><span data-stu-id="b39f6-226">This leads tooa second set of issues that can impact hello service lifecycle.</span></span> <span data-ttu-id="b39f6-227">hello 타이밍 및 hello 복제본 이동 하는 여부에 따라 반환 예외 hello 컬렉션 또는 종료 합니다.</span><span class="sxs-lookup"><span data-stu-id="b39f6-227">hello collections return Exceptions based on hello timing and whether hello replica is being moved or shut down.</span></span> <span data-ttu-id="b39f6-228">이러한 예외는 올바르게 처리되어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="b39f6-228">These exceptions should be handled correctly.</span></span> <span data-ttu-id="b39f6-229">Service Fabric에서 발생한(throw) 예외는 영구[(`FabricException`)](https://docs.microsoft.com/en-us/dotnet/api/system.fabric.fabricexception?view=azure-dotnet) 및 일시적[(`FabricTransientException`)](https://docs.microsoft.com/en-us/dotnet/api/system.fabric.fabrictransientexception?view=azure-dotnet) 범주로 분류됩니다.</span><span class="sxs-lookup"><span data-stu-id="b39f6-229">Exceptions thrown by Service Fabric fall into permanent [(`FabricException`)](https://docs.microsoft.com/en-us/dotnet/api/system.fabric.fabricexception?view=azure-dotnet) and transient [(`FabricTransientException`)](https://docs.microsoft.com/en-us/dotnet/api/system.fabric.fabrictransientexception?view=azure-dotnet) categories.</span></span> <span data-ttu-id="b39f6-230">영구 예외를 기록 하 고 몇 가지 재시도 논리에 따라 hello 일시적 예외가 다시 시도할 수 하는 동안 throw 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="b39f6-230">Permanent exceptions should be logged and thrown, while hello transient exceptions may be retried based on some retry logic.</span></span>

<span data-ttu-id="b39f6-231">Hello 사용에서 제공 하는 hello 예외 처리 `ReliableCollections` 서비스 수명 주기 이벤트와 함께에서 테스트 및 신뢰할 수 있는 서비스 유효성 검사의 중요 한 부분입니다.</span><span class="sxs-lookup"><span data-stu-id="b39f6-231">Handling hello exceptions that come from use of hello `ReliableCollections` in conjunction with service lifecycle events is an important part of testing and validating a Reliable Service.</span></span> <span data-ttu-id="b39f6-232">권장 사항 hello는 항상 toorun 부하 상태에서 서비스 업그레이드를 수행 하는 동안 및 [chaos 테스트](service-fabric-controlled-chaos.md) 적이 tooproduction를 배포 하기 전에.</span><span class="sxs-lookup"><span data-stu-id="b39f6-232">hello recommendation is always toorun your service under load while performing upgrades and [chaos testing](service-fabric-controlled-chaos.md) before ever deploying tooproduction.</span></span> <span data-ttu-id="b39f6-233">이러한 기본 단계를 통해 서비스가 올바르게 구현되고 수명 주기 이벤트가 올바르게 처리되도록 할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="b39f6-233">These basic steps help ensure that your service is correctly implemented and handles lifecycle events correctly.</span></span>


## <a name="notes-on-service-lifecycle"></a><span data-ttu-id="b39f6-234">서비스 수명 주기에 대한 참고 사항</span><span class="sxs-lookup"><span data-stu-id="b39f6-234">Notes on service lifecycle</span></span>
  - <span data-ttu-id="b39f6-235">두 hello `RunAsync()` 메서드와 hello `CreateServiceReplicaListeners/CreateServiceInstanceListeners` 호출은 선택 사항입니다.</span><span class="sxs-lookup"><span data-stu-id="b39f6-235">Both hello `RunAsync()` method and hello `CreateServiceReplicaListeners/CreateServiceInstanceListeners` calls are optional.</span></span> <span data-ttu-id="b39f6-236">서비스에는 이러한 항목이 있거나 없을 수도 있습니다.</span><span class="sxs-lookup"><span data-stu-id="b39f6-236">A service may have one of them, both, or neither.</span></span> <span data-ttu-id="b39f6-237">예를 들어 응답 toouser 호출에는 모든 작업을 수행 하는 hello 서비스, 있는지 사용할 필요가 없다고 tooimplement `RunAsync()`합니다.</span><span class="sxs-lookup"><span data-stu-id="b39f6-237">For example, if hello service does all its work in response toouser calls, there is no need for it tooimplement `RunAsync()`.</span></span> <span data-ttu-id="b39f6-238">Hello 통신 수신기만 및 해당 관련된 코드는 필요 합니다.</span><span class="sxs-lookup"><span data-stu-id="b39f6-238">Only hello communication listeners and their associated code are necessary.</span></span> <span data-ttu-id="b39f6-239">마찬가지로, 만들고 통신 수신기를 반환 hello 서비스 toodo를 작동 하는 배경만 있을 수 있습니다는 선택 사항, 하며만 tooimplement`RunAsync()`</span><span class="sxs-lookup"><span data-stu-id="b39f6-239">Similarly, creating and returning communication listeners is optional, as hello service may have only background work toodo, and so only needs tooimplement `RunAsync()`</span></span>
  - <span data-ttu-id="b39f6-240">서비스 toocomplete에 대해 유효한 `RunAsync()` 성공적으로 및에서 반환 합니다.</span><span class="sxs-lookup"><span data-stu-id="b39f6-240">It is valid for a service toocomplete `RunAsync()` successfully and return from it.</span></span> <span data-ttu-id="b39f6-241">완료는 실패 조건이 아닙니다.</span><span class="sxs-lookup"><span data-stu-id="b39f6-241">Completing is not a failure condition.</span></span> <span data-ttu-id="b39f6-242">완료 `RunAsync()` hello 서비스의 hello 백그라운드 작업이 완료 되었음을 나타냅니다.</span><span class="sxs-lookup"><span data-stu-id="b39f6-242">Completing `RunAsync()` indicates that hello background work of hello service has completed.</span></span> <span data-ttu-id="b39f6-243">상태 저장 신뢰할 수 있는 서비스에 대 한 `RunAsync()` hello 복제본에서 주 tooSecondary 강등 백 tooPrimary 올라갑니다 경우 다시 호출 됩니다.</span><span class="sxs-lookup"><span data-stu-id="b39f6-243">For stateful reliable services, `RunAsync()` is called again if hello replica were demoted from Primary tooSecondary and then promoted back tooPrimary.</span></span>
  - <span data-ttu-id="b39f6-244">예기치 않은 예외가 발생(throw)되어 서비스가 `RunAsync()`에서 종료되는 경우 실패로 간주됩니다.</span><span class="sxs-lookup"><span data-stu-id="b39f6-244">If a service exits from `RunAsync()` by throwing some unexpected exception, this constitutes a failure.</span></span> <span data-ttu-id="b39f6-245">hello 서비스 개체는 종료 하 고 상태 오류를 보고 합니다.</span><span class="sxs-lookup"><span data-stu-id="b39f6-245">hello service object is shut down and a health error reported.</span></span>
  - <span data-ttu-id="b39f6-246">이러한 방법 중에서 반환 하는 방법에 시간 제한이 없으며 상태인 동안 즉시 hello 기능 toowrite tooReliable 컬렉션으로 손실 되 고 모든 실제 작업을 완료할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="b39f6-246">While there is no time limit on returning from these methods, you immediately lose hello ability toowrite tooReliable Collections and therefore cannot complete any real work.</span></span> <span data-ttu-id="b39f6-247">가능한 한 빨리 hello 취소 요청을 받으면 반환 하는 것이 좋습니다.</span><span class="sxs-lookup"><span data-stu-id="b39f6-247">It is recommended that you return as quickly as possible upon receiving hello cancellation request.</span></span> <span data-ttu-id="b39f6-248">서비스는 적절 한 시간 내에 서비스 패브릭 강제로 수 toothese API 호출 응답 하지 않을 경우 서비스를 종료 합니다.</span><span class="sxs-lookup"><span data-stu-id="b39f6-248">If your service does not respond toothese API calls in a reasonable amount of time Service Fabric may forcibly terminate your service.</span></span> <span data-ttu-id="b39f6-249">이러한 상황은 일반적으로 응용 프로그램을 업그레이드하거나 서비스를 삭제할 때 발생합니다.</span><span class="sxs-lookup"><span data-stu-id="b39f6-249">Usually this only happens during application upgrades or when a service is being deleted.</span></span> <span data-ttu-id="b39f6-250">이 시간 제한은 기본적으로 15분입니다.</span><span class="sxs-lookup"><span data-stu-id="b39f6-250">This timeout is 15 minutes by default.</span></span>
  - <span data-ttu-id="b39f6-251">Hello에서 발생 한 실패 `OnCloseAsync()` path 결과에서 `OnAbort()` hello에 대 한 마지막 발생할 가능성이 있는 최상의 기회는 호출 되 고 tooclean를 서비스 하 고 요청할가 있는 모든 리소스를 해제 합니다.</span><span class="sxs-lookup"><span data-stu-id="b39f6-251">Failures in hello `OnCloseAsync()` path result in `OnAbort()` being called which is a last-chance best-effort opportunity for hello service tooclean up and release any resources that they have claimed.</span></span>

## <a name="next-steps"></a><span data-ttu-id="b39f6-252">다음 단계</span><span class="sxs-lookup"><span data-stu-id="b39f6-252">Next steps</span></span>
- [<span data-ttu-id="b39f6-253">TooReliable 서비스 소개</span><span class="sxs-lookup"><span data-stu-id="b39f6-253">Introduction tooReliable Services</span></span>](service-fabric-reliable-services-introduction.md)
- [<span data-ttu-id="b39f6-254">Reliable Services 빠른 시작</span><span class="sxs-lookup"><span data-stu-id="b39f6-254">Reliable Services quick start</span></span>](service-fabric-reliable-services-quick-start.md)
- [<span data-ttu-id="b39f6-255">신뢰할 수 있는 서비스 고급 사용법</span><span class="sxs-lookup"><span data-stu-id="b39f6-255">Reliable Services advanced usage</span></span>](service-fabric-reliable-services-advanced-usage.md)
