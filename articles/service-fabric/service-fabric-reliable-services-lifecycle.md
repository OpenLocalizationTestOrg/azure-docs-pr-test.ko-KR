---
title: "Azure Service Fabric Reliable Services의 수명 주기 개요 | Microsoft Docs"
description: "Service Fabric Reliable Services의 다른 수명 주기 이벤트에 대해 알아보기"
services: Service-Fabric
documentationcenter: .net
author: masnider
manager: timlt
editor: vturecek;
ms.assetid: 
ms.service: Service-Fabric
ms.devlang: dotnet
ms.topic: article
ms.tgt_pltfrm: NA
ms.workload: NA
ms.date: 08/18/2017
ms.author: masnider
ms.openlocfilehash: 16021ca72a2f10070b6409417ff0d88009591331
ms.sourcegitcommit: 50e23e8d3b1148ae2d36dad3167936b4e52c8a23
ms.translationtype: MT
ms.contentlocale: ko-KR
ms.lasthandoff: 08/18/2017
---
# <a name="reliable-services-lifecycle-overview"></a><span data-ttu-id="92213-103">Reliable Services 수명 주기 개요</span><span class="sxs-lookup"><span data-stu-id="92213-103">Reliable services lifecycle overview</span></span>
> [!div class="op_single_selector"]
> * [<span data-ttu-id="92213-104">Windows에서 C#</span><span class="sxs-lookup"><span data-stu-id="92213-104">C# on Windows</span></span>](service-fabric-reliable-services-lifecycle.md)
> * [<span data-ttu-id="92213-105">Linux에서 Java</span><span class="sxs-lookup"><span data-stu-id="92213-105">Java on Linux</span></span>](service-fabric-reliable-services-lifecycle-java.md)
>
>

<span data-ttu-id="92213-106">Reliable Services의 수명 주기를 고려할 경우 수명 주기에 대한 기본 사항이 가장 중요합니다.</span><span class="sxs-lookup"><span data-stu-id="92213-106">When thinking about the lifecycles of Reliable Services, the basics of the lifecycle are the most important.</span></span> <span data-ttu-id="92213-107">일반적으로:</span><span class="sxs-lookup"><span data-stu-id="92213-107">In general:</span></span>

- <span data-ttu-id="92213-108">시작 중</span><span class="sxs-lookup"><span data-stu-id="92213-108">During Startup</span></span>
  - <span data-ttu-id="92213-109">서비스가 생성됩니다.</span><span class="sxs-lookup"><span data-stu-id="92213-109">Services are constructed</span></span>
  - <span data-ttu-id="92213-110">0개 이상의 수신기를 생성하고 반환할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="92213-110">They have an opportunity to construct and return zero or more listeners</span></span>
  - <span data-ttu-id="92213-111">반환된 모든 수신기 열리면 서비스와의 통신이 가능합니다.</span><span class="sxs-lookup"><span data-stu-id="92213-111">Any returned listeners are opened, allowing communication with the service</span></span>
  - <span data-ttu-id="92213-112">서비스의 RunAsync 메서드를 호출하면 서비스가 장기 실행 중인 백그라운드 작업을 수행할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="92213-112">The Service's RunAsync method is called, allowing the service to do long running or background work</span></span>
- <span data-ttu-id="92213-113">종료 중</span><span class="sxs-lookup"><span data-stu-id="92213-113">During shutdown</span></span>
  - <span data-ttu-id="92213-114">RunAsync에 전달된 취소 토큰이 취소되고 수신기 닫힙니다.</span><span class="sxs-lookup"><span data-stu-id="92213-114">The cancellation token passed to RunAsync is canceled, and the listeners are closed</span></span>
  - <span data-ttu-id="92213-115">작업이 완료되면 서비스 개체 자체는 소멸됩니다.</span><span class="sxs-lookup"><span data-stu-id="92213-115">Once that is complete, the service object itself is destructed</span></span>

<span data-ttu-id="92213-116">이러한 이벤트의 정확한 순서에 대한 세부 정보가 있습니다.</span><span class="sxs-lookup"><span data-stu-id="92213-116">There are details around the exact ordering of these events.</span></span> <span data-ttu-id="92213-117">특히 이벤트의 순서는 Reliable Service가 상태 비저장인지 또는 상태 저장인지에 따라 약간 변경될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="92213-117">In particular, the order of events may change slightly depending on whether the Reliable Service is Stateless or Stateful.</span></span> <span data-ttu-id="92213-118">또한 상태 저장 서비스의 경우 주 복제본 교환 시나리오를 처리해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="92213-118">In addition, for stateful services, we have to deal with the Primary swap scenario.</span></span> <span data-ttu-id="92213-119">이 과정 중에 서비스를 종료하지 않고 주 복제본의 역할을 다른 복제본으로 전송하거나 복구합니다.</span><span class="sxs-lookup"><span data-stu-id="92213-119">During this sequence, the role of Primary is transferred to another replica (or comes back) without the service shutting down.</span></span> <span data-ttu-id="92213-120">마지막으로 오류 또는 실패 조건에 대해 고려해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="92213-120">Finally, we have to think about error or failure conditions.</span></span>

## <a name="stateless-service-startup"></a><span data-ttu-id="92213-121">상태 비저장 서비스 시작</span><span class="sxs-lookup"><span data-stu-id="92213-121">Stateless service startup</span></span>
<span data-ttu-id="92213-122">상태 비저장 서비스의 수명 주기는 매우 간단합니다.</span><span class="sxs-lookup"><span data-stu-id="92213-122">The lifecycle of a stateless service is fairly straightforward.</span></span> <span data-ttu-id="92213-123">이벤트의 순서는 다음과 같습니다.</span><span class="sxs-lookup"><span data-stu-id="92213-123">Here's the order of events:</span></span>

1. <span data-ttu-id="92213-124">서비스를 생성합니다.</span><span class="sxs-lookup"><span data-stu-id="92213-124">The Service is constructed</span></span>
2. <span data-ttu-id="92213-125">그런 다음 두 가지 작업이 병렬로 수행됩니다.</span><span class="sxs-lookup"><span data-stu-id="92213-125">Then, in parallel two things happen:</span></span>
    - <span data-ttu-id="92213-126">`StatelessService.CreateServiceInstanceListeners()`가 호출되고 반환된 모든 수신기가 열립니다.</span><span class="sxs-lookup"><span data-stu-id="92213-126">`StatelessService.CreateServiceInstanceListeners()` is invoked and any returned listeners are Opened.</span></span> <span data-ttu-id="92213-127">`ICommunicationListener.OpenAsync()`가 각 수신기에서 호출됩니다.</span><span class="sxs-lookup"><span data-stu-id="92213-127">`ICommunicationListener.OpenAsync()` is called on each listener</span></span>
    - <span data-ttu-id="92213-128">서비스의 `StatelessService.RunAsync()` 메서드가 호출됩니다.</span><span class="sxs-lookup"><span data-stu-id="92213-128">The service's `StatelessService.RunAsync()` method is called</span></span>
3. <span data-ttu-id="92213-129">있는 경우 서비스의 `StatelessService.OnOpenAsync()` 메서드가 호출됩니다.</span><span class="sxs-lookup"><span data-stu-id="92213-129">If present, the service's `StatelessService.OnOpenAsync()` method is called.</span></span> <span data-ttu-id="92213-130">이는 일반적이지 않은 재정의이지만 사용 가능합니다.</span><span class="sxs-lookup"><span data-stu-id="92213-130">This is an uncommon override, but it is available.</span></span>

<span data-ttu-id="92213-131">수신기 및 RunAsync를 만들고 여는 호출 간에 순서가 없다는 점이 중요합니다.</span><span class="sxs-lookup"><span data-stu-id="92213-131">It is important to note that there is no ordering between the calls to create and open the listeners and RunAsync.</span></span> <span data-ttu-id="92213-132">RunAsync가 시작되기 전에 수신기가 열릴 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="92213-132">The listeners may open before RunAsync is started.</span></span> <span data-ttu-id="92213-133">마찬가지로 통신 수신기를 열고 생성하기 전에 RunAsync를 호출할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="92213-133">Similarly, RunAsync may end up invoked before the communication listeners are open or have even been constructed.</span></span> <span data-ttu-id="92213-134">동기화가 필요한 경우 구현 작업에 연습으로 남겨 둡니다.</span><span class="sxs-lookup"><span data-stu-id="92213-134">If any synchronization is required, it is left as an exercise to the implementer.</span></span> <span data-ttu-id="92213-135">일반적인 솔루션:</span><span class="sxs-lookup"><span data-stu-id="92213-135">Common solutions:</span></span>

  - <span data-ttu-id="92213-136">경우에 따라 다른 정보를 만들거나 수행할 때까지 수신기는 작동할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="92213-136">Sometimes listeners can't function until some other information is created or work done.</span></span> <span data-ttu-id="92213-137">상태 비저장 서비스의 경우 해당 작업은 일반적으로 다음과 같은 다른 위치에서 수행할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="92213-137">For stateless services that work can usually be done in other locations, such as:</span></span> 
    - <span data-ttu-id="92213-138">서비스의 생성자에서</span><span class="sxs-lookup"><span data-stu-id="92213-138">in the service's constructor</span></span>
    - <span data-ttu-id="92213-139">`CreateServiceInstanceListeners()` 호출 중</span><span class="sxs-lookup"><span data-stu-id="92213-139">during the `CreateServiceInstanceListeners()` call</span></span>
    - <span data-ttu-id="92213-140">수신기 자체 생성의 일부로서</span><span class="sxs-lookup"><span data-stu-id="92213-140">as a part of the construction of the listener itself</span></span>
  - <span data-ttu-id="92213-141">경우에 따라 RunAsync의 코드는 수신기 열릴 때까지 시작하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="92213-141">Sometimes the code in RunAsync does not want to start until the listeners are open.</span></span> <span data-ttu-id="92213-142">이 경우에 추가 조정이 필요합니다.</span><span class="sxs-lookup"><span data-stu-id="92213-142">In this case additional coordination is necessary.</span></span> <span data-ttu-id="92213-143">한 가지 일반적인 해결 방법으로 완료되는 시기를 나타내는 수신기 내의 플래그가 있습니다.</span><span class="sxs-lookup"><span data-stu-id="92213-143">One common solution is some flag within the listeners indicating when they have completed.</span></span> <span data-ttu-id="92213-144">이 플래그는 실제 작업을 계속하기 전에 RunAsync에서 확인됩니다.</span><span class="sxs-lookup"><span data-stu-id="92213-144">This flag is then checked in RunAsync before continuing to actual work.</span></span>

## <a name="stateless-service-shutdown"></a><span data-ttu-id="92213-145">상태 비저장 서비스 종료</span><span class="sxs-lookup"><span data-stu-id="92213-145">Stateless service shutdown</span></span>
<span data-ttu-id="92213-146">상태 비저장 서비스를 종료할 경우 동일한 패턴이 역방향으로 다음과 같이 따라옵니다.</span><span class="sxs-lookup"><span data-stu-id="92213-146">When shutting down a stateless service, the same pattern is followed, just in reverse:</span></span>

1. <span data-ttu-id="92213-147">병렬로</span><span class="sxs-lookup"><span data-stu-id="92213-147">In parallel</span></span>
    - <span data-ttu-id="92213-148">열려 있는 수신기가 닫힙니다.</span><span class="sxs-lookup"><span data-stu-id="92213-148">Any open listeners are Closed.</span></span> <span data-ttu-id="92213-149">`ICommunicationListener.CloseAsync()`가 각 수신기에서 호출됩니다.</span><span class="sxs-lookup"><span data-stu-id="92213-149">`ICommunicationListener.CloseAsync()` is called on each listener.</span></span>
    - <span data-ttu-id="92213-150">`RunAsync()`에 전달된 취소 토큰이 취소됩니다.</span><span class="sxs-lookup"><span data-stu-id="92213-150">The cancellation token passed to `RunAsync()` is canceled.</span></span> <span data-ttu-id="92213-151">취소 토큰의 `IsCancellationRequested` 속성을 확인하면 true를 반환하고, 호출되는 경우 토큰의 `ThrowIfCancellationRequested` 메서드에서 `OperationCanceledException`이 발생(throw)됩니다.</span><span class="sxs-lookup"><span data-stu-id="92213-151">Checking the cancellation token's `IsCancellationRequested` property returns true, and if called the token's `ThrowIfCancellationRequested` method throws an `OperationCanceledException`.</span></span>
2. <span data-ttu-id="92213-152">`CloseAsync()`가 각 수신기에서 완료되고 `RunAsync()`도 완료되면 서비스의 `StatelessService.OnCloseAsync()` 메서드가 호출됩니다(있는 경우).</span><span class="sxs-lookup"><span data-stu-id="92213-152">Once `CloseAsync()` completes on each listener and `RunAsync()` also completes, the service's `StatelessService.OnCloseAsync()` method is called, if present.</span></span> <span data-ttu-id="92213-153">`StatelessService.OnCloseAsync()`를 재정의하는 것은 일반적이지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="92213-153">It is uncommon to override `StatelessService.OnCloseAsync()`.</span></span>
3. <span data-ttu-id="92213-154">`StatelessService.OnCloseAsync()`이 완료되면 서비스 개체는 소멸됩니다.</span><span class="sxs-lookup"><span data-stu-id="92213-154">After `StatelessService.OnCloseAsync()` completes, the service object is destructed</span></span>

## <a name="stateful-service-startup"></a><span data-ttu-id="92213-155">상태 저장 서비스 시작</span><span class="sxs-lookup"><span data-stu-id="92213-155">Stateful service Startup</span></span>
<span data-ttu-id="92213-156">상태 저장 서비스는 몇 가지를 변경한 상태 비저장 서비스 패턴과 비슷합니다.</span><span class="sxs-lookup"><span data-stu-id="92213-156">Stateful services have a similar pattern to stateless services, with a few changes.</span></span> <span data-ttu-id="92213-157">상태 저장 서비스를 시작하면 이벤트의 순서는 다음과 같습니다.</span><span class="sxs-lookup"><span data-stu-id="92213-157">When starting up a stateful service, the order of events is as follows:</span></span>

1. <span data-ttu-id="92213-158">서비스를 생성합니다.</span><span class="sxs-lookup"><span data-stu-id="92213-158">The Service is constructed</span></span>
2. <span data-ttu-id="92213-159">`StatefulServiceBase.OnOpenAsync()`을 호출합니다.</span><span class="sxs-lookup"><span data-stu-id="92213-159">`StatefulServiceBase.OnOpenAsync()` is called.</span></span> <span data-ttu-id="92213-160">이는 서비스에서 드물게 재정의됩니다.</span><span class="sxs-lookup"><span data-stu-id="92213-160">This is uncommonly overridden in the service.</span></span>
3. <span data-ttu-id="92213-161">다음과 같은 작업이 병렬로 수행됩니다.</span><span class="sxs-lookup"><span data-stu-id="92213-161">The following things happen in parallel</span></span>
    - <span data-ttu-id="92213-162">`StatefulServiceBase.CreateServiceReplicaListeners()`가 호출됩니다.</span><span class="sxs-lookup"><span data-stu-id="92213-162">`StatefulServiceBase.CreateServiceReplicaListeners()` is invoked</span></span> 
      - <span data-ttu-id="92213-163">서비스가 주 복제본인 경우 반환된 모든 수신기가 열립니다.</span><span class="sxs-lookup"><span data-stu-id="92213-163">If the service is a Primary all returned listeners are Opened.</span></span> <span data-ttu-id="92213-164">`ICommunicationListener.OpenAsync()`가 각 수신기에서 호출됩니다.</span><span class="sxs-lookup"><span data-stu-id="92213-164">`ICommunicationListener.OpenAsync()` is called on each listener.</span></span>
      - <span data-ttu-id="92213-165">서비스가 보조 복제본인 경우 `ListenOnSecondary = true`로 표시된 수신기만 열립니다.</span><span class="sxs-lookup"><span data-stu-id="92213-165">If the service is a Secondary, only those listeners marked as `ListenOnSecondary = true` are opened.</span></span> <span data-ttu-id="92213-166">보조 복제본에서 수신기가 열려 있는 경우는 일반적이지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="92213-166">Having listeners that are open on Secondaries is less common.</span></span>
    - <span data-ttu-id="92213-167">서비스가 현재 주 복제본인 경우 서비스의 `StatefulServiceBase.RunAsync()` 메서드가 호출됩니다.</span><span class="sxs-lookup"><span data-stu-id="92213-167">The if the Service is currently a Primary, the service's `StatefulServiceBase.RunAsync()` method is called</span></span>
4. <span data-ttu-id="92213-168">모든 복제본 수신기의 `OpenAsync()` 호출이 완료되고 `RunAsync()`가 호출되면 `StatefulServiceBase.OnChangeRoleAsync()`가 호출됩니다.</span><span class="sxs-lookup"><span data-stu-id="92213-168">Once all the replica listener's `OpenAsync()` calls complete and `RunAsync()` is called, `StatefulServiceBase.OnChangeRoleAsync()` is called.</span></span> <span data-ttu-id="92213-169">이는 서비스에서 드물게 재정의됩니다.</span><span class="sxs-lookup"><span data-stu-id="92213-169">This is uncommonly overridden in the service.</span></span>

<span data-ttu-id="92213-170">상태 비저장 서비스와 마찬가지로 수신기가 만들어지고 열리는 순서와 RunAsync가 호출되는 순서 사이에는 조정되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="92213-170">Similarly to stateless services, there's no coordination between the order in which the listeners are created and opened and when RunAsync is called.</span></span> <span data-ttu-id="92213-171">조정이 필요한 경우 해결 방법은 거의 동일합니다.</span><span class="sxs-lookup"><span data-stu-id="92213-171">If you need coordination, the solutions are much the same.</span></span> <span data-ttu-id="92213-172">한 가지 추가 사례가 있습니다. 즉 통신 수신기에 도달한 호출에는 일부 [신뢰할 수 있는 컬렉션](service-fabric-reliable-services-reliable-collections.md) 내에 보관된 정보가 필요합니다.</span><span class="sxs-lookup"><span data-stu-id="92213-172">THere is one additional case: say that the calls arriving at the communication listeners require information kept inside some [Reliable Collections](service-fabric-reliable-services-reliable-collections.md).</span></span> <span data-ttu-id="92213-173">신뢰할 수 있는 컬렉션을 읽기 가능하거나 쓰기 가능하게 되고 RunAsync가 시작하기 전에 통신 수신기를 열 수 있기 때문에 일부 추가 조정이 필요합니다.</span><span class="sxs-lookup"><span data-stu-id="92213-173">Because the communication listeners could open before the reliable collections are readable or writeable, and before RunAsync could start, some additional coordination is necessary.</span></span> <span data-ttu-id="92213-174">가장 간단하고 일반적인 솔루션은 통신 수신기에서 클라이언트가 사용하는 몇 가지 오류 코드를 반환하여 요청을 다시 시도하는 것입니다.</span><span class="sxs-lookup"><span data-stu-id="92213-174">The simplest and most common solution is for the communication listeners to return some error code that the client uses to know to retry the request.</span></span>

## <a name="stateful-service-shutdown"></a><span data-ttu-id="92213-175">상태 저장 서비스 종료</span><span class="sxs-lookup"><span data-stu-id="92213-175">Stateful service Shutdown</span></span>
<span data-ttu-id="92213-176">상태 비저장 서비스와 마찬가지로 종료 중 수명 주기 이벤트는 시작 시와 동일하지만 역방향으로 이뤄집니다.</span><span class="sxs-lookup"><span data-stu-id="92213-176">Similarly to Stateless services, the lifecycle events during shutdown are the same as during startup, but reversed.</span></span> <span data-ttu-id="92213-177">상태 저장 서비스가 종료되면 다음과 같은 이벤트가 발생합니다.</span><span class="sxs-lookup"><span data-stu-id="92213-177">When a stateful service is being shut down, the following events occur:</span></span>

1. <span data-ttu-id="92213-178">병렬로</span><span class="sxs-lookup"><span data-stu-id="92213-178">In parallel</span></span>
    - <span data-ttu-id="92213-179">열려 있는 수신기가 닫힙니다.</span><span class="sxs-lookup"><span data-stu-id="92213-179">Any open listeners are Closed.</span></span> <span data-ttu-id="92213-180">`ICommunicationListener.CloseAsync()`가 각 수신기에서 호출됩니다.</span><span class="sxs-lookup"><span data-stu-id="92213-180">`ICommunicationListener.CloseAsync()` is called on each listener.</span></span>
    - <span data-ttu-id="92213-181">`RunAsync()`에 전달된 취소 토큰이 취소됩니다.</span><span class="sxs-lookup"><span data-stu-id="92213-181">The cancellation token passed to `RunAsync()` is canceled.</span></span> <span data-ttu-id="92213-182">취소 토큰의 `IsCancellationRequested` 속성을 확인하면 true를 반환하고, 호출되는 경우 토큰의 `ThrowIfCancellationRequested` 메서드에서 `OperationCanceledException`이 발생(throw)됩니다.</span><span class="sxs-lookup"><span data-stu-id="92213-182">Checking the cancellation token's `IsCancellationRequested` property returns true, and if called the token's `ThrowIfCancellationRequested` method throws an `OperationCanceledException`.</span></span>
2. <span data-ttu-id="92213-183">`CloseAsync()`이 각 수신기에서 완료되고 `RunAsync()`도 완료되면 서비스의 `StatefulServiceBase.OnChangeRoleAsync()`이 호출됩니다.</span><span class="sxs-lookup"><span data-stu-id="92213-183">Once `CloseAsync()` completes on each listener and `RunAsync()` also completes, the service's `StatefulServiceBase.OnChangeRoleAsync()` is called.</span></span> <span data-ttu-id="92213-184">(서비스에서 일반적이지 않게 재정의됩니다.)</span><span class="sxs-lookup"><span data-stu-id="92213-184">(This is uncommonly overridden in the service.)</span></span>
    - <span data-ttu-id="92213-185">RunAsync가 완료되기를 기다리는 것은 이 서비스 복제본이 주 복제본인 경우에만 필요합니다.</span><span class="sxs-lookup"><span data-stu-id="92213-185">Waiting for RunAsync to complete is only necessary if this service replica was a Primary.</span></span>
3. <span data-ttu-id="92213-186">`StatefulServiceBase.OnChangeRoleAsync()` 메서드가 완료되면 `StatefulServiceBase.OnCloseAsync()` 메서드가 호출됩니다.</span><span class="sxs-lookup"><span data-stu-id="92213-186">Once the `StatefulServiceBase.OnChangeRoleAsync()` method completes, the `StatefulServiceBase.OnCloseAsync()` method is called.</span></span> <span data-ttu-id="92213-187">이는 일반적이지 않은 재정의이지만 사용 가능합니다.</span><span class="sxs-lookup"><span data-stu-id="92213-187">This is an uncommon override, but it is available.</span></span>
3. <span data-ttu-id="92213-188">`StatefulServiceBase.OnCloseAsync()`이 완료되면 서비스 개체는 소멸됩니다.</span><span class="sxs-lookup"><span data-stu-id="92213-188">After `StatefulServiceBase.OnCloseAsync()` completes, the service object is destructed.</span></span>

## <a name="stateful-service-primary-swaps"></a><span data-ttu-id="92213-189">상태 저장 서비스 주 교환</span><span class="sxs-lookup"><span data-stu-id="92213-189">Stateful service primary swaps</span></span>
<span data-ttu-id="92213-190">상태 저장 서비스가 실행되는 동안 해당 상태 저장 서비스의 주 복제본은 해당 통신 수신기를 열고 해당 RunAsync 메서드를 호출합니다.</span><span class="sxs-lookup"><span data-stu-id="92213-190">While a stateful service is running, only the Primary replicas of that stateful services have their communication listeners opened and their RunAsync method called.</span></span> <span data-ttu-id="92213-191">보조 복제본을 생성하지만 더 이상 호출하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="92213-191">Secondary are constructed but see no further calls.</span></span> <span data-ttu-id="92213-192">하지만 상태 저장 서비스가 실행되는 동안 현재 주 복제본인 복제본을 변경할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="92213-192">While a stateful service is running however, which replica is currently the Primary can change.</span></span> <span data-ttu-id="92213-193">복제본이 확인할 수 있는 수명 주기 이벤트의 측면에서 무슨 의미인가요?</span><span class="sxs-lookup"><span data-stu-id="92213-193">What does this mean in terms of the lifecycle events that a replica can see?</span></span> <span data-ttu-id="92213-194">상태 저장 복제본이 확인하는 동작은 강등되는 복제본인지 승격되는 복제본인지에 따라 달라 집니다.</span><span class="sxs-lookup"><span data-stu-id="92213-194">The behavior the stateful replica sees depends on whether it is the replica being demoted or promoted during the swap.</span></span>

### <a name="for-the-primary-being-demoted"></a><span data-ttu-id="92213-195">강등되는 주 복제본의 경우</span><span class="sxs-lookup"><span data-stu-id="92213-195">For the primary being demoted</span></span>
<span data-ttu-id="92213-196">Service Fabric은 이 복제본에서 메시지 처리를 중지하고 수행 중인 모든 백그라운드 작업을 종료하도록 합니다.</span><span class="sxs-lookup"><span data-stu-id="92213-196">Service Fabric needs this replica to stop processing messages and quit any background work it is doing.</span></span> <span data-ttu-id="92213-197">결과적으로 이 단계는 서비스가 종료될 경우와 유사합니다.</span><span class="sxs-lookup"><span data-stu-id="92213-197">As a result, this step looks similar to when the service is being shut down.</span></span> <span data-ttu-id="92213-198">한 가지 차이점은 서비스가 보조 복제본으로 그대로 남아 있으므로 소멸되거나 종료되지 않는다는 점입니다.</span><span class="sxs-lookup"><span data-stu-id="92213-198">One difference is that the Service isn't destructed or closed since it remains as a Secondary.</span></span> <span data-ttu-id="92213-199">다음 API가 호출됩니다.</span><span class="sxs-lookup"><span data-stu-id="92213-199">The following APIs are called:</span></span>

1. <span data-ttu-id="92213-200">병렬로</span><span class="sxs-lookup"><span data-stu-id="92213-200">In parallel</span></span>
    - <span data-ttu-id="92213-201">열려 있는 수신기가 닫힙니다.</span><span class="sxs-lookup"><span data-stu-id="92213-201">Any open listeners are Closed.</span></span> <span data-ttu-id="92213-202">`ICommunicationListener.CloseAsync()`가 각 수신기에서 호출됩니다.</span><span class="sxs-lookup"><span data-stu-id="92213-202">`ICommunicationListener.CloseAsync()` is called on each listener.</span></span>
    - <span data-ttu-id="92213-203">`RunAsync()`에 전달된 취소 토큰이 취소됩니다.</span><span class="sxs-lookup"><span data-stu-id="92213-203">The cancellation token passed to `RunAsync()` is canceled.</span></span> <span data-ttu-id="92213-204">취소 토큰의 `IsCancellationRequested` 속성을 확인하면 true를 반환하고, 호출되는 경우 토큰의 `ThrowIfCancellationRequested` 메서드에서 `OperationCanceledException`이 발생(throw)됩니다.</span><span class="sxs-lookup"><span data-stu-id="92213-204">Checking the cancellation token's `IsCancellationRequested` property returns true, and if called the token's `ThrowIfCancellationRequested` method throws an `OperationCanceledException`.</span></span>
2. <span data-ttu-id="92213-205">`CloseAsync()`이 각 수신기에서 완료되고 `RunAsync()`도 완료되면 서비스의 `StatefulServiceBase.OnChangeRoleAsync()`이 호출됩니다.</span><span class="sxs-lookup"><span data-stu-id="92213-205">Once `CloseAsync()` completes on each listener and `RunAsync()` also completes, the service's `StatefulServiceBase.OnChangeRoleAsync()` is called.</span></span> <span data-ttu-id="92213-206">이는 서비스에서 드물게 재정의됩니다.</span><span class="sxs-lookup"><span data-stu-id="92213-206">This is uncommonly overridden in the service.</span></span>

### <a name="for-the-secondary-being-promoted"></a><span data-ttu-id="92213-207">승격되는 보조 복제본의 경우</span><span class="sxs-lookup"><span data-stu-id="92213-207">For the secondary being promoted</span></span>
<span data-ttu-id="92213-208">마찬가지로 Service Fabric에서 이 복제본을 사용하여 통신 중에 메시지에 대한 수신 대기를 시작하고, 관심 있는 모든 백그라운드 작업을 시작해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="92213-208">Similarly, Service Fabric needs this replica to start listening for messages on the wire and start any background tasks it cares about.</span></span> <span data-ttu-id="92213-209">결과적으로 이 프로세스는 복제본 자체가 이미 존재한다는 점을 제외하면 서비스를 만들 때와 유사합니다.</span><span class="sxs-lookup"><span data-stu-id="92213-209">As a result, this process looks similar to when the service is created, except that the replica itself already exists.</span></span> <span data-ttu-id="92213-210">다음 API가 호출됩니다.</span><span class="sxs-lookup"><span data-stu-id="92213-210">The following APIs are called:</span></span>

1. <span data-ttu-id="92213-211">병렬로</span><span class="sxs-lookup"><span data-stu-id="92213-211">In parallel</span></span>
    - <span data-ttu-id="92213-212">`StatefulServiceBase.CreateServiceReplicaListeners()`가 호출되고 반환된 모든 수신기가 열립니다.</span><span class="sxs-lookup"><span data-stu-id="92213-212">`StatefulServiceBase.CreateServiceReplicaListeners()` is invoked and any returned listeners are Opened.</span></span> <span data-ttu-id="92213-213">`ICommunicationListener.OpenAsync()`가 각 수신기에서 호출됩니다.</span><span class="sxs-lookup"><span data-stu-id="92213-213">`ICommunicationListener.OpenAsync()` is called on each listener.</span></span>
    - <span data-ttu-id="92213-214">서비스의 `StatefulServiceBase.RunAsync()` 메서드가 호출됩니다.</span><span class="sxs-lookup"><span data-stu-id="92213-214">The service's `StatefulServiceBase.RunAsync()` method is called</span></span>
2. <span data-ttu-id="92213-215">모든 복제본 수신기의 `OpenAsync()` 호출이 완료되고 `RunAsync()`가 호출되었으면 `StatefulServiceBase.OnChangeRoleAsync()`가 호출됩니다.</span><span class="sxs-lookup"><span data-stu-id="92213-215">Once all the replica listener's `OpenAsync()` calls complete and `RunAsync()` has been called,  `StatefulServiceBase.OnChangeRoleAsync()` is called.</span></span> <span data-ttu-id="92213-216">이는 서비스에서 드물게 재정의됩니다.</span><span class="sxs-lookup"><span data-stu-id="92213-216">This is uncommonly overridden in the service.</span></span>

### <a name="common-issues-during-stateful-service-shutdown-and-primary-demotion"></a><span data-ttu-id="92213-217">상태 저장 서비스 종료 및 기본 수준 내리기 동안의 일반적인 문제</span><span class="sxs-lookup"><span data-stu-id="92213-217">Common issues during stateful service shutdown and primary demotion</span></span>
<span data-ttu-id="92213-218">Service Fabric에서는 다양한 이유로 상태 저장 서비스에 대한 주 복제본을 변경합니다.</span><span class="sxs-lookup"><span data-stu-id="92213-218">Service Fabric changes the Primary of a stateful service for a variety of reasons.</span></span> <span data-ttu-id="92213-219">가장 일반적인 것은 [클러스터 재분산](service-fabric-cluster-resource-manager-balancing.md) 및 [응용 프로그램 업그레이드](service-fabric-application-upgrade.md)입니다.</span><span class="sxs-lookup"><span data-stu-id="92213-219">The most common are [cluster rebalancing](service-fabric-cluster-resource-manager-balancing.md) and [application upgrade](service-fabric-application-upgrade.md).</span></span> <span data-ttu-id="92213-220">이러한 작업 동안(서비스가 삭제되었는지 확인하는 경우처럼 정상적인 서비스 종료 동안에도) 서비스에서 `CancellationToken`을 준수하는 것이 중요합니다.</span><span class="sxs-lookup"><span data-stu-id="92213-220">During these operations (as well as during normal service shutdown, like you'd see if the service was deleted), it is important that the service respect the `CancellationToken`.</span></span> <span data-ttu-id="92213-221">취소를 완전히 처리하지 않는 서비스에는 몇 가지 문제가 발생합니다.</span><span class="sxs-lookup"><span data-stu-id="92213-221">Services that do not handle cancellation cleanly will experience several issues.</span></span> <span data-ttu-id="92213-222">특히 Service Fabric에서 서비스가 정상적으로 중지되기를 기다리기 때문에 이러한 작업이 느려질 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="92213-222">In particular, these operations will be slow since Service Fabric waits for the services to stop gracefully.</span></span> <span data-ttu-id="92213-223">이로 인해 궁극적으로 시간이 초과되고 롤백하게 되는 실패한 업그레이드로 이어질 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="92213-223">This can ultimately lead to failed upgrades that time out and roll back.</span></span> <span data-ttu-id="92213-224">취소 토큰을 사용하지 않으면 핫 노드가 되어 클러스터가 분산되지 않을 수도 있지만, 다른 곳으로 이동하는 데 시간이 너무 오래 걸리므로 서비스를 다시 분산할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="92213-224">Failure to honor the cancellation token can also cause imbalanced clusters because nodes get hot but the services can't be rebalanced since it takes too long to move them elsewhere.</span></span> 

<span data-ttu-id="92213-225">상태 저장 서비스이므로 [신뢰할 수 있는 컬렉션](service-fabric-reliable-services-reliable-collections.md)을 사용하고 있을 가능성이 큽니다.</span><span class="sxs-lookup"><span data-stu-id="92213-225">Since the services are stateful, it is also likely that they are using the [Reliable Collections](service-fabric-reliable-services-reliable-collections.md).</span></span> <span data-ttu-id="92213-226">Service Fabric에서 주 복제본이 강등될 때 가장 먼저 발생하는 상황 중 하나는 기본 상태에 대한 쓰기 액세스가 철회된다는 것입니다.</span><span class="sxs-lookup"><span data-stu-id="92213-226">In Service Fabric, when a Primary is demoted, one of the first things that happens is that write access to the underlying state is revoked.</span></span> <span data-ttu-id="92213-227">이로 인해 서비스 수명 주기에 영향을 줄 수 있는 두 번째 문제 집합이 발생합니다.</span><span class="sxs-lookup"><span data-stu-id="92213-227">This leads to a second set of issues that can impact the service lifecycle.</span></span> <span data-ttu-id="92213-228">컬렉션에서는 타이밍 및 복제본이 이동되거나 종료되는지 여부에 따라 예외를 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="92213-228">The collections return Exceptions based on the timing and whether the replica is being moved or shut down.</span></span> <span data-ttu-id="92213-229">이러한 예외는 올바르게 처리되어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="92213-229">These exceptions should be handled correctly.</span></span> <span data-ttu-id="92213-230">Service Fabric에서 발생한(throw) 예외는 영구[(`FabricException`)](https://docs.microsoft.com/en-us/dotnet/api/system.fabric.fabricexception?view=azure-dotnet) 및 일시적[(`FabricTransientException`)](https://docs.microsoft.com/en-us/dotnet/api/system.fabric.fabrictransientexception?view=azure-dotnet) 범주로 분류됩니다.</span><span class="sxs-lookup"><span data-stu-id="92213-230">Exceptions thrown by Service Fabric fall into permanent [(`FabricException`)](https://docs.microsoft.com/en-us/dotnet/api/system.fabric.fabricexception?view=azure-dotnet) and transient [(`FabricTransientException`)](https://docs.microsoft.com/en-us/dotnet/api/system.fabric.fabrictransientexception?view=azure-dotnet) categories.</span></span> <span data-ttu-id="92213-231">영구 예외는 기록되고 방출(throw)되어야 하지만, 일시적 예외는 몇 가지 다시 시도 논리에 따라 다시 시도될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="92213-231">Permanent exceptions should be logged and thrown, while the transient exceptions may be retried based on some retry logic.</span></span>

<span data-ttu-id="92213-232">서비스 수명 주기 이벤트와 함께 `ReliableCollections` 사용으로 인한 예외 처리는 신뢰할 수 있는 서비스의 테스트 및 유효성 검사에 대한 중요한 부분입니다.</span><span class="sxs-lookup"><span data-stu-id="92213-232">Handling the exceptions that come from use of the `ReliableCollections` in conjunction with service lifecycle events is an important part of testing and validating a Reliable Service.</span></span> <span data-ttu-id="92213-233">권장 사항은 항상 프로덕션에 배포하기 전에 업그레이드 및 [비정상 상황 테스트(chaos testing)](service-fabric-controlled-chaos.md)를 수행하는 동안 로드 상태에서 서비스를 실행하는 것입니다.</span><span class="sxs-lookup"><span data-stu-id="92213-233">The recommendation is always to run your service under load while performing upgrades and [chaos testing](service-fabric-controlled-chaos.md) before ever deploying to production.</span></span> <span data-ttu-id="92213-234">이러한 기본 단계를 통해 서비스가 올바르게 구현되고 수명 주기 이벤트가 올바르게 처리되도록 할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="92213-234">These basic steps help ensure that your service is correctly implemented and handles lifecycle events correctly.</span></span>


## <a name="notes-on-service-lifecycle"></a><span data-ttu-id="92213-235">서비스 수명 주기에 대한 참고 사항</span><span class="sxs-lookup"><span data-stu-id="92213-235">Notes on service lifecycle</span></span>
  - <span data-ttu-id="92213-236">`RunAsync()` 메서드 및 `CreateServiceReplicaListeners/CreateServiceInstanceListeners` 호출은 모두 선택 사항입니다.</span><span class="sxs-lookup"><span data-stu-id="92213-236">Both the `RunAsync()` method and the `CreateServiceReplicaListeners/CreateServiceInstanceListeners` calls are optional.</span></span> <span data-ttu-id="92213-237">서비스에는 이러한 항목이 있거나 없을 수도 있습니다.</span><span class="sxs-lookup"><span data-stu-id="92213-237">A service may have one of them, both, or neither.</span></span> <span data-ttu-id="92213-238">예를 들어, 서비스가 모든 작업을 사용자 호출에 대한 응답으로 수행할 경우 `RunAsync()`을(를) 구현할 필요가 없습니다.</span><span class="sxs-lookup"><span data-stu-id="92213-238">For example, if the service does all its work in response to user calls, there is no need for it to implement `RunAsync()`.</span></span> <span data-ttu-id="92213-239">통신 수신기 및 해당 관련 코드만이 필요합니다.</span><span class="sxs-lookup"><span data-stu-id="92213-239">Only the communication listeners and their associated code are necessary.</span></span> <span data-ttu-id="92213-240">마찬가지로 통신 수신기를 만들고 반환하는 작업은 선택적이며 서비스가 백그라운드 작업을 수행해야 하므로 `RunAsync()`을 구현해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="92213-240">Similarly, creating and returning communication listeners is optional, as the service may have only background work to do, and so only needs to implement `RunAsync()`</span></span>
  - <span data-ttu-id="92213-241">서비스가 `RunAsync()`을 성공적으로 완료하고 거기에서 반환하는 작업이 유효합니다.</span><span class="sxs-lookup"><span data-stu-id="92213-241">It is valid for a service to complete `RunAsync()` successfully and return from it.</span></span> <span data-ttu-id="92213-242">완료는 실패 조건이 아닙니다.</span><span class="sxs-lookup"><span data-stu-id="92213-242">Completing is not a failure condition.</span></span> <span data-ttu-id="92213-243">`RunAsync()`를 완료하면 서비스의 백그라운드 작업이 완료되었음을 나타냅니다.</span><span class="sxs-lookup"><span data-stu-id="92213-243">Completing `RunAsync()` indicates that the background work of the service has completed.</span></span> <span data-ttu-id="92213-244">상태 저장 신뢰할 수 있는 서비스의 경우 복제본이 주에서 보조로 강등된 다음 다시 주로 승격되면 `RunAsync()`가 다시 호출됩니다.</span><span class="sxs-lookup"><span data-stu-id="92213-244">For stateful reliable services, `RunAsync()` is called again if the replica were demoted from Primary to Secondary and then promoted back to Primary.</span></span>
  - <span data-ttu-id="92213-245">예기치 않은 예외가 발생(throw)되어 서비스가 `RunAsync()`에서 종료되는 경우 실패로 간주됩니다.</span><span class="sxs-lookup"><span data-stu-id="92213-245">If a service exits from `RunAsync()` by throwing some unexpected exception, this constitutes a failure.</span></span> <span data-ttu-id="92213-246">서비스 개체가 종료되고 상태 오류가 보고됩니다.</span><span class="sxs-lookup"><span data-stu-id="92213-246">The service object is shut down and a health error reported.</span></span>
  - <span data-ttu-id="92213-247">이러한 메서드에서 반환에는 시간 제한이 없으며 신뢰할 수 있는 컬렉션에 작성할 수 있는 기능이 즉시 손실되고 모든 실제 작업을 완료할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="92213-247">While there is no time limit on returning from these methods, you immediately lose the ability to write to Reliable Collections and therefore cannot complete any real work.</span></span> <span data-ttu-id="92213-248">취소 요청을 받는 즉시 최대한 신속하게 반환하는 것이 좋습니다.</span><span class="sxs-lookup"><span data-stu-id="92213-248">It is recommended that you return as quickly as possible upon receiving the cancellation request.</span></span> <span data-ttu-id="92213-249">서비스가 적절한 시간 내에 이러한 API 호출에 응답하지 않으면 Service Fabric은 서비스를 강제로 종료할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="92213-249">If your service does not respond to these API calls in a reasonable amount of time Service Fabric may forcibly terminate your service.</span></span> <span data-ttu-id="92213-250">이러한 상황은 일반적으로 응용 프로그램을 업그레이드하거나 서비스를 삭제할 때 발생합니다.</span><span class="sxs-lookup"><span data-stu-id="92213-250">Usually this only happens during application upgrades or when a service is being deleted.</span></span> <span data-ttu-id="92213-251">이 시간 제한은 기본적으로 15분입니다.</span><span class="sxs-lookup"><span data-stu-id="92213-251">This timeout is 15 minutes by default.</span></span>
  - <span data-ttu-id="92213-252">`OnCloseAsync()` 경로의 오류로 인해 `OnAbort()`가 호출되고 이것이 서비스에서 요구하는 리소스를 정리하고 릴리스할 수 있는 마지막 방법입니다.</span><span class="sxs-lookup"><span data-stu-id="92213-252">Failures in the `OnCloseAsync()` path result in `OnAbort()` being called which is a last-chance best-effort opportunity for the service to clean up and release any resources that they have claimed.</span></span>

## <a name="next-steps"></a><span data-ttu-id="92213-253">다음 단계</span><span class="sxs-lookup"><span data-stu-id="92213-253">Next steps</span></span>
- [<span data-ttu-id="92213-254">Reliable Services 소개</span><span class="sxs-lookup"><span data-stu-id="92213-254">Introduction to Reliable Services</span></span>](service-fabric-reliable-services-introduction.md)
- [<span data-ttu-id="92213-255">Reliable Services 빠른 시작</span><span class="sxs-lookup"><span data-stu-id="92213-255">Reliable Services quick start</span></span>](service-fabric-reliable-services-quick-start.md)
- [<span data-ttu-id="92213-256">신뢰할 수 있는 서비스 고급 사용법</span><span class="sxs-lookup"><span data-stu-id="92213-256">Reliable Services advanced usage</span></span>](service-fabric-reliable-services-advanced-usage.md)
