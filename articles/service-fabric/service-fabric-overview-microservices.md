---
title: "Azure에서 aaaIntroduction toomicroservices | Microsoft Docs"
description: "microservices 접근 방식으로 클라우드 응용 프로그램을 구축이 최신 응용 프로그램 개발에 대 한 중요 한 이유 및 Azure 서비스 패브릭 제공 하는 방법을 플랫폼 tooachieve이의 개요."
services: service-fabric
documentationcenter: .net
author: msfussell
manager: timlt
editor: 
ms.assetid: fae2be85-0ab4-4cd3-9d1f-e0d95fe1959b
ms.service: service-fabric
ms.devlang: dotnet
ms.topic: article
ms.tgt_pltfrm: NA
ms.workload: NA
ms.date: 07/02/2017
ms.author: msfussell
ms.openlocfilehash: b11920b9105e7575390e8fcf0d1ef6ab3c632978
ms.sourcegitcommit: 523283cc1b3c37c428e77850964dc1c33742c5f0
ms.translationtype: MT
ms.contentlocale: ko-KR
ms.lasthandoff: 10/06/2017
---
# <a name="why-a-microservices-approach-toobuilding-applications"></a><span data-ttu-id="b991c-103">이유는 microservices toobuilding 응용 프로그램에 접근?</span><span class="sxs-lookup"><span data-stu-id="b991c-103">Why a microservices approach toobuilding applications?</span></span>
<span data-ttu-id="b991c-104">소프트웨어 개발자로서 응용 프로그램을 구성 요소 부분으로 팩터링하는 것에 대한 생각에는 새로울 것이 없습니다.</span><span class="sxs-lookup"><span data-stu-id="b991c-104">As software developers, there is nothing new in how we think about factoring an application into component parts.</span></span> <span data-ttu-id="b991c-105">개체 방향, 소프트웨어 추상화 및 구성 요소화 hello 중앙 패러다임은</span><span class="sxs-lookup"><span data-stu-id="b991c-105">It is hello central paradigm of object orientation, software abstractions, and componentization.</span></span> <span data-ttu-id="b991c-106">오늘이 factorization tootake hello 형태의 클래스와 인터페이스 공유 라이브러리 및 기술 계층 간에 경향이 있습니다.</span><span class="sxs-lookup"><span data-stu-id="b991c-106">Today, this factorization tends tootake hello form of classes and interfaces between shared libraries and technology layers.</span></span> <span data-ttu-id="b991c-107">일반적으로 백엔드 스토어, 중간 계층 비즈니스 논리, 프런트엔드 사용자 인터페이스(UI)를 통한 계층화된 접근 방식을 이용합니다.</span><span class="sxs-lookup"><span data-stu-id="b991c-107">Typically, a tiered approach is taken with a back-end store, middle-tier business logic, and a front-end user interface (UI).</span></span> <span data-ttu-id="b991c-108">어떤 *가* 있는지, 개발자로 작성은 지난 몇 년 hello에 따른 변화 hello 클라우드에 대 한 되는 응용 프로그램을 배포 하 고 hello 비즈니스에 의해 발생 합니다.</span><span class="sxs-lookup"><span data-stu-id="b991c-108">What *has* changed over hello last few years is that we, as developers, are building distributed applications that are for hello cloud and driven by hello business.</span></span>

<span data-ttu-id="b991c-109">hello 변화 하는 비즈니스 요구 됩니다.</span><span class="sxs-lookup"><span data-stu-id="b991c-109">hello changing business needs are:</span></span>

* <span data-ttu-id="b991c-110">작성 되 고 (예) 새 지역에서 눈금 tooreach 고객에서 작동 하는 서비스입니다.</span><span class="sxs-lookup"><span data-stu-id="b991c-110">A service that's built and operates at scale tooreach customers in new geographical regions (for example).</span></span>
* <span data-ttu-id="b991c-111">Agile 방법으로 기능 및 특성 toobe 수 toorespond toocustomer 수요의 더 빠른 배달 합니다.</span><span class="sxs-lookup"><span data-stu-id="b991c-111">Faster delivery of features and capabilities toobe able toorespond toocustomer demands in an agile way.</span></span>
* <span data-ttu-id="b991c-112">향상 된 리소스 사용률 tooreduce 비용입니다.</span><span class="sxs-lookup"><span data-stu-id="b991c-112">Improved resource utilization tooreduce costs.</span></span>

<span data-ttu-id="b991c-113">이러한 비즈니스 요구가 응용 프로그램을 구축하는 *방식* 에 영향을 미칩니다.</span><span class="sxs-lookup"><span data-stu-id="b991c-113">These business needs are affecting *how* we build applications.</span></span>

<span data-ttu-id="b991c-114">Azure toomicroservices hello 방법에 대 한 자세한 내용은 [Microservices: hello 클라우드에서 제공 하는 응용 프로그램 revolution](https://azure.microsoft.com/blog/microservices-an-application-revolution-powered-by-the-cloud/)합니다.</span><span class="sxs-lookup"><span data-stu-id="b991c-114">For more information about hello approach of Azure toomicroservices, read [Microservices: An application revolution powered by hello cloud](https://azure.microsoft.com/blog/microservices-an-application-revolution-powered-by-the-cloud/).</span></span>

## <a name="monolithic-vs-microservice-design-approach"></a><span data-ttu-id="b991c-115">모놀리식과 마이크로 서비스 디자인 방법 비교</span><span class="sxs-lookup"><span data-stu-id="b991c-115">Monolithic vs. microservice design approach</span></span>
<span data-ttu-id="b991c-116">모든 응용 프로그램은 시간에 따라 진화합니다.</span><span class="sxs-lookup"><span data-stu-id="b991c-116">All applications evolve over time.</span></span> <span data-ttu-id="b991c-117">응용 프로그램 성공 유용한 toopeople 됨으로써 개선 합니다.</span><span class="sxs-lookup"><span data-stu-id="b991c-117">Successful applications evolve by being useful toopeople.</span></span> <span data-ttu-id="b991c-118">실패한 응용 프로그램은 진화하지 않고 결국은 퇴출됩니다.</span><span class="sxs-lookup"><span data-stu-id="b991c-118">Unsuccessful applications do not evolve and eventually are deprecated.</span></span> <span data-ttu-id="b991c-119">hello 질문이: 양을 알아 요구 사항에 대해 오늘 및 됩니다 되 hello 나중에 있습니까?</span><span class="sxs-lookup"><span data-stu-id="b991c-119">hello question becomes: How much do you know about your requirements today, and what will they be in hello future?</span></span> <span data-ttu-id="b991c-120">예를 들어 한 부서에 대한 보고 응용 프로그램을 빌드하고 있다고 가정해 보겠습니다.</span><span class="sxs-lookup"><span data-stu-id="b991c-120">For example, let's say that you are building a reporting application for a department.</span></span> <span data-ttu-id="b991c-121">회사의 hello 범위 내에서 hello 응용 프로그램 하 게 유지 되도록 하 고 hello 보고서는 수명이 짧은 확실 합니다.</span><span class="sxs-lookup"><span data-stu-id="b991c-121">You are sure that hello application remains within hello scope of your company and that hello reports are short-lived.</span></span> <span data-ttu-id="b991c-122">선택 하는 방법 간에 차이가 있는, 예를 들어, 수백만 개의 고객의 비디오 콘텐츠 tootens를 제공 하는 서비스를 작성 합니다.</span><span class="sxs-lookup"><span data-stu-id="b991c-122">Your choice of approach is different from, say, building a service that delivers video content tootens of millions of customers.</span></span> 

<span data-ttu-id="b991c-123">경우에 따라 특정 hello 도어 작업 개념 증명으로 가져오는 hello 응용 프로그램을 나중에 재설계 수 있는지 알고 있지만 hello 구동 요소입니다.</span><span class="sxs-lookup"><span data-stu-id="b991c-123">Sometimes, getting something out hello door as proof of concept is hello driving factor, while you know that hello application can be redesigned later.</span></span> <span data-ttu-id="b991c-124">절대 사용되지 않을 무언가를 과하게 가공하는 것은 아무런 의미가 없습니다.</span><span class="sxs-lookup"><span data-stu-id="b991c-124">There is little point in over-engineering something that never gets used.</span></span> <span data-ttu-id="b991c-125">hello 일반적인 엔지니어링 절충 값입니다.</span><span class="sxs-lookup"><span data-stu-id="b991c-125">It’s hello usual engineering trade-off.</span></span> <span data-ttu-id="b991c-126">다른 손 hello hello 클라우드, hello 기대 하는 발생 한 증가 및 사용에 대 한 빌드에 대 한 회사와 통신 하는 경우.</span><span class="sxs-lookup"><span data-stu-id="b991c-126">On hello other hand, when companies talk about building for hello cloud, hello expectation is growth and usage.</span></span> <span data-ttu-id="b991c-127">hello 문제는 발생 한 증가 및 소수 자릿수를 예측할 수입니다.</span><span class="sxs-lookup"><span data-stu-id="b991c-127">hello issue is that growth and scale are unpredictable.</span></span> <span data-ttu-id="b991c-128">같은 toobe 수 tooprototype 신속 하 게 이후 성공적으로 경로 toodeal에 한다고 아는 것도 하는 중입니다.</span><span class="sxs-lookup"><span data-stu-id="b991c-128">We would like toobe able tooprototype quickly while also knowing that we are on a path toodeal with future success.</span></span> <span data-ttu-id="b991c-129">이 hello lean 시작 방법: 빌드를 측정, 배울 수 있으며 반복 합니다.</span><span class="sxs-lookup"><span data-stu-id="b991c-129">This is hello lean startup approach: build, measure, learn, and iterate.</span></span>

<span data-ttu-id="b991c-130">Hello 클라이언트-서버 연대 하는 동안 각 계층에서 특정 기술을 사용 하 여 계층화 된 응용 프로그램을 구축에 toofocus를 경향을 했습니다.</span><span class="sxs-lookup"><span data-stu-id="b991c-130">During hello client-server era, we tended toofocus on building tiered applications by using specific technologies in each tier.</span></span> <span data-ttu-id="b991c-131">hello 용어 *모놀리식* 이러한 방법에 대 한 응용 프로그램 나타났습니다.</span><span class="sxs-lookup"><span data-stu-id="b991c-131">hello term *monolithic* application has emerged for these approaches.</span></span> <span data-ttu-id="b991c-132">hello 인터페이스 경향을 toobe hello 계층 간 및 더 밀접 하 게 결합 된 디자인 각 계층 내의 구성 요소 간에 사용 됩니다.</span><span class="sxs-lookup"><span data-stu-id="b991c-132">hello interfaces tended toobe between hello tiers, and a more tightly coupled design was used between components within each tier.</span></span> <span data-ttu-id="b991c-133">개발자들은 라이브러리에 컴파일되고 몇 개의 실행 파일과 DLL로 연결된 클래스를 설계하고 팩터링했습니다.</span><span class="sxs-lookup"><span data-stu-id="b991c-133">Developers designed and factored classes that were compiled into libraries and linked together into a few executables and DLLs.</span></span> 

<span data-ttu-id="b991c-134">모놀리식 디자인 방법 이점 toosuch가 됩니다.</span><span class="sxs-lookup"><span data-stu-id="b991c-134">There are benefits toosuch a monolithic design approach.</span></span> <span data-ttu-id="b991c-135">종종 간단 toodesign 되며 (IPC) 프로세스 간 통신을 통해 이러한 호출은 경우가 많기 때문에 구성 요소 간의 더 빨리 호출을 했습니다.</span><span class="sxs-lookup"><span data-stu-id="b991c-135">It's often simpler toodesign, and it has faster calls between components, because these calls are often over interprocess communication (IPC).</span></span> <span data-ttu-id="b991c-136">또한 모든 사용자에 toobe 더 많은 사람들이 리소스가 효율적으로 단일 제품을 테스트 합니다.</span><span class="sxs-lookup"><span data-stu-id="b991c-136">Also, everyone tests a single product, which tends toobe more people-resource efficient.</span></span> <span data-ttu-id="b991c-137">hello 단점은 계층화 된 레이어 간에 밀접 한 결합을를 개별 구성 요소를 확장할 수는 없습니다.</span><span class="sxs-lookup"><span data-stu-id="b991c-137">hello downside is that there's a tight coupling between tiered layers, and you cannot scale individual components.</span></span> <span data-ttu-id="b991c-138">다른 사용자에 대 한 toowait 해야 tooperform 수정 또는 업그레이드를 할 경우 toofinish 사람은 테스트 합니다.</span><span class="sxs-lookup"><span data-stu-id="b991c-138">If you need tooperform fixes or upgrades, you have toowait for others toofinish their testing.</span></span> <span data-ttu-id="b991c-139">것이 더 어렵게 toobe agile 합니다.</span><span class="sxs-lookup"><span data-stu-id="b991c-139">It is more difficult toobe agile.</span></span>

<span data-ttu-id="b991c-140">Microservices 이러한 단점이 주소 및 더 근접 비즈니스 요구 사항, 앞에 오는 hello로 하지만 이점과 부채 합니다.</span><span class="sxs-lookup"><span data-stu-id="b991c-140">Microservices address these downsides and more closely align with hello preceding business requirements, but they also have both benefits and liabilities.</span></span> <span data-ttu-id="b991c-141">hello microservices 이점은 각에 일반적으로 확장 또는 축소, 테스트, 배포 하 고 독립적으로 관리할 수 있는 간단한 비즈니스 기능을 캡슐화 합니다.</span><span class="sxs-lookup"><span data-stu-id="b991c-141">hello benefits of microservices are that each one typically encapsulates simpler business functionality, which you scale up or down, test, deploy, and manage independently.</span></span> <span data-ttu-id="b991c-142">때문에 중요 한 한 마이크로 서비스 접근 방법의 중요 한 장점은 팀은 보다 비즈니스 시나리오에서 더에 의해 발생 하는 hello 계층화 된 접근 방식을 기술 합니다.</span><span class="sxs-lookup"><span data-stu-id="b991c-142">One important benefit of a microservice approach is that teams are driven more by business scenarios than by technology, which hello tiered approach encourages.</span></span> <span data-ttu-id="b991c-143">실제 상황에서 더 적은 규모의 팀이 고객 시나리오를 기반으로 마이크로 서비스를 개발하고 원하는 기술을 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="b991c-143">In practice, smaller teams develop a microservice based on a customer scenario and use any technologies they choose.</span></span> 

<span data-ttu-id="b991c-144">즉, hello 조직 toostandardize 기술 toomaintain 마이크로 서비스 응용 프로그램 필요 하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="b991c-144">In other words, hello organization doesn’t need toostandardize tech toomaintain microservice applications.</span></span> <span data-ttu-id="b991c-145">개별 팀이 어떤 의미 팀 전문 지식에 따라에 대 한 통화를 하거나 가장 적합 한 toosolve hello 문제가 무엇입니까 직접 서비스를 수행할 수 있도록 합니다.</span><span class="sxs-lookup"><span data-stu-id="b991c-145">Individual teams that own services can do what makes sense for them based on team expertise or what’s most appropriate toosolve hello problem.</span></span> <span data-ttu-id="b991c-146">실제로 특정 NoSQL 스토어나 웹 응용 프로그램 프레임워크 등 일련의 권장 기술이 선호됩니다.</span><span class="sxs-lookup"><span data-stu-id="b991c-146">In practice, a set of recommended technologies, such as a particular NoSQL store or web application framework, is preferable.</span></span>

<span data-ttu-id="b991c-147">hello 단점은 microservices의 증가 하는 hello 별도 엔터티 수와 더 복잡 한 배포 및 버전 관리를 다루는 관리 됩니다.</span><span class="sxs-lookup"><span data-stu-id="b991c-147">hello downside of microservices comes in managing hello increased number of separate entities and dealing with more complex deployments and versioning.</span></span> <span data-ttu-id="b991c-148">네트워크 대기 시간을 해당 하는 hello 뿐만 아니라 hello microservices 간의 네트워크 트래픽이 증가합니다.</span><span class="sxs-lookup"><span data-stu-id="b991c-148">Network traffic between hello microservices increases as well as hello corresponding network latencies.</span></span> <span data-ttu-id="b991c-149">필요 이상으로 세밀한 서비스는 성능 문제를 야기합니다.</span><span class="sxs-lookup"><span data-stu-id="b991c-149">Lots of chatty, granular services are a recipe for a performance nightmare.</span></span> <span data-ttu-id="b991c-150">이러한 종속성을 보려면 도구 toohelp 없이 너무 "참조" hello 전체 시스템.</span><span class="sxs-lookup"><span data-stu-id="b991c-150">Without tools toohelp view these dependencies, it is hard too“see” hello whole system.</span></span> 

<span data-ttu-id="b991c-151">표준 hello 마이크로 서비스 접근 방식으로 작동 확인 방법을 hello 속한 항목만의 허용 되 고 toocommunicate에서 필요한 엄격한 계약 보다는 한 서비스에 동의 하는 것입니다.</span><span class="sxs-lookup"><span data-stu-id="b991c-151">Standards make hello microservice approach work by agreeing on how toocommunicate and being tolerant of only hello things you need from a service, rather than rigid contracts.</span></span> <span data-ttu-id="b991c-152">서비스에서 서로 독립적으로 업데이트 때문 hello에 이러한 계약을 디자인, 중요 한 toodefine입니다.</span><span class="sxs-lookup"><span data-stu-id="b991c-152">It is important toodefine these contracts up front in hello design, because services update independently of each other.</span></span> <span data-ttu-id="b991c-153">마이크로 서비스 접근 방식을 통한 설계와 연결된 또 다른 설명은 "세분화된 서비스 지향 아키텍처(SOA)"입니다.</span><span class="sxs-lookup"><span data-stu-id="b991c-153">Another description coined for designing with a microservices approach is “fine-grained service-oriented architecture (SOA).”</span></span>

<span data-ttu-id="b991c-154">***가장 간단한 hello microservices 디자인 방법은 독립 변경 tooeach 및 합의 표준을 사용 하 여 통신을 위해 서비스의 분리 된 페더레이션에 대 한 합니다.***</span><span class="sxs-lookup"><span data-stu-id="b991c-154">***At its simplest, hello microservices design approach is about a decoupled federation of services, with independent changes tooeach, and agreed-upon standards for communication.***</span></span>

<span data-ttu-id="b991c-155">사용자는 사실을 발견 더 많은 클라우드 앱을 생산 되는 대로이 분해의 전반적인 hello 독립적이 고 시나리오에 중점을 둔 서비스로 응용 프로그램은 더 우수한 장기 접근 방식입니다.</span><span class="sxs-lookup"><span data-stu-id="b991c-155">As more cloud apps are produced, people discover that this decomposition of hello overall app into independent, scenario-focused services is a better long-term approach.</span></span>

## <a name="comparison-between-application-development-approaches"></a><span data-ttu-id="b991c-156">응용 프로그램 개발 접근 방식 비교</span><span class="sxs-lookup"><span data-stu-id="b991c-156">Comparison between application development approaches</span></span>
![서비스 패브릭 플랫폼 응용 프로그램 개발][Image1]

1) <span data-ttu-id="b991c-158">모놀리식 앱은 도메인 특정 기능을 포함하며 일반적으로 웹, 비즈니스, 데이터 등의 기능 계층으로 구분됩니다.</span><span class="sxs-lookup"><span data-stu-id="b991c-158">A monolithic app contains domain-specific functionality and is normally divided by functional layers, such as web, business, and data.</span></span>

2) <span data-ttu-id="b991c-159">모놀리식 앱은 여러 서버/가상 컴퓨터/컨테이너에 복제하여 확장합니다.</span><span class="sxs-lookup"><span data-stu-id="b991c-159">You scale a monolithic app by cloning it on multiple servers/virtual machines/containers.</span></span>

3) <span data-ttu-id="b991c-160">마이크로 서비스 응용 프로그램은 기능을 더 작은 개별 서비스로 구분합니다.</span><span class="sxs-lookup"><span data-stu-id="b991c-160">A microservice application separates functionality into separate smaller services.</span></span>

4) <span data-ttu-id="b991c-161">hello microservices 접근 방식을 눈금으로 배포 하 여 각 서비스 하지 독립적으로 서버/가상 컴퓨터에서 이러한 서비스의 인스턴스를 만드는/컨테이너입니다.</span><span class="sxs-lookup"><span data-stu-id="b991c-161">hello microservices approach scales out by deploying each service independently, creating instances of these services across servers/virtual machines/containers.</span></span>

<span data-ttu-id="b991c-162">마이크로 서비스를 사용 하 여 디자인 방법은 모든 프로젝트에 대 한 통치 하지 않습니다. 하지만 앞에서 설명한 hello 비즈니스 목표와 더욱 긴밀 하 게 정렬지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="b991c-162">Designing with a microservice approach is not a panacea for all projects, but it does align more closely with hello business objectives described earlier.</span></span> <span data-ttu-id="b991c-163">모놀리식 접근 방식으로 시작 하는 것은 microservices 디자인에 나중에 hello 기회 toorework hello 코드 해야 알고 있는 경우 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="b991c-163">Starting with a monolithic approach might be acceptable if you know that you will have hello opportunity toorework hello code later into a microservices design.</span></span> <span data-ttu-id="b991c-164">더 일반적으로 모놀리식 응용 프로그램으로 시작 하 고 느린 나누십시오 단계별로 더 scalable 또는 agile toobe를 필요로 하는 기능 영역 hello로 시작 합니다.</span><span class="sxs-lookup"><span data-stu-id="b991c-164">More commonly, you begin with a monolithic application and slowly break it up in stages, starting with hello functional areas that need toobe more scalable or agile.</span></span>

<span data-ttu-id="b991c-165">toosummarize, hello 마이크로 서비스 방법은 toocompose 응용 프로그램의 많은 작은 서비스입니다.</span><span class="sxs-lookup"><span data-stu-id="b991c-165">toosummarize, hello microservice approach is toocompose your application of many small services.</span></span> <span data-ttu-id="b991c-166">hello 서비스 컴퓨터의 클러스터 전체에서 배포 되는 컨테이너에서 실행 됩니다.</span><span class="sxs-lookup"><span data-stu-id="b991c-166">hello services run in containers that are deployed across a cluster of machines.</span></span> <span data-ttu-id="b991c-167">소규모 팀은 시나리오에 대 한 서비스를 개발 하 고 독립적으로 버전을 테스트 하지, 배포 및 hello 전체 응용 프로그램을 개발할 수 있도록 각 서비스의 크기를 조정 합니다.</span><span class="sxs-lookup"><span data-stu-id="b991c-167">Smaller teams develop a service that focuses on a scenario and independently test, version, deploy, and scale each service so that hello entire application can evolve.</span></span>

## <a name="what-is-a-microservice"></a><span data-ttu-id="b991c-168">마이크로 서비스란?</span><span class="sxs-lookup"><span data-stu-id="b991c-168">What is a microservice?</span></span>
<span data-ttu-id="b991c-169">마이크로 서비스에 대한 정의는 여러 가지가 있습니다.</span><span class="sxs-lookup"><span data-stu-id="b991c-169">There are different definitions of microservices.</span></span> <span data-ttu-id="b991c-170">Hello 인터넷을 검색 하는 경우 자신의 관점 및 정의 제공 하는 유용한 많은 리소스를 찾을 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="b991c-170">If you search hello Internet, you'll find many useful resources that provide their own viewpoints and definitions.</span></span> <span data-ttu-id="b991c-171">그러나 대부분의 hello microservices의 특성에 따라 광범위 하 게 합의:</span><span class="sxs-lookup"><span data-stu-id="b991c-171">However, most of hello following characteristics of microservices are widely agreed upon:</span></span>

* <span data-ttu-id="b991c-172">고객 또는 비즈니스 시나리오를 캡슐화합니다.</span><span class="sxs-lookup"><span data-stu-id="b991c-172">Encapsulate a customer or business scenario.</span></span> <span data-ttu-id="b991c-173">해결 중인 hello 문제가 무엇입니까?</span><span class="sxs-lookup"><span data-stu-id="b991c-173">What is hello problem you are solving?</span></span>
* <span data-ttu-id="b991c-174">소규모 엔지니어링 팀에서 개발합니다.</span><span class="sxs-lookup"><span data-stu-id="b991c-174">Developed by a small engineering team.</span></span>
* <span data-ttu-id="b991c-175">어느 프로그래밍 언어로나 작성되고 모든 프레임워크에 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="b991c-175">Written in any programming language and use any framework.</span></span>
* <span data-ttu-id="b991c-176">개별적으로 버전 관리, 배포 및 확장되는 코드 및 상태(필요한 경우)로 구성됩니다.</span><span class="sxs-lookup"><span data-stu-id="b991c-176">Consist of code and (optionally) state, both of which are independently versioned, deployed, and scaled.</span></span>
* <span data-ttu-id="b991c-177">잘 정의된 인터페이스와 프로토콜을 통해 타 마이크로 서비스와 상호 작용합니다.</span><span class="sxs-lookup"><span data-stu-id="b991c-177">Interact with other microservices over well-defined interfaces and protocols.</span></span>
* <span data-ttu-id="b991c-178">사용 되는 고유 이름 (Url) tooresolve 위치로 있어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="b991c-178">Have unique names (URLs) used tooresolve their location.</span></span>
* <span data-ttu-id="b991c-179">일관 되 고 오류의 hello 현재 상태에서 사용할 수 있는 상태로 유지 합니다.</span><span class="sxs-lookup"><span data-stu-id="b991c-179">Remain consistent and available in hello presence of failures.</span></span>

<span data-ttu-id="b991c-180">이러한 특징을 다음으로 요약할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="b991c-180">You can summarize these characteristics into:</span></span>

<span data-ttu-id="b991c-181">***마이크로 서비스 응용 프로그램은 독립적으로 버전 관리되며 확장성 있는 소규모 고객 중심 서비스로 구성됩니다. 이 서비스들은 잘 정의된 인터페이스가 있는 표준 프로토콜을 통해 서로 통신합니다.***</span><span class="sxs-lookup"><span data-stu-id="b991c-181">***Microservice applications are composed of small, independently versioned, and scalable customer-focused services that communicate with each other over standard protocols with well-defined interfaces.***</span></span>

<span data-ttu-id="b991c-182">Hello 섹션 앞의 처음 두 점은 hello 다룬 하 고 이제 확장 하 고 명확 하 게 hello 다른 키를 누릅니다.</span><span class="sxs-lookup"><span data-stu-id="b991c-182">We covered hello first two points in hello preceding section, and now we expand on and clarify hello others.</span></span>

### <a name="written-in-any-programming-language-and-use-any-framework"></a><span data-ttu-id="b991c-183">어느 프로그래밍 언어로나 작성되고 모든 프레임워크에 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="b991c-183">Written in any programming language and use any framework</span></span>
<span data-ttu-id="b991c-184">개발자, 우리는 무료 toochoose 우리의 기술 또는 hello 서비스의 hello 요구에 따라 원하는 언어 또는 프레임 워크 것입니다.</span><span class="sxs-lookup"><span data-stu-id="b991c-184">As developers, we should be free toochoose a language or framework that we want, depending on our skills or hello needs of hello service.</span></span> <span data-ttu-id="b991c-185">일부 서비스에서 다른 모든 c + +의 성능 이점을 hello 값 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="b991c-185">In some services, you might value hello performance benefits of C++ above all else.</span></span> <span data-ttu-id="b991c-186">다른 서비스에서는 C# 또는 Java에서 관리 되는 개발의 hello 용이성 가장 중요할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="b991c-186">In other services, hello ease of managed development in C# or Java might be most important.</span></span> <span data-ttu-id="b991c-187">경우에 따라 데이터 저장소 기술을 toouse 특정 파트너 라이브러리를 할 수 있습니다 또는 수단 제공을 서비스 tooclients hello 합니다.</span><span class="sxs-lookup"><span data-stu-id="b991c-187">In some cases, you may need toouse a specific partner library, data storage technology, or means of exposing hello service tooclients.</span></span>

<span data-ttu-id="b991c-188">기술을 선택한 후 operational toohello 또는 수명 주기 관리 및 hello 서비스의 크기 조정을 제공 됩니다.</span><span class="sxs-lookup"><span data-stu-id="b991c-188">After you have chosen a technology, you come toohello operational or lifecycle management and scaling of hello service.</span></span>

### <a name="allows-code-and-state-toobe-independently-versioned-deployed-and-scaled"></a><span data-ttu-id="b991c-189">배포 하 고 크기가 조정 코드와 상태 toobe 독립적으로 버전이 지정 허용</span><span class="sxs-lookup"><span data-stu-id="b991c-189">Allows code and state toobe independently versioned, deployed, and scaled</span></span>
<span data-ttu-id="b991c-190">하지만 Microservices, hello 코드 및 필요에 따라 hello 상태 toowrite 선택 해야 독립적으로 배포, 업그레이드 및 크기를 조정 합니다.</span><span class="sxs-lookup"><span data-stu-id="b991c-190">However you choose toowrite your microservices, hello code and optionally hello state should independently deploy, upgrade, and scale.</span></span> <span data-ttu-id="b991c-191">실제로 hello 어렵게 하는 문제 toosolve 중 하나 때문에 이것이 tooyour 선택 하는 기술 두어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="b991c-191">This is actually one of hello harder problems toosolve, because it comes down tooyour choice of technologies.</span></span> <span data-ttu-id="b991c-192">크기 조정, 어떻게 toopartition (또는 분할) 둘 다 hello 코드와 상태를 이해는 어려운입니다.</span><span class="sxs-lookup"><span data-stu-id="b991c-192">For scaling, understanding how toopartition (or shard) both hello code and state is challenging.</span></span> <span data-ttu-id="b991c-193">Hello 코드와 상태는 오늘, 별도 기술을 사용할 때 프로그램 마이크로 서비스에 대 한 hello 배포 스크립트 toobe 수 toocope로 확장을 모두 필요.</span><span class="sxs-lookup"><span data-stu-id="b991c-193">When hello code and state use separate technologies, which is common today, hello deployment scripts for your microservice need toobe able toocope with scaling them both.</span></span> <span data-ttu-id="b991c-194">이것은 또한 민첩성 및 유연성을 있으므로 tooupgrade 필요 없이 hello microservices 중 일부를 업그레이드할 수 있습니다 이러한 작업을 한 번에 모든 합니다.</span><span class="sxs-lookup"><span data-stu-id="b991c-194">This is also about agility and flexibility, so you can upgrade some of hello microservices without having tooupgrade all of them at once.</span></span>

<span data-ttu-id="b991c-195">잠시 동안 마이크로 서비스 접근 방식 비교 모놀리식 toohello 반환, hello 다음 다이어그램 차이점을 보여 줍니다 hello hello 접근 방식 toostoring 상태에 있습니다.</span><span class="sxs-lookup"><span data-stu-id="b991c-195">Returning toohello monolithic versus microservice approach for a moment, hello following diagram shows hello differences in hello approach toostoring state.</span></span>

#### <a name="state-storage-between-application-styles"></a><span data-ttu-id="b991c-196">응용 프로그램 스타일 간의 상태 저장</span><span class="sxs-lookup"><span data-stu-id="b991c-196">State storage between application styles</span></span>
![서비스 패브릭 플랫폼 상태 저장][Image2]

<span data-ttu-id="b991c-198">***hello 왼쪽에 hello 모놀리식 방법에는 단일 데이터베이스와 계층의 특정 기술에 있습니다.***</span><span class="sxs-lookup"><span data-stu-id="b991c-198">***hello monolithic approach on hello left has a single database and tiers of specific technologies.***</span></span>

<span data-ttu-id="b991c-199">***hello 오른쪽에 hello microservices 방법에는 상호 연결 된 microservices 다양 한 기술을 사용 하 고 있는 상태는 일반적으로 범위가 지정 된 toohello 마이크로 서비스에 대 한 그래프.***</span><span class="sxs-lookup"><span data-stu-id="b991c-199">***hello microservices approach on hello right has a graph of interconnected microservices where state is typically scoped toohello microservice and various technologies are used.***</span></span>

<span data-ttu-id="b991c-200">일반적으로 모놀리식 방식으로 hello 응용이 단일 데이터베이스를 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="b991c-200">In a monolithic approach, typically hello application uses a single database.</span></span> <span data-ttu-id="b991c-201">hello 장점은 단일 위치를 쉽게 toodeploy 하므로 된다는 점입니다.</span><span class="sxs-lookup"><span data-stu-id="b991c-201">hello advantage is that it is a single location, which makes it easy toodeploy.</span></span> <span data-ttu-id="b991c-202">각 구성 요소는 단일 테이블 toostore 상태로 있을 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="b991c-202">Each component can have a single table toostore its state.</span></span> <span data-ttu-id="b991c-203">팀은 challenge 되 toostrictly 별도 상태와 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="b991c-203">Teams need toostrictly separate state, which is a challenge.</span></span> <span data-ttu-id="b991c-204">필연적으로 되지 temptations tooadd 새 열 tooan 기존 고객 테이블, 테이블 간의 조인 작업을 수행할 수 있으며 hello 저장소 계층에서 종속성을 만듭니다.</span><span class="sxs-lookup"><span data-stu-id="b991c-204">Inevitably there are temptations tooadd a new column tooan existing customer table, do a join between tables, and create dependencies at hello storage layer.</span></span> <span data-ttu-id="b991c-205">이러한 경우가 발생하면, 개별 구성 요소를 확장할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="b991c-205">After this happens, you can't scale individual components.</span></span> 

<span data-ttu-id="b991c-206">Hello microservices 방법에서는 각 서비스를 관리 하 고 자체의 상태를 저장 합니다.</span><span class="sxs-lookup"><span data-stu-id="b991c-206">In hello microservices approach, each service manages and stores its own state.</span></span> <span data-ttu-id="b991c-207">각 서비스는 hello 서비스의 코드와 상태를 모두 함께 toomeet hello 요구 크기를 조정 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="b991c-207">Each service is responsible for scaling both code and state together toomeet hello demands of hello service.</span></span> <span data-ttu-id="b991c-208">한 가지 단점이 하는 경우에 필요 toocreate 뷰 또는 쿼리, 응용 프로그램의 데이터의 서로 다른 상태 저장소 tooquery 필요 합니다.</span><span class="sxs-lookup"><span data-stu-id="b991c-208">A downside is that when there is a need toocreate views, or queries, of your application’s data, you need tooquery across disparate state stores.</span></span> <span data-ttu-id="b991c-209">일반적으로 이 문제는 마이크로 서비스의 컬렉션에 걸쳐 뷰를 구축하는 개별 마이크로 서비스를 갖춤으로써 해결할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="b991c-209">Typically, this is solved by having a separate microservice that builds a view across a collection of microservices.</span></span> <span data-ttu-id="b991c-210">Hello 데이터에 여러 개의 임시 쿼리 tooperform 해야 할 경우 각 마이크로 서비스 오프 라인 분석을 위해 데이터 tooa 데이터 웨어하우징 서비스 작성을 고려해 야 합니다.</span><span class="sxs-lookup"><span data-stu-id="b991c-210">If you need tooperform multiple impromptu queries on hello data, each microservice should consider writing its data tooa data warehousing service for offline analytics.</span></span>

<span data-ttu-id="b991c-211">버전 관리는 한 마이크로 서비스의 배포 된 특정 toohello 버전 여러 하므로, 배포 하 고 함께 실행 하는 다양 한 버전입니다.</span><span class="sxs-lookup"><span data-stu-id="b991c-211">Versioning is specific toohello deployed version of a microservice so that multiple, different versions deploy and run side by side.</span></span> <span data-ttu-id="b991c-212">버전 관리는 마이크로 서비스의 최신 버전 업그레이드 하는 동안 오류가 발생 하 고 필요한 tooroll 백 tooan hello 시나리오에서는 이전 버전입니다.</span><span class="sxs-lookup"><span data-stu-id="b991c-212">Versioning addresses hello scenarios where a newer version of a microservice fails during upgrade and needs tooroll back tooan earlier version.</span></span> <span data-ttu-id="b991c-213">hello 버전 관리에 대 한 다른 시나리오에서 수행 중인 A/B-스타일 테스트, 여기서는 다른 사용자가 경험 hello 서비스의 여러 버전.</span><span class="sxs-lookup"><span data-stu-id="b991c-213">hello other scenario for versioning is performing A/B-style testing, where different users experience different versions of hello service.</span></span> <span data-ttu-id="b991c-214">예를 들어, 공개 전에 더 광범위 하 게 일반적인 tooupgrade 특정 고객 tootest 새로운 기능 집합에 대 한 마이크로 서비스입니다.</span><span class="sxs-lookup"><span data-stu-id="b991c-214">For example, it is common tooupgrade a microservice for a specific set of customers tootest new functionality before rolling it out more widely.</span></span> <span data-ttu-id="b991c-215">Microservices의 수명 주기 관리, 후이 구문은 이제 더 광범위 toocommunication 사이입니다.</span><span class="sxs-lookup"><span data-stu-id="b991c-215">After lifecycle management of microservices, this now brings us toocommunication between them.</span></span>

### <a name="interacts-with-other-microservices-over-well-defined-interfaces-and-protocols"></a><span data-ttu-id="b991c-216">잘 정의된 인터페이스와 프로토콜을 통해 타 마이크로 서비스와 상호 작용</span><span class="sxs-lookup"><span data-stu-id="b991c-216">Interacts with other microservices over well-defined interfaces and protocols</span></span>
<span data-ttu-id="b991c-217">이 항목 지난 10 년 동안 hello를 통해 게시 한 서비스 지향 아키텍처에 대 한 광범위 한 홍보 자료 통신 패턴을 설명 하기 때문에 거의 관심이 여기에서 필요 합니다.</span><span class="sxs-lookup"><span data-stu-id="b991c-217">This topic needs little attention here, because extensive literature about service-oriented architecture that has been published over hello past 10 years describes communication patterns.</span></span> <span data-ttu-id="b991c-218">일반적으로 서비스 통신 방법을 사용 하 여는 REST를 HTTP 및 TCP 프로토콜 및 XML 또는 JSON hello serialization 형식으로.</span><span class="sxs-lookup"><span data-stu-id="b991c-218">Generally, service communication uses a REST approach with HTTP and TCP protocols and XML or JSON as hello serialization format.</span></span> <span data-ttu-id="b991c-219">인터페이스의 관점에서 hello 웹 디자인 방법 수용 하는 방법에 대 한 됩니다.</span><span class="sxs-lookup"><span data-stu-id="b991c-219">From an interface perspective, it is about embracing hello web design approach.</span></span> <span data-ttu-id="b991c-220">그러나 바이너리 프로토콜이나 자체 데이터 형식을 사용하지 않을 이유는 없습니다.</span><span class="sxs-lookup"><span data-stu-id="b991c-220">But nothing stops you from using binary protocols or your own data formats.</span></span> <span data-ttu-id="b991c-221">준비 사람 toohave 어려워지므로 공개적으로 사용할 수 있는 경우 프로그램 microservices를 사용 하 여 합니다.</span><span class="sxs-lookup"><span data-stu-id="b991c-221">Be prepared for people toohave a harder time using your microservices if these are openly available.</span></span>

### <a name="has-a-unique-name-url-used-tooresolve-its-location"></a><span data-ttu-id="b991c-222">고유 이름 (URL)에 해당 위치를 tooresolve 사용</span><span class="sxs-lookup"><span data-stu-id="b991c-222">Has a unique name (URL) used tooresolve its location</span></span>
<span data-ttu-id="b991c-223">어떻게 म 유지 이라는 hello 마이크로 서비스 접근 방식을 hello 웹 같은 기억?</span><span class="sxs-lookup"><span data-stu-id="b991c-223">Remember how we keep saying that hello microservice approach is like hello web?</span></span> <span data-ttu-id="b991c-224">처럼 hello 웹 프로그램 마이크로 서비스 필요 toobe 주소 지정 가능한 때마다 실행 되 고 합니다.</span><span class="sxs-lookup"><span data-stu-id="b991c-224">Like hello web, your microservice needs toobe addressable wherever it is running.</span></span> <span data-ttu-id="b991c-225">컴퓨터 및 특정 마이크로 서비스를 실행할 컴퓨터에 대해 고려하면 급격한 문제가 발생합니다.</span><span class="sxs-lookup"><span data-stu-id="b991c-225">If you are thinking about machines and which one is running a particular microservice, things go bad quickly.</span></span> 

<span data-ttu-id="b991c-226">특정 URL tooa 특정 컴퓨터를 동일한 방식으로 DNS 확인 hello, 현재 위치를 검색할 수 있도록 toohave 고유한 이름을 프로그램 마이크로 서비스에 필요 합니다.</span><span class="sxs-lookup"><span data-stu-id="b991c-226">In hello same way that DNS resolves a particular URL tooa particular machine, your microservice needs toohave a unique name so that its current location is discoverable.</span></span> <span data-ttu-id="b991c-227">Microservices는 hello 인프라에서 실행 되는 별개는 주소 지정 가능 이름이 필요 합니다.</span><span class="sxs-lookup"><span data-stu-id="b991c-227">Microservices need addressable names that make them independent from hello infrastructure that they are running on.</span></span> <span data-ttu-id="b991c-228">이 때문에 서비스의 배포 방법을 검색 방법을 사이의 상호 작용 임을 의미 toobe 서비스 레지스트리 필요 합니다.</span><span class="sxs-lookup"><span data-stu-id="b991c-228">This implies that there is an interaction between how your service is deployed and how it is discovered, because there needs toobe a service registry.</span></span> <span data-ttu-id="b991c-229">마찬가지로, 한 컴퓨터에서 오류가 발생 hello 레지스트리 서비스가 해야 등에 대 한 이제 hello 서비스가 실행 됩니다.</span><span class="sxs-lookup"><span data-stu-id="b991c-229">Equally, when a machine fails, hello registry service must tell you where hello service is now running.</span></span> 

<span data-ttu-id="b991c-230">제기 toohello 다음 항목: 복원 력과 일관성을 유지 합니다.</span><span class="sxs-lookup"><span data-stu-id="b991c-230">This brings us toohello next topic: resilience and consistency.</span></span>

### <a name="remains-consistent-and-available-in-hello-presence-of-failures"></a><span data-ttu-id="b991c-231">일관 되 고 오류의 hello 현재 상태에서 사용할 수 있는 상태로 유지 됩니다.</span><span class="sxs-lookup"><span data-stu-id="b991c-231">Remains consistent and available in hello presence of failures</span></span>
<span data-ttu-id="b991c-232">예기치 않은 오류를 처리 하는 분산된 시스템에서 특히 hello 가장 어려운 문제 toosolve, 중 하나입니다.</span><span class="sxs-lookup"><span data-stu-id="b991c-232">Dealing with unexpected failures is one of hello hardest problems toosolve, especially in a distributed system.</span></span> <span data-ttu-id="b991c-233">개발자로 작성 하는 hello 코드의 대부분은 예외 처리, 및에이 hello 대부분 시간이 소요 된 위치에서 테스트 합니다.</span><span class="sxs-lookup"><span data-stu-id="b991c-233">Much of hello code that we write as developers is handling exceptions, and this is also where hello most time is spent in testing.</span></span> <span data-ttu-id="b991c-234">hello 문제는 toohandle 오류 코드를 작성 보다 훨씬 복잡 합니다.</span><span class="sxs-lookup"><span data-stu-id="b991c-234">hello problem is more involved than writing code toohandle failures.</span></span> <span data-ttu-id="b991c-235">Hello hello 마이크로 서비스 실행 중인 시스템에 실패 하면 어떻게 되나요?</span><span class="sxs-lookup"><span data-stu-id="b991c-235">What happens when hello machine where hello microservice is running fails?</span></span> <span data-ttu-id="b991c-236">뿐만 아니라 않습니다 toodetect이 마이크로 서비스 오류 (자체적으로 하드 문제)을 필요는 없지만 대상이 필요 하기 toorestart 프로그램 마이크로 서비스입니다.</span><span class="sxs-lookup"><span data-stu-id="b991c-236">Not only do you need toodetect this microservice failure (a hard problem on its own), but you also need something toorestart your microservice.</span></span> 

<span data-ttu-id="b991c-237">마이크로 서비스는 toobe 탄력적인 toofailures 되어야 하며 가용성 이유로 다른 컴퓨터에서 자주 다시 시작 합니다.</span><span class="sxs-lookup"><span data-stu-id="b991c-237">A microservice needs toobe resilient toofailures and restart often on another machine for availability reasons.</span></span> <span data-ttu-id="b991c-238">이 다운 toohello 저장 된 상태를 hello 마이크로 서비스를 대신 하 여 hello 마이크로 서비스에서이 상태를 복구할 수와 인지 hello 마이크로 서비스 수 toorestart 성공적으로 제공 됩니다.</span><span class="sxs-lookup"><span data-stu-id="b991c-238">This also comes down toohello state that was saved on behalf of hello microservice, where hello microservice can recover this state from, and whether hello microservice is able toorestart successfully.</span></span> <span data-ttu-id="b991c-239">즉, hello 계산 (hello 프로세스 다시 시작)에 toobe 복원 력을 부여할 뿐만 아니라 hello 상태 또는 데이터 (데이터 손실 및 hello 데이터가 없는 일관성 유지)에 복원 력을 부여할 필요 합니다.</span><span class="sxs-lookup"><span data-stu-id="b991c-239">In other words, there needs toobe resilience in hello compute (hello process restarts) as well as resilience in hello state or data (no data loss and hello data remains consistent).</span></span>

<span data-ttu-id="b991c-240">복원 력 hello 문제가 응용 프로그램 업그레이드를 사용 하는 동안 오류가 발생할 때와 같은 다른 시나리오 중 중요 합니다.</span><span class="sxs-lookup"><span data-stu-id="b991c-240">hello problems of resiliency are compounded during other scenarios, such as when failures happen during an application upgrade.</span></span> <span data-ttu-id="b991c-241">hello hello 배포 시스템을 사용 하는 마이크로 서비스 필요 하지 않은 toorecover 합니다.</span><span class="sxs-lookup"><span data-stu-id="b991c-241">hello microservice, working with hello deployment system, doesn't need toorecover.</span></span> <span data-ttu-id="b991c-242">또한 toothen 필요한 toomove 정방향 toohello 최신 버전을 계속 하거나 대신 롤백 이전 버전 toomaintain tooa 일관성 있는 상태로 수 있는지 여부를 결정 합니다.</span><span class="sxs-lookup"><span data-stu-id="b991c-242">It also needs toothen decide whether it can continue toomove forward toohello newer version or instead roll back tooa previous version toomaintain a consistent state.</span></span> <span data-ttu-id="b991c-243">와 같은 만큼 충분 한 컴퓨터가 되는지 앞으로 이동 하는 사용 가능한 tookeep 및 hello 마이크로 서비스의 이전 버전 toorecover toobe 것으로 간주 해야 하는 방법을 질문 합니다.</span><span class="sxs-lookup"><span data-stu-id="b991c-243">Questions such as whether enough machines are available tookeep moving forward and how toorecover previous versions of hello microservice need toobe considered.</span></span> <span data-ttu-id="b991c-244">이렇게 하려면 hello 마이크로 서비스 tooemit 상태 정보 toobe 수 toomake 이러한 결정 합니다.</span><span class="sxs-lookup"><span data-stu-id="b991c-244">This requires hello microservice tooemit health information toobe able toomake these decisions.</span></span>

### <a name="reports-health-and-diagnostics"></a><span data-ttu-id="b991c-245">보고서 상태 및 진단</span><span class="sxs-lookup"><span data-stu-id="b991c-245">Reports health and diagnostics</span></span>
<span data-ttu-id="b991c-246">당연하지만 자주 간과되는 것으로, 마이크로 서비스는 자신의 상태와 진단을 보고하는 것이 필수적입니다.</span><span class="sxs-lookup"><span data-stu-id="b991c-246">It may seem obvious, and it is often overlooked, but a microservice must report its health and diagnostics.</span></span> <span data-ttu-id="b991c-247">보고가 없으면 운영의 견지에서는 정보가 거의 없습니다.</span><span class="sxs-lookup"><span data-stu-id="b991c-247">Otherwise, there is little insight from an operations perspective.</span></span> <span data-ttu-id="b991c-248">독립 서비스 및 시스템 클록 스큐 toomake 감각 hello 이벤트 순서는 것은 어려울 처리의 조합에 대해 진단 이벤트를 상호 연결 합니다.</span><span class="sxs-lookup"><span data-stu-id="b991c-248">Correlating diagnostic events across a set of independent services and dealing with machine clock skews toomake sense of hello event order is challenging.</span></span> <span data-ttu-id="b991c-249">Hello에서 같은 방식으로 합의 프로토콜 및 데이터에 대 한 마이크로 서비스 상호 작용 하는 형식, 쿼리 및 보기를 위한 toolog 상태 및 진단 이벤트는 결국에 이벤트를 저장 하는 방법에 대 한 표준화에 대 한 요구가 있습니다 시나리오입니다.</span><span class="sxs-lookup"><span data-stu-id="b991c-249">In hello same way that you interact with a microservice over agreed-upon protocols and data formats, there emerges a need for standardization in how toolog health and diagnostic events that ultimately end up in an event store for querying and viewing.</span></span> <span data-ttu-id="b991c-250">마이크로 서비스 접근 방식에서는 여러 팀이 단일 로깅 형식에 동의하는 것이 중요합니다.</span><span class="sxs-lookup"><span data-stu-id="b991c-250">In a microservices approach, it is key that different teams agree on a single logging format.</span></span> <span data-ttu-id="b991c-251">Hello 응용 프로그램 전체에서에서 일관적인 접근 방식을 tooviewing 진단 이벤트 toobe 필요합니다.</span><span class="sxs-lookup"><span data-stu-id="b991c-251">There needs toobe a consistent approach tooviewing diagnostic events in hello application as a whole.</span></span>

<span data-ttu-id="b991c-252">상태는 진단과 다릅니다.</span><span class="sxs-lookup"><span data-stu-id="b991c-252">Health is different from diagnostics.</span></span> <span data-ttu-id="b991c-253">현재 상태 tootake 적절 한 조치를 보고 하는 hello 마이크로 서비스에 대 한 상태가입니다.</span><span class="sxs-lookup"><span data-stu-id="b991c-253">Health is about hello microservice reporting its current state tootake appropriate actions.</span></span> <span data-ttu-id="b991c-254">좋은 예로 업그레이드 및 배포 메커니즘 toomaintain 가용성과 함께 작동 합니다.</span><span class="sxs-lookup"><span data-stu-id="b991c-254">A good example is working with upgrade and deployment mechanisms toomaintain availability.</span></span> <span data-ttu-id="b991c-255">서비스 tooa 프로세스 크래시 인해 현재 정상 상태가 되었거나 컴퓨터 다시 부팅, 있지만 hello 서비스 작동 중일 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="b991c-255">Although a service may be currently unhealthy due tooa process crash or machine reboot, hello service might still be operational.</span></span> <span data-ttu-id="b991c-256">hello 필요한 것 toomake이이 나빠지는 업그레이드를 수행 하면 됩니다.</span><span class="sxs-lookup"><span data-stu-id="b991c-256">hello last thing you need is toomake this worse by performing an upgrade.</span></span> <span data-ttu-id="b991c-257">hello 가장 좋은 방법은 toodo 조사 먼저 또는 마이크로 서비스 toorecover hello에 대 한 시간을 허용 합니다.</span><span class="sxs-lookup"><span data-stu-id="b991c-257">hello best approach is toodo an investigation first or allow time for hello microservice toorecover.</span></span> <span data-ttu-id="b991c-258">마이크로 서비스의 상태 이벤트를 통해 정보에 입각한 의사 결정을 내리고 효과적인 자체 복구 서비스를 만들 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="b991c-258">Health events from a microservice help us make informed decisions and, in effect, help create self-healing services.</span></span>

## <a name="service-fabric-as-a-microservices-platform"></a><span data-ttu-id="b991c-259">마이크로 서비스 플랫폼으로서의 서비스 패브릭</span><span class="sxs-lookup"><span data-stu-id="b991c-259">Service Fabric as a microservices platform</span></span>
<span data-ttu-id="b991c-260">Azure 서비스 패브릭에서 Microsoft에서 전환 된 스타일에서 toodelivering 서비스 일반적으로 모놀리식 상자 제품을 제공 하지 못할 분명해졌습니다.</span><span class="sxs-lookup"><span data-stu-id="b991c-260">Azure Service Fabric emerged from a transition by Microsoft from delivering box products, which were typically monolithic in style, toodelivering services.</span></span> <span data-ttu-id="b991c-261">구축 및 작동 하는 큰 서비스와 Azure SQL 데이터베이스 및 Azure Cosmos DB 모양 서비스 패브릭 같은 hello 경험 합니다.</span><span class="sxs-lookup"><span data-stu-id="b991c-261">hello experience of building and operating large services, such as Azure SQL Database and Azure Cosmos DB, shaped Service Fabric.</span></span> <span data-ttu-id="b991c-262">hello 플랫폼 발전 함에 따라 시간이 지남에 따라 점점 더 많은 서비스 채택으로 합니다.</span><span class="sxs-lookup"><span data-stu-id="b991c-262">hello platform evolved over time as more and more services adopted it.</span></span> <span data-ttu-id="b991c-263">중요 한 사실은 Azure에서 뿐만 아니라 Windows 서버 배포의 독립 실행형 서비스 패브릭 toorun 해야 했습니다.</span><span class="sxs-lookup"><span data-stu-id="b991c-263">Importantly, Service Fabric had toorun not only in Azure but also in standalone Windows Server deployments.</span></span>

<span data-ttu-id="b991c-264">***서비스 패브릭의 hello 목표 toosolve 빌드 및 실행 하는 서비스의 hello 어려운 문제 이며 팀 microservices 방식을 사용 하 여 비즈니스 문제를 해결할 수 있도록 인프라 리소스를 효율적으로 활용 합니다.***</span><span class="sxs-lookup"><span data-stu-id="b991c-264">***hello aim of Service Fabric is toosolve hello hard problems of building and running a service and utilize infrastructure resources efficiently, so that teams can solve business problems using a microservices approach.***</span></span>

<span data-ttu-id="b991c-265">서비스 패브릭 제공 세 가지 넓은 영역 toohelp microservices 접근 방식을 사용 하는 응용 프로그램 빌드:</span><span class="sxs-lookup"><span data-stu-id="b991c-265">Service Fabric provides three broad areas toohelp you build applications that use a microservices approach:</span></span>

* <span data-ttu-id="b991c-266">시스템 서비스 toodeploy 제공 하는 플랫폼 업그레이드, 검색 및 실패 한 서비스를 다시 시작, 서비스 검색, 메시지를 라우팅할 상태를 관리 및 상태를 모니터링 합니다.</span><span class="sxs-lookup"><span data-stu-id="b991c-266">A platform that provides system services toodeploy, upgrade, detect, and restart failed services, discover services, route messages, manage state, and monitor health.</span></span> <span data-ttu-id="b991c-267">이러한 시스템 서비스를 통해 앞에서 설명한 microservices의 hello 특징을 많이 적용 합니다.</span><span class="sxs-lookup"><span data-stu-id="b991c-267">These system services in effect enable many of hello characteristics of microservices previously described.</span></span>
* <span data-ttu-id="b991c-268">기능 toodeploy 응용 프로그램으로 또는 컨테이너에서 실행 중 하나를 처리합니다.</span><span class="sxs-lookup"><span data-stu-id="b991c-268">Ability toodeploy applications either running in containers or as processes.</span></span> <span data-ttu-id="b991c-269">Service Fabric은 컨테이너 및 프로세스 조정자입니다.</span><span class="sxs-lookup"><span data-stu-id="b991c-269">Service Fabric is a container and process orchestrator.</span></span>
* <span data-ttu-id="b991c-270">생산적인 프로그래밍 Api microservices로 응용 프로그램을 빌드할 toohelp: [ASP.NET Core, Reliable Actors 및 신뢰할 수 있는 서비스](service-fabric-choose-framework.md)합니다.</span><span class="sxs-lookup"><span data-stu-id="b991c-270">Productive programming APIs,  toohelp you build applications as microservices: [ASP.NET Core, Reliable Actors, and Reliable Services](service-fabric-choose-framework.md).</span></span> <span data-ttu-id="b991c-271">모든 코드 toobuild 프로그램 마이크로 서비스를 선택할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="b991c-271">You can choose any code toobuild your microservice.</span></span> <span data-ttu-id="b991c-272">하지만 이러한 Api hello 작업을 더 간단 하 게 확인 하 고 좀 더 깊게 hello 플랫폼에 통합 합니다.</span><span class="sxs-lookup"><span data-stu-id="b991c-272">But these APIs make hello job more straightforward, and they integrate with hello platform at a deeper level.</span></span> <span data-ttu-id="b991c-273">예를 들어, 상태 및 진단 정보를 받거나 기본 제공되는 고가용성을 활용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="b991c-273">This way, for example, you can get health and diagnostics information, or you can take advantage of built-in high availability.</span></span>

<span data-ttu-id="b991c-274">***Service Fabric은 서비스를 구축한 방법과 무관하며 어느 기술이나 사용할 수 있습니다. 그러나 toobuild microservices 더 쉽게 확인 하는 기본 제공 프로그래밍 Api 제공지 않습니다.***</span><span class="sxs-lookup"><span data-stu-id="b991c-274">***Service Fabric is agnostic on how you build your service, and you can use any technology. However, it does provide built-in programming APIs that make it easier toobuild microservices.***</span></span>

### <a name="migrating-existing-applications-tooservice-fabric"></a><span data-ttu-id="b991c-275">기존 응용 프로그램 tooService 패브릭 마이그레이션</span><span class="sxs-lookup"><span data-stu-id="b991c-275">Migrating existing applications tooService Fabric</span></span>
<span data-ttu-id="b991c-276">키 방법을 tooService 패브릭은 tooreuse 기존 코드와 새 microservices 현대화 된 수입니다.</span><span class="sxs-lookup"><span data-stu-id="b991c-276">A key approach tooService Fabric is tooreuse existing code, which can then be modernized with new microservices.</span></span> <span data-ttu-id="b991c-277">5 단계 tooapplication 현대화 있으며 시작 하 고 hello 단계에서 중지할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="b991c-277">There are five stages tooapplication modernization, and you can start and stop at any of hello stages.</span></span> <span data-ttu-id="b991c-278">이 단계는 다음과 같습니다.</span><span class="sxs-lookup"><span data-stu-id="b991c-278">These are;</span></span>

1) <span data-ttu-id="b991c-279">기존의 모놀리식 응용 프로그램 선택</span><span class="sxs-lookup"><span data-stu-id="b991c-279">Take a traditional monolithic application</span></span>
2) <span data-ttu-id="b991c-280">리프트 하 고 이동-서비스 패브릭에서 컨테이너 또는 게스트 실행 파일 toohost 기존 코드를 사용 합니다.</span><span class="sxs-lookup"><span data-stu-id="b991c-280">Lift and Shift - Use containers or guest executables toohost existing code in Service Fabric.</span></span>
3) <span data-ttu-id="b991c-281">현대화 - 컨테이너화된 기존 코드와 함께 새 마이크로 서비스가 추가되었습니다.</span><span class="sxs-lookup"><span data-stu-id="b991c-281">Modernization - New microservices added alongside existing containerized code.</span></span> 
4) <span data-ttu-id="b991c-282">혁신-분해 합니다. hello 모놀리식 microservices 요구에 따라 순수 하 게 합니다.</span><span class="sxs-lookup"><span data-stu-id="b991c-282">Innovate - Break hello monolithic into microservices purely based on need.</span></span>
5) <span data-ttu-id="b991c-283">Microservices-새 최적의 응용 프로그램을 구축 또는 기존 모놀리식 응용 프로그램의 hello 변환으로 변환 합니다.</span><span class="sxs-lookup"><span data-stu-id="b991c-283">Transformed into microservices - hello transformation of existing monolithic applications or building new greenfield applications.</span></span>

![마이그레이션 tooMicroservices][Image3]

<span data-ttu-id="b991c-285">중요 한 tooemphasis 다시 설정할 수 있는 것이 **시작 하 고 위의 모든이 단계에서 중지**, 없는 toomoved toohello 다음 단계를 강요 합니다.</span><span class="sxs-lookup"><span data-stu-id="b991c-285">It is important tooemphasis again, that you can **start and stop at any of these stages**, you are not compelled toomoved toohello next stage.</span></span> <span data-ttu-id="b991c-286">이제 이러한 각 단계에 대한 예제를 살펴보겠습니다.</span><span class="sxs-lookup"><span data-stu-id="b991c-286">Let's now look at examples for each of these stages.</span></span>

<span data-ttu-id="b991c-287">**이동할** -많은 수의 회사는 아니며 해지 하 고 기존 모놀리식 응용 프로그램 컨테이너 toofor로 변화 하는 원인은 두;</span><span class="sxs-lookup"><span data-stu-id="b991c-287">**Lift and Shift** - large numbers of companies are lifting and shifting existing monolithic applications into containers toofor two reasons;</span></span>

- <span data-ttu-id="b991c-288">Tooconsolidation 및 더 높은 밀도에 기존 하드웨어 또는 실행 중인 응용 프로그램의 제거로 인해 비용된 절감.</span><span class="sxs-lookup"><span data-stu-id="b991c-288">Cost reduction either due tooconsolidation and removal  of existing hardware or running applications at higher density.</span></span> 
- <span data-ttu-id="b991c-289">개발 및 운영 간의 일관된 배포 계약</span><span class="sxs-lookup"><span data-stu-id="b991c-289">Consistent deployment contract between development and operations.</span></span>

<span data-ttu-id="b991c-290">비용된 절감 이해할 수 있으며 기존 응용 프로그램의 많은 되는 Microsoft에서 단순히 toomillions 달러의 컨테이너 화 된 합니다.</span><span class="sxs-lookup"><span data-stu-id="b991c-290">Cost reductions are understandable and within Microsoft large numbers of existing applications are being containerized simply toomillions of dollars.</span></span> <span data-ttu-id="b991c-291">일관 된 배포는 동일 하 게 중요 하지만 쉽다는 점 tooevaluate 합니다.</span><span class="sxs-lookup"><span data-stu-id="b991c-291">Consistent deployment is harder tooevaluate, but equally as important.</span></span> <span data-ttu-id="b991c-292">개발자가 할 수 표시 가능한 toochoose hello 기술 해당 도구 모음을 수 있지만 hello 작업은 페이로드만 단 하나의 방식은 toodeploy를 허용 하 고 이러한 응용 프로그램을 관리 합니다.</span><span class="sxs-lookup"><span data-stu-id="b991c-292">It says that developers can still be free toochoose hello technology that suites them, however hello operations will only accept a single way toodeploy and manage these applications.</span></span> <span data-ttu-id="b991c-293">Toodeal hello 복잡 한 다양 한 기술 사용 하는 것과 작업 hello를 완화 하거나 특정 구성을 선택 개발자 tooonly 강제 적용 합니다.</span><span class="sxs-lookup"><span data-stu-id="b991c-293">It alleviates hello operations from having toodeal with hello complexity of many different technologies or forcing developers tooonly choose certain ones.</span></span> <span data-ttu-id="b991c-294">기본적으로 모든 응용 프로그램은 자체 포함된 배포 이미지에 컨테이너화됩니다.</span><span class="sxs-lookup"><span data-stu-id="b991c-294">Essentially every application is containerized into self-contained deployment images.</span></span>

<span data-ttu-id="b991c-295">대부분의 조직에서는 여기까지만 수행합니다.</span><span class="sxs-lookup"><span data-stu-id="b991c-295">Many organizations stop here.</span></span> <span data-ttu-id="b991c-296">컨테이너의 hello 이점이 이미 있는 및 서비스 패브릭 배포, 업그레이드, 버전 관리, 롤백, 상태 모니터링 등의 hello 전체 관리 환경을 제공 합니다.</span><span class="sxs-lookup"><span data-stu-id="b991c-296">They already have hello benefits of containers and Service Fabric provides hello complete management experience from deployment, upgrades, versioning, rollbacks, health monitoring etc.</span></span>

<span data-ttu-id="b991c-297">**현대화** -는 컨테이너 화 된 기존 코드와 함께 새 서비스의 hello 추가 합니다.</span><span class="sxs-lookup"><span data-stu-id="b991c-297">**Modernization** - is hello addition of new services alongside existing containerized code.</span></span> <span data-ttu-id="b991c-298">Toowrite 새 코드를 사용 하도록 하려는 경우 hello microservices 경로 아래의 최상의 toodecide tootake 작은 단계입니다.</span><span class="sxs-lookup"><span data-stu-id="b991c-298">If you are going toowrite new code, it is best toodecide tootake small steps down hello microservices path.</span></span> <span data-ttu-id="b991c-299">그러면 새 REST API 끝점 또는 새로운 비즈니스 논리를 추가할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="b991c-299">This could be adding a new REST API endpoint, or new business logic.</span></span> <span data-ttu-id="b991c-300">이러한 방식으로 새 microservices 건물 및 개발 및 배포 연습 여행 hello에서 시작 하면 합니다.</span><span class="sxs-lookup"><span data-stu-id="b991c-300">This way, you start on hello journey of building new microservices and practice developing and deploying them.</span></span>

<span data-ttu-id="b991c-301">**혁신** -이러한 원래 변화 비즈니스 요구가 문서의 hello 시작 시 hello microservices 접근 방식에 영향을 주는 기억?</span><span class="sxs-lookup"><span data-stu-id="b991c-301">**Innovate** - remember those original changing business needs at hello start of this article, that are driving hello microservices approach?</span></span> <span data-ttu-id="b991c-302">이 단계 hello에 의사 결정은, 이러한 상황이 발생 toomy 현재 응용 프로그램은 및 toostart hello monolith 분할 하거나 혁신 그렇다면 싶습니다.</span><span class="sxs-lookup"><span data-stu-id="b991c-302">At this stage hello decision is, are these happening toomy current application and if so, I need toostart splitting hello monolith, or innovating.</span></span> <span data-ttu-id="b991c-303">여기에 있는 예제는 데이터베이스가 워크플로 큐로 사용되어 병목 상태를 처리 중인 경우입니다.</span><span class="sxs-lookup"><span data-stu-id="b991c-303">An example here is when a database becomes a processing bottleneck, since it is being used as a workflow queue.</span></span> <span data-ttu-id="b991c-304">Hello hello 증가 하는 워크플로 요청 수로 눈금에 대 한 분산 요구 toobe를 작동 합니다.</span><span class="sxs-lookup"><span data-stu-id="b991c-304">As hello number of workflow requests increasing hello work needs toobe distributed for scale.</span></span> <span data-ttu-id="b991c-305">따라서 크기 조정이 아니라는 hello 응용 프로그램의 해당 특정 부분에 있어야 tooupdate 더 자주는 마이크로 서비스를 분할이 out 시키고 혁신 하도록 돕습니다.</span><span class="sxs-lookup"><span data-stu-id="b991c-305">So for that particular piece of hello application that is not scaling, or you need tooupdate more frequently, split this out into a microservice and innovate.</span></span> 

<span data-ttu-id="b991c-306">**마이크로 서비스로 변환** - 응용 프로그램이 마이크로 서비스로 완벽하게 구성(또는 분리)된 경우입니다.</span><span class="sxs-lookup"><span data-stu-id="b991c-306">**Transformed into microservices** - this is where your application is fully composed of (or decomposed into) microservices.</span></span> <span data-ttu-id="b991c-307">여기에 tooreach hello microservices 여행을 했습니다.</span><span class="sxs-lookup"><span data-stu-id="b991c-307">tooreach here, you have made hello microservices journey.</span></span> <span data-ttu-id="b991c-308">시작할 수 있습니다 여기서 toodo 하지만이 microservices 플랫폼 toohelp 없이 상당한 투자가 없는지 확인 합니다.</span><span class="sxs-lookup"><span data-stu-id="b991c-308">You can start here, but toodo this without a microservices platform toohelp you is a significant investment.</span></span> 

### <a name="are-microservices-right-for-my-application"></a><span data-ttu-id="b991c-309">마이크로 서비스가 내 응용 프로그램에 적합할까요?</span><span class="sxs-lookup"><span data-stu-id="b991c-309">Are microservices right for my application?</span></span>
<span data-ttu-id="b991c-310">아마도 그렇습니다.</span><span class="sxs-lookup"><span data-stu-id="b991c-310">Maybe.</span></span> <span data-ttu-id="b991c-311">Microsoft에서 점점 더 많은 팀 toobuild 업무 용도 대 한 hello 클라우드에 대 한 시작으로 그 중 대부분 실현 마이크로 서비스와 비슷한 접근 방식을 활용 하는 hello에서 발생 했습니다.</span><span class="sxs-lookup"><span data-stu-id="b991c-311">What we experienced was that as more and more teams in Microsoft began toobuild for hello cloud for business reasons, many of them realized hello benefits of taking a microservice-like approach.</span></span> <span data-ttu-id="b991c-312">예를 들어, Bing은 수년 동안 검색에서 마이크로 서비스를 개발하고 있습니다.</span><span class="sxs-lookup"><span data-stu-id="b991c-312">Bing, for example, has been developing microservices in search for years.</span></span> <span data-ttu-id="b991c-313">다른 팀에 대 한 hello microservices 접근 방식은 새로운 이었습니다.</span><span class="sxs-lookup"><span data-stu-id="b991c-313">For other teams, hello microservices approach was new.</span></span> <span data-ttu-id="b991c-314">팀 강도의 자신의 핵심 영역 외부 어려운 문제 toosolve 했음을 발견 합니다.</span><span class="sxs-lookup"><span data-stu-id="b991c-314">Teams found that there were hard problems toosolve outside of their core areas of strength.</span></span> <span data-ttu-id="b991c-315">이 때문에 서비스 패브릭 서비스를 구축 하기 위한 선택 항목의 hello 기술로 계속 해 서 기반을 획득 합니다.</span><span class="sxs-lookup"><span data-stu-id="b991c-315">This is why Service Fabric gained traction as hello technology of choice for building services.</span></span>

<span data-ttu-id="b991c-316">서비스 패브릭의 hello 목표는 마이크로 서비스 접근 방식으로 응용 프로그램 구축 tooreduce hello 복잡성을 많은 비용이 많이 드는 다시 디자인으로 통해 toogo 보유 하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="b991c-316">hello objective of Service Fabric is tooreduce hello complexities of building applications with a microservice approach, so that you do not have toogo through as many costly redesigns.</span></span> <span data-ttu-id="b991c-317">작은 항목부터 시작, 필요한 경우 크기를 조정, 서비스 사용 안 함, 새 값을 추가 및 발전 고객 사용량은 hello 접근 방식입니다.</span><span class="sxs-lookup"><span data-stu-id="b991c-317">Start small, scale when needed, deprecate services, add new ones, and evolve with customer usage is hello approach.</span></span> <span data-ttu-id="b991c-318">또한 toobe 대부분 개발자를 위한 보다 쉽게 수행할 toomake microservices 해결 아직 많은 다른 문제가 있는 알고 있습니다.</span><span class="sxs-lookup"><span data-stu-id="b991c-318">We also know that there are many other problems yet toobe solved toomake microservices more approachable for most developers.</span></span> <span data-ttu-id="b991c-319">컨테이너 및 hello 행위자 프로그래밍 모델은 해당 방향에 작은 단계 예 있고 함수 우리는 더 많은 혁신으로 인해 나옵니다 toomake이 더 쉽습니다.</span><span class="sxs-lookup"><span data-stu-id="b991c-319">Containers and hello actor programming model are examples of small steps in that direction, and we are sure that more innovations will emerge toomake this easier.</span></span>
 
<!--Every topic should have next steps and links toohello next logical set of content tookeep hello customer engaged-->

## <a name="next-steps"></a><span data-ttu-id="b991c-320">다음 단계</span><span class="sxs-lookup"><span data-stu-id="b991c-320">Next steps</span></span>
* [<span data-ttu-id="b991c-321">서비스 패브릭 용어 개요</span><span class="sxs-lookup"><span data-stu-id="b991c-321">Service Fabric terminology overview</span></span>](service-fabric-technical-overview.md)
* [<span data-ttu-id="b991c-322">Microservices:는 응용 프로그램 revolution hello 클라우드 기반의</span><span class="sxs-lookup"><span data-stu-id="b991c-322">Microservices: An application revolution powered by hello cloud</span></span>](https://azure.microsoft.com/en-us/blog/microservices-an-application-revolution-powered-by-the-cloud/)

[Image1]: media/service-fabric-overview-microservices/monolithic-vs-micro.png
[Image2]: media/service-fabric-overview-microservices/statemonolithic-vs-micro.png
[Image3]: media/service-fabric-overview-microservices/microservices-migration.png
