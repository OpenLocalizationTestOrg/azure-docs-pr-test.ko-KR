---
title: "Azure 마이크로 서비스 소개 | Microsoft Docs"
description: "마이크로 서비스 접근 방식을 통해 클라우드 응용 프로그램을 빌드하는 것이 왜 현대 응용 프로그램 개발에서 중요하며 Azure Service Fabric이 어떻게 이를 위한 플랫폼을 제공하는지에 대한 개요"
services: service-fabric
documentationcenter: .net
author: msfussell
manager: timlt
editor: 
ms.assetid: fae2be85-0ab4-4cd3-9d1f-e0d95fe1959b
ms.service: service-fabric
ms.devlang: dotnet
ms.topic: article
ms.tgt_pltfrm: NA
ms.workload: NA
ms.date: 07/02/2017
ms.author: msfussell
ms.openlocfilehash: 53c142217c67465d29fa413f4edb4f96fcb4c6cc
ms.sourcegitcommit: 02e69c4a9d17645633357fe3d46677c2ff22c85a
ms.translationtype: MT
ms.contentlocale: ko-KR
ms.lasthandoff: 08/03/2017
---
# <a name="why-a-microservices-approach-to-building-applications"></a><span data-ttu-id="efbc1-103">응용 프로그램 구축에 마이크로 서비스 접근 방식이 필요한 이유</span><span class="sxs-lookup"><span data-stu-id="efbc1-103">Why a microservices approach to building applications?</span></span>
<span data-ttu-id="efbc1-104">소프트웨어 개발자로서 응용 프로그램을 구성 요소 부분으로 팩터링하는 것에 대한 생각에는 새로울 것이 없습니다.</span><span class="sxs-lookup"><span data-stu-id="efbc1-104">As software developers, there is nothing new in how we think about factoring an application into component parts.</span></span> <span data-ttu-id="efbc1-105">객체 지향, 소프트웨어 추상화 및 구성 요소화가 중심적인 패러다임입니다.</span><span class="sxs-lookup"><span data-stu-id="efbc1-105">It is the central paradigm of object orientation, software abstractions, and componentization.</span></span> <span data-ttu-id="efbc1-106">현재 이러한 팩토링화는 공유 라이브러리와 기술 계층 간의 인터페이스와 클래스의 형태를 취하는 경향이 있습니다.</span><span class="sxs-lookup"><span data-stu-id="efbc1-106">Today, this factorization tends to take the form of classes and interfaces between shared libraries and technology layers.</span></span> <span data-ttu-id="efbc1-107">일반적으로 백엔드 스토어, 중간 계층 비즈니스 논리, 프런트엔드 사용자 인터페이스(UI)를 통한 계층화된 접근 방식을 이용합니다.</span><span class="sxs-lookup"><span data-stu-id="efbc1-107">Typically, a tiered approach is taken with a back-end store, middle-tier business logic, and a front-end user interface (UI).</span></span> <span data-ttu-id="efbc1-108">지난 몇 년 동안 우리 개발자들이 *겪은* 변화는 비즈니스에서 운영하는 클라우드용 배포 응용 프로그램을 구축하는 것이었습니다.</span><span class="sxs-lookup"><span data-stu-id="efbc1-108">What *has* changed over the last few years is that we, as developers, are building distributed applications that are for the cloud and driven by the business.</span></span>

<span data-ttu-id="efbc1-109">변화하는 비즈니스 요구는 다음과 같습니다.</span><span class="sxs-lookup"><span data-stu-id="efbc1-109">The changing business needs are:</span></span>

* <span data-ttu-id="efbc1-110">예를 들어 새로운 지역의 고객에 도달하기 위해 대규모로 빌드되고 운영되는 서비스가 필요합니다.</span><span class="sxs-lookup"><span data-stu-id="efbc1-110">A service that's built and operates at scale to reach customers in new geographical regions (for example).</span></span>
* <span data-ttu-id="efbc1-111">고객의 요구에 민첩하게 대처할 수 있도록 기능과 특징을 더 빠르게 전달해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="efbc1-111">Faster delivery of features and capabilities to be able to respond to customer demands in an agile way.</span></span>
* <span data-ttu-id="efbc1-112">리소스 사용률 향상으로 비용을 줄여야 합니다.</span><span class="sxs-lookup"><span data-stu-id="efbc1-112">Improved resource utilization to reduce costs.</span></span>

<span data-ttu-id="efbc1-113">이러한 비즈니스 요구가 응용 프로그램을 구축하는 *방식* 에 영향을 미칩니다.</span><span class="sxs-lookup"><span data-stu-id="efbc1-113">These business needs are affecting *how* we build applications.</span></span>

<span data-ttu-id="efbc1-114">마이크로 서비스에 대한 Azure의 접근 방식에 대한 자세한 내용은 [마이크로 서비스: 클라우드가 제공하는 응용 프로그램 혁명](https://azure.microsoft.com/blog/microservices-an-application-revolution-powered-by-the-cloud/)을 참고합니다.</span><span class="sxs-lookup"><span data-stu-id="efbc1-114">For more information about the approach of Azure to microservices, read [Microservices: An application revolution powered by the cloud](https://azure.microsoft.com/blog/microservices-an-application-revolution-powered-by-the-cloud/).</span></span>

## <a name="monolithic-vs-microservice-design-approach"></a><span data-ttu-id="efbc1-115">모놀리식과 마이크로 서비스 디자인 방법 비교</span><span class="sxs-lookup"><span data-stu-id="efbc1-115">Monolithic vs. microservice design approach</span></span>
<span data-ttu-id="efbc1-116">모든 응용 프로그램은 시간에 따라 진화합니다.</span><span class="sxs-lookup"><span data-stu-id="efbc1-116">All applications evolve over time.</span></span> <span data-ttu-id="efbc1-117">성공적인 응용 프로그램은 사람들에게 유용하게 되어 진화합니다.</span><span class="sxs-lookup"><span data-stu-id="efbc1-117">Successful applications evolve by being useful to people.</span></span> <span data-ttu-id="efbc1-118">실패한 응용 프로그램은 진화하지 않고 결국은 퇴출됩니다.</span><span class="sxs-lookup"><span data-stu-id="efbc1-118">Unsuccessful applications do not evolve and eventually are deprecated.</span></span> <span data-ttu-id="efbc1-119">문제는 현재의 요구 사항에 대해 얼마나 알고 있으며 그러한 요구 사항이 향후 어떻게 될 것인가입니다.</span><span class="sxs-lookup"><span data-stu-id="efbc1-119">The question becomes: How much do you know about your requirements today, and what will they be in the future?</span></span> <span data-ttu-id="efbc1-120">예를 들어 한 부서에 대한 보고 응용 프로그램을 빌드하고 있다고 가정해 보겠습니다.</span><span class="sxs-lookup"><span data-stu-id="efbc1-120">For example, let's say that you are building a reporting application for a department.</span></span> <span data-ttu-id="efbc1-121">응용 프로그램이 회사의 범위 내에서 유지되며 보고서의 수명이 단기인 것이 확실합니다.</span><span class="sxs-lookup"><span data-stu-id="efbc1-121">You are sure that the application remains within the scope of your company and that the reports are short-lived.</span></span> <span data-ttu-id="efbc1-122">수천만의 고객에게 비디오 콘텐츠를 제공하는 서비스를 구축하는 것과는 다른 방식으로 접근해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="efbc1-122">Your choice of approach is different from, say, building a service that delivers video content to tens of millions of customers.</span></span> 

<span data-ttu-id="efbc1-123">응용 프로그램이 향후 재설계될 수 있다는 점을 알고 있는 상황에서 개념 증명의 형태로 무언가를 내놓는 것은 종종 촉진 요인이 됩니다.</span><span class="sxs-lookup"><span data-stu-id="efbc1-123">Sometimes, getting something out the door as proof of concept is the driving factor, while you know that the application can be redesigned later.</span></span> <span data-ttu-id="efbc1-124">절대 사용되지 않을 무언가를 과하게 가공하는 것은 아무런 의미가 없습니다.</span><span class="sxs-lookup"><span data-stu-id="efbc1-124">There is little point in over-engineering something that never gets used.</span></span> <span data-ttu-id="efbc1-125">이것은 일반적인 엔지니어링 절충입니다.</span><span class="sxs-lookup"><span data-stu-id="efbc1-125">It’s the usual engineering trade-off.</span></span> <span data-ttu-id="efbc1-126">반면 회사에서 클라우드를 위한 구축을 이야기할 때 기대하는 것은 성장과 사용입니다.</span><span class="sxs-lookup"><span data-stu-id="efbc1-126">On the other hand, when companies talk about building for the cloud, the expectation is growth and usage.</span></span> <span data-ttu-id="efbc1-127">이러한 성장과 확장에서의 문제는 예측할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="efbc1-127">The issue is that growth and scale are unpredictable.</span></span> <span data-ttu-id="efbc1-128">신속하게 프로토타입화할 수 있는 동시에 미래의 성공을 위해 대비할 수 있기를 바라게 됩니다.</span><span class="sxs-lookup"><span data-stu-id="efbc1-128">We would like to be able to prototype quickly while also knowing that we are on a path to deal with future success.</span></span> <span data-ttu-id="efbc1-129">이것이 구축, 측정, 학습, 반복으로 이루어진 간결한 시작 접근 방식입니다.</span><span class="sxs-lookup"><span data-stu-id="efbc1-129">This is the lean startup approach: build, measure, learn, and iterate.</span></span>

<span data-ttu-id="efbc1-130">클라이언트-서버 시절에는 각 계층마다 특정한 기술을 활용하여 계층화된 응용 프로그램을 구축하는 데 주력하는 경향이 있었습니다.</span><span class="sxs-lookup"><span data-stu-id="efbc1-130">During the client-server era, we tended to focus on building tiered applications by using specific technologies in each tier.</span></span> <span data-ttu-id="efbc1-131">이러한 접근 방식에 대해 *모놀리식* 응용 프로그램이라는 용어가 부상했습니다.</span><span class="sxs-lookup"><span data-stu-id="efbc1-131">The term *monolithic* application has emerged for these approaches.</span></span> <span data-ttu-id="efbc1-132">인터페이스가 계층 사이에 속하는 경향이 있기 때문에 각 계층 내의 구성 요소 사이에는 더 긴밀히 연결된 설계가 적용되었습니다.</span><span class="sxs-lookup"><span data-stu-id="efbc1-132">The interfaces tended to be between the tiers, and a more tightly coupled design was used between components within each tier.</span></span> <span data-ttu-id="efbc1-133">개발자들은 라이브러리에 컴파일되고 몇 개의 실행 파일과 DLL로 연결된 클래스를 설계하고 팩터링했습니다.</span><span class="sxs-lookup"><span data-stu-id="efbc1-133">Developers designed and factored classes that were compiled into libraries and linked together into a few executables and DLLs.</span></span> 

<span data-ttu-id="efbc1-134">이러한 모놀리식 설계 방법에는 몇 가지 장점이 있습니다.</span><span class="sxs-lookup"><span data-stu-id="efbc1-134">There are benefits to such a monolithic design approach.</span></span> <span data-ttu-id="efbc1-135">이러한 호출은 프로세스 간 통신(IPC)을 통해 자주 이루어지기 때문에 더 간단하게 설계할 수 있고 구성 요소 간의 호출이 더 빠릅니다.</span><span class="sxs-lookup"><span data-stu-id="efbc1-135">It's often simpler to design, and it has faster calls between components, because these calls are often over interprocess communication (IPC).</span></span> <span data-ttu-id="efbc1-136">또한 모두가 단일 제품을 테스트하며 인적 리소스의 효율성이 더 높습니다.</span><span class="sxs-lookup"><span data-stu-id="efbc1-136">Also, everyone tests a single product, which tends to be more people-resource efficient.</span></span> <span data-ttu-id="efbc1-137">단점은 계층화된 레이어 사이가 단단히 결합되어 있기 때문에 개별 구성 요소를 확장할 수 없다는 점입니다.</span><span class="sxs-lookup"><span data-stu-id="efbc1-137">The downside is that there's a tight coupling between tiered layers, and you cannot scale individual components.</span></span> <span data-ttu-id="efbc1-138">즉 수정이나 업그레이드가 필요할 때 다른 개발자가 테스트를 마칠 때까지 기다려야 합니다.</span><span class="sxs-lookup"><span data-stu-id="efbc1-138">If you need to perform fixes or upgrades, you have to wait for others to finish their testing.</span></span> <span data-ttu-id="efbc1-139">민첩한 개발이 어렵습니다.</span><span class="sxs-lookup"><span data-stu-id="efbc1-139">It is more difficult to be agile.</span></span>

<span data-ttu-id="efbc1-140">마이크로 서비스는 이러한 단점을 해결할 수 있으며 앞의 비즈니스 요구 사항과 더 밀접하게 연결되어 있지만 여기에도 장단점이 있습니다.</span><span class="sxs-lookup"><span data-stu-id="efbc1-140">Microservices address these downsides and more closely align with the preceding business requirements, but they also have both benefits and liabilities.</span></span> <span data-ttu-id="efbc1-141">마이크로 서비스의 장점은 일반적으로 각각이 더 간단한 비즈니스 기능을 캡슐화하며 독립적으로 확장/축소, 테스트, 배포 및 관리한다는 점입니다.</span><span class="sxs-lookup"><span data-stu-id="efbc1-141">The benefits of microservices are that each one typically encapsulates simpler business functionality, which you scale up or down, test, deploy, and manage independently.</span></span> <span data-ttu-id="efbc1-142">마이크로 서비스 접근 방식의 한 가지 중요한 장점은 팀이 기술 주도 방식이 되기 쉬운 계층식 접근 방식보다는 비즈니스 시나리오에 더 초점을 맞추게 된다는 것입니다.</span><span class="sxs-lookup"><span data-stu-id="efbc1-142">One important benefit of a microservice approach is that teams are driven more by business scenarios than by technology, which the tiered approach encourages.</span></span> <span data-ttu-id="efbc1-143">실제 상황에서 더 적은 규모의 팀이 고객 시나리오를 기반으로 마이크로 서비스를 개발하고 원하는 기술을 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="efbc1-143">In practice, smaller teams develop a microservice based on a customer scenario and use any technologies they choose.</span></span> 

<span data-ttu-id="efbc1-144">다시 말해 조직에서는 마이크로 서비스 응용 프로그램을 유지하기 위해 기술을 표준화할 필요가 없습니다.</span><span class="sxs-lookup"><span data-stu-id="efbc1-144">In other words, the organization doesn’t need to standardize tech to maintain microservice applications.</span></span> <span data-ttu-id="efbc1-145">자체 서비스를 보유한 개별 팀은 팀의 전문 지식을 바탕으로 합리적이거나 문제 해결에 가장 적합한 것을 수행할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="efbc1-145">Individual teams that own services can do what makes sense for them based on team expertise or what’s most appropriate to solve the problem.</span></span> <span data-ttu-id="efbc1-146">실제로 특정 NoSQL 스토어나 웹 응용 프로그램 프레임워크 등 일련의 권장 기술이 선호됩니다.</span><span class="sxs-lookup"><span data-stu-id="efbc1-146">In practice, a set of recommended technologies, such as a particular NoSQL store or web application framework, is preferable.</span></span>

<span data-ttu-id="efbc1-147">마이크로 서비스의 단점에는 증가하는 개별 개체 수의 관리, 더 복잡한 배포 처리 및 버전 작업이 있습니다.</span><span class="sxs-lookup"><span data-stu-id="efbc1-147">The downside of microservices comes in managing the increased number of separate entities and dealing with more complex deployments and versioning.</span></span> <span data-ttu-id="efbc1-148">마이크로 서비스 간의 트래픽 및 해당 네트워크 대기 시간 증가도 있습니다.</span><span class="sxs-lookup"><span data-stu-id="efbc1-148">Network traffic between the microservices increases as well as the corresponding network latencies.</span></span> <span data-ttu-id="efbc1-149">필요 이상으로 세밀한 서비스는 성능 문제를 야기합니다.</span><span class="sxs-lookup"><span data-stu-id="efbc1-149">Lots of chatty, granular services are a recipe for a performance nightmare.</span></span> <span data-ttu-id="efbc1-150">이러한 종속성을 확인하는 도구 없이는 전체 시스템을 "파악하기" 어렵습니다.</span><span class="sxs-lookup"><span data-stu-id="efbc1-150">Without tools to help view these dependencies, it is hard to “see” the whole system.</span></span> 

<span data-ttu-id="efbc1-151">표준은 통신 방법에 대해 동의하고 엄격한 계약보다는 서비스에서 필요한 것에 대해서만 용인하여 마이크로 서비스 접근 방식을 작동하게 합니다.</span><span class="sxs-lookup"><span data-stu-id="efbc1-151">Standards make the microservice approach work by agreeing on how to communicate and being tolerant of only the things you need from a service, rather than rigid contracts.</span></span> <span data-ttu-id="efbc1-152">서비스는 서로 독립적으로 업데이트되므로 설계 과정의 처음부터 이러한 계약을 정의하는 것이 중요합니다.</span><span class="sxs-lookup"><span data-stu-id="efbc1-152">It is important to define these contracts up front in the design, because services update independently of each other.</span></span> <span data-ttu-id="efbc1-153">마이크로 서비스 접근 방식을 통한 설계와 연결된 또 다른 설명은 "세분화된 서비스 지향 아키텍처(SOA)"입니다.</span><span class="sxs-lookup"><span data-stu-id="efbc1-153">Another description coined for designing with a microservices approach is “fine-grained service-oriented architecture (SOA).”</span></span>

<span data-ttu-id="efbc1-154">***마이크로 서비스 설계 접근 방식을 가장 간단하게 말하자면 각각 및 협의된 통신 표준에 대한 독립적인 변경을 통해 서비스의 페더레이션을 분리하는 것입니다.***</span><span class="sxs-lookup"><span data-stu-id="efbc1-154">***At its simplest, the microservices design approach is about a decoupled federation of services, with independent changes to each, and agreed-upon standards for communication.***</span></span>

<span data-ttu-id="efbc1-155">점점 더 많은 클라우드 앱이 제작되면서 전체 앱을 이렇게 독립적인 시나리오 중심적 서비스로 해체하는 것이 더 장기적인 접근 방식이라는 점을 사람들이 알게 되고 있습니다.</span><span class="sxs-lookup"><span data-stu-id="efbc1-155">As more cloud apps are produced, people discover that this decomposition of the overall app into independent, scenario-focused services is a better long-term approach.</span></span>

## <a name="comparison-between-application-development-approaches"></a><span data-ttu-id="efbc1-156">응용 프로그램 개발 접근 방식 비교</span><span class="sxs-lookup"><span data-stu-id="efbc1-156">Comparison between application development approaches</span></span>
![서비스 패브릭 플랫폼 응용 프로그램 개발][Image1]

1) <span data-ttu-id="efbc1-158">모놀리식 앱은 도메인 특정 기능을 포함하며 일반적으로 웹, 비즈니스, 데이터 등의 기능 계층으로 구분됩니다.</span><span class="sxs-lookup"><span data-stu-id="efbc1-158">A monolithic app contains domain-specific functionality and is normally divided by functional layers, such as web, business, and data.</span></span>

2) <span data-ttu-id="efbc1-159">모놀리식 앱은 여러 서버/가상 컴퓨터/컨테이너에 복제하여 확장합니다.</span><span class="sxs-lookup"><span data-stu-id="efbc1-159">You scale a monolithic app by cloning it on multiple servers/virtual machines/containers.</span></span>

3) <span data-ttu-id="efbc1-160">마이크로 서비스 응용 프로그램은 기능을 더 작은 개별 서비스로 구분합니다.</span><span class="sxs-lookup"><span data-stu-id="efbc1-160">A microservice application separates functionality into separate smaller services.</span></span>

4) <span data-ttu-id="efbc1-161">마이크로 서비스 접근 방식에서는 각 서비스를 독립적으로 배포하여 확장하며 서버/가상 컴퓨터/컨테이너 간에 이러한 서비스의 인스턴스를 만듭니다.</span><span class="sxs-lookup"><span data-stu-id="efbc1-161">The microservices approach scales out by deploying each service independently, creating instances of these services across servers/virtual machines/containers.</span></span>

<span data-ttu-id="efbc1-162">마이크로 서비스 접근 방식을 통한 설계는 모든 프로젝트에서 적용되는 만능 해결책은 아니지만 앞서 설명한 비즈니스 목표와 더 긴밀하게 연결됩니다.</span><span class="sxs-lookup"><span data-stu-id="efbc1-162">Designing with a microservice approach is not a panacea for all projects, but it does align more closely with the business objectives described earlier.</span></span> <span data-ttu-id="efbc1-163">나중에 코드를 마이크로 서비스 설계에 포함시키기 위해 재작업할 기회가 있다는 점을 알고 있다면 모놀리식 접근 방식으로 시작하는 것도 좋습니다.</span><span class="sxs-lookup"><span data-stu-id="efbc1-163">Starting with a monolithic approach might be acceptable if you know that you will have the opportunity to rework the code later into a microservices design.</span></span> <span data-ttu-id="efbc1-164">모놀리식 응용 프로그램을 시작하고, 확장성 또는 민첩성이 더 필요한 기능 영역부터 천천히 단계별로 분할하는 것이 더 일반적입니다.</span><span class="sxs-lookup"><span data-stu-id="efbc1-164">More commonly, you begin with a monolithic application and slowly break it up in stages, starting with the functional areas that need to be more scalable or agile.</span></span>

<span data-ttu-id="efbc1-165">요약하면 마이크로 서비스 접근 방식은 많은 소규모 서비스의 응용 프로그램을 작성하는 것입니다.</span><span class="sxs-lookup"><span data-stu-id="efbc1-165">To summarize, the microservice approach is to compose your application of many small services.</span></span> <span data-ttu-id="efbc1-166">이러한 서비스는 컴퓨터의 클러스터에 걸쳐 배포된 컨테이너에서 실행됩니다.</span><span class="sxs-lookup"><span data-stu-id="efbc1-166">The services run in containers that are deployed across a cluster of machines.</span></span> <span data-ttu-id="efbc1-167">더 적은 규모의 팀은 시나리오에 초점을 맞추는 서비스를 개발하고 전체 응용 프로그램이 진화하도록 각 서비스를 독립적으로 테스트, 버전 관리, 배포 및 확장합니다.</span><span class="sxs-lookup"><span data-stu-id="efbc1-167">Smaller teams develop a service that focuses on a scenario and independently test, version, deploy, and scale each service so that the entire application can evolve.</span></span>

## <a name="what-is-a-microservice"></a><span data-ttu-id="efbc1-168">마이크로 서비스란?</span><span class="sxs-lookup"><span data-stu-id="efbc1-168">What is a microservice?</span></span>
<span data-ttu-id="efbc1-169">마이크로 서비스에 대한 정의는 여러 가지가 있습니다.</span><span class="sxs-lookup"><span data-stu-id="efbc1-169">There are different definitions of microservices.</span></span> <span data-ttu-id="efbc1-170">인터넷을 검색하면 자신의 관점 및 정의를 제공하는 많은 유용한 리소스를 찾을 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="efbc1-170">If you search the Internet, you'll find many useful resources that provide their own viewpoints and definitions.</span></span> <span data-ttu-id="efbc1-171">그러나 통용되는 마이크로 서비스의 일반적인 특징은 다음과 같습니다.</span><span class="sxs-lookup"><span data-stu-id="efbc1-171">However, most of the following characteristics of microservices are widely agreed upon:</span></span>

* <span data-ttu-id="efbc1-172">고객 또는 비즈니스 시나리오를 캡슐화합니다.</span><span class="sxs-lookup"><span data-stu-id="efbc1-172">Encapsulate a customer or business scenario.</span></span> <span data-ttu-id="efbc1-173">해결하려는 문제가 무엇입니까?</span><span class="sxs-lookup"><span data-stu-id="efbc1-173">What is the problem you are solving?</span></span>
* <span data-ttu-id="efbc1-174">소규모 엔지니어링 팀에서 개발합니다.</span><span class="sxs-lookup"><span data-stu-id="efbc1-174">Developed by a small engineering team.</span></span>
* <span data-ttu-id="efbc1-175">어느 프로그래밍 언어로나 작성되고 모든 프레임워크에 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="efbc1-175">Written in any programming language and use any framework.</span></span>
* <span data-ttu-id="efbc1-176">개별적으로 버전 관리, 배포 및 확장되는 코드 및 상태(필요한 경우)로 구성됩니다.</span><span class="sxs-lookup"><span data-stu-id="efbc1-176">Consist of code and (optionally) state, both of which are independently versioned, deployed, and scaled.</span></span>
* <span data-ttu-id="efbc1-177">잘 정의된 인터페이스와 프로토콜을 통해 타 마이크로 서비스와 상호 작용합니다.</span><span class="sxs-lookup"><span data-stu-id="efbc1-177">Interact with other microservices over well-defined interfaces and protocols.</span></span>
* <span data-ttu-id="efbc1-178">자신의 위치를 확인하기 위해 사용하는 고유 이름(URL)이 있습니다.</span><span class="sxs-lookup"><span data-stu-id="efbc1-178">Have unique names (URLs) used to resolve their location.</span></span>
* <span data-ttu-id="efbc1-179">일관되며 오류 시 사용 가능한 상태를 유지합니다.</span><span class="sxs-lookup"><span data-stu-id="efbc1-179">Remain consistent and available in the presence of failures.</span></span>

<span data-ttu-id="efbc1-180">이러한 특징을 다음으로 요약할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="efbc1-180">You can summarize these characteristics into:</span></span>

<span data-ttu-id="efbc1-181">***마이크로 서비스 응용 프로그램은 독립적으로 버전 관리되며 확장성 있는 소규모 고객 중심 서비스로 구성됩니다. 이 서비스들은 잘 정의된 인터페이스가 있는 표준 프로토콜을 통해 서로 통신합니다.***</span><span class="sxs-lookup"><span data-stu-id="efbc1-181">***Microservice applications are composed of small, independently versioned, and scalable customer-focused services that communicate with each other over standard protocols with well-defined interfaces.***</span></span>

<span data-ttu-id="efbc1-182">앞 섹션에서는 처음 두 가지 내용만 다루었으며 나머지는 앞으로 확대하여 상세히 설명할 것입니다.</span><span class="sxs-lookup"><span data-stu-id="efbc1-182">We covered the first two points in the preceding section, and now we expand on and clarify the others.</span></span>

### <a name="written-in-any-programming-language-and-use-any-framework"></a><span data-ttu-id="efbc1-183">어느 프로그래밍 언어로나 작성되고 모든 프레임워크에 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="efbc1-183">Written in any programming language and use any framework</span></span>
<span data-ttu-id="efbc1-184">개발자인 우리는 자신의 기술이나 서비스 요구에 따라 원하는 프레임워크나 언어를 자유롭게 선택할 수 있어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="efbc1-184">As developers, we should be free to choose a language or framework that we want, depending on our skills or the needs of the service.</span></span> <span data-ttu-id="efbc1-185">어떤 서비스에서는 무엇보다도 C++의 성능 장점을 중시할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="efbc1-185">In some services, you might value the performance benefits of C++ above all else.</span></span> <span data-ttu-id="efbc1-186">한편 다른 서비스에서는 C# 또는 Java의 관리 개발 편의를 가장 중요하게 여길 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="efbc1-186">In other services, the ease of managed development in C# or Java might be most important.</span></span> <span data-ttu-id="efbc1-187">일부 경우 특정 파트너 라이브러리, 데이터 저장소 기술 또는 서비스를 클라이언트에 노출하는 방법을 사용해야 할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="efbc1-187">In some cases, you may need to use a specific partner library, data storage technology, or means of exposing the service to clients.</span></span>

<span data-ttu-id="efbc1-188">기술을 선택한 후에는 운영 또는 수명 주기 관리와 서비스 확장 문제가 뒤따릅니다.</span><span class="sxs-lookup"><span data-stu-id="efbc1-188">After you have chosen a technology, you come to the operational or lifecycle management and scaling of the service.</span></span>

### <a name="allows-code-and-state-to-be-independently-versioned-deployed-and-scaled"></a><span data-ttu-id="efbc1-189">개별적으로 버전 관리, 배포 및 확장되는 코드와 상태 허용</span><span class="sxs-lookup"><span data-stu-id="efbc1-189">Allows code and state to be independently versioned, deployed, and scaled</span></span>
<span data-ttu-id="efbc1-190">그러나 코드 및 경우에 따라 상태에서 개별적으로 배포, 업그레이드 및 확장되는 마이크로 서비스를 작성하도록 선택합니다.</span><span class="sxs-lookup"><span data-stu-id="efbc1-190">However you choose to write your microservices, the code and optionally the state should independently deploy, upgrade, and scale.</span></span> <span data-ttu-id="efbc1-191">이는 결국 기술의 선택에 달려 있으므로 실제로 더 해결하기 어려운 문제 중 하나입니다.</span><span class="sxs-lookup"><span data-stu-id="efbc1-191">This is actually one of the harder problems to solve, because it comes down to your choice of technologies.</span></span> <span data-ttu-id="efbc1-192">확장을 위해 코드와 상태를 파티션(또는 분할) 방법을 이해하는 것은 어렵습니다.</span><span class="sxs-lookup"><span data-stu-id="efbc1-192">For scaling, understanding how to partition (or shard) both the code and state is challenging.</span></span> <span data-ttu-id="efbc1-193">현재 일반화된 코드 및 상태가 별도의 기술을 사용할 경우 마이크로 서비스의 배포 스크립트가 둘 다의 확장을 처리할 수 있어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="efbc1-193">When the code and state use separate technologies, which is common today, the deployment scripts for your microservice need to be able to cope with scaling them both.</span></span> <span data-ttu-id="efbc1-194">모든 서비스를 한꺼번에 업그레이드하지 않고도 일부 마이크로 서비스를 업그레이드할 수 있을 때의 민첩성 및 유연성과도 관련이 있습니다.</span><span class="sxs-lookup"><span data-stu-id="efbc1-194">This is also about agility and flexibility, so you can upgrade some of the microservices without having to upgrade all of them at once.</span></span>

<span data-ttu-id="efbc1-195">잠시 다음의 다이어그램을 통해 모놀리식과 마이크로 서비스 접근 방식의 비교로 돌아가보면 상태를 저장하는 접근 방식에서의 차이를 알 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="efbc1-195">Returning to the monolithic versus microservice approach for a moment, the following diagram shows the differences in the approach to storing state.</span></span>

#### <a name="state-storage-between-application-styles"></a><span data-ttu-id="efbc1-196">응용 프로그램 스타일 간의 상태 저장</span><span class="sxs-lookup"><span data-stu-id="efbc1-196">State storage between application styles</span></span>
![서비스 패브릭 플랫폼 상태 저장][Image2]

<span data-ttu-id="efbc1-198">***왼쪽의 모놀리식 접근 방식에는 단일 데이터베이스와 특정 기술의 계층이 있습니다.***</span><span class="sxs-lookup"><span data-stu-id="efbc1-198">***The monolithic approach on the left has a single database and tiers of specific technologies.***</span></span>

<span data-ttu-id="efbc1-199">***오른쪽의 마이크로 서비스 접근 방식은 상호 연결된 마이크로 서비스의 그래프로, 일반적으로 상태가 마이크로 서비스로 보여지며 다양한 기술이 사용됩니다.***</span><span class="sxs-lookup"><span data-stu-id="efbc1-199">***The microservices approach on the right has a graph of interconnected microservices where state is typically scoped to the microservice and various technologies are used.***</span></span>

<span data-ttu-id="efbc1-200">모놀리식 접근 방식에서 응용 프로그램은 일반적으로 단일 데이터베이스를 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="efbc1-200">In a monolithic approach, typically the application uses a single database.</span></span> <span data-ttu-id="efbc1-201">장점은 단일 위치라 배포가 용이하다는 점입니다.</span><span class="sxs-lookup"><span data-stu-id="efbc1-201">The advantage is that it is a single location, which makes it easy to deploy.</span></span> <span data-ttu-id="efbc1-202">각 구성 요소에는 상태 저장을 위한 단일 테이블이 있습니다.</span><span class="sxs-lookup"><span data-stu-id="efbc1-202">Each component can have a single table to store its state.</span></span> <span data-ttu-id="efbc1-203">팀은 상태를 엄격히 구분해야 하지만, 이는 어려운 일입니다.</span><span class="sxs-lookup"><span data-stu-id="efbc1-203">Teams need to strictly separate state, which is a challenge.</span></span> <span data-ttu-id="efbc1-204">기존 고객 테이블에 새 열을 추가하고 테이블 간을 조인하며 저장소 계층에서 종속성을 만들고자 하는 충동이 필연적으로 있게 됩니다.</span><span class="sxs-lookup"><span data-stu-id="efbc1-204">Inevitably there are temptations to add a new column to an existing customer table, do a join between tables, and create dependencies at the storage layer.</span></span> <span data-ttu-id="efbc1-205">이러한 경우가 발생하면, 개별 구성 요소를 확장할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="efbc1-205">After this happens, you can't scale individual components.</span></span> 

<span data-ttu-id="efbc1-206">마이크로 서비스 접근 방식에서는 각 서비스가 자체 상태를 관리 및 저장합니다.</span><span class="sxs-lookup"><span data-stu-id="efbc1-206">In the microservices approach, each service manages and stores its own state.</span></span> <span data-ttu-id="efbc1-207">각 서비스는 서비스의 수요에 맞게 코드와 상태를 함께 확장해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="efbc1-207">Each service is responsible for scaling both code and state together to meet the demands of the service.</span></span> <span data-ttu-id="efbc1-208">이 경우에 응용 프로그램 데이터의 뷰나 쿼리를 만들 때 분산된 상태 저장에 걸쳐 쿼리해야 한다는 단점이 있습니다.</span><span class="sxs-lookup"><span data-stu-id="efbc1-208">A downside is that when there is a need to create views, or queries, of your application’s data, you need to query across disparate state stores.</span></span> <span data-ttu-id="efbc1-209">일반적으로 이 문제는 마이크로 서비스의 컬렉션에 걸쳐 뷰를 구축하는 개별 마이크로 서비스를 갖춤으로써 해결할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="efbc1-209">Typically, this is solved by having a separate microservice that builds a view across a collection of microservices.</span></span> <span data-ttu-id="efbc1-210">데이터에 대해 여러 임시 쿼리를 수행해야 한다면 오프라인 분석을 위해 각 마이크로 서비스가 자신의 데이터를 데이터 웨어하우징 서비스에 기록해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="efbc1-210">If you need to perform multiple impromptu queries on the data, each microservice should consider writing its data to a data warehousing service for offline analytics.</span></span>

<span data-ttu-id="efbc1-211">버전 관리는 마이크로 서비스의 배포된 버전에 특정하므로 여러 다른 버전을 배포하고 나란히 실행합니다.</span><span class="sxs-lookup"><span data-stu-id="efbc1-211">Versioning is specific to the deployed version of a microservice so that multiple, different versions deploy and run side by side.</span></span> <span data-ttu-id="efbc1-212">버전 관리는 업그레이드 중에 최신인 마이크로 서비스 버전이 실패하여 이전 버전으로 롤백해야 하는 시나리오를 해결할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="efbc1-212">Versioning addresses the scenarios where a newer version of a microservice fails during upgrade and needs to roll back to an earlier version.</span></span> <span data-ttu-id="efbc1-213">버전 관리의 다른 시나리오는 서로 다른 사용자가 서로 다른 서비스 버전을 경험하는 A/B 스타일 테스트를 수행하는 경우입니다.</span><span class="sxs-lookup"><span data-stu-id="efbc1-213">The other scenario for versioning is performing A/B-style testing, where different users experience different versions of the service.</span></span> <span data-ttu-id="efbc1-214">예를 들어, 새 기능을 더 널리 배포하기 전에 테스트를 위해 특정 고객 집단에서만 마이크로 서비스를 업그레이드하는 것이 일반적입니다.</span><span class="sxs-lookup"><span data-stu-id="efbc1-214">For example, it is common to upgrade a microservice for a specific set of customers to test new functionality before rolling it out more widely.</span></span> <span data-ttu-id="efbc1-215">마이크로 서비스의 수명 주기 관리 후에는 서로 간의 통신에 대해 이야기할 차례입니다.</span><span class="sxs-lookup"><span data-stu-id="efbc1-215">After lifecycle management of microservices, this now brings us to communication between them.</span></span>

### <a name="interacts-with-other-microservices-over-well-defined-interfaces-and-protocols"></a><span data-ttu-id="efbc1-216">잘 정의된 인터페이스와 프로토콜을 통해 타 마이크로 서비스와 상호 작용</span><span class="sxs-lookup"><span data-stu-id="efbc1-216">Interacts with other microservices over well-defined interfaces and protocols</span></span>
<span data-ttu-id="efbc1-217">지난 10년 동안 게시된 서비스 지향 아키텍처에 관한 광범위한 문서에는 통신 패턴에 대해 설명되어 있기 때문에 이 항목에 주의를 기울여야 합니다.</span><span class="sxs-lookup"><span data-stu-id="efbc1-217">This topic needs little attention here, because extensive literature about service-oriented architecture that has been published over the past 10 years describes communication patterns.</span></span> <span data-ttu-id="efbc1-218">일반적으로 서비스 통신은 직렬화 형식으로 HTTP 및 TCP 프로토콜과 XML 또는 JSON이 있는 REST 접근 방식을 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="efbc1-218">Generally, service communication uses a REST approach with HTTP and TCP protocols and XML or JSON as the serialization format.</span></span> <span data-ttu-id="efbc1-219">인터페이스 관점에서 보면 웹 설계 접근 방식을 포괄하는 것입니다.</span><span class="sxs-lookup"><span data-stu-id="efbc1-219">From an interface perspective, it is about embracing the web design approach.</span></span> <span data-ttu-id="efbc1-220">그러나 바이너리 프로토콜이나 자체 데이터 형식을 사용하지 않을 이유는 없습니다.</span><span class="sxs-lookup"><span data-stu-id="efbc1-220">But nothing stops you from using binary protocols or your own data formats.</span></span> <span data-ttu-id="efbc1-221">공개적으로 사용 가능한 경우 마이크로 서비스를 사용하는 것이 다소 어렵다는 점에 미리 대비해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="efbc1-221">Be prepared for people to have a harder time using your microservices if these are openly available.</span></span>

### <a name="has-a-unique-name-url-used-to-resolve-its-location"></a><span data-ttu-id="efbc1-222">자신의 위치를 확인하기 위해 사용하는 고유 이름(URL)이 있음</span><span class="sxs-lookup"><span data-stu-id="efbc1-222">Has a unique name (URL) used to resolve its location</span></span>
<span data-ttu-id="efbc1-223">마이크로 서비스 접근 방식이 웹과 같다고 이야기해온 사실을 기억하시나요?</span><span class="sxs-lookup"><span data-stu-id="efbc1-223">Remember how we keep saying that the microservice approach is like the web?</span></span> <span data-ttu-id="efbc1-224">웹처럼 마이크로 서비스는 실행하는 모든 곳에서 주소 지정이 가능해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="efbc1-224">Like the web, your microservice needs to be addressable wherever it is running.</span></span> <span data-ttu-id="efbc1-225">컴퓨터 및 특정 마이크로 서비스를 실행할 컴퓨터에 대해 고려하면 급격한 문제가 발생합니다.</span><span class="sxs-lookup"><span data-stu-id="efbc1-225">If you are thinking about machines and which one is running a particular microservice, things go bad quickly.</span></span> 

<span data-ttu-id="efbc1-226">DNS가 특정 URL을 특정 컴퓨터에 확인하는 것과 동일한 방법으로 마이크로 서비스는 현재 위치를 검색할 수 있는 고유의 이름이 필요합니다.</span><span class="sxs-lookup"><span data-stu-id="efbc1-226">In the same way that DNS resolves a particular URL to a particular machine, your microservice needs to have a unique name so that its current location is discoverable.</span></span> <span data-ttu-id="efbc1-227">마이크로 서비스는 자신이 실행 중인 인프라에서 자신을 독립적으로 구분하는 주소 지정 가능한 이름이 필요합니다.</span><span class="sxs-lookup"><span data-stu-id="efbc1-227">Microservices need addressable names that make them independent from the infrastructure that they are running on.</span></span> <span data-ttu-id="efbc1-228">서비스 레지스트리가 있어야 하므로 이는 서비스가 배포된 방식과 확인되는 방식 간의 상호 작용이 있다는 것을 의미합니다.</span><span class="sxs-lookup"><span data-stu-id="efbc1-228">This implies that there is an interaction between how your service is deployed and how it is discovered, because there needs to be a service registry.</span></span> <span data-ttu-id="efbc1-229">마찬가지로 컴퓨터가 실패하는 경우 레지스트리 서비스는 현재 서비스를 실행 중인 위치를 알려 주어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="efbc1-229">Equally, when a machine fails, the registry service must tell you where the service is now running.</span></span> 

<span data-ttu-id="efbc1-230">그래서 다음 토픽은 복원력과 일관성에 대한 것입니다.</span><span class="sxs-lookup"><span data-stu-id="efbc1-230">This brings us to the next topic: resilience and consistency.</span></span>

### <a name="remains-consistent-and-available-in-the-presence-of-failures"></a><span data-ttu-id="efbc1-231">일관되며 오류 시 사용 가능한 상태 유지</span><span class="sxs-lookup"><span data-stu-id="efbc1-231">Remains consistent and available in the presence of failures</span></span>
<span data-ttu-id="efbc1-232">예기치 않은 오류를 처리하는 것은 특히 분산된 시스템에서는 가장 까다로운 문제 중 하나입니다.</span><span class="sxs-lookup"><span data-stu-id="efbc1-232">Dealing with unexpected failures is one of the hardest problems to solve, especially in a distributed system.</span></span> <span data-ttu-id="efbc1-233">개발자들이 작성하는 코드의 대부분이 예외 처리에 관한 것이고 테스트 중에 가장 많은 시간을 소요하는 부분이기도 합니다.</span><span class="sxs-lookup"><span data-stu-id="efbc1-233">Much of the code that we write as developers is handling exceptions, and this is also where the most time is spent in testing.</span></span> <span data-ttu-id="efbc1-234">문제는 오류를 처리하는 코드를 작성하는 것보다 조금 더 복잡합니다.</span><span class="sxs-lookup"><span data-stu-id="efbc1-234">The problem is more involved than writing code to handle failures.</span></span> <span data-ttu-id="efbc1-235">마이크로 서비스가 실행되고 있는 컴퓨터가 실패하면 어떻게 될까요?</span><span class="sxs-lookup"><span data-stu-id="efbc1-235">What happens when the machine where the microservice is running fails?</span></span> <span data-ttu-id="efbc1-236">이 마이크로 서비스 오류를 탐지해야 할 뿐 아니라(그 자체만으로 까다로운 문제) 마이크로 서비스를 다시 시작하기 위한 무언가가 필요합니다.</span><span class="sxs-lookup"><span data-stu-id="efbc1-236">Not only do you need to detect this microservice failure (a hard problem on its own), but you also need something to restart your microservice.</span></span> 

<span data-ttu-id="efbc1-237">마이크로 서비스는 오류에 유연해야 하며 종종 가용성을 위해 다른 컴퓨터에서 다시 시작해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="efbc1-237">A microservice needs to be resilient to failures and restart often on another machine for availability reasons.</span></span> <span data-ttu-id="efbc1-238">또한 마이크로 서비스를 대신하여 저장되는 상태, 마이크로 서비스가 이 상태를 복구할 수 있는 위치, 마이크로 서비스가 성공적으로 다시 시작할 수 있는지 여부에 대해 생각해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="efbc1-238">This also comes down to the state that was saved on behalf of the microservice, where the microservice can recover this state from, and whether the microservice is able to restart successfully.</span></span> <span data-ttu-id="efbc1-239">다시 말해 계산에서의 복원력(프로세스 다시 시작)뿐 아니라 상태 또는 데이터에서의 복원력(데이터 손실 없음, 데이터 일관성 유지)도 필요합니다.</span><span class="sxs-lookup"><span data-stu-id="efbc1-239">In other words, there needs to be resilience in the compute (the process restarts) as well as resilience in the state or data (no data loss and the data remains consistent).</span></span>

<span data-ttu-id="efbc1-240">복원력의 문제는 응용 프로그램 업그레이드 중 오류가 발생하는 경우와 같은 다른 시나리오 상황에서 복잡해집니다.</span><span class="sxs-lookup"><span data-stu-id="efbc1-240">The problems of resiliency are compounded during other scenarios, such as when failures happen during an application upgrade.</span></span> <span data-ttu-id="efbc1-241">배포 시스템과 작업하는 마이크로 서비스는 복구할 필요가 없습니다.</span><span class="sxs-lookup"><span data-stu-id="efbc1-241">The microservice, working with the deployment system, doesn't need to recover.</span></span> <span data-ttu-id="efbc1-242">이후 최신 버전으로의 이전을 계속할지 또는 일관된 상태를 유지하기 위해 이전 버전으로 롤백할지 결정하는 것도 필요합니다.</span><span class="sxs-lookup"><span data-stu-id="efbc1-242">It also needs to then decide whether it can continue to move forward to the newer version or instead roll back to a previous version to maintain a consistent state.</span></span> <span data-ttu-id="efbc1-243">계속 진행하기 위해 컴퓨터 대수가 충분한지, 마이크로 서비스의 이전 버전 복구를 어떻게 복구할지 등의 질문을 고려해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="efbc1-243">Questions such as whether enough machines are available to keep moving forward and how to recover previous versions of the microservice need to be considered.</span></span> <span data-ttu-id="efbc1-244">이를 위해서는 판단이 가능하도록 마이크로 서비스가 상태 정보를 내보내야 합니다.</span><span class="sxs-lookup"><span data-stu-id="efbc1-244">This requires the microservice to emit health information to be able to make these decisions.</span></span>

### <a name="reports-health-and-diagnostics"></a><span data-ttu-id="efbc1-245">보고서 상태 및 진단</span><span class="sxs-lookup"><span data-stu-id="efbc1-245">Reports health and diagnostics</span></span>
<span data-ttu-id="efbc1-246">당연하지만 자주 간과되는 것으로, 마이크로 서비스는 자신의 상태와 진단을 보고하는 것이 필수적입니다.</span><span class="sxs-lookup"><span data-stu-id="efbc1-246">It may seem obvious, and it is often overlooked, but a microservice must report its health and diagnostics.</span></span> <span data-ttu-id="efbc1-247">보고가 없으면 운영의 견지에서는 정보가 거의 없습니다.</span><span class="sxs-lookup"><span data-stu-id="efbc1-247">Otherwise, there is little insight from an operations perspective.</span></span> <span data-ttu-id="efbc1-248">일련의 독립적인 서비스를 통틀어 진단 이벤트 간의 상관 관계를 파악하고 이벤트 순서를 알기 위해 컴퓨터의 시간 차이를 이해하는 것은 어려운 작업입니다.</span><span class="sxs-lookup"><span data-stu-id="efbc1-248">Correlating diagnostic events across a set of independent services and dealing with machine clock skews to make sense of the event order is challenging.</span></span> <span data-ttu-id="efbc1-249">협의된 프로토콜과 데이터 형식을 통해 마이크로 서비스와 상호 작용하는 것과 같은 방식으로, 로그 상태와 진단 이벤트를 로깅하는 방법의 표준화에 대한 협의가 필요하게 됩니다. 이는 궁극적으로 쿼리 및 보기를 위한 이벤트 저장소로 귀결됩니다.</span><span class="sxs-lookup"><span data-stu-id="efbc1-249">In the same way that you interact with a microservice over agreed-upon protocols and data formats, there emerges a need for standardization in how to log health and diagnostic events that ultimately end up in an event store for querying and viewing.</span></span> <span data-ttu-id="efbc1-250">마이크로 서비스 접근 방식에서는 여러 팀이 단일 로깅 형식에 동의하는 것이 중요합니다.</span><span class="sxs-lookup"><span data-stu-id="efbc1-250">In a microservices approach, it is key that different teams agree on a single logging format.</span></span> <span data-ttu-id="efbc1-251">응용 프로그램에서 진단 이벤트를 전체적으로 보는 데 일관된 접근 방식이 필요합니다.</span><span class="sxs-lookup"><span data-stu-id="efbc1-251">There needs to be a consistent approach to viewing diagnostic events in the application as a whole.</span></span>

<span data-ttu-id="efbc1-252">상태는 진단과 다릅니다.</span><span class="sxs-lookup"><span data-stu-id="efbc1-252">Health is different from diagnostics.</span></span> <span data-ttu-id="efbc1-253">상태는 적절한 조치를 취하도록 마이크로 서비스가 현재 상태를 보고하는 것입니다.</span><span class="sxs-lookup"><span data-stu-id="efbc1-253">Health is about the microservice reporting its current state to take appropriate actions.</span></span> <span data-ttu-id="efbc1-254">좋은 예는 가용성 유지를 위한 업그레이드 및 배포 메커니즘과의 상호 작용입니다.</span><span class="sxs-lookup"><span data-stu-id="efbc1-254">A good example is working with upgrade and deployment mechanisms to maintain availability.</span></span> <span data-ttu-id="efbc1-255">프로세스 충돌이나 컴퓨터 재부팅으로 서비스가 현재 정상 상태가 아니더라도 계속 운영될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="efbc1-255">Although a service may be currently unhealthy due to a process crash or machine reboot, the service might still be operational.</span></span> <span data-ttu-id="efbc1-256">업그레이드를 수행하여 상황을 악화시키는 일은 지양해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="efbc1-256">The last thing you need is to make this worse by performing an upgrade.</span></span> <span data-ttu-id="efbc1-257">먼저 조사부터 하거나 마이크로 서비스가 복구할 시간을 주는 것이 최선입니다.</span><span class="sxs-lookup"><span data-stu-id="efbc1-257">The best approach is to do an investigation first or allow time for the microservice to recover.</span></span> <span data-ttu-id="efbc1-258">마이크로 서비스의 상태 이벤트를 통해 정보에 입각한 의사 결정을 내리고 효과적인 자체 복구 서비스를 만들 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="efbc1-258">Health events from a microservice help us make informed decisions and, in effect, help create self-healing services.</span></span>

## <a name="service-fabric-as-a-microservices-platform"></a><span data-ttu-id="efbc1-259">마이크로 서비스 플랫폼으로서의 서비스 패브릭</span><span class="sxs-lookup"><span data-stu-id="efbc1-259">Service Fabric as a microservices platform</span></span>
<span data-ttu-id="efbc1-260">Azure Service Fabric은 Microsoft가 보통 모놀리식 스타일의 박스 제품을 제공하는 것에서 서비스를 제공하는 것으로 전환해가는 과정에서 나타났습니다.</span><span class="sxs-lookup"><span data-stu-id="efbc1-260">Azure Service Fabric emerged from a transition by Microsoft from delivering box products, which were typically monolithic in style, to delivering services.</span></span> <span data-ttu-id="efbc1-261">Azure SQL Database 및 Azure Cosmos DB와 같은 대규모 서비스를 구축 및 운영한 경험을 기반으로 Service Fabric을 만들었습니다.</span><span class="sxs-lookup"><span data-stu-id="efbc1-261">The experience of building and operating large services, such as Azure SQL Database and Azure Cosmos DB, shaped Service Fabric.</span></span> <span data-ttu-id="efbc1-262">플랫폼은 시간이 지남에 따라 더 많은 서비스를 도입하는 방향으로 발전했습니다.</span><span class="sxs-lookup"><span data-stu-id="efbc1-262">The platform evolved over time as more and more services adopted it.</span></span> <span data-ttu-id="efbc1-263">중요한 점은 Service Fabric이 Azure뿐 아니라 독립 실행형 Windows Server 배포에서 실행되어야 했다는 점입니다.</span><span class="sxs-lookup"><span data-stu-id="efbc1-263">Importantly, Service Fabric had to run not only in Azure but also in standalone Windows Server deployments.</span></span>

<span data-ttu-id="efbc1-264">***Service Fabric의 목표는 인프라 리소스의 효율적 활용 등, 서비스 구축 및 실행의 난제를 해결하여 팀이 마이크로 서비스 접근 방식을 사용하여 비즈니스 문제를 해결할 수 있게 하는 것입니다.***</span><span class="sxs-lookup"><span data-stu-id="efbc1-264">***The aim of Service Fabric is to solve the hard problems of building and running a service and utilize infrastructure resources efficiently, so that teams can solve business problems using a microservices approach.***</span></span>

<span data-ttu-id="efbc1-265">Service Fabric은 마이크로 서비스 접근 방식을 사용하는 응용 프로그램을 빌드하기 위해 세 가지 광범위한 영역을 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="efbc1-265">Service Fabric provides three broad areas to help you build applications that use a microservices approach:</span></span>

* <span data-ttu-id="efbc1-266">실패한 서비스를 배포, 업그레이드, 검색 및 다시 시작하고 서비스를 검색하며 메시지를 라우팅하고 상태를 관리 및 모니터링하는 시스템 서비스를 제공하는 플랫폼입니다.</span><span class="sxs-lookup"><span data-stu-id="efbc1-266">A platform that provides system services to deploy, upgrade, detect, and restart failed services, discover services, route messages, manage state, and monitor health.</span></span> <span data-ttu-id="efbc1-267">이러한 시스템 서비스는 이전에 설명한 마이크로 서비스의 여러 특징을 구현하는 데 효과적입니다.</span><span class="sxs-lookup"><span data-stu-id="efbc1-267">These system services in effect enable many of the characteristics of microservices previously described.</span></span>
* <span data-ttu-id="efbc1-268">컨테이너에서 실행되거나 프로세스로 실행되는 응용 프로그램을 배포하는 기능입니다.</span><span class="sxs-lookup"><span data-stu-id="efbc1-268">Ability to deploy applications either running in containers or as processes.</span></span> <span data-ttu-id="efbc1-269">Service Fabric은 컨테이너 및 프로세스 조정자입니다.</span><span class="sxs-lookup"><span data-stu-id="efbc1-269">Service Fabric is a container and process orchestrator.</span></span>
* <span data-ttu-id="efbc1-270">마이크로 서비스로서 응용 프로그램을 구축하는 데 도움이 되는 생산성 있는 프로그래밍 API: [ASP.NET Core, Reliable Actors 및 Reliable Services](service-fabric-choose-framework.md).</span><span class="sxs-lookup"><span data-stu-id="efbc1-270">Productive programming APIs,  to help you build applications as microservices: [ASP.NET Core, Reliable Actors, and Reliable Services](service-fabric-choose-framework.md).</span></span> <span data-ttu-id="efbc1-271">코드를 선택하여 마이크로 서비스를 빌드할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="efbc1-271">You can choose any code to build your microservice.</span></span> <span data-ttu-id="efbc1-272">그러나 이러한 API를 사용하면 작업이 더 간단해지고 플랫폼과의 통합 수준은 더 높아집니다.</span><span class="sxs-lookup"><span data-stu-id="efbc1-272">But these APIs make the job more straightforward, and they integrate with the platform at a deeper level.</span></span> <span data-ttu-id="efbc1-273">예를 들어, 상태 및 진단 정보를 받거나 기본 제공되는 고가용성을 활용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="efbc1-273">This way, for example, you can get health and diagnostics information, or you can take advantage of built-in high availability.</span></span>

<span data-ttu-id="efbc1-274">***Service Fabric은 서비스를 구축한 방법과 무관하며 어느 기술이나 사용할 수 있습니다. 그러나 마이크로 서비스를 보다 간편하게 구축할 수 있는 기본 제공 프로그래밍 API를 제공합니다.***</span><span class="sxs-lookup"><span data-stu-id="efbc1-274">***Service Fabric is agnostic on how you build your service, and you can use any technology. However, it does provide built-in programming APIs that make it easier to build microservices.***</span></span>

### <a name="migrating-existing-applications-to-service-fabric"></a><span data-ttu-id="efbc1-275">Service Fabric으로 기존 응용 프로그램 마이그레이션</span><span class="sxs-lookup"><span data-stu-id="efbc1-275">Migrating existing applications to Service Fabric</span></span>
<span data-ttu-id="efbc1-276">Service Fabric의 주요 방법은 기존 코드를 다시 사용하는 것입니다. 그런 다음 새 마이크로 서비스를 사용하여 업그레이드할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="efbc1-276">A key approach to Service Fabric is to reuse existing code, which can then be modernized with new microservices.</span></span> <span data-ttu-id="efbc1-277">응용 프로그램을 업그레이드하는 다섯 단계가 있으며 어떤 단계에서든지 시작하고 중지할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="efbc1-277">There are five stages to application modernization, and you can start and stop at any of the stages.</span></span> <span data-ttu-id="efbc1-278">이 단계는 다음과 같습니다.</span><span class="sxs-lookup"><span data-stu-id="efbc1-278">These are;</span></span>

1) <span data-ttu-id="efbc1-279">기존의 모놀리식 응용 프로그램 선택</span><span class="sxs-lookup"><span data-stu-id="efbc1-279">Take a traditional monolithic application</span></span>
2) <span data-ttu-id="efbc1-280">전환 - 컨테이너 또는 게스트 실행 파일을 사용하여 Service Fabric에서 기존 코드를 호스트합니다.</span><span class="sxs-lookup"><span data-stu-id="efbc1-280">Lift and Shift - Use containers or guest executables to host existing code in Service Fabric.</span></span>
3) <span data-ttu-id="efbc1-281">현대화 - 컨테이너화된 기존 코드와 함께 새 마이크로 서비스가 추가되었습니다.</span><span class="sxs-lookup"><span data-stu-id="efbc1-281">Modernization - New microservices added alongside existing containerized code.</span></span> 
4) <span data-ttu-id="efbc1-282">혁신 - 요구에 따라 모놀리식 응용 프로그램을 마이크로 서비스로 나눕니다.</span><span class="sxs-lookup"><span data-stu-id="efbc1-282">Innovate - Break the monolithic into microservices purely based on need.</span></span>
5) <span data-ttu-id="efbc1-283">마이크로 서비스로 변형 - 기존 모놀리식 응용 프로그램을 변환하거나 새 최적의 응용 프로그램을 구축합니다.</span><span class="sxs-lookup"><span data-stu-id="efbc1-283">Transformed into microservices - the transformation of existing monolithic applications or building new greenfield applications.</span></span>

![마이크로 서비스로 마이그레이션][Image3]

<span data-ttu-id="efbc1-285">**어떤 단계에서든 시작하고 중지**할 수 있으며 다음 단계로 이동하지 않아도 됩니다.</span><span class="sxs-lookup"><span data-stu-id="efbc1-285">It is important to emphasis again, that you can **start and stop at any of these stages**, you are not compelled to moved to the next stage.</span></span> <span data-ttu-id="efbc1-286">이제 이러한 각 단계에 대한 예제를 살펴보겠습니다.</span><span class="sxs-lookup"><span data-stu-id="efbc1-286">Let's now look at examples for each of these stages.</span></span>

<span data-ttu-id="efbc1-287">**전환** - 다음과 같은 두 가지 이유로 많은 회사들이 모놀리식 기존 응용 프로그램을 컨테이너로 전환하고 있습니다.</span><span class="sxs-lookup"><span data-stu-id="efbc1-287">**Lift and Shift** - large numbers of companies are lifting and shifting existing monolithic applications into containers to for two reasons;</span></span>

- <span data-ttu-id="efbc1-288">기존 하드웨어 또는 실행 중인 응용 프로그램의 통합 및 제거로 인한 상당한 수준의 비용 절감</span><span class="sxs-lookup"><span data-stu-id="efbc1-288">Cost reduction either due to consolidation and removal  of existing hardware or running applications at higher density.</span></span> 
- <span data-ttu-id="efbc1-289">개발 및 운영 간의 일관된 배포 계약</span><span class="sxs-lookup"><span data-stu-id="efbc1-289">Consistent deployment contract between development and operations.</span></span>

<span data-ttu-id="efbc1-290">Microsoft 내에서 많은 기존 응용 프로그램을 단순하게 컨테이너화하여 수백만 달러의 비용을 절감할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="efbc1-290">Cost reductions are understandable and within Microsoft large numbers of existing applications are being containerized simply to millions of dollars.</span></span> <span data-ttu-id="efbc1-291">일관된 배포는 평가하기 어렵지만 동일하게 중요합니다.</span><span class="sxs-lookup"><span data-stu-id="efbc1-291">Consistent deployment is harder to evaluate, but equally as important.</span></span> <span data-ttu-id="efbc1-292">개발자가 맞는 기술을 자유롭게 선택 가능하지만 작업은 이러한 응용 프로그램을 배포하고 관리하는 한 가지 방법만을 수락합니다.</span><span class="sxs-lookup"><span data-stu-id="efbc1-292">It says that developers can still be free to choose the technology that suites them, however the operations will only accept a single way to deploy and manage these applications.</span></span> <span data-ttu-id="efbc1-293">다양한 기술의 복잡성을 처리해야 하거나 개발자가 특정 기술만을 선택하도록 강요하지 않도록 작업을 완화합니다.</span><span class="sxs-lookup"><span data-stu-id="efbc1-293">It alleviates the operations from having to deal with the complexity of many different technologies or forcing developers to only choose certain ones.</span></span> <span data-ttu-id="efbc1-294">기본적으로 모든 응용 프로그램은 자체 포함된 배포 이미지에 컨테이너화됩니다.</span><span class="sxs-lookup"><span data-stu-id="efbc1-294">Essentially every application is containerized into self-contained deployment images.</span></span>

<span data-ttu-id="efbc1-295">대부분의 조직에서는 여기까지만 수행합니다.</span><span class="sxs-lookup"><span data-stu-id="efbc1-295">Many organizations stop here.</span></span> <span data-ttu-id="efbc1-296">컨테이너의 이점을 이미 얻었기 때문입니다. Service Fabric은 배포, 업그레이드, 버전 관리, 롤백, 상태 모니터링 등의 전체 관리 환경을 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="efbc1-296">They already have the benefits of containers and Service Fabric provides the complete management experience from deployment, upgrades, versioning, rollbacks, health monitoring etc.</span></span>

<span data-ttu-id="efbc1-297">**현대화** - 컨테이너화된 기존 코드와 함께 새로운 서비스를 추가하는 것입니다.</span><span class="sxs-lookup"><span data-stu-id="efbc1-297">**Modernization** - is the addition of new services alongside existing containerized code.</span></span> <span data-ttu-id="efbc1-298">새 코드를 작성하려는 경우 마이크로 서비스 경로의 단계를 따르도록 결정하는 것이 좋습니다.</span><span class="sxs-lookup"><span data-stu-id="efbc1-298">If you are going to write new code, it is best to decide to take small steps down the microservices path.</span></span> <span data-ttu-id="efbc1-299">그러면 새 REST API 끝점 또는 새로운 비즈니스 논리를 추가할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="efbc1-299">This could be adding a new REST API endpoint, or new business logic.</span></span> <span data-ttu-id="efbc1-300">이러한 방식으로 새 마이크로 서비스를 빌드하고 개발 및 배포하는 연습을 시작하면 됩니다.</span><span class="sxs-lookup"><span data-stu-id="efbc1-300">This way, you start on the journey of building new microservices and practice developing and deploying them.</span></span>

<span data-ttu-id="efbc1-301">**혁신** - 이 문서의 시작 부분에 있는 변화하는 초기 비즈니스 요구 사항이 마이크로 서비스 방식이었나요?</span><span class="sxs-lookup"><span data-stu-id="efbc1-301">**Innovate** - remember those original changing business needs at the start of this article, that are driving the microservices approach?</span></span> <span data-ttu-id="efbc1-302">이 단계에서는 현재 내 응용 프로그램에 발생한 상황인지, 그렇다면 모놀리식으로 분할하거나 혁신하기 시작해야 하는지 결정합니다.</span><span class="sxs-lookup"><span data-stu-id="efbc1-302">At this stage the decision is, are these happening to my current application and if so, I need to start splitting the monolith, or innovating.</span></span> <span data-ttu-id="efbc1-303">여기에 있는 예제는 데이터베이스가 워크플로 큐로 사용되어 병목 상태를 처리 중인 경우입니다.</span><span class="sxs-lookup"><span data-stu-id="efbc1-303">An example here is when a database becomes a processing bottleneck, since it is being used as a workflow queue.</span></span> <span data-ttu-id="efbc1-304">워크플로 요청의 수가 증가하므로 작업은 크기에 따라 배포되야 합니다.</span><span class="sxs-lookup"><span data-stu-id="efbc1-304">As the number of workflow requests increasing the work needs to be distributed for scale.</span></span> <span data-ttu-id="efbc1-305">크기 조정되지 않은 응용 프로그램의 해당 특정 부분의 경우 더 자주 업데이트해야 합니다. 이를 마이크로 서비스 및 혁신으로 나눕니다.</span><span class="sxs-lookup"><span data-stu-id="efbc1-305">So for that particular piece of the application that is not scaling, or you need to update more frequently, split this out into a microservice and innovate.</span></span> 

<span data-ttu-id="efbc1-306">**마이크로 서비스로 변환** - 응용 프로그램이 마이크로 서비스로 완벽하게 구성(또는 분리)된 경우입니다.</span><span class="sxs-lookup"><span data-stu-id="efbc1-306">**Transformed into microservices** - this is where your application is fully composed of (or decomposed into) microservices.</span></span> <span data-ttu-id="efbc1-307">그렇게 하려면 마이크로 서비스를 시작합니다.</span><span class="sxs-lookup"><span data-stu-id="efbc1-307">To reach here, you have made the microservices journey.</span></span> <span data-ttu-id="efbc1-308">여기에서 시작할 수는 있지만 마이크로 서비스 플랫폼의 도움없이 이 작업을 수행하려면 많은 투자가 필요합니다.</span><span class="sxs-lookup"><span data-stu-id="efbc1-308">You can start here, but to do this without a microservices platform to help you is a significant investment.</span></span> 

### <a name="are-microservices-right-for-my-application"></a><span data-ttu-id="efbc1-309">마이크로 서비스가 내 응용 프로그램에 적합할까요?</span><span class="sxs-lookup"><span data-stu-id="efbc1-309">Are microservices right for my application?</span></span>
<span data-ttu-id="efbc1-310">아마도 그렇습니다.</span><span class="sxs-lookup"><span data-stu-id="efbc1-310">Maybe.</span></span> <span data-ttu-id="efbc1-311">비즈니스적인 이유로 클라우드에 대해 구축을 시작하는 팀들이 점점 더 늘어나고 있습니다. 이들 중 다수는 마이크로 서비스와 유사한 접근 방식의 장점을 인식하게 되었습니다.</span><span class="sxs-lookup"><span data-stu-id="efbc1-311">What we experienced was that as more and more teams in Microsoft began to build for the cloud for business reasons, many of them realized the benefits of taking a microservice-like approach.</span></span> <span data-ttu-id="efbc1-312">예를 들어, Bing은 수년 동안 검색에서 마이크로 서비스를 개발하고 있습니다.</span><span class="sxs-lookup"><span data-stu-id="efbc1-312">Bing, for example, has been developing microservices in search for years.</span></span> <span data-ttu-id="efbc1-313">다른 팀의 경우 마이크로 서비스 접근 방식은 새로웠습니다.</span><span class="sxs-lookup"><span data-stu-id="efbc1-313">For other teams, the microservices approach was new.</span></span> <span data-ttu-id="efbc1-314">팀은 핵심 역량이 아니면서 해결이 필요한 까다로운 문제를 찾았습니다.</span><span class="sxs-lookup"><span data-stu-id="efbc1-314">Teams found that there were hard problems to solve outside of their core areas of strength.</span></span> <span data-ttu-id="efbc1-315">이 때문에 서비스 구축을 위해 서비스 패브릭을 선택해야 하는 근거를 얻고 있습니다.</span><span class="sxs-lookup"><span data-stu-id="efbc1-315">This is why Service Fabric gained traction as the technology of choice for building services.</span></span>

<span data-ttu-id="efbc1-316">서비스 패브릭의 목표는 마이크로 서비스를 통한 응용 프로그램 구축의 복잡성을 줄여 비용이 소요되는 여러 번의 재설계를 겪지 않아도 되게 하는 것입니다.</span><span class="sxs-lookup"><span data-stu-id="efbc1-316">The objective of Service Fabric is to reduce the complexities of building applications with a microservice approach, so that you do not have to go through as many costly redesigns.</span></span> <span data-ttu-id="efbc1-317">소규모로 시작해서 필요에 따라 확장하고, 고객 사용에 따라 서비스를 중단하고 새 서비스를 추가하며 진화해가는 것이 바로 이 접근 방식입니다.</span><span class="sxs-lookup"><span data-stu-id="efbc1-317">Start small, scale when needed, deprecate services, add new ones, and evolve with customer usage is the approach.</span></span> <span data-ttu-id="efbc1-318">대부분의 개발자들이 더 쉽게 마이크로 서비스에 접근할 수 있게 하기 위해서는 아직 많은 문제들을 해결해야 한다는 점도 알고 있습니다.</span><span class="sxs-lookup"><span data-stu-id="efbc1-318">We also know that there are many other problems yet to be solved to make microservices more approachable for most developers.</span></span> <span data-ttu-id="efbc1-319">컨테이너와 행위자 프로그래밍 모델은 이 방향으로 나아가기 위한 예이며 더 편리한 활용을 위해 앞으로 더 많은 혁신이 등장할 것을 확신합니다.</span><span class="sxs-lookup"><span data-stu-id="efbc1-319">Containers and the actor programming model are examples of small steps in that direction, and we are sure that more innovations will emerge to make this easier.</span></span>
 
<!--Every topic should have next steps and links to the next logical set of content to keep the customer engaged-->

## <a name="next-steps"></a><span data-ttu-id="efbc1-320">다음 단계</span><span class="sxs-lookup"><span data-stu-id="efbc1-320">Next steps</span></span>
* [<span data-ttu-id="efbc1-321">서비스 패브릭 용어 개요</span><span class="sxs-lookup"><span data-stu-id="efbc1-321">Service Fabric terminology overview</span></span>](service-fabric-technical-overview.md)
* [<span data-ttu-id="efbc1-322">마이크로 서비스: 클라우드가 지원하는 응용 프로그램 혁명</span><span class="sxs-lookup"><span data-stu-id="efbc1-322">Microservices: An application revolution powered by the cloud</span></span>](https://azure.microsoft.com/en-us/blog/microservices-an-application-revolution-powered-by-the-cloud/)

[Image1]: media/service-fabric-overview-microservices/monolithic-vs-micro.png
[Image2]: media/service-fabric-overview-microservices/statemonolithic-vs-micro.png
[Image3]: media/service-fabric-overview-microservices/microservices-migration.png
