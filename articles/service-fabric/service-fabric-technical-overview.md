---
title: "Azure Service Fabric 용어 aaaLearn | Microsoft Docs"
description: "서비스 패브릭의 용어에 대해 간략하게 소개하고 주요 용어 개념 및 hello 설명서의 hello 나머지 부분에 사용 된 용어에 설명 합니다."
services: service-fabric
documentationcenter: .net
author: rwike77
manager: timlt
editor: chackdan;subramar
ms.assetid: 3a970679-e19e-43b3-9be8-71773f307c57
ms.service: service-fabric
ms.devlang: dotnet
ms.topic: article
ms.tgt_pltfrm: NA
ms.workload: NA
ms.date: 06/02/2017
ms.author: ryanwi
ms.openlocfilehash: 4781fc0527b8a58e534183249bc2759aded2730b
ms.sourcegitcommit: 523283cc1b3c37c428e77850964dc1c33742c5f0
ms.translationtype: MT
ms.contentlocale: ko-KR
ms.lasthandoff: 10/06/2017
---
# <a name="service-fabric-terminology-overview"></a><span data-ttu-id="bfe8f-104">서비스 패브릭 용어 개요</span><span class="sxs-lookup"><span data-stu-id="bfe8f-104">Service Fabric terminology overview</span></span>
<span data-ttu-id="bfe8f-105">서비스 패브릭은 분산된 시스템 플랫폼으로 쉽게 toopackage를 사용 하면을 배포 하 고 확장성과 안정성이 뛰어난 microservices 관리 합니다.</span><span class="sxs-lookup"><span data-stu-id="bfe8f-105">Service Fabric is a distributed systems platform that makes it easy toopackage, deploy, and manage scalable and reliable microservices.</span></span> <span data-ttu-id="bfe8f-106">서비스 패브릭 toounderstand hello 용어 hello 설명서에서 사용 하 여 사용 되는이 항목 세부 정보 hello 용어입니다.</span><span class="sxs-lookup"><span data-stu-id="bfe8f-106">This topic details hello terminology used by Service Fabric toounderstand hello terms used in hello documentation.</span></span>

<span data-ttu-id="bfe8f-107">hello이 섹션에 나열 된 개념 에서도 설명 Microsoft Virtual Academy 동영상을 따라 hello: <a target="_blank" href="https://mva.microsoft.com/en-US/training-courses/building-microservices-applications-on-azure-service-fabric-16747?l=tbuZM46yC_5206218965">핵심 개념</a>, <a target="_blank" href="https://mva.microsoft.com/en-US/training-courses/building-microservices-applications-on-azure-service-fabric-16747?l=tlkI046yC_2906218965">디자인 타임 개념</a>, 및 <a target="_blank" href="https://mva.microsoft.com/en-US/training-courses/building-microservices-applications-on-azure-service-fabric-16747?l=x7CVH56yC_1406218965">런타임에개념</a>.</span><span class="sxs-lookup"><span data-stu-id="bfe8f-107">hello concepts listed in this section are also discussed in hello following Microsoft Virtual Academy videos: <a target="_blank" href="https://mva.microsoft.com/en-US/training-courses/building-microservices-applications-on-azure-service-fabric-16747?l=tbuZM46yC_5206218965">Core concepts</a>, <a target="_blank" href="https://mva.microsoft.com/en-US/training-courses/building-microservices-applications-on-azure-service-fabric-16747?l=tlkI046yC_2906218965">Design-time concepts</a>, and <a target="_blank" href="https://mva.microsoft.com/en-US/training-courses/building-microservices-applications-on-azure-service-fabric-16747?l=x7CVH56yC_1406218965">Run-time concepts</a>.</span></span>

## <a name="infrastructure-concepts"></a><span data-ttu-id="bfe8f-108">인프라 개념</span><span class="sxs-lookup"><span data-stu-id="bfe8f-108">Infrastructure concepts</span></span>
<span data-ttu-id="bfe8f-109">**클러스터**: 마이크로 서비스가 배포되고 관리되는 네트워크로 연결된 가상 또는 실제 컴퓨터 집합입니다.</span><span class="sxs-lookup"><span data-stu-id="bfe8f-109">**Cluster**: A network-connected set of virtual or physical machines into which your microservices are deployed and managed.</span></span>  <span data-ttu-id="bfe8f-110">클러스터의 컴퓨터 toothousands를 확장할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="bfe8f-110">Clusters can scale toothousands of machines.</span></span>

<span data-ttu-id="bfe8f-111">**노드**: 클러스터의 일부인 컴퓨터로 VM 노드라고 합니다.</span><span class="sxs-lookup"><span data-stu-id="bfe8f-111">**Node**: A machine or VM that is part of a cluster is called a node.</span></span> <span data-ttu-id="bfe8f-112">각 노드는 노드 이름(문자열)에 할당됩니다.</span><span class="sxs-lookup"><span data-stu-id="bfe8f-112">Each node is assigned a node name (a string).</span></span> <span data-ttu-id="bfe8f-113">노드는 배치 속성과 같은 특징이 있습니다.</span><span class="sxs-lookup"><span data-stu-id="bfe8f-113">Nodes have characteristics such as placement properties.</span></span> <span data-ttu-id="bfe8f-114">각 컴퓨터 또는 VM이 Windows 서비스인 `FabricHost.exe`를 자동으로 시작하여 부팅을 실행하기 시작한 다음 `Fabric.exe` 및 `FabricGateway.exe`이라는 두 개의 실행 파일을 시작합니다.</span><span class="sxs-lookup"><span data-stu-id="bfe8f-114">Each machine or VM has an auto-start Windows service, `FabricHost.exe`, which starts running upon boot and then starts two executables: `Fabric.exe` and `FabricGateway.exe`.</span></span> <span data-ttu-id="bfe8f-115">이러한 두 개의 실행 개체는 hello 노드를 확인합니다.</span><span class="sxs-lookup"><span data-stu-id="bfe8f-115">These two executables make up hello node.</span></span> <span data-ttu-id="bfe8f-116">테스트 시나리오에서는 `Fabric.exe` 및 `FabricGateway.exe`와 같은 여러 인스턴스를 실행하여 단일 컴퓨터 또는 VM에 여러 노드를 호스트할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="bfe8f-116">For testing scenarios, you can host multiple nodes on a single machine or VM by running multiple instances of `Fabric.exe` and `FabricGateway.exe`.</span></span>

## <a name="application-concepts"></a><span data-ttu-id="bfe8f-117">응용 프로그램 개념</span><span class="sxs-lookup"><span data-stu-id="bfe8f-117">Application concepts</span></span>
<span data-ttu-id="bfe8f-118">**응용 프로그램 종류**: hello 서비스 형식의 할당 된 이름/버전 tooa 컬렉션입니다.</span><span class="sxs-lookup"><span data-stu-id="bfe8f-118">**Application Type**: hello name/version assigned tooa collection of service types.</span></span> <span data-ttu-id="bfe8f-119">에 정의 된는 `ApplicationManifest.xml` 파일, toohello 서비스 패브릭 클러스터 이미지 저장소 복사 다음에 응용 프로그램 패키지 디렉터리에 포함 합니다.</span><span class="sxs-lookup"><span data-stu-id="bfe8f-119">Defined in an `ApplicationManifest.xml` file, embedded in an application package directory, which is then copied toohello Service Fabric cluster's image store.</span></span> <span data-ttu-id="bfe8f-120">그런 다음 hello 클러스터 내에서이 응용 프로그램 종류에서 명명된 된 응용 프로그램을 만들 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="bfe8f-120">You can then create a named application from this application type within hello cluster.</span></span>

<span data-ttu-id="bfe8f-121">읽기 hello [응용 프로그램 모델](service-fabric-application-model.md) 대 한 자세한 내용은 문서.</span><span class="sxs-lookup"><span data-stu-id="bfe8f-121">Read hello [Application Model](service-fabric-application-model.md) article for more information.</span></span>

<span data-ttu-id="bfe8f-122">**응용 프로그램 패키지**: hello 응용 프로그램 종류를 포함 하는 디스크 디렉터리 `ApplicationManifest.xml` 파일입니다.</span><span class="sxs-lookup"><span data-stu-id="bfe8f-122">**Application Package**: A disk directory containing hello application type's `ApplicationManifest.xml` file.</span></span> <span data-ttu-id="bfe8f-123">참조 hello hello 응용 프로그램 종류를 구성 하는 각 서비스 유형에 대 한 서비스 패키지입니다.</span><span class="sxs-lookup"><span data-stu-id="bfe8f-123">References hello service packages for each service type that makes up hello application type.</span></span> <span data-ttu-id="bfe8f-124">hello 응용 프로그램 패키지 디렉터리의 hello 파일은 복사 tooService 패브릭 클러스터 이미지 저장소입니다.</span><span class="sxs-lookup"><span data-stu-id="bfe8f-124">hello files in hello application package directory are copied tooService Fabric cluster's image store.</span></span> <span data-ttu-id="bfe8f-125">예를 들어 전자 메일 응용 프로그램 종류에 대 한 응용 프로그램 패키지 참조가 tooa 큐 서비스 패키지, 프런트 엔드 서비스 패키지 및 데이터베이스 서비스 패키지를 포함할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="bfe8f-125">For example, an application package for an email application type could contain references tooa queue service package, a frontend service package, and a database service package.</span></span>

<span data-ttu-id="bfe8f-126">**이름은 응용 프로그램**: hello 응용 프로그램 패키지의 응용 프로그램 종류 (이름/버전 사용)를 지정 하 여 hello 클러스터 내에서 hello 응용 프로그램의 인스턴스를 만들 응용 프로그램 패키지를 복사한 toohello 이미지 저장소 후 합니다.</span><span class="sxs-lookup"><span data-stu-id="bfe8f-126">**Named Application**: After an application package is copied toohello image store, you create an instance of hello application within hello cluster by specifying hello application package's application type (using its name/version).</span></span> <span data-ttu-id="bfe8f-127">각 응용 프로그램 형식 인스턴스는 `"fabric:/MyNamedApp"`와 같은 URI 이름이 할당됩니다.</span><span class="sxs-lookup"><span data-stu-id="bfe8f-127">Each application type instance is assigned a URI name that looks like: `"fabric:/MyNamedApp"`.</span></span> <span data-ttu-id="bfe8f-128">클러스터 내에서 단일 응용 프로그램 형식에서 여러 명명된 응용 프로그램을 만들 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="bfe8f-128">Within a cluster, you can create multiple named applications from a single application type.</span></span> <span data-ttu-id="bfe8f-129">또한 다른 형식의 응용 프로그램에서 명명된 응용 프로그램을 만들 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="bfe8f-129">You can also create named applications from different application types.</span></span> <span data-ttu-id="bfe8f-130">명명된 응용 프로그램은 각각 독립적으로 관리되고 버전이 지정됩니다.</span><span class="sxs-lookup"><span data-stu-id="bfe8f-130">Each named application is managed and versioned independently.</span></span>      

<span data-ttu-id="bfe8f-131">**서비스 유형**: hello 이름/버전 tooa 서비스의 코드 패키지, 데이터 패키지 및 패키지 구성에 할당 합니다.</span><span class="sxs-lookup"><span data-stu-id="bfe8f-131">**Service Type**: hello name/version assigned tooa service's code packages, data packages, and configuration packages.</span></span> <span data-ttu-id="bfe8f-132">에 정의 된 한 `ServiceManifest.xml` 파일을 서비스 패키지 디렉터리 및 hello 서비스 패키지 디렉터리에 포함 된 응용 프로그램 패키지에서 참조 한 다음 `ApplicationManifest.xml` 파일입니다.</span><span class="sxs-lookup"><span data-stu-id="bfe8f-132">Defined in a `ServiceManifest.xml` file, embedded in a service package directory and hello service package directory is then referenced by an application package's `ApplicationManifest.xml` file.</span></span> <span data-ttu-id="bfe8f-133">Hello 클러스터 내에서 명명된 된 응용 프로그램을 만든 후 만들 수 있습니다는 명명된 서비스 hello 중 하나에서 응용 프로그램 종류의 서비스 유형.</span><span class="sxs-lookup"><span data-stu-id="bfe8f-133">Within hello cluster, after creating a named application, you can create a named service from one of hello application type's service types.</span></span> <span data-ttu-id="bfe8f-134">서비스 유형 hello `ServiceManifest.xml` 파일 hello 서비스에 설명 합니다.</span><span class="sxs-lookup"><span data-stu-id="bfe8f-134">hello service type's `ServiceManifest.xml` file describes hello service.</span></span>

<span data-ttu-id="bfe8f-135">읽기 hello [응용 프로그램 모델](service-fabric-application-model.md) 대 한 자세한 내용은 문서.</span><span class="sxs-lookup"><span data-stu-id="bfe8f-135">Read hello [Application Model](service-fabric-application-model.md) article for more information.</span></span>

<span data-ttu-id="bfe8f-136">서비스의 두 가지 형식이 있습니다.</span><span class="sxs-lookup"><span data-stu-id="bfe8f-136">There are two types of services:</span></span>

* <span data-ttu-id="bfe8f-137">**Stateless:** hello 서비스의 영구 상태와 같은 Azure 저장소, Azure SQL 데이터베이스 또는 Azure Cosmos DB는 외부 저장소 서비스에 저장 되 면 상태 비저장 서비스를 사용 합니다.</span><span class="sxs-lookup"><span data-stu-id="bfe8f-137">**Stateless:** Use a stateless service when hello service's persistent state is stored in an external storage service such as Azure Storage, Azure SQL Database, or Azure Cosmos DB.</span></span> <span data-ttu-id="bfe8f-138">에 영구 저장소가 없는 전혀 hello 서비스 하는 경우에 상태 비저장 서비스를 사용 합니다.</span><span class="sxs-lookup"><span data-stu-id="bfe8f-138">Use a stateless service when hello service has no persistent storage at all.</span></span> <span data-ttu-id="bfe8f-139">예를 들어는 계산기 서비스 여기서 값 toohello 서비스에 전달 됩니다, 계산 이러한 값을 사용 하 여 수행 됩니다 결과가 반환 됩니다.</span><span class="sxs-lookup"><span data-stu-id="bfe8f-139">For example, a calculator service where values are passed toohello service, a computation is performed using these values, and a result is returned.</span></span>
* <span data-ttu-id="bfe8f-140">**상태 저장:** 서비스 패브릭 toomanage의 신뢰할 수 있는 컬렉션 또는 Reliable Actors 프로그래밍 모델을 통해 서비스의 상태를 원하는 경우 상태 저장 서비스를 사용 합니다.</span><span class="sxs-lookup"><span data-stu-id="bfe8f-140">**Stateful:** Use a stateful service when you want Service Fabric toomanage your service's state via its Reliable Collections or Reliable Actors programming models.</span></span> <span data-ttu-id="bfe8f-141">Toospread 프로그램 상태를 통해 하려는 (확장성)에 대 한 경우는 파티션의 수를 지정 합니다. 명명 된 서비스 만들기.</span><span class="sxs-lookup"><span data-stu-id="bfe8f-141">Specify how many partitions you want toospread your state over (for scalability) when creating a named service.</span></span> <span data-ttu-id="bfe8f-142">Tooreplicate 횟수를 지정할 수도 노드 (안정성)에 대 한 전체 상태입니다.</span><span class="sxs-lookup"><span data-stu-id="bfe8f-142">Also specify how many times tooreplicate your state across nodes (for reliability).</span></span> <span data-ttu-id="bfe8f-143">명명된 서비스 각각에는 하나의 기본 복제본과 여러 보조 복제본이 있습니다.</span><span class="sxs-lookup"><span data-stu-id="bfe8f-143">Each named service has a single primary replica and multiple secondary replicas.</span></span> <span data-ttu-id="bfe8f-144">Toohello 주 복제본을 작성 하 여 명명 된 서비스의 상태를 수정 합니다.</span><span class="sxs-lookup"><span data-stu-id="bfe8f-144">You modify your named service's state by writing toohello primary replica.</span></span> <span data-ttu-id="bfe8f-145">서비스 패브릭은이 상태 tooall hello 보조 복제본 동기화 상태를 유지 한 다음 복제 합니다. 서비스 패브릭 실패 하 고 기존 보조 복제본 tooa 주 복제본을 승격 하는 주 복제본에 자동으로 검색 합니다.</span><span class="sxs-lookup"><span data-stu-id="bfe8f-145">Service Fabric then replicates this state tooall hello secondary replicas keeping your state in sync. Service Fabric automatically detects when a primary replica fails and promotes an existing secondary replica tooa primary replica.</span></span> <span data-ttu-id="bfe8f-146">그러면 서비스 패브릭은 새로운 보조 복제본을 만듭니다.</span><span class="sxs-lookup"><span data-stu-id="bfe8f-146">Service Fabric then creates a new secondary replica.</span></span>  

<span data-ttu-id="bfe8f-147">**서비스 패키지**: hello 서비스 형식이 포함 된 디스크 디렉터리 `ServiceManifest.xml` 파일입니다.</span><span class="sxs-lookup"><span data-stu-id="bfe8f-147">**Service Package**: A disk directory containing hello service type's `ServiceManifest.xml` file.</span></span> <span data-ttu-id="bfe8f-148">이 파일은 hello 코드, 정적 데이터 및 구성 패키지 hello 서비스 유형에 대 한 참조입니다.</span><span class="sxs-lookup"><span data-stu-id="bfe8f-148">This file references hello code, static data, and configuration packages for hello service type.</span></span> <span data-ttu-id="bfe8f-149">hello 응용 프로그램 종류에서 참조 하는 hello 서비스 패키지 디렉터리에 파일 hello `ApplicationManifest.xml` 파일입니다.</span><span class="sxs-lookup"><span data-stu-id="bfe8f-149">hello files in hello service package directory are referenced by hello application type's `ApplicationManifest.xml` file.</span></span> <span data-ttu-id="bfe8f-150">예를 들어 서비스 패키지 toohello 코드, 정적 데이터 및 데이터베이스 서비스를 구성 하는 구성 패키지를 참조할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="bfe8f-150">For example, a service package could refer toohello code, static data, and configuration packages that make up a database service.</span></span>

<span data-ttu-id="bfe8f-151">**서비스 라는**: 명명된 된 응용 프로그램을 만든 후 hello 서비스 유형 (이름/버전 사용)를 지정 하 여 hello 클러스터 내에서 해당 서비스 형식의 인스턴스를 만들 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="bfe8f-151">**Named Service**: After creating a named application, you can create an instance of one of its service types within hello cluster by specifying hello service type (using its name/version).</span></span> <span data-ttu-id="bfe8f-152">각 서비스 형식 인스턴스는 명명된 응용 프로그램의 URI로 범위가 지정된 URI 이름이 할당됩니다.</span><span class="sxs-lookup"><span data-stu-id="bfe8f-152">Each service type instance is assigned a URI name scoped under its named application's URI.</span></span> <span data-ttu-id="bfe8f-153">예를 들어 "MyDatabase" 라는 이름은 응용 프로그램 "MyNamedApp" 내 서비스를 만들면 hello URI 같습니다: `"fabric:/MyNamedApp/MyDatabase"`합니다.</span><span class="sxs-lookup"><span data-stu-id="bfe8f-153">For example, if you create a "MyDatabase" named service within a "MyNamedApp" named application, hello URI looks like: `"fabric:/MyNamedApp/MyDatabase"`.</span></span> <span data-ttu-id="bfe8f-154">명명된 응용 프로그램 내에서 몇 가지 명명된 서비스를 만들 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="bfe8f-154">Within a named application, you can create several named services.</span></span> <span data-ttu-id="bfe8f-155">명명된 각 서비스는 고유한 파티션 구성표 및 복제본/인스턴스 수를 가질 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="bfe8f-155">Each named service can have its own partition scheme and instance/replica counts.</span></span>

<span data-ttu-id="bfe8f-156">**코드 패키지**: hello 서비스 유형을 실행 파일 (일반적으로 EXE/DLL 파일)를 포함 하는 디스크 디렉터리입니다.</span><span class="sxs-lookup"><span data-stu-id="bfe8f-156">**Code Package**: A disk directory containing hello service type's executable files (typically EXE/DLL files).</span></span> <span data-ttu-id="bfe8f-157">hello 서비스 종류에서 참조 하는 hello 코드 패키지 디렉터리에 파일 hello `ServiceManifest.xml` 파일입니다.</span><span class="sxs-lookup"><span data-stu-id="bfe8f-157">hello files in hello code package directory are referenced by hello service type's `ServiceManifest.xml` file.</span></span> <span data-ttu-id="bfe8f-158">명명 된 서비스를 만들면 hello 코드 패키지는 복사한 toohello 노드 또는 노드 선택한 toorun hello 라는 서비스.</span><span class="sxs-lookup"><span data-stu-id="bfe8f-158">When a named service is created, hello code package is copied toohello node or nodes selected toorun hello named service.</span></span> <span data-ttu-id="bfe8f-159">그런 다음 hello 코드 실행을 시작 합니다.</span><span class="sxs-lookup"><span data-stu-id="bfe8f-159">Then hello code starts running.</span></span> <span data-ttu-id="bfe8f-160">코드 패키지 실행 파일은 다음과 같은 두 종류가 있습니다.</span><span class="sxs-lookup"><span data-stu-id="bfe8f-160">There are two types of code package executables:</span></span>

* <span data-ttu-id="bfe8f-161">**게스트 실행 파일**:으로 실행 하는 실행 파일-hello 호스트 운영 체제 (Windows 또는 Linux)에 있습니다.</span><span class="sxs-lookup"><span data-stu-id="bfe8f-161">**Guest executables**: Executables that run as-is on hello host operating system (Windows or Linux).</span></span> <span data-ttu-id="bfe8f-162">즉, 이러한 실행 파일 서비스 패브릭 런타임에서 파일 링크 tooor 참조 하지 않는 및 모든 서비스 패브릭 프로그래밍 모델을 사용 하지 마십시오.</span><span class="sxs-lookup"><span data-stu-id="bfe8f-162">That is, these executables do not link tooor reference any Service Fabric runtime files and therefore do not use any Service Fabric programming models.</span></span> <span data-ttu-id="bfe8f-163">이러한 실행 파일 이름 지정에 대 한 끝점 검색 서비스와 같은 일부 서비스 패브릭 기능 hello 없습니다 toouse 됩니다.</span><span class="sxs-lookup"><span data-stu-id="bfe8f-163">These executables are unable toouse some Service Fabric features such as hello naming service for endpoint discovery.</span></span> <span data-ttu-id="bfe8f-164">게스트 실행 파일 부하 메트릭을 특정 tooeach 서비스 인스턴스를 보고할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="bfe8f-164">Guest executables cannot report load metrics specific tooeach service instance.</span></span>
* <span data-ttu-id="bfe8f-165">**서비스 호스트 실행 파일**: 서비스 패브릭 기능을 사용 하도록 서비스 패브릭 tooService 패브릭 런타임 파일을 연결 하 여 프로그래밍 모델을 사용 하는 실행 파일입니다.</span><span class="sxs-lookup"><span data-stu-id="bfe8f-165">**Service Host Executables**: Executables that use Service Fabric programming models by linking tooService Fabric runtime files, enabling Service Fabric features.</span></span> <span data-ttu-id="bfe8f-166">예를 들어 명명된 서비스 인스턴스는 서비스 패브릭의 이름 지정 서비스를 사용하여 끝점을 등록할 수 있고 부하 메트릭을 보고할 수도 있습니다.</span><span class="sxs-lookup"><span data-stu-id="bfe8f-166">For example, a named service instance can register endpoints with Service Fabric's Naming Service and can also report load metrics.</span></span>      

<span data-ttu-id="bfe8f-167">**데이터 패키지**: hello 서비스 유형이 정적, 읽기 전용 데이터 파일 (일반적으로: 사진, 소리 및 비디오 파일)를 포함 하는 디스크 디렉터리입니다.</span><span class="sxs-lookup"><span data-stu-id="bfe8f-167">**Data Package**: A disk directory containing hello service type's static, read-only data files (typically photo, sound, and video files).</span></span> <span data-ttu-id="bfe8f-168">hello 서비스 종류에서 참조 하는 hello 데이터 패키지 디렉터리에 파일 hello `ServiceManifest.xml` 파일입니다.</span><span class="sxs-lookup"><span data-stu-id="bfe8f-168">hello files in hello data package directory are referenced by hello service type's `ServiceManifest.xml` file.</span></span> <span data-ttu-id="bfe8f-169">명명 된 서비스를 만들면 hello 데이터 패키지는 복사한 toohello 노드 또는 노드 선택한 toorun hello 라는 서비스.</span><span class="sxs-lookup"><span data-stu-id="bfe8f-169">When a named service is created, hello data package is copied toohello node or nodes selected toorun hello named service.</span></span>  <span data-ttu-id="bfe8f-170">hello 코드 실행을 시작 하 고 이제 hello 데이터 파일에 액세스할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="bfe8f-170">hello code starts running and can now access hello data files.</span></span>

<span data-ttu-id="bfe8f-171">**구성 패키지**: hello 서비스 유형이 정적을 포함 하는 디스크 디렉터리, 읽기 전용으로 구성 파일 (일반적으로 텍스트 파일).</span><span class="sxs-lookup"><span data-stu-id="bfe8f-171">**Configuration Package**: A disk directory containing hello service type's static, read-only configuration files (typically text files).</span></span> <span data-ttu-id="bfe8f-172">hello 서비스 종류에서 참조 하는 hello 구성 패키지 디렉터리에서 파일 hello `ServiceManifest.xml` 파일입니다.</span><span class="sxs-lookup"><span data-stu-id="bfe8f-172">hello files in hello configuration package directory are referenced by hello service type's `ServiceManifest.xml` file.</span></span> <span data-ttu-id="bfe8f-173">명명 된 서비스를 만들면 hello 구성 패키지의 hello 파일은 복사 toohello 하나 또는 더 많은 노드 선택한 toorun hello 라는 서비스입니다.</span><span class="sxs-lookup"><span data-stu-id="bfe8f-173">When a named service is created, hello files in hello configuration package are copied toohello one or more nodes selected toorun hello named service.</span></span> <span data-ttu-id="bfe8f-174">그런 다음 hello 코드 실행을 시작 하 고 이제 hello 구성 파일에 액세스할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="bfe8f-174">Then hello code starts running and can now access hello configuration files.</span></span>

<span data-ttu-id="bfe8f-175">**컨테이너**: 기본적으로 Service Fabric은 이러한 서비스를 프로세스로 배포하고 활성화합니다.</span><span class="sxs-lookup"><span data-stu-id="bfe8f-175">**Containers**: By default, Service Fabric deploys and activates services as processes.</span></span> <span data-ttu-id="bfe8f-176">Service Fabric도 컨테이너 이미지에 서비스를 배포할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="bfe8f-176">Service Fabric can also deploy services in container images.</span></span> <span data-ttu-id="bfe8f-177">컨테이너는 응용 프로그램에서 기본 운영 체제 hello를 가상화 하는 가상화 기술입니다.</span><span class="sxs-lookup"><span data-stu-id="bfe8f-177">Containers are a virtualization technology that virtualizes hello underlying operating system from applications.</span></span> <span data-ttu-id="bfe8f-178">응용 프로그램 및 해당 런타임, 종속성 및 시스템 라이브러리는 운영 체제 구문 전체, 개인 액세스 toohello 컨테이너의 고유한 격리 보기 컨테이너 내에서 실행 합니다.</span><span class="sxs-lookup"><span data-stu-id="bfe8f-178">An application and its runtime, dependencies, and system libraries run inside a container with full, private access toohello container's own isolated view of operating system constructs.</span></span> <span data-ttu-id="bfe8f-179">Service Fabric은 Linux 및 Windows Server 컨테이너에서 Docker 컨테이너를 지원합니다.</span><span class="sxs-lookup"><span data-stu-id="bfe8f-179">Service Fabric supports Docker containers on Linux and Windows Server containers.</span></span>  <span data-ttu-id="bfe8f-180">자세한 내용은 [Service Fabric 및 컨테이너](service-fabric-containers-overview.md)를 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="bfe8f-180">For more information, read [Service Fabric and containers](service-fabric-containers-overview.md).</span></span>

<span data-ttu-id="bfe8f-181">**파티션 구성표**: 명명된 서비스를 만들 때 파티션 구성표를 지정합니다.</span><span class="sxs-lookup"><span data-stu-id="bfe8f-181">**Partition Scheme**: When creating a named service, you specify a partition scheme.</span></span> <span data-ttu-id="bfe8f-182">많은 양의 상태를 사용 하 여 서비스는 hello 상태 hello 클러스터의 노드 전체에 분산 하는 파티션 간에 hello 데이터를 분할 합니다.</span><span class="sxs-lookup"><span data-stu-id="bfe8f-182">Services with large amounts of state split hello data across partitions, which spreads hello state across hello cluster's nodes.</span></span> <span data-ttu-id="bfe8f-183">이렇게 하면 명명 된 서비스의 상태 tooscale가 있습니다.</span><span class="sxs-lookup"><span data-stu-id="bfe8f-183">This allows your named service's state tooscale.</span></span> <span data-ttu-id="bfe8f-184">상태 저장 서비스에 복제본이 있는 반면 파티션 내에서 명명된 상태 비저장 서비스에는 인스턴스가 있습니다.</span><span class="sxs-lookup"><span data-stu-id="bfe8f-184">Within a partition, stateless named services have instances while stateful named services have replicas.</span></span> <span data-ttu-id="bfe8f-185">일반적으로 명명된 상태 비저장 서비스는 내부 상태가 없기 때문에 하나의 파티션만을 가질 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="bfe8f-185">Usually, stateless named services only ever have one partition since they have no internal state.</span></span> <span data-ttu-id="bfe8f-186">가용성;에 대 한 hello 파티션 인스턴스 제공 하나의 인스턴스가 실패 하면 다른 인스턴스와 toooperate를 정상적으로 계속 하 고 그런 다음 서비스 패브릭은 새 인스턴스를 만듭니다.</span><span class="sxs-lookup"><span data-stu-id="bfe8f-186">hello partition instances provide for availability; if one instance fails, other instances continue toooperate normally and then Service Fabric will create a new instance.</span></span> <span data-ttu-id="bfe8f-187">명명 된 서비스 상태 저장 복제본 내에서 상태를 유지 하 고 각 파티션에 자체 복제본을 동기화 상태로 유지 되 고 모든 hello 상태로 설정 하는 합니다. 서비스 패브릭 복제 실패로 처리할지, hello 기존 복제본에서 새 복제 데이터베이스를 작성 합니다.</span><span class="sxs-lookup"><span data-stu-id="bfe8f-187">Stateful named services maintain their state within replicas and each partition has its own replica set with all hello state being kept in sync. Should a replica fail, Service Fabric builds a new replica from hello existing replicas.</span></span>

<span data-ttu-id="bfe8f-188">읽기 hello [신뢰할 수 있는 파티션 서비스 패브릭 서비스](service-fabric-concepts-partitioning.md) 대 한 자세한 내용은 문서.</span><span class="sxs-lookup"><span data-stu-id="bfe8f-188">Read hello [Partition Service Fabric reliable services](service-fabric-concepts-partitioning.md) article for more information.</span></span>

## <a name="system-services"></a><span data-ttu-id="bfe8f-189">시스템 서비스</span><span class="sxs-lookup"><span data-stu-id="bfe8f-189">System services</span></span>
<span data-ttu-id="bfe8f-190">서비스 패브릭의 hello 플랫폼 기능을 제공 하는 모든 클러스터에서 만들어진 시스템 서비스가 있습니다.</span><span class="sxs-lookup"><span data-stu-id="bfe8f-190">There are system services that are created in every cluster that provide hello platform capabilities of Service Fabric.</span></span>

<span data-ttu-id="bfe8f-191">**서비스 이름 지정**: 각 서비스 패브릭 클러스터에 hello 클러스터에서 서비스 이름을 tooa 위치를 확인 하는 명명 서비스를 합니다.</span><span class="sxs-lookup"><span data-stu-id="bfe8f-191">**Naming Service**: Each Service Fabric cluster has a Naming service, which resolves service names tooa location in hello cluster.</span></span> <span data-ttu-id="bfe8f-192">Hello 서비스 이름, 속성, 비슷한 tooan 관리 인터넷 서비스 DNS (Domain Name) hello 클러스터에 대 한 합니다.</span><span class="sxs-lookup"><span data-stu-id="bfe8f-192">You manage hello service names and properties, similar tooan internet Domain Name Service (DNS) for hello cluster.</span></span> <span data-ttu-id="bfe8f-193">클라이언트는 서비스 이름 및 해당 위치에 안전 하 게 명명 서비스 tooresolve hello를 사용 하 여 hello 클러스터에 있는 모든 노드 통신 합니다.</span><span class="sxs-lookup"><span data-stu-id="bfe8f-193">Clients securely communicate with any node in hello cluster using hello Naming Service tooresolve a service name and its location.</span></span>  <span data-ttu-id="bfe8f-194">예를 들어 기한 toofailures, 리소스 분산 또는 hello 클러스터의 크기 조정 hello hello 클러스터 내에서 응용 프로그램 이동 합니다.</span><span class="sxs-lookup"><span data-stu-id="bfe8f-194">Applications move within hello cluster for example due toofailures, resource balancing, or hello resizing of hello cluster.</span></span> <span data-ttu-id="bfe8f-195">서비스와 클라이언트 hello 현재 네트워크 위치를 확인 있는 개발할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="bfe8f-195">You can develop services and clients which resolve hello current network location.</span></span> <span data-ttu-id="bfe8f-196">클라이언트는 hello 실제 컴퓨터 IP 주소와 현재 실행 중인 포트를 가져옵니다.</span><span class="sxs-lookup"><span data-stu-id="bfe8f-196">Clients obtain hello actual machine IP address and port where it is currently running.</span></span>

<span data-ttu-id="bfe8f-197">읽기 [서비스와 통신](service-fabric-connect-and-communicate-with-services.md) hello 클라이언트와 서비스 통신 hello 명명 서비스를 사용 하는 Api에 대 한 자세한 내용은 합니다.</span><span class="sxs-lookup"><span data-stu-id="bfe8f-197">Read [Communicate with services](service-fabric-connect-and-communicate-with-services.md) for more information on hello client and service communication APIs that work with hello Naming service.</span></span>

<span data-ttu-id="bfe8f-198">**이미지 저장소 서비스**: 각 서비스 패브릭 클러스터에는 배포되어 버전이 지정된 응용 프로그램 패키지가 보관되는 이미지 저장소 서비스가 있습니다.</span><span class="sxs-lookup"><span data-stu-id="bfe8f-198">**Image Store Service**: Each Service Fabric cluster has an Image Store service where deployed, versioned application packages are kept.</span></span> <span data-ttu-id="bfe8f-199">응용 프로그램 패키지 toohello 이미지 저장소를 복사한 다음 해당 응용 프로그램 패키지 내에 포함 된 hello 응용 프로그램 종류를 등록 합니다.</span><span class="sxs-lookup"><span data-stu-id="bfe8f-199">Copy an application package toohello Image Store and then register hello application type contained within that application package.</span></span> <span data-ttu-id="bfe8f-200">Hello 응용 프로그램 유형을 프로 비전 되 면 여기에서 명명된 된 응용 프로그램을 만듭니다.</span><span class="sxs-lookup"><span data-stu-id="bfe8f-200">After hello application type is provisioned, you create a named application from it.</span></span> <span data-ttu-id="bfe8f-201">명명 된 모든 응용 프로그램을 삭제 한 후 hello 이미지 저장소 서비스에서에서 응용 프로그램 종류를 등록 취소할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="bfe8f-201">You can unregister an application type from hello Image Store service after all its named applications have been deleted.</span></span>

<span data-ttu-id="bfe8f-202">읽기 [hello ImageStoreConnectionString 설정 이해](service-fabric-image-store-connection-string.md) hello 이미지 저장소 서비스에 대 한 자세한 내용은 합니다.</span><span class="sxs-lookup"><span data-stu-id="bfe8f-202">Read [Understand hello ImageStoreConnectionString setting](service-fabric-image-store-connection-string.md) for more information about hello Image Store service.</span></span>

<span data-ttu-id="bfe8f-203">읽기 hello [응용 프로그램 배포](service-fabric-deploy-remove-applications.md) 응용 프로그램 toohello 이미지 저장소 서비스를 배포 하는 방법에 대 한 자세한 내용은 문서입니다.</span><span class="sxs-lookup"><span data-stu-id="bfe8f-203">Read hello [Deploy an application](service-fabric-deploy-remove-applications.md) article for more information on deploying applications toohello Image store service.</span></span>

## <a name="built-in-programming-models"></a><span data-ttu-id="bfe8f-204">기본 제공 프로그래밍 모델</span><span class="sxs-lookup"><span data-stu-id="bfe8f-204">Built-in programming models</span></span>
<span data-ttu-id="bfe8f-205">Toobuild 서비스 패브릭 서비스를 사용할 수 있는.NET Framework 프로그래밍 모델은:</span><span class="sxs-lookup"><span data-stu-id="bfe8f-205">There are .NET Framework programming models available for you toobuild Service Fabric services:</span></span>

<span data-ttu-id="bfe8f-206">**신뢰할 수 있는 서비스**: API toobuild 상태 비저장 및 상태 저장 서비스입니다.</span><span class="sxs-lookup"><span data-stu-id="bfe8f-206">**Reliable Services**: An API toobuild stateless and stateful services.</span></span> <span data-ttu-id="bfe8f-207">상태 저장 서비스는 신뢰할 수 있는 컬렉션(예: 사전 또는 큐)에 자신의 상태를 저장합니다.</span><span class="sxs-lookup"><span data-stu-id="bfe8f-207">Stateful service store their state in Reliable Collections (such as a dictionary or a queue).</span></span> <span data-ttu-id="bfe8f-208">웹 API 및 Windows Communication Foundation (WCF)와 같은 다양 한 통신 스택에 tooplug를 가져올 수도 있습니다.</span><span class="sxs-lookup"><span data-stu-id="bfe8f-208">You also get tooplug in various communication stacks such as Web API and Windows Communication Foundation (WCF).</span></span>

<span data-ttu-id="bfe8f-209">**Reliable Actors**: hello 가상 행위자 프로그래밍 모델을 통해 API toobuild 상태 비저장 및 상태 저장 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="bfe8f-209">**Reliable Actors**: An API toobuild stateless and stateful objects through hello virtual Actor programming model.</span></span> <span data-ttu-id="bfe8f-210">이 모델은 계산/상태의 독립적인 단위가 많은 경우 유용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="bfe8f-210">This model can be useful when you have lots of independent units of computation/state.</span></span> <span data-ttu-id="bfe8f-211">되기 때문에이 모델 턴 기반 스레딩 모델을 사용 하는 경우 개별 행위자의 아웃 바운드 요청을 모두 완료 될 때까지 다른 들어오는 요청을 처리할 수 없습니다 이후 tooother 행위자 또는 서비스를 호출 하는 가장 좋은 tooavoid 코드.</span><span class="sxs-lookup"><span data-stu-id="bfe8f-211">Because this model uses a turn-based threading model, it is best tooavoid code that calls out tooother actors or services since an individual actor cannot process other incoming requests until all its outbound requests have completed.</span></span>

<span data-ttu-id="bfe8f-212">읽기 hello [서비스에 대 한 프로그래밍 모델 선택](service-fabric-choose-framework.md) 대 한 자세한 내용은 문서.</span><span class="sxs-lookup"><span data-stu-id="bfe8f-212">Read hello [Choose a Programming Model for your service](service-fabric-choose-framework.md) article for more information.</span></span>

<!--Every topic should have next steps and links toohello next logical set of content tookeep hello customer engaged-->
## <a name="next-steps"></a><span data-ttu-id="bfe8f-213">다음 단계</span><span class="sxs-lookup"><span data-stu-id="bfe8f-213">Next steps</span></span>
<span data-ttu-id="bfe8f-214">서비스 패브릭에 대 한 자세한 toolearn:</span><span class="sxs-lookup"><span data-stu-id="bfe8f-214">toolearn more about Service Fabric:</span></span>

* [<span data-ttu-id="bfe8f-215">서비스 패브릭의 개요</span><span class="sxs-lookup"><span data-stu-id="bfe8f-215">Overview of Service Fabric</span></span>](service-fabric-overview.md)
* [<span data-ttu-id="bfe8f-216">이유는 microservices toobuilding 응용 프로그램에 접근?</span><span class="sxs-lookup"><span data-stu-id="bfe8f-216">Why a microservices approach toobuilding applications?</span></span>](service-fabric-overview-microservices.md)
* [<span data-ttu-id="bfe8f-217">응용 프로그램 시나리오</span><span class="sxs-lookup"><span data-stu-id="bfe8f-217">Application scenarios</span></span>](service-fabric-application-scenarios.md)

