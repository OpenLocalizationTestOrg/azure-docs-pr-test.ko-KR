---
title: "서비스 패브릭 서비스의 aaaScalability | Microsoft Docs"
description: "설명 방법을 tooscale 서비스 패브릭 서비스"
services: service-fabric
documentationcenter: .net
author: masnider
manager: timlt
editor: 
ms.assetid: ed324f23-242f-47b7-af1a-e55c839e7d5d
ms.service: service-fabric
ms.devlang: dotnet
ms.topic: article
ms.tgt_pltfrm: NA
ms.workload: NA
ms.date: 08/18/2017
ms.author: masnider
ms.openlocfilehash: 5af06f8f71ad5dee32ba115b922842684867e654
ms.sourcegitcommit: 523283cc1b3c37c428e77850964dc1c33742c5f0
ms.translationtype: MT
ms.contentlocale: ko-KR
ms.lasthandoff: 10/06/2017
---
# <a name="scaling-in-service-fabric"></a><span data-ttu-id="d0425-103">Service Fabric에서 크기 조정</span><span class="sxs-lookup"><span data-stu-id="d0425-103">Scaling in Service Fabric</span></span>
<span data-ttu-id="d0425-104">Azure 서비스 패브릭 hello 서비스, 파티션 및 복제본에 클러스터의 노드를 hello 관리 하 여 확장 가능한 응용 프로그램을 쉽게 toobuild 있습니다.</span><span class="sxs-lookup"><span data-stu-id="d0425-104">Azure Service Fabric makes it easy toobuild scalable applications by managing hello services, partitions, and replicas on hello nodes of a cluster.</span></span> <span data-ttu-id="d0425-105">많은 작업을 실행 동일한 하드웨어 사용 하면 최대 리소스 사용률 hello 하지만 또한 선택 하는 방법 tooscale 작업 측면에서 유연성을 제공 합니다.</span><span class="sxs-lookup"><span data-stu-id="d0425-105">Running many workloads on hello same hardware enables maximum resource utilization, but also provides flexibility in terms of how you choose tooscale your workloads.</span></span> 

<span data-ttu-id="d0425-106">Service Fabric에서 크기를 조정하는 경우 다음과 같은 여러 가지 방법으로 수행됩니다.</span><span class="sxs-lookup"><span data-stu-id="d0425-106">Scaling in Service Fabric is accomplished several different ways:</span></span>

1. <span data-ttu-id="d0425-107">크기 조정: 상태 비저장 서비스 인스턴스 만들기 또는 제거</span><span class="sxs-lookup"><span data-stu-id="d0425-107">Scaling by creating or removing stateless service instances</span></span>
2. <span data-ttu-id="d0425-108">크기 조정: 명명된 새 서비스 만들기 또는 제거</span><span class="sxs-lookup"><span data-stu-id="d0425-108">Scaling by creating or removing new named services</span></span>
3. <span data-ttu-id="d0425-109">크기 조정: 명명된 새 응용 프로그램 인스턴스 만들기 또는 제거</span><span class="sxs-lookup"><span data-stu-id="d0425-109">Scaling by creating or removing new named application instances</span></span>
4. <span data-ttu-id="d0425-110">크기 조정: 분할된 서비스 사용</span><span class="sxs-lookup"><span data-stu-id="d0425-110">Scaling by using partitioned services</span></span>
5. <span data-ttu-id="d0425-111">추가 하 고 hello 클러스터에서 노드를 제거 하 여 크기 조정</span><span class="sxs-lookup"><span data-stu-id="d0425-111">Scaling by adding and removing nodes from hello cluster</span></span> 
6. <span data-ttu-id="d0425-112">크기 조정: 클러스터 리소스 관리자 메트릭 사용</span><span class="sxs-lookup"><span data-stu-id="d0425-112">Scaling by using Cluster Resource Manager metrics</span></span>

## <a name="scaling-by-creating-or-removing-stateless-service-instances"></a><span data-ttu-id="d0425-113">크기 조정: 상태 비저장 서비스 인스턴스 만들기 또는 제거</span><span class="sxs-lookup"><span data-stu-id="d0425-113">Scaling by creating or removing stateless service instances</span></span>
<span data-ttu-id="d0425-114">서비스 패브릭 내에서 가장 간단한 방법으로 tooscale hello 중 하나는 상태 비저장 서비스와 함께 작동합니다.</span><span class="sxs-lookup"><span data-stu-id="d0425-114">One of hello simplest ways tooscale within Service Fabric works with stateless services.</span></span> <span data-ttu-id="d0425-115">기회 toodefine 가져오기 상태 비저장 서비스를 만들 때는 `InstanceCount`합니다.</span><span class="sxs-lookup"><span data-stu-id="d0425-115">When you create a stateless service, you get a chance toodefine an `InstanceCount`.</span></span> <span data-ttu-id="d0425-116">`InstanceCount`hello 서비스가 시작 될 때 해당 서비스 코드의 실행 중인 복사본 수 만들어집니다 정의 합니다.</span><span class="sxs-lookup"><span data-stu-id="d0425-116">`InstanceCount` defines how many running copies of that service's code are created when hello service starts up.</span></span> <span data-ttu-id="d0425-117">예를 들어 hello 클러스터에 100 개의 노드가 있다고 이라고 가정해 보겠습니다.</span><span class="sxs-lookup"><span data-stu-id="d0425-117">Let's say, for example, that there are 100 nodes in hello cluster.</span></span> <span data-ttu-id="d0425-118">`InstanceCount`가 10인 서비스를 만든다고 가정해 보겠습니다.</span><span class="sxs-lookup"><span data-stu-id="d0425-118">Let's also say that a service is created with an `InstanceCount` of 10.</span></span> <span data-ttu-id="d0425-119">런타임 중 hello 코드의 10이 실행 중인 사본 모두 될 수 사용량이 또는 충분히 사용 하지 못할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="d0425-119">During runtime, those 10 running copies of hello code could all become too busy (or could be not busy enough).</span></span> <span data-ttu-id="d0425-120">한 가지 방법은 tooscale 해당 작업은 인스턴스 toochange hello 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="d0425-120">One way tooscale that workload is toochange hello number of instances.</span></span> <span data-ttu-id="d0425-121">예를 들어, 모니터링 또는 관리 코드의 몇 가지 인스턴스 too50 또는 too5 hello 기존 수를 변경, hello 작업 또는 축소에 따라 hello tooscale이 필요한 여부에 따라 로드할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="d0425-121">For example, some piece of monitoring or management code can change hello existing number of instances too50, or too5, depending on whether hello workload needs tooscale in or out based on hello load.</span></span> 

<span data-ttu-id="d0425-122">C#:</span><span class="sxs-lookup"><span data-stu-id="d0425-122">C#:</span></span>

```csharp
StatelessServiceUpdateDescription updateDescription = new StatelessServiceUpdateDescription(); 
updateDescription.InstanceCount = 50;
await fabricClient.ServiceManager.UpdateServiceAsync(new Uri("fabric:/app/service"), updateDescription);
```

<span data-ttu-id="d0425-123">Powershell:</span><span class="sxs-lookup"><span data-stu-id="d0425-123">Powershell:</span></span>

```posh
Update-ServiceFabricService -Stateless -ServiceName $serviceName -InstanceCount 50
```
### <a name="using-dynamic-instance-count"></a><span data-ttu-id="d0425-124">동적 인스턴스 수 사용</span><span class="sxs-lookup"><span data-stu-id="d0425-124">Using Dynamic Instance Count</span></span>
<span data-ttu-id="d0425-125">서비스 패브릭 특별히 상태 비저장 서비스에 자동으로 방법 toochange hello 인스턴스 수를 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="d0425-125">Specifically for stateless services, Service Fabric offers an automatic way toochange hello instance count.</span></span> <span data-ttu-id="d0425-126">이렇게 하면 사용할 수 있는 노드의 hello 수 동적으로 hello 서비스 tooscale가 있습니다.</span><span class="sxs-lookup"><span data-stu-id="d0425-126">This allows hello service tooscale dynamically with hello number of nodes that are available.</span></span> <span data-ttu-id="d0425-127">이 동작을 hello 방식으로 tooopt tooset hello 인스턴스 수는 =-1입니다.</span><span class="sxs-lookup"><span data-stu-id="d0425-127">hello way tooopt into this behavior is tooset hello instance count = -1.</span></span> <span data-ttu-id="d0425-128">InstanceCount =-1은 명령 tooService 패브릭 "모든 노드에서이 상태 비저장 서비스를 실행 합니다." 라는</span><span class="sxs-lookup"><span data-stu-id="d0425-128">InstanceCount = -1 is an instruction tooService Fabric that says "Run this stateless service on every node."</span></span> <span data-ttu-id="d0425-129">Hello 노드 수가 변경 되 면 서비스 패브릭 자동으로 변경 hello 인스턴스 개수 toomatch hello 서비스 유효한 모든 노드에서 실행 되 고 있는지 확인 합니다.</span><span class="sxs-lookup"><span data-stu-id="d0425-129">If hello number of nodes changes, Service Fabric automatically changes hello instance count toomatch, ensuring that hello service is running on all valid nodes.</span></span> 

<span data-ttu-id="d0425-130">C#:</span><span class="sxs-lookup"><span data-stu-id="d0425-130">C#:</span></span>

```csharp
StatelessServiceDescription serviceDescription = new StatelessServiceDescription();
//Set other service properties necessary for creation....
serviceDescription.InstanceCount = -1;
await fc.ServiceManager.CreateServiceAsync(serviceDescription);
```

<span data-ttu-id="d0425-131">Powershell:</span><span class="sxs-lookup"><span data-stu-id="d0425-131">Powershell:</span></span>

```posh
New-ServiceFabricService -ApplicationName $applicationName -ServiceName $serviceName -ServiceTypeName $serviceTypeName -Stateless -PartitionSchemeSingleton -InstanceCount "-1"
```

## <a name="scaling-by-creating-or-removing-new-named-services"></a><span data-ttu-id="d0425-132">크기 조정: 명명된 새 서비스 만들기 또는 제거</span><span class="sxs-lookup"><span data-stu-id="d0425-132">Scaling by creating or removing new named services</span></span>
<span data-ttu-id="d0425-133">지정 된 서비스 인스턴스가 서비스 유형의 특정 인스턴스가 (참조 [서비스 패브릭 응용 프로그램 수명 주기](service-fabric-application-lifecycle.md)) hello 클러스터의 일부 응용 프로그램 명명 된 인스턴스 내에서.</span><span class="sxs-lookup"><span data-stu-id="d0425-133">A named service instance is a specific instance of a service type (see [Service Fabric application life cycle](service-fabric-application-lifecycle.md)) within some named application instance in hello cluster.</span></span> 

<span data-ttu-id="d0425-134">서비스가 더 많거나 적게 사용됨에 따라 명명된 새 서비스 인스턴스가 만들어지거나 제거될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="d0425-134">New named service instances can be created (or removed) as services become more or less busy.</span></span> <span data-ttu-id="d0425-135">따라서 요청 toobe를 일반적으로 기존 서비스 toodecrease의 부하를 허용 하는 더 많은 서비스 인스턴스를 분산할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="d0425-135">This allows requests toobe spread across more service instances, usually allowing load on existing services toodecrease.</span></span> <span data-ttu-id="d0425-136">서비스를 만들 때 서비스 패브릭 클러스터 리소스 관리자 hello hello 서비스를 분산 방식에서 hello 클러스터에 배치 합니다.</span><span class="sxs-lookup"><span data-stu-id="d0425-136">When creating services, hello Service Fabric Cluster Resource Manager places hello services in hello cluster in a distributed fashion.</span></span> <span data-ttu-id="d0425-137">hello 정확한 결정 hello에 따라 관리 됩니다 [메트릭](service-fabric-cluster-resource-manager-metrics.md) hello 클러스터 및 기타 배치 규칙의 합니다.</span><span class="sxs-lookup"><span data-stu-id="d0425-137">hello exact decisions are governed by hello [metrics](service-fabric-cluster-resource-manager-metrics.md) in hello cluster and other placement rules.</span></span> <span data-ttu-id="d0425-138">서비스를 여러 가지 방법으로 만들 수 있지만 hello 가장 일반적으로는 호출 하는 등의 관리 작업을 통해 [ `New-ServiceFabricService` ](https://docs.microsoft.com/en-us/powershell/module/servicefabric/new-servicefabricservice?view=azureservicefabricps), 또는 코드를 호출 하 여 [ `CreateServiceAsync` ](https://docs.microsoft.com/en-us/dotnet/api/system.fabric.fabricclient.servicemanagementclient.createserviceasync?view=azure-dotnet)합니다.</span><span class="sxs-lookup"><span data-stu-id="d0425-138">Services can be created several different ways, but hello most common are either through administrative actions like someone calling [`New-ServiceFabricService`](https://docs.microsoft.com/en-us/powershell/module/servicefabric/new-servicefabricservice?view=azureservicefabricps), or by code calling [`CreateServiceAsync`](https://docs.microsoft.com/en-us/dotnet/api/system.fabric.fabricclient.servicemanagementclient.createserviceasync?view=azure-dotnet).</span></span> <span data-ttu-id="d0425-139">`CreateServiceAsync`도 호출할 수 있습니다에서 hello 클러스터에서 실행 되는 다른 서비스 내에서.</span><span class="sxs-lookup"><span data-stu-id="d0425-139">`CreateServiceAsync` can even be called from within other services running in hello cluster.</span></span>

<span data-ttu-id="d0425-140">서비스를 동적으로 만들면 모든 종류의 시나리오에서 사용할 수 있으며 일반적인 패턴입니다.</span><span class="sxs-lookup"><span data-stu-id="d0425-140">Creating services dynamically can be used in all sorts of scenarios, and is a common pattern.</span></span> <span data-ttu-id="d0425-141">예를 들어 특정 워크플로를 나타내는 상태 저장 서비스를 고려합니다.</span><span class="sxs-lookup"><span data-stu-id="d0425-141">For example, consider a stateful service that represents a particular workflow.</span></span> <span data-ttu-id="d0425-142">호출 작업을 나타내는 toothis 서비스를 tooshow 숨겨지며이 서비스는 진행 중인 tooexecute hello 단계 toothat 워크플로 및 레코드 진행 합니다.</span><span class="sxs-lookup"><span data-stu-id="d0425-142">Calls representing work are going tooshow up toothis service, and this service is going tooexecute hello steps toothat workflow and record progress.</span></span> 

<span data-ttu-id="d0425-143">이 특정 서비스 규모를 어떻게 수행한 것? hello 서비스 될 수 있습니다 어떤 형태로 다중 테 넌 트 및 호출 수락 고 같은 다양 한 인스턴스의 hello에 대 한 단계를 시작 워크플로 한 번에 모두 있습니다.</span><span class="sxs-lookup"><span data-stu-id="d0425-143">How would you make this particular service scale? hello service could be multi-tenant in some form, and accept calls and kick off steps for many different instances of hello same workflow all at once.</span></span> <span data-ttu-id="d0425-144">그러나를 만들 수는 hello 코드 이후 더 복잡 한 tooworry 다양 한 인스턴스의 hello에 대 한 현재 다양 한 고객에서 및 다양 한 단계에서 모두 동일한 워크플로의 합니다.</span><span class="sxs-lookup"><span data-stu-id="d0425-144">However, that can make hello code more complex, since now it has tooworry about many different instances of hello same workflow, all at different stages and from different customers.</span></span> <span data-ttu-id="d0425-145">또한 눈금 문제 hello hello 해결 되지 않으면 동시에 여러 워크플로 처리 합니다.</span><span class="sxs-lookup"><span data-stu-id="d0425-145">Also, handling multiple workflows at hello same time doesn't solve hello scale problem.</span></span> <span data-ttu-id="d0425-146">즉, 특정 시점에이 서비스는 특정 컴퓨터에서 너무 많은 리소스 toofit 사용 합니다.</span><span class="sxs-lookup"><span data-stu-id="d0425-146">This is because at some point this service will consume too many resources toofit on a particular machine.</span></span> <span data-ttu-id="d0425-147">또한 hello 첫 번째 위치에서이 패턴에 대 한 기본 제공 되지 않는 많은 서비스 코드 toosome 내재 된 병목 현상 또는 저하 인해 어려움을 겪을 합니다.</span><span class="sxs-lookup"><span data-stu-id="d0425-147">Many services not built for this pattern in hello first place also experience difficulty due toosome inherent bottleneck or slowdown in their code.</span></span> <span data-ttu-id="d0425-148">이러한 유형의 문제를 추적 하는 동시 워크플로 hello 수를 더 큰 가져오면 hello 서비스 하지 toowork도를 일으킬 있습니다.</span><span class="sxs-lookup"><span data-stu-id="d0425-148">These types of issues cause hello service not toowork as well when hello number of concurrent workflows it is tracking gets larger.</span></span>  

<span data-ttu-id="d0425-149">솔루션은 toocreate 인스턴스 tootrack hello 워크플로의 모든 다른 인스턴스에 대해이 서비스의 원하는 합니다.</span><span class="sxs-lookup"><span data-stu-id="d0425-149">A solution is toocreate an instance of this service for every different instance of hello workflow you want tootrack.</span></span> <span data-ttu-id="d0425-150">유용한 패턴 이므로 hello 서비스는 상태 저장 또는 상태 비저장 든 작동 합니다.</span><span class="sxs-lookup"><span data-stu-id="d0425-150">This is a great pattern and works whether hello service is stateless or stateful.</span></span> <span data-ttu-id="d0425-151">이 패턴 toowork에는 일반적으로 다른 서비스 "작업 관리자 서비스" 역할입니다.</span><span class="sxs-lookup"><span data-stu-id="d0425-151">For this pattern toowork, there's usually another service that acts as a "Workload Manager Service".</span></span> <span data-ttu-id="d0425-152">이 서비스의 작업을 hello tooreceive 요청과 tooroute 이러한 요청 tooother 서비스입니다.</span><span class="sxs-lookup"><span data-stu-id="d0425-152">hello job of this service is tooreceive requests and tooroute those requests tooother services.</span></span> <span data-ttu-id="d0425-153">hello 관리자 hello 메시지를 받을 때 hello 작업 서비스의 인스턴스를 동적으로 만들 수 있습니다 및 요청 toothose 서비스에 전달 합니다.</span><span class="sxs-lookup"><span data-stu-id="d0425-153">hello manager can dynamically create an instance of hello workload service when it receives hello message, and then pass on requests toothose services.</span></span> <span data-ttu-id="d0425-154">또한 hello 관리자 서비스는 지정 된 워크플로 서비스 작업 완료 되 면 콜백을 받을 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="d0425-154">hello manager service could also receive callbacks when a given workflow service completes its job.</span></span> <span data-ttu-id="d0425-155">Hello 관리자가 이러한 콜백을 받는 경우 hello 워크플로 서비스의 해당 인스턴스를 삭제 또는 이상의 호출을 예상 되는 경우 사용자에 게 그대로 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="d0425-155">When hello manager receives these callbacks it could delete that instance of hello workflow service, or leave it if more calls are expected.</span></span> 

<span data-ttu-id="d0425-156">이러한 유형의 관리자의 고급 버전 관리 하는 hello 서비스의 풀 만들 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="d0425-156">Advanced versions of this type of manager can even create pools of hello services that it manages.</span></span> <span data-ttu-id="d0425-157">hello 풀은 새 요청이 들어올 때 없다는 toowait 서비스 toospin hello에 대 한 확인 하는 데 도움이 됩니다.</span><span class="sxs-lookup"><span data-stu-id="d0425-157">hello pool helps ensure that when a new request comes in it doesn't have toowait for hello service toospin up.</span></span> <span data-ttu-id="d0425-158">대신, hello 관리자 수 방금 hello 풀에서 현재 사용 중 없는 워크플로 서비스를 선택 하거나 임의로 라우팅할 합니다.</span><span class="sxs-lookup"><span data-stu-id="d0425-158">Instead, hello manager can just pick a workflow service that is not currently busy from hello pool, or route randomly.</span></span> <span data-ttu-id="d0425-159">사용할 수 있는 서비스 풀을 유지 하면 새 요청을 처리 보다 빠르게 이기는 hello 요청에 생성 되는 새 서비스 toobe에 대 한 toowait 될 가능성이 적기 때문 있습니다.</span><span class="sxs-lookup"><span data-stu-id="d0425-159">Keeping a pool of services available makes handling new requests faster, since it is less likely that hello request has toowait for a new service toobe spun up.</span></span> <span data-ttu-id="d0425-160">새 서비스를 만드는 것은 빠르지만 자유롭거나 즉각적이지는 않습니다.</span><span class="sxs-lookup"><span data-stu-id="d0425-160">Creating new services is quick, but not free or instantaneous.</span></span> <span data-ttu-id="d0425-161">hello 풀은 hello hello 요청 서비스를 제공 하기 전에 toowait에 시간을 최소화 하는 데 도움이 됩니다.</span><span class="sxs-lookup"><span data-stu-id="d0425-161">hello pool helps minimize hello amount of time hello request has toowait before being serviced.</span></span> <span data-ttu-id="d0425-162">응답 시간이 가장 중요 한 문제 hello 때 종종이 관리자 및 풀 패턴을 볼 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="d0425-162">You'll often see this manager and pool pattern when response times matter hello most.</span></span> <span data-ttu-id="d0425-163">큐 hello 요청 및 hello 백그라운드에서 만드는 hello 서비스 및 _다음_ 에 전달할 이기도 인기 있는 관리자 패턴을 만들고 일부 추적 hello 작업량의 해당 서비스가 현재 기반 서비스를 삭제 하는 대로 보류 중인 합니다.</span><span class="sxs-lookup"><span data-stu-id="d0425-163">Queuing hello request and creating hello service in hello background and _then_ passing it on is also a popular manager pattern, as is creating and deleting services based on some tracking of hello amount of work that service currently has pending.</span></span> 

## <a name="scaling-by-creating-or-removing-new-named-application-instances"></a><span data-ttu-id="d0425-164">크기 조정: 명명된 새 응용 프로그램 인스턴스 만들기 또는 제거</span><span class="sxs-lookup"><span data-stu-id="d0425-164">Scaling by creating or removing new named application instances</span></span>
<span data-ttu-id="d0425-165">만들기 및 전체 응용 프로그램 인스턴스 삭제는 비슷한 toohello 패턴을 만들고 서비스를 삭제입니다.</span><span class="sxs-lookup"><span data-stu-id="d0425-165">Creating and deleting whole application instances is similar toohello pattern of creating and deleting services.</span></span> <span data-ttu-id="d0425-166">이 패턴에 대 한 hello 요청은 표시 된 것에 따라 hello 의사 결정을 수행 하는 몇 가지 관리자 서비스 않으며에서 발생 하는 hello 정보 hello hello 클러스터 내의 다른 서비스입니다.</span><span class="sxs-lookup"><span data-stu-id="d0425-166">For this pattern, there's some manager service that is making hello decision based on hello requests that it is seeing and hello information it is receiving from hello other services inside hello cluster.</span></span> 

<span data-ttu-id="d0425-167">어떤 기존 응용 프로그램에서 명명된 새 서비스 인스턴스를 만드는 대신 명명된 새 응용 프로그램 인스턴스를 만들어야 하나요?</span><span class="sxs-lookup"><span data-stu-id="d0425-167">When should creating a new named application instance be used instead of creating a new named service instances in some already existing application?</span></span> <span data-ttu-id="d0425-168">여기에는 다음 몇 가지 경우가 있습니다.</span><span class="sxs-lookup"><span data-stu-id="d0425-168">There's a few cases:</span></span>

  * <span data-ttu-id="d0425-169">hello 새 응용 프로그램 인스턴스가 해당 코드 toorun 일부 특정 id 또는 보안 설정에 필요한 고객에 대 한 합니다.</span><span class="sxs-lookup"><span data-stu-id="d0425-169">hello new application instance is for a customer whose code needs toorun under some particular identity or security settings.</span></span>
    * <span data-ttu-id="d0425-170">서비스 패브릭 서로 다른 코드 패키지 toorun 특정 id를 정의할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="d0425-170">Service Fabric allows defining different code packages toorun under particular identities.</span></span> <span data-ttu-id="d0425-171">순서 toolaunch hello hello 정품 인증 하는 서로 다른 id로 동일한 코드 패키지 해야 toooccur 서로 다른 응용 프로그램의 경우.</span><span class="sxs-lookup"><span data-stu-id="d0425-171">In order toolaunch hello same code package under different identities, hello activations need toooccur in different application instances.</span></span> <span data-ttu-id="d0425-172">기존 고객의 워크로드가 배포되는 경우를 고려합니다.</span><span class="sxs-lookup"><span data-stu-id="d0425-172">Consider a case where you have an existing customer's workloads deployed.</span></span> <span data-ttu-id="d0425-173">이러한 모니터링 하 고 원격 데이터베이스 또는 다른 시스템 등 액세스 tooother 리소스가 제어할 수 있도록 특정 id를 서비스가 실행 될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="d0425-173">These may be running under a particular identity so you can monitor and control their access tooother resources, such as remote databases or other systems.</span></span> <span data-ttu-id="d0425-174">이 경우 새 고객 등록 하는 경우 원하지 않을 것 tooactivate hello의 코드 동일한 컨텍스트 (프로세스 공간)입니다.</span><span class="sxs-lookup"><span data-stu-id="d0425-174">In this case, when a new customer signs up, you probably don't want tooactivate their code in hello same context (process space).</span></span> <span data-ttu-id="d0425-175">할 수 하는 동안 것이 어려워집니다 특정 id의 hello 컨텍스트 내에서 서비스 코드 tooact 프로그램에 대 한 합니다.</span><span class="sxs-lookup"><span data-stu-id="d0425-175">While you could, this makes it harder for your service code tooact within hello context of a particular identity.</span></span> <span data-ttu-id="d0425-176">일반적으로 더 많은 보안, 격리 및 ID 관리 코드가 있어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="d0425-176">You typically must have more security, isolation, and identity management code.</span></span> <span data-ttu-id="d0425-177">사용 하는 대신 다른 서비스의 명명 된 인스턴스 내 같은 응용 프로그램 인스턴스에 hello 및 동일한 프로세스 공간 따라서 hello, 서로 다른 명명 된 서비스 패브릭 응용 프로그램 인스턴스를 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="d0425-177">Instead of using different named service instances within hello same application instance and hence hello same process space, you can use different named Service Fabric Application instances.</span></span> <span data-ttu-id="d0425-178">이렇게 하면 보다 쉽게 toodefine 서로 다른 id 컨텍스트.</span><span class="sxs-lookup"><span data-stu-id="d0425-178">This makes it easier toodefine different identity contexts.</span></span>
  * <span data-ttu-id="d0425-179">새 응용 프로그램 인스턴스 hello 구성 하는 방법으로도 사용</span><span class="sxs-lookup"><span data-stu-id="d0425-179">hello new application instance also serves as a means of configuration</span></span>
    * <span data-ttu-id="d0425-180">기본적으로 모든 응용 프로그램 인스턴스 내에서 특정 서비스 유형의 서비스 인스턴스를 명명 된 hello hello 지정 된 노드에서 동일한 프로세스에서 실행 됩니다.</span><span class="sxs-lookup"><span data-stu-id="d0425-180">By default, all of hello named service instances of a particular service type within an application instance will run in hello same process on a given node.</span></span> <span data-ttu-id="d0425-181">즉 각 서비스 인스턴스마다 다르게 구성할 수 있지만 이 방법은 복잡합니다.</span><span class="sxs-lookup"><span data-stu-id="d0425-181">What this means is that while you can configure each service instance differently, doing so is complicated.</span></span> <span data-ttu-id="d0425-182">서비스는 toolook 구성 패키지 내에서 해당 구성을 사용 하는 몇 가지 토큰이 있어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="d0425-182">Services must have some token they use toolook up their config within a configuration package.</span></span> <span data-ttu-id="d0425-183">일반적으로 바로 hello 서비스의 이름입니다.</span><span class="sxs-lookup"><span data-stu-id="d0425-183">Usually this is just hello service's name.</span></span> <span data-ttu-id="d0425-184">이 정상적으로 작동 하지만 해당 응용 프로그램 인스턴스 내 hello 개별 명명 된 서비스 인스턴스의 hello 구성 toohello 이름을 결합 합니다.</span><span class="sxs-lookup"><span data-stu-id="d0425-184">This works fine, but it couples hello configuration toohello names of hello individual named service instances within that application instance.</span></span> <span data-ttu-id="d0425-185">이 혼동 될 수 있으며 구성 이후 하드 toomanage는 일반적으로 응용 프로그램 인스턴스 특정 값으로 디자인 타임 아티팩트입니다.</span><span class="sxs-lookup"><span data-stu-id="d0425-185">This can be confusing and hard toomanage since configuration is normally a design time artifact with application instance specific values.</span></span> <span data-ttu-id="d0425-186">더 많은 서비스를 항상 만들기 의미 더 많은 응용 프로그램 업그레이드 hello 구성 패키지 또는 toodeploy 새로 내 toochange hello 정보 hello 새 서비스의 특정 정보를 볼 수 있도록 합니다.</span><span class="sxs-lookup"><span data-stu-id="d0425-186">Creating more services always means more application upgrades toochange hello information within hello config packages or toodeploy new ones so that hello new services can look up their specific information.</span></span> <span data-ttu-id="d0425-187">것이 더 쉽게 toocreate 완전히 새로운 응용 프로그램 명명 된 인스턴스입니다.</span><span class="sxs-lookup"><span data-stu-id="d0425-187">It's often easier toocreate a whole new named application instance.</span></span> <span data-ttu-id="d0425-188">그런 다음 모든 구성은 hello 서비스에 대 한 필요 hello 응용 프로그램 매개 변수 tooset 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="d0425-188">Then you can use hello application parameters tooset whatever configuration is necessary for hello services.</span></span> <span data-ttu-id="d0425-189">이러한 방식으로 hello 서비스 내에 만들어진 모든 응용 프로그램 인스턴스는 명명 된 특정 구성 설정을 상속할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="d0425-189">This way all of hello services that are created within that named application instance can inherit particular configuration settings.</span></span> <span data-ttu-id="d0425-190">예를 들어 hello 설정 및 암호와 같은 또는 고객 리소스 제한 당 모든 고객에 대 한 사용자 지정 된 단일 구성 파일 대신 대신 해야 다른 응용 프로그램 인스턴스를 이러한 설정 사용 하 여 각 고객에 대 한 재정의 합니다.</span><span class="sxs-lookup"><span data-stu-id="d0425-190">For example, instead of having a single configuration file with hello settings and customizations for every customer, such as secrets or per customer resource limits, you'd instead have a different application instance for each customer with these settings overridden.</span></span> 
  * <span data-ttu-id="d0425-191">업그레이드 한계로 hello 새 응용 프로그램 역</span><span class="sxs-lookup"><span data-stu-id="d0425-191">hello new application serves as an upgrade boundary</span></span>
    * <span data-ttu-id="d0425-192">Service Fabric 내에서 명명된 다른 응용 프로그램 인스턴스는 업그레이드를 위한 경계 역할을 합니다.</span><span class="sxs-lookup"><span data-stu-id="d0425-192">Within Service Fabric, different named application instances serve as boundaries for upgrade.</span></span> <span data-ttu-id="d0425-193">단일 명명 된 응용 프로그램 인스턴스를 업그레이드 하는 다른 명명 된 응용 프로그램 인스턴스가 실행 되는 hello 코드를 영향을 주지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="d0425-193">An upgrade of one named application instance will not impact hello code that another named application instance is running.</span></span> <span data-ttu-id="d0425-194">hello 서로 다른 응용 프로그램은 실행 될 서로 다른 버전의 코드 hello의 hello에 같은 노드.</span><span class="sxs-lookup"><span data-stu-id="d0425-194">hello different applications will end up running different versions of hello same code on hello same nodes.</span></span> <span data-ttu-id="d0425-195">또는 not으로 다른 서비스를 업그레이드 동일 hello 새 코드 hello 따라야 하는지 여부를 선택할 수 있으므로 toomake 크기 조정 의사 결정을 할 때이 비율을 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="d0425-195">This can be a factor when you need toomake a scaling decision because you can choose whether hello new code should follow hello same upgrades as another service or not.</span></span> <span data-ttu-id="d0425-196">예를 들어, 특정 고객의 작업을 만들고 서비스를 동적으로 삭제 하 여 크기 조정 작업을 담당 하는 hello 관리자 서비스 도착 호출 합니다.</span><span class="sxs-lookup"><span data-stu-id="d0425-196">For example, say that a call arrives at hello manager service that is responsible for scaling a particular customer's workloads by creating and deleting services dynamically.</span></span> <span data-ttu-id="d0425-197">그러나이 경우 hello 호출은 연결 된 작업에는 _새_ 고객 합니다.</span><span class="sxs-lookup"><span data-stu-id="d0425-197">In this case however, hello call is for a workload associated with a _new_ customer.</span></span> <span data-ttu-id="d0425-198">대부분의 고객 뿐 아니라 이유로 hello 보안 및 구성 이전에 표시 된를 서로 격리 된 비슷하지만 특정 버전의 hello 소프트웨어 선택 및 실행 측면에서 더 많은 유연성을 제공 하기 때문에 이러한 가져오기 업그레이드할 때.</span><span class="sxs-lookup"><span data-stu-id="d0425-198">Most customers like being isolated from each other not just for hello security and configuration reasons listed previously, but because it provides more flexibility in terms of running specific versions of hello software and choosing when they get upgraded.</span></span> <span data-ttu-id="d0425-199">또한 새 응용 프로그램 인스턴스를 만들고 및 hello 서비스를 만들 수 있습니다 있습니다 toofurther 파티션 단순히 hello 업그레이드를 한 번 닿는 서비스입니다.</span><span class="sxs-lookup"><span data-stu-id="d0425-199">You may also create a new application instance and create hello service there simply toofurther partition hello amount of your services that any one upgrade will touch.</span></span> <span data-ttu-id="d0425-200">별도의 응용 프로그램 인스턴스에서 응용 프로그램 업그레이드를 수행할 때 더 자세한 세분성을 제공하며, A/B 테스트 및 파랑/녹색 배포도 가능하게 합니다.</span><span class="sxs-lookup"><span data-stu-id="d0425-200">Separate application instances provide greater granularity when doing application upgrades, and also enable A/B testing and Blue/Green deployments.</span></span> 
  * <span data-ttu-id="d0425-201">기존 응용 프로그램 인스턴스가 hello 꽉</span><span class="sxs-lookup"><span data-stu-id="d0425-201">hello existing application instance is full</span></span>
    * <span data-ttu-id="d0425-202">서비스 패브릭에서 [응용 프로그램 용량](service-fabric-cluster-resource-manager-application-groups.md) 는 특정 응용 프로그램 인스턴스에 대해 toocontrol hello 양을 사용 가능한 리소스를 사용할 수 있는 개념입니다.</span><span class="sxs-lookup"><span data-stu-id="d0425-202">In Service Fabric, [application capacity](service-fabric-cluster-resource-manager-application-groups.md) is a concept that you can use toocontrol hello amount of resources available for particular application instances.</span></span> <span data-ttu-id="d0425-203">예를 들어, 주어진된 서비스가 필요한 순서 tooscale에서 만든 다른 인스턴스 toohave 있는지 결정할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="d0425-203">For example, you may decide that a given service needs toohave another instance created in order tooscale.</span></span> <span data-ttu-id="d0425-204">그러나 이 응용 프로그램 인스턴스에는 특정 메트릭에 대한 용량이 부족합니다.</span><span class="sxs-lookup"><span data-stu-id="d0425-204">However, this application instance is out of capacity for a certain metric.</span></span> <span data-ttu-id="d0425-205">이 특정 고객 또는 워크 로드 해야 계속 부여할 수 있으면 더 많은 리소스, 있습니다 수 hello 해당 응용 프로그램에 대 한 기존 용량을 늘릴 하거나 새 응용 프로그램을 만듭니다.</span><span class="sxs-lookup"><span data-stu-id="d0425-205">If this particular customer or workload should still be granted more resources, then you could either increase hello existing capacity for that application or create a new application.</span></span> 

## <a name="scaling-at-hello-partition-level"></a><span data-ttu-id="d0425-206">Hello 파티션 수준에서 크기 조정</span><span class="sxs-lookup"><span data-stu-id="d0425-206">Scaling at hello partition level</span></span>
<span data-ttu-id="d0425-207">Service Fabric은 파티션을 지원합니다.</span><span class="sxs-lookup"><span data-stu-id="d0425-207">Service Fabric supports partitioning.</span></span> <span data-ttu-id="d0425-208">분할은 서비스를 여러 논리적 및 물리적 섹션으로 나누며, 각 섹션은 독립적으로 작동합니다.</span><span class="sxs-lookup"><span data-stu-id="d0425-208">Partitioning splits a service into several logical and physical sections, each of which operates independently.</span></span> <span data-ttu-id="d0425-209">이 상태 저장 서비스에 유용을 아무도 복제본의 설정 때문에 toohandle hello에 대 한 모든 호출에 한 번에 모든 hello 상태를 조작 합니다.</span><span class="sxs-lookup"><span data-stu-id="d0425-209">This is useful with stateful services, since no one set of replicas has toohandle all hello calls and manipulate all of hello state at once.</span></span> <span data-ttu-id="d0425-210">hello [개요 분할](service-fabric-concepts-partitioning.md) hello 유형의 지원 되는 파티션 구성표에 대해 설명 합니다.</span><span class="sxs-lookup"><span data-stu-id="d0425-210">hello [partitioning overview](service-fabric-concepts-partitioning.md) provides information on hello types of partitioning schemes that are supported.</span></span> <span data-ttu-id="d0425-211">각 파티션의 hello 복제본 클러스터에서 해당 서비스의 부하를 분산 하 고, 두 hello 서비스 전체 또는 파티션의 단일 실패 지점이 있음을 보장 hello 노드에 분산 됩니다.</span><span class="sxs-lookup"><span data-stu-id="d0425-211">hello replicas of each partition are spread across hello nodes in a cluster, distributing that service's load and ensuring that neither hello service as a whole or any partition has a single point of failure.</span></span> 

<span data-ttu-id="d0425-212">서비스가 0개의 하위 키, 99개의 상위 키 및 4개의 파티션 개수를 가진 범위 지정 파티션 구성표를 사용한다고 가정합니다.</span><span class="sxs-lookup"><span data-stu-id="d0425-212">Consider a service that uses a ranged partitioning scheme with a low key of 0, a high key of 99, and a partition count of 4.</span></span> <span data-ttu-id="d0425-213">3 노드 클러스터에서 hello 서비스 다음과 같이 각 노드에서 hello 리소스를 공유 하는 4 개의 복제본으로 배치할지 수 있습니다.:</span><span class="sxs-lookup"><span data-stu-id="d0425-213">In a three-node cluster, hello service might be laid out with four replicas that share hello resources on each node as shown here:</span></span>

<span data-ttu-id="d0425-214"><center>
![3개의 노드가 있는 파티션 레이아웃](./media/service-fabric-concepts-scalability/layout-three-nodes.png)
</center></span><span class="sxs-lookup"><span data-stu-id="d0425-214"><center>
![Partition layout with three nodes](./media/service-fabric-concepts-scalability/layout-three-nodes.png)
</center></span></span>

<span data-ttu-id="d0425-215">Hello 노드 수를 늘리면 서비스 패브릭 옮겨집니다 hello 기존 복제본의 일부 있습니다.</span><span class="sxs-lookup"><span data-stu-id="d0425-215">If you increase hello number of nodes, Service Fabric will move some of hello existing replicas there.</span></span> <span data-ttu-id="d0425-216">예를 들어 hello 노드 수가 증가 toofour 빌드하고 hello 복제본 가져오기 가정해 봅니다.</span><span class="sxs-lookup"><span data-stu-id="d0425-216">For example, let's say hello number of nodes increases toofour and hello replicas get redistributed.</span></span> <span data-ttu-id="d0425-217">Toodifferent 파티션에 속하는 각 이제 hello 서비스는 각 노드에서 실행 하는 3 개의 복제본, 이제 합니다.</span><span class="sxs-lookup"><span data-stu-id="d0425-217">Now hello service now has three replicas running on each node, each belonging toodifferent partitions.</span></span> <span data-ttu-id="d0425-218">이렇게 하면 hello 새 노드가 콜드 되지 않으면 이후 보다 우수한 리소스 사용률과가 있습니다.</span><span class="sxs-lookup"><span data-stu-id="d0425-218">This allows better resource utilization since hello new node isn't cold.</span></span> <span data-ttu-id="d0425-219">일반적으로 성능이 향상 됩니다 각 서비스에 더 많은 리소스가 사용 가능한 tooit 합니다.</span><span class="sxs-lookup"><span data-stu-id="d0425-219">Typically, it also improves performance as each service has more resources available tooit.</span></span>

<span data-ttu-id="d0425-220"><center>
![4개의 노드가 있는 파티션 레이아웃](./media/service-fabric-concepts-scalability/layout-four-nodes.png)
</center></span><span class="sxs-lookup"><span data-stu-id="d0425-220"><center>
![Partition layout with four nodes](./media/service-fabric-concepts-scalability/layout-four-nodes.png)
</center></span></span>

## <a name="scaling-by-using-hello-service-fabric-cluster-resource-manager-and-metrics"></a><span data-ttu-id="d0425-221">서비스 패브릭 클러스터 리소스 관리자 hello 및 메트릭을 사용 하 여 크기 조정</span><span class="sxs-lookup"><span data-stu-id="d0425-221">Scaling by using hello Service Fabric Cluster Resource Manager and metrics</span></span>
<span data-ttu-id="d0425-222">[메트릭](service-fabric-cluster-resource-manager-metrics.md) 서비스 패브릭의 리소스 소비 tooService를 표현 하는 방법이 됩니다.</span><span class="sxs-lookup"><span data-stu-id="d0425-222">[Metrics](service-fabric-cluster-resource-manager-metrics.md) are how services express their resource consumption tooService Fabric.</span></span> <span data-ttu-id="d0425-223">메트릭을 사용 하 여 기회 tooreorganize hello 클러스터 리소스 관리자를 제공 하 고 hello 클러스터의 hello 레이아웃을 최적화 합니다.</span><span class="sxs-lookup"><span data-stu-id="d0425-223">Using metrics gives hello Cluster Resource Manager an opportunity tooreorganize and optimize hello layout of hello cluster.</span></span> <span data-ttu-id="d0425-224">예를 들어 hello 클러스터에 리소스를 많이 있을 수 있지만 있습니다 수를 할당할 수 toohello 서비스를 현재 작업을 수행 합니다.</span><span class="sxs-lookup"><span data-stu-id="d0425-224">For example, there may be plenty of resources in hello cluster, but they might not be allocated toohello services that are currently doing work.</span></span> <span data-ttu-id="d0425-225">메트릭을 사용 하면 클러스터 리소스 관리자 tooreorganize hello 액세스할 수 있는 서비스는 hello 클러스터 tooensure toohello 사용 가능한 리소스입니다.</span><span class="sxs-lookup"><span data-stu-id="d0425-225">Using metrics allows hello Cluster Resource Manager tooreorganize hello cluster tooensure that services have access toohello available resources.</span></span> 


## <a name="scaling-by-adding-and-removing-nodes-from-hello-cluster"></a><span data-ttu-id="d0425-226">추가 하 고 hello 클러스터에서 노드를 제거 하 여 크기 조정</span><span class="sxs-lookup"><span data-stu-id="d0425-226">Scaling by adding and removing nodes from hello cluster</span></span> 
<span data-ttu-id="d0425-227">서비스 패브릭 크기 조정에 대 한 또 다른 옵션에는 hello 클러스터의 toochange hello 크기입니다.</span><span class="sxs-lookup"><span data-stu-id="d0425-227">Another option for scaling with Service Fabric is toochange hello size of hello cluster.</span></span> <span data-ttu-id="d0425-228">노드 추가 또는 제거 하나 이상의 hello 노드 형식에 대 한 hello 클러스터의 의미 hello hello 클러스터 크기를 변경 합니다.</span><span class="sxs-lookup"><span data-stu-id="d0425-228">Changing hello size of hello cluster means adding or removing nodes for one or more of hello node types in hello cluster.</span></span> <span data-ttu-id="d0425-229">예를 들어 들어 hello 클러스터에서 hello 노드의 모든는 핫 하는 경우.</span><span class="sxs-lookup"><span data-stu-id="d0425-229">For example, consider a case where all of hello nodes in hello cluster are hot.</span></span> <span data-ttu-id="d0425-230">즉, hello 클러스터의 리소스를 거의 모두 사용 됩니다.</span><span class="sxs-lookup"><span data-stu-id="d0425-230">This means that hello cluster's resources are almost all consumed.</span></span> <span data-ttu-id="d0425-231">클러스터에 가장 좋은 방법은 tooscale hello는이 경우 더 많은 노드 toohello 추가 합니다.</span><span class="sxs-lookup"><span data-stu-id="d0425-231">In this case, adding more nodes toohello cluster is hello best way tooscale.</span></span> <span data-ttu-id="d0425-232">Hello 새 노드 가입 hello 클러스터 hello 서비스 패브릭 클러스터 리소스 관리자 이동 서비스 toothem hello 기존 노드에 대 한 전체 부하를 생성 합니다.</span><span class="sxs-lookup"><span data-stu-id="d0425-232">Once hello new nodes join hello cluster hello Service Fabric Cluster Resource Manager moves services toothem, resulting in less total load on hello existing nodes.</span></span> <span data-ttu-id="d0425-233">인스턴스 수가 -1인 상태 비저장 서비스의 경우 더 많은 서비스 인스턴스가 자동으로 만들어집니다.</span><span class="sxs-lookup"><span data-stu-id="d0425-233">For stateless services with instance count = -1, more service instances are automatically created.</span></span> <span data-ttu-id="d0425-234">따라서 일부 호출 toomove를 hello 기존 노드 toohello 새 노드를 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="d0425-234">This allows some calls toomove from hello existing nodes toohello new nodes.</span></span> 

<span data-ttu-id="d0425-235">추가 및 제거 노드 toohello 클러스터 hello 서비스 패브릭 Azure 리소스 관리자 PowerShell 모듈을 통해 수행할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="d0425-235">Adding and removing nodes toohello cluster can be accomplished via hello Service Fabric Azure Resource Manager PowerShell module.</span></span>

```posh
Add-AzureRmServiceFabricNode -ResourceGroupName $resourceGroupName -Name $clusterResourceName -NodeType $nodeTypeName  -NumberOfNodesToAdd 5 
Remove-AzureRmServiceFabricNode -ResourceGroupName $resourceGroupName -Name $clusterResourceName -NodeType $nodeTypeName -NumberOfNodesToRemove 5
```

## <a name="putting-it-all-together"></a><span data-ttu-id="d0425-236">모든 항목 요약</span><span class="sxs-lookup"><span data-stu-id="d0425-236">Putting it all together</span></span>
<span data-ttu-id="d0425-237">여기에 설명 된 하 고 예를 통해 통신 하는 모든 hello 아이디어 보겠습니다.</span><span class="sxs-lookup"><span data-stu-id="d0425-237">Let's take all hello ideas that we've discussed here and talk through an example.</span></span> <span data-ttu-id="d0425-238">서비스는 hello 고려: 고치려는 toobuild 주소록을 역할을 하는 서비스 toonames 및 연락처 정보를 보유 합니다.</span><span class="sxs-lookup"><span data-stu-id="d0425-238">Consider hello following service: you are trying toobuild a service that acts as an address book, holding on toonames and contact information.</span></span> 

<span data-ttu-id="d0425-239">다양 한 질문 관련된 tooscale 있는 들겠지만 오른쪽: 사용자 수는 진행 중인 toohave?</span><span class="sxs-lookup"><span data-stu-id="d0425-239">Right up front you have a bunch of questions related tooscale: How many users are you going toohave?</span></span> <span data-ttu-id="d0425-240">각 사용자가 연락처를 얼마나 많이 저장하나요?</span><span class="sxs-lookup"><span data-stu-id="d0425-240">How many contacts will each user store?</span></span> <span data-ttu-id="d0425-241">시도 toofigure이 모두 때 하면 대기 중입니다. hello에 대 한 서비스를 처음으로 어렵습니다.</span><span class="sxs-lookup"><span data-stu-id="d0425-241">Trying toofigure this all out when you are standing up your service for hello first time is difficult.</span></span> <span data-ttu-id="d0425-242">특정 파티션 수와 단일 정적 서비스 toogo 휴가가 경우를 가정해 봅니다.</span><span class="sxs-lookup"><span data-stu-id="d0425-242">Let's say you were going toogo with a single static service with a specific partition count.</span></span> <span data-ttu-id="d0425-243">hello 파티션 수 문제가 발생할 수 있습니다 toohave 배율 나중에 잘못 된 선택의 hello 결과가 발생 합니다.</span><span class="sxs-lookup"><span data-stu-id="d0425-243">hello consequences of picking hello wrong partition count could cause you toohave scale issues later.</span></span> <span data-ttu-id="d0425-244">마찬가지로, 모든 hello 정보 hello 오른쪽 수 없을 수도 있습니다를 선택 하는 경우에 필요.</span><span class="sxs-lookup"><span data-stu-id="d0425-244">Similarly, even if you pick hello right count you might not have all hello information you need.</span></span> <span data-ttu-id="d0425-245">예를 들어 갖게 hello 클러스터 들겠지만, toodecide hello 크기 hello 노드 수 및 크기 측면에서 모두 됩니다.</span><span class="sxs-lookup"><span data-stu-id="d0425-245">For example, you also have toodecide hello size of hello cluster up front, both in terms of hello number of nodes and their sizes.</span></span> <span data-ttu-id="d0425-246">일반적으로 하드 toopredict 서비스 리소스의 수는 수명 주기 동안 tooconsume 것입니다.</span><span class="sxs-lookup"><span data-stu-id="d0425-246">It's usually hard toopredict how many resources a service is going tooconsume over its lifetime.</span></span> <span data-ttu-id="d0425-247">실제로 hello 서비스에 게 표시 되는 시간 hello 트래픽 패턴 보다 먼저 하드 tooknow 수도 있습니다.</span><span class="sxs-lookup"><span data-stu-id="d0425-247">It can also be hard tooknow ahead of time hello traffic pattern that hello service actually sees.</span></span> <span data-ttu-id="d0425-248">예를 들어 maybe 사람에서에서 추가 및 제거의 연락처 것만 hello 아침 또는 미정 배포 균등 하 게 hello 하루의 hello 과정입니다.</span><span class="sxs-lookup"><span data-stu-id="d0425-248">For example, maybe people add and remove their contacts only first thing in hello morning, or maybe it's distributed evenly over hello course of hello day.</span></span> <span data-ttu-id="d0425-249">바탕 tooscale에 및를 동적으로 할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="d0425-249">Based on this you might need tooscale out and in dynamically.</span></span> <span data-ttu-id="d0425-250">이전에, 및 tooneed tooscale 거 하지만 어느 쪽 야 tooneed tooreact toochanging 리소스 사용 서비스에 의해 toopredict을 배울 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="d0425-250">Maybe you can learn toopredict when you're going tooneed tooscale out and in, but either way you're probably going tooneed tooreact toochanging resource consumption by your service.</span></span> <span data-ttu-id="d0425-251">이 될 수 있습니다 순서 tooprovide hello 클러스터의 hello 크기 변경 더 많은 리소스가 충분 하지 않을 기존 리소스의 사용을 다시 구성 하는 경우.</span><span class="sxs-lookup"><span data-stu-id="d0425-251">This can involve changing hello size of hello cluster in order tooprovide more resources when reorganizing use of existing resources isn't enough.</span></span> 

<span data-ttu-id="d0425-252">하지만 이유 toopick 모든 사용자에 대해 아웃 단일 파티션 구성표도 시도?</span><span class="sxs-lookup"><span data-stu-id="d0425-252">But why even try toopick a single partition scheme out for all users?</span></span> <span data-ttu-id="d0425-253">만 tooone 서비스와 하나의 정적 클러스터? 실제 상황 hello 일반적으로 보다 동적입니다.</span><span class="sxs-lookup"><span data-stu-id="d0425-253">Why limit yourself tooone service and one static cluster? hello real situation is usually more dynamic.</span></span> 

<span data-ttu-id="d0425-254">눈금을 개발할 때는 hello를 동적 패턴을 따르는 것이 좋습니다.</span><span class="sxs-lookup"><span data-stu-id="d0425-254">When building for scale, consider hello following dynamic pattern.</span></span> <span data-ttu-id="d0425-255">Tooadapt 해야 것 tooyour 상황.</span><span class="sxs-lookup"><span data-stu-id="d0425-255">You may need tooadapt it tooyour situation:</span></span>

1. <span data-ttu-id="d0425-256">들겠지만 모두를 위한 toopick 파티션 구성표를 시도 하는 대신 빌드 "관리자 서비스"입니다.</span><span class="sxs-lookup"><span data-stu-id="d0425-256">Instead of trying toopick a partitioning scheme for everyone up front, build a "manager service".</span></span>
2. <span data-ttu-id="d0425-257">hello 작업이 hello 관리자 서비스의 서비스에 등록할 때 toolook 고객 정보를입니다.</span><span class="sxs-lookup"><span data-stu-id="d0425-257">hello job of hello manager service is toolook at customer information when they sign up for your service.</span></span> <span data-ttu-id="d0425-258">그런 다음 해당 정보에 따라 hello 관리자 서비스의 인스턴스를 만듭니다 프로그램 _실제_ 연락처 저장소 서비스 _해당 고객에 대 한_합니다.</span><span class="sxs-lookup"><span data-stu-id="d0425-258">Then depending on that information hello manager service create an instance of your _actual_ contact-storage service _just for that customer_.</span></span> <span data-ttu-id="d0425-259">특정 구성, 격리, 또는 업그레이드를 필요로 할 경우이 고객에 대 한 toospin 응용 프로그램 인스턴스를 결정할 수도 있습니다.</span><span class="sxs-lookup"><span data-stu-id="d0425-259">If they require particular configuration, isolation, or upgrades, you can also decide toospin up an Application instance for this customer.</span></span> 

<span data-ttu-id="d0425-260">이 동적 만들기 패턴은 다음과 같은 많은 이점을 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="d0425-260">This dynamic creation pattern many benefits:</span></span>

  - <span data-ttu-id="d0425-261">모든 사용자에 게 들겠지만 tooguess hello 올바른 파티션 수를 시도 하는 또는 빌드 무한히 단독으로 확장 가능한 단일 서비스입니다.</span><span class="sxs-lookup"><span data-stu-id="d0425-261">You're not trying tooguess hello correct partition count for all users up front or build a single service that is infinitely scalable all on its own.</span></span> 
  - <span data-ttu-id="d0425-262">다른 사용자가 동일한 파티션 수, 복제본 수, 배치 제약 조건, 메트릭, 기본 로드, 서비스 이름, dns 설정 또는 hello hello 서비스에서 지정한 다른 속성과 toohave hello 없는 또는 응용 프로그램 수준입니다.</span><span class="sxs-lookup"><span data-stu-id="d0425-262">Different users don't have toohave hello same partition count, replica count, placement constraints, metrics, default loads, service names, dns settings, or any of hello other properties specified at hello service or application level.</span></span> 
  - <span data-ttu-id="d0425-263">추가 데이터 조각화를 구성할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="d0425-263">You gain additional data segmentation.</span></span> <span data-ttu-id="d0425-264">각 고객에 게 hello 서비스의 자체 복사본</span><span class="sxs-lookup"><span data-stu-id="d0425-264">Each customer has their own copy of hello service</span></span>
    - <span data-ttu-id="d0425-265">각 고객 서비스마다 예상되는 규모에 따라 필요한 만큼 더 많거나 적은 파티션 또는 복제본으로 다르게 구성되어 더 많거나 적은 리소스가 허용될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="d0425-265">Each customer service can be configured differently and granted more or fewer resources, with more or fewer partitions or replicas as necessary based on their expected scale.</span></span>
      - <span data-ttu-id="d0425-266">예를 들어 "Gold" 계층 hello에 대 한 지불 hello 고객-복제본 수를 늘리거나 큰 파티션 수를 가져올 수 있습니다 및 잠재적으로 리소스 용량 메트릭 및 응용 프로그램을 통해 tootheir 서비스입니다.</span><span class="sxs-lookup"><span data-stu-id="d0425-266">For example, say hello customer paid for hello "Gold" tier - they could get more replicas or greater partition count, and potentially resources dedicated tootheir services via metrics and application capacities.</span></span>
      - <span data-ttu-id="d0425-267">또는 이러한 제공 hello 연락처 필요할 수 있음을 나타내는 정보는 "작음" 되었습니다-몇 가지 파티션만 대기줄 또는 다른 고객을 사용 하 여 공유 서비스 풀에도 배치 될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="d0425-267">Or say they provided information indicating hello number of contacts they needed was "Small" - they would get only a few partitions, or could even be put into a shared service pool with other customers.</span></span>
  - <span data-ttu-id="d0425-268">고객 tooshow를 기다리는 동안 다양 한 서비스 인스턴스 또는 복제본을 실행 하지 하는</span><span class="sxs-lookup"><span data-stu-id="d0425-268">You're not running a bunch of service instances or replicas while you're waiting for customers tooshow up</span></span>
  - <span data-ttu-id="d0425-269">고객 떠나고 하는 경우 해당 서비스 또는 응용 프로그램 카탈로그 생성을 삭제 하는 hello 관리자 것 만큼 간단는 다음 서비스에서 해당 정보를 제거 합니다.</span><span class="sxs-lookup"><span data-stu-id="d0425-269">If a customer ever leaves, then removing their information from your service is as simple as having hello manager delete that service or application that it created.</span></span>

## <a name="next-steps"></a><span data-ttu-id="d0425-270">다음 단계</span><span class="sxs-lookup"><span data-stu-id="d0425-270">Next steps</span></span>
<span data-ttu-id="d0425-271">서비스 패브릭 개념에 대 한 자세한 내용은 다음 문서는 hello 참조:</span><span class="sxs-lookup"><span data-stu-id="d0425-271">For more information on Service Fabric concepts, see hello following articles:</span></span>

* [<span data-ttu-id="d0425-272">서비스 패브릭 서비스의 가용성</span><span class="sxs-lookup"><span data-stu-id="d0425-272">Availability of Service Fabric services</span></span>](service-fabric-availability-services.md)
* [<span data-ttu-id="d0425-273">서비스 패브릭 서비스 분할</span><span class="sxs-lookup"><span data-stu-id="d0425-273">Partitioning Service Fabric services</span></span>](service-fabric-concepts-partitioning.md)
