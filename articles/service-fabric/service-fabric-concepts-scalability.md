---
title: "Service Fabric 서비스의 확장성 | Microsoft Docs"
description: "서비스 패브릭 서비스의 규모를 조정하는 방법을 설명합니다."
services: service-fabric
documentationcenter: .net
author: masnider
manager: timlt
editor: 
ms.assetid: ed324f23-242f-47b7-af1a-e55c839e7d5d
ms.service: service-fabric
ms.devlang: dotnet
ms.topic: article
ms.tgt_pltfrm: NA
ms.workload: NA
ms.date: 08/18/2017
ms.author: masnider
ms.openlocfilehash: e2dd48341499b18ebd1433611063746e95a5ac62
ms.sourcegitcommit: 18ad9bc049589c8e44ed277f8f43dcaa483f3339
ms.translationtype: MT
ms.contentlocale: ko-KR
ms.lasthandoff: 08/29/2017
---
# <a name="scaling-in-service-fabric"></a><span data-ttu-id="eba24-103">Service Fabric에서 크기 조정</span><span class="sxs-lookup"><span data-stu-id="eba24-103">Scaling in Service Fabric</span></span>
<span data-ttu-id="eba24-104">Azure Service Fabric을 사용하면 클러스터 노드의 서비스, 파티션 및 복제본을 관리하여 확장 가능한 응용 프로그램을 쉽게 빌드할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="eba24-104">Azure Service Fabric makes it easy to build scalable applications by managing the services, partitions, and replicas on the nodes of a cluster.</span></span> <span data-ttu-id="eba24-105">동일한 하드웨어에서 많은 워크로드를 실행하면 리소스를 최대한 활용할 수 있을 뿐만 아니라 워크로드의 크기를 조정하기 위해 선택하는 방법에 유연성도 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="eba24-105">Running many workloads on the same hardware enables maximum resource utilization, but also provides flexibility in terms of how you choose to scale your workloads.</span></span> 

<span data-ttu-id="eba24-106">Service Fabric에서 크기를 조정하는 경우 다음과 같은 여러 가지 방법으로 수행됩니다.</span><span class="sxs-lookup"><span data-stu-id="eba24-106">Scaling in Service Fabric is accomplished several different ways:</span></span>

1. <span data-ttu-id="eba24-107">크기 조정: 상태 비저장 서비스 인스턴스 만들기 또는 제거</span><span class="sxs-lookup"><span data-stu-id="eba24-107">Scaling by creating or removing stateless service instances</span></span>
2. <span data-ttu-id="eba24-108">크기 조정: 명명된 새 서비스 만들기 또는 제거</span><span class="sxs-lookup"><span data-stu-id="eba24-108">Scaling by creating or removing new named services</span></span>
3. <span data-ttu-id="eba24-109">크기 조정: 명명된 새 응용 프로그램 인스턴스 만들기 또는 제거</span><span class="sxs-lookup"><span data-stu-id="eba24-109">Scaling by creating or removing new named application instances</span></span>
4. <span data-ttu-id="eba24-110">크기 조정: 분할된 서비스 사용</span><span class="sxs-lookup"><span data-stu-id="eba24-110">Scaling by using partitioned services</span></span>
5. <span data-ttu-id="eba24-111">크기 조정: 클러스터에서 노드 추가 및 제거</span><span class="sxs-lookup"><span data-stu-id="eba24-111">Scaling by adding and removing nodes from the cluster</span></span> 
6. <span data-ttu-id="eba24-112">크기 조정: 클러스터 리소스 관리자 메트릭 사용</span><span class="sxs-lookup"><span data-stu-id="eba24-112">Scaling by using Cluster Resource Manager metrics</span></span>

## <a name="scaling-by-creating-or-removing-stateless-service-instances"></a><span data-ttu-id="eba24-113">크기 조정: 상태 비저장 서비스 인스턴스 만들기 또는 제거</span><span class="sxs-lookup"><span data-stu-id="eba24-113">Scaling by creating or removing stateless service instances</span></span>
<span data-ttu-id="eba24-114">Service Fabric 내에서 크기를 조정하는 가장 간단한 방법 중 하나는 상태 비저장 서비스를 사용하는 것입니다.</span><span class="sxs-lookup"><span data-stu-id="eba24-114">One of the simplest ways to scale within Service Fabric works with stateless services.</span></span> <span data-ttu-id="eba24-115">상태 비저장 서비스를 만들 때 `InstanceCount`를 정의할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="eba24-115">When you create a stateless service, you get a chance to define an `InstanceCount`.</span></span> <span data-ttu-id="eba24-116">`InstanceCount`는 서비스를 시작할 때 만들어지는 서비스 코드의 실행 복사본 수를 정의합니다.</span><span class="sxs-lookup"><span data-stu-id="eba24-116">`InstanceCount` defines how many running copies of that service's code are created when the service starts up.</span></span> <span data-ttu-id="eba24-117">예를 들어 클러스터에 100개의 노드가 있고,</span><span class="sxs-lookup"><span data-stu-id="eba24-117">Let's say, for example, that there are 100 nodes in the cluster.</span></span> <span data-ttu-id="eba24-118">`InstanceCount`가 10인 서비스를 만든다고 가정해 보겠습니다.</span><span class="sxs-lookup"><span data-stu-id="eba24-118">Let's also say that a service is created with an `InstanceCount` of 10.</span></span> <span data-ttu-id="eba24-119">런타임 중에 코드 실행 중인 10개 복사본이 모두 바쁘게 사용될 수 있거나 충분히 사용되지 않을 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="eba24-119">During runtime, those 10 running copies of the code could all become too busy (or could be not busy enough).</span></span> <span data-ttu-id="eba24-120">해당 워크로드의 크기를 조정하는 한 가지 방법은 인스턴스 수를 변경하는 것입니다.</span><span class="sxs-lookup"><span data-stu-id="eba24-120">One way to scale that workload is to change the number of instances.</span></span> <span data-ttu-id="eba24-121">예를 들어 일부 모니터링 또는 관리 코드는 로드에 기반하여 워크로드를 확장 또는 축소해야 하는지 여부에 따라 기존 인스턴스 수를 50 또는 5로 변경할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="eba24-121">For example, some piece of monitoring or management code can change the existing number of instances to 50, or to 5, depending on whether the workload needs to scale in or out based on the load.</span></span> 

<span data-ttu-id="eba24-122">C#:</span><span class="sxs-lookup"><span data-stu-id="eba24-122">C#:</span></span>

```csharp
StatelessServiceUpdateDescription updateDescription = new StatelessServiceUpdateDescription(); 
updateDescription.InstanceCount = 50;
await fabricClient.ServiceManager.UpdateServiceAsync(new Uri("fabric:/app/service"), updateDescription);
```

<span data-ttu-id="eba24-123">Powershell:</span><span class="sxs-lookup"><span data-stu-id="eba24-123">Powershell:</span></span>

```posh
Update-ServiceFabricService -Stateless -ServiceName $serviceName -InstanceCount 50
```
### <a name="using-dynamic-instance-count"></a><span data-ttu-id="eba24-124">동적 인스턴스 수 사용</span><span class="sxs-lookup"><span data-stu-id="eba24-124">Using Dynamic Instance Count</span></span>
<span data-ttu-id="eba24-125">특히 상태 비저장 서비스의 경우 Service Fabric에서 인스턴스 수를 자동으로 변경하는 방법을 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="eba24-125">Specifically for stateless services, Service Fabric offers an automatic way to change the instance count.</span></span> <span data-ttu-id="eba24-126">이렇게 하면 사용 가능한 노드 수를 통해 서비스의 크기를 동적으로 조정할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="eba24-126">This allows the service to scale dynamically with the number of nodes that are available.</span></span> <span data-ttu-id="eba24-127">이 동작을 선택하는 방법은 인스턴스 수를 -1로 설정하는 것입니다.</span><span class="sxs-lookup"><span data-stu-id="eba24-127">The way to opt into this behavior is to set the instance count = -1.</span></span> <span data-ttu-id="eba24-128">InstanceCount = -1은 "모든 노드에서 이 상태 비저장 서비스 실행"이라는 Service Fabric에 대한 명령입니다.</span><span class="sxs-lookup"><span data-stu-id="eba24-128">InstanceCount = -1 is an instruction to Service Fabric that says "Run this stateless service on every node."</span></span> <span data-ttu-id="eba24-129">노드 수가 변경되면 Service Fabric에서 인스턴스 수가 일치하도록 자동으로 변경하여 서비스가 유효한 모든 노드에서 실행되고 있는지 확인합니다.</span><span class="sxs-lookup"><span data-stu-id="eba24-129">If the number of nodes changes, Service Fabric automatically changes the instance count to match, ensuring that the service is running on all valid nodes.</span></span> 

<span data-ttu-id="eba24-130">C#:</span><span class="sxs-lookup"><span data-stu-id="eba24-130">C#:</span></span>

```csharp
StatelessServiceDescription serviceDescription = new StatelessServiceDescription();
//Set other service properties necessary for creation....
serviceDescription.InstanceCount = -1;
await fc.ServiceManager.CreateServiceAsync(serviceDescription);
```

<span data-ttu-id="eba24-131">Powershell:</span><span class="sxs-lookup"><span data-stu-id="eba24-131">Powershell:</span></span>

```posh
New-ServiceFabricService -ApplicationName $applicationName -ServiceName $serviceName -ServiceTypeName $serviceTypeName -Stateless -PartitionSchemeSingleton -InstanceCount "-1"
```

## <a name="scaling-by-creating-or-removing-new-named-services"></a><span data-ttu-id="eba24-132">크기 조정: 명명된 새 서비스 만들기 또는 제거</span><span class="sxs-lookup"><span data-stu-id="eba24-132">Scaling by creating or removing new named services</span></span>
<span data-ttu-id="eba24-133">명명된 서비스 인스턴스는 클러스터의 명명된 특정 응용 프로그램 인스턴스 내에 있는 서비스 유형의 특정 인스턴스입니다([Service Fabric 응용 프로그램 수명 주기](service-fabric-application-lifecycle.md)참조).</span><span class="sxs-lookup"><span data-stu-id="eba24-133">A named service instance is a specific instance of a service type (see [Service Fabric application life cycle](service-fabric-application-lifecycle.md)) within some named application instance in the cluster.</span></span> 

<span data-ttu-id="eba24-134">서비스가 더 많거나 적게 사용됨에 따라 명명된 새 서비스 인스턴스가 만들어지거나 제거될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="eba24-134">New named service instances can be created (or removed) as services become more or less busy.</span></span> <span data-ttu-id="eba24-135">이렇게 하면 더 많은 서비스 인스턴스에서 요청을 분산할 수 있으므로 대개 기존 서비스에 대한 로드를 줄일 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="eba24-135">This allows requests to be spread across more service instances, usually allowing load on existing services to decrease.</span></span> <span data-ttu-id="eba24-136">서비스를 만들 때 Service Fabric 클러스터 리소스 관리자에서 클러스터에 서비스를 분산 방식으로 배치합니다.</span><span class="sxs-lookup"><span data-stu-id="eba24-136">When creating services, the Service Fabric Cluster Resource Manager places the services in the cluster in a distributed fashion.</span></span> <span data-ttu-id="eba24-137">정확한 결정은 클러스터 및 다른 배치 규칙의 [메트릭](service-fabric-cluster-resource-manager-metrics.md)으로 관리됩니다.</span><span class="sxs-lookup"><span data-stu-id="eba24-137">The exact decisions are governed by the [metrics](service-fabric-cluster-resource-manager-metrics.md) in the cluster and other placement rules.</span></span> <span data-ttu-id="eba24-138">서비스는 여러 가지 방법으로 만들 수 있지만 가장 일반적인 방법은 [`New-ServiceFabricService`](https://docs.microsoft.com/en-us/powershell/module/servicefabric/new-servicefabricservice?view=azureservicefabricps)를 호출하는 사람이나 [`CreateServiceAsync`](https://docs.microsoft.com/en-us/dotnet/api/system.fabric.fabricclient.servicemanagementclient.createserviceasync?view=azure-dotnet)를 호출하는 코드와 같은 관리 작업을 사용하는 것입니다.</span><span class="sxs-lookup"><span data-stu-id="eba24-138">Services can be created several different ways, but the most common are either through administrative actions like someone calling [`New-ServiceFabricService`](https://docs.microsoft.com/en-us/powershell/module/servicefabric/new-servicefabricservice?view=azureservicefabricps), or by code calling [`CreateServiceAsync`](https://docs.microsoft.com/en-us/dotnet/api/system.fabric.fabricclient.servicemanagementclient.createserviceasync?view=azure-dotnet).</span></span> <span data-ttu-id="eba24-139">`CreateServiceAsync`는 클러스터에서 실행되는 다른 서비스에서도 호출할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="eba24-139">`CreateServiceAsync` can even be called from within other services running in the cluster.</span></span>

<span data-ttu-id="eba24-140">서비스를 동적으로 만들면 모든 종류의 시나리오에서 사용할 수 있으며 일반적인 패턴입니다.</span><span class="sxs-lookup"><span data-stu-id="eba24-140">Creating services dynamically can be used in all sorts of scenarios, and is a common pattern.</span></span> <span data-ttu-id="eba24-141">예를 들어 특정 워크플로를 나타내는 상태 저장 서비스를 고려합니다.</span><span class="sxs-lookup"><span data-stu-id="eba24-141">For example, consider a stateful service that represents a particular workflow.</span></span> <span data-ttu-id="eba24-142">작업을 나타내는 호출이 이 서비스에 표시되며, 이 서비스에서는 해당 워크플로에 대한 단계를 실행하고 진행 상황을 기록합니다.</span><span class="sxs-lookup"><span data-stu-id="eba24-142">Calls representing work are going to show up to this service, and this service is going to execute the steps to that workflow and record progress.</span></span> 

<span data-ttu-id="eba24-143">이 특정 서비스의 규모를 어떻게 만들까요?</span><span class="sxs-lookup"><span data-stu-id="eba24-143">How would you make this particular service scale?</span></span> <span data-ttu-id="eba24-144">서비스는 어떤 형태로든 다중 테넌트가 될 수 있으며, 동일한 워크플로의 다양한 여러 인스턴스에 대한 호출을 모두 수락하고 단계를 동시에 시작할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="eba24-144">The service could be multi-tenant in some form, and accept calls and kick off steps for many different instances of the same workflow all at once.</span></span> <span data-ttu-id="eba24-145">그러나 이제는 서로 다른 단계와 다른 고객으로부터 동일한 워크플로의 다양한 여러 인스턴스를 걱정해야 하기 때문에 코드를 더욱 복잡하게 만들 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="eba24-145">However, that can make the code more complex, since now it has to worry about many different instances of the same workflow, all at different stages and from different customers.</span></span> <span data-ttu-id="eba24-146">또한 여러 워크플로를 동시에 처리해도 규모 문제가 해결되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="eba24-146">Also, handling multiple workflows at the same time doesn't solve the scale problem.</span></span> <span data-ttu-id="eba24-147">이는 특정 시점에 이 서비스에서 너무 많은 리소스를 소비하여 특정 컴퓨터에 적합하지 않기 때문입니다.</span><span class="sxs-lookup"><span data-stu-id="eba24-147">This is because at some point this service will consume too many resources to fit on a particular machine.</span></span> <span data-ttu-id="eba24-148">첫 번째 위치에서 이 패턴에 맞게 빌드되지 않은 많은 서비스에서는 코드의 고유한 병목 현상 또는 속도 저하로 인해 어려움을 겪기도 합니다.</span><span class="sxs-lookup"><span data-stu-id="eba24-148">Many services not built for this pattern in the first place also experience difficulty due to some inherent bottleneck or slowdown in their code.</span></span> <span data-ttu-id="eba24-149">이러한 유형의 문제로 인해 추적 중인 동시 워크플로의 수가 커지면 서비스가 제대로 작동하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="eba24-149">These types of issues cause the service not to work as well when the number of concurrent workflows it is tracking gets larger.</span></span>  

<span data-ttu-id="eba24-150">해결 방법은 추적하려는 워크플로의 다른 모든 인스턴스에 대해 이 서비스의 인스턴스를 만드는 것입니다. 이는 훌륭한 패턴이며 서비스가 상태 비저장 또는 상태 저장인지의 여부에 관계 없이 작동합니다.</span><span class="sxs-lookup"><span data-stu-id="eba24-150">A solution is to create an instance of this service for every different instance of the workflow you want to track. This is a great pattern and works whether the service is stateless or stateful.</span></span> <span data-ttu-id="eba24-151">이 패턴이 작동하기 위해 일반적으로 "워크로드 관리자 서비스" 역할을 하는 또 다른 서비스가 있습니다.</span><span class="sxs-lookup"><span data-stu-id="eba24-151">For this pattern to work, there's usually another service that acts as a "Workload Manager Service".</span></span> <span data-ttu-id="eba24-152">이 서비스의 작업은 요청을 받고 이러한 요청을 다른 서비스로 라우팅하는 것입니다.</span><span class="sxs-lookup"><span data-stu-id="eba24-152">The job of this service is to receive requests and to route those requests to other services.</span></span> <span data-ttu-id="eba24-153">메시지를 받은 관리자에서 워크로드 서비스의 인스턴스를 동적으로 만든 다음 해당 서비스에 요청을 전달할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="eba24-153">The manager can dynamically create an instance of the workload service when it receives the message, and then pass on requests to those services.</span></span> <span data-ttu-id="eba24-154">관리자 서비스는 지정된 워크플로 서비스에서 작업을 완료할 때 콜백을 받을 수도 있습니다.</span><span class="sxs-lookup"><span data-stu-id="eba24-154">The manager service could also receive callbacks when a given workflow service completes its job.</span></span> <span data-ttu-id="eba24-155">관리자에서 이러한 콜백을 받으면 워크플로 서비스의 해당 인스턴스를 삭제하거나 더 많은 호출이 예상되는 경우 관리자에게 남겨 둘 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="eba24-155">When the manager receives these callbacks it could delete that instance of the workflow service, or leave it if more calls are expected.</span></span> 

<span data-ttu-id="eba24-156">이 유형의 관리자의 고급 버전에서는 관리하는 서비스의 풀을 만들 수도 있습니다.</span><span class="sxs-lookup"><span data-stu-id="eba24-156">Advanced versions of this type of manager can even create pools of the services that it manages.</span></span> <span data-ttu-id="eba24-157">풀을 사용하면 새 요청이 들어올 때 서비스가 회전될 때까지 기다릴 필요가 없습니다.</span><span class="sxs-lookup"><span data-stu-id="eba24-157">The pool helps ensure that when a new request comes in it doesn't have to wait for the service to spin up.</span></span> <span data-ttu-id="eba24-158">대신 현재 풀에서 사용되지 않거나 무작위로 라우팅되는 워크플로 서비스를 관리자에서 선택할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="eba24-158">Instead, the manager can just pick a workflow service that is not currently busy from the pool, or route randomly.</span></span> <span data-ttu-id="eba24-159">서비스 풀을 사용할 수 있도록 유지하면 새 서비스가 회전될 때까지 요청이 대기해야 할 가능성이 낮기 때문에 새 요청을 더 빠르게 처리할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="eba24-159">Keeping a pool of services available makes handling new requests faster, since it is less likely that the request has to wait for a new service to be spun up.</span></span> <span data-ttu-id="eba24-160">새 서비스를 만드는 것은 빠르지만 자유롭거나 즉각적이지는 않습니다.</span><span class="sxs-lookup"><span data-stu-id="eba24-160">Creating new services is quick, but not free or instantaneous.</span></span> <span data-ttu-id="eba24-161">풀을 사용하면 요청에 서비스를 제공하기 전에 대기해야 하는 시간을 최소화할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="eba24-161">The pool helps minimize the amount of time the request has to wait before being serviced.</span></span> <span data-ttu-id="eba24-162">응답 시간이 가장 중요한 경우 이 관리자와 풀 패턴을 자주 보게 됩니다.</span><span class="sxs-lookup"><span data-stu-id="eba24-162">You'll often see this manager and pool pattern when response times matter the most.</span></span> <span data-ttu-id="eba24-163">요청을 큐에 넣고 백그라운드에서 서비스를 만든 _후에_ 해당 요청을 전달하는 것도 현재 서비스에서 보류 중인 작업량을 추적하여 이에 따라 서비스를 만들거나 삭제하는 것과 같이 널리 사용되는 관리자 패턴입니다.</span><span class="sxs-lookup"><span data-stu-id="eba24-163">Queuing the request and creating the service in the background and _then_ passing it on is also a popular manager pattern, as is creating and deleting services based on some tracking of the amount of work that service currently has pending.</span></span> 

## <a name="scaling-by-creating-or-removing-new-named-application-instances"></a><span data-ttu-id="eba24-164">크기 조정: 명명된 새 응용 프로그램 인스턴스 만들기 또는 제거</span><span class="sxs-lookup"><span data-stu-id="eba24-164">Scaling by creating or removing new named application instances</span></span>
<span data-ttu-id="eba24-165">전체 응용 프로그램 인스턴스를 만들고 삭제하는 것은 서비스를 만들고 삭제하는 패턴과 비슷합니다.</span><span class="sxs-lookup"><span data-stu-id="eba24-165">Creating and deleting whole application instances is similar to the pattern of creating and deleting services.</span></span> <span data-ttu-id="eba24-166">이 패턴에는 보고 있는 요청과 클러스터 내부의 다른 서비스에서 받는 정보에 따라 결정하는 관리자 서비스가 있습니다.</span><span class="sxs-lookup"><span data-stu-id="eba24-166">For this pattern, there's some manager service that is making the decision based on the requests that it is seeing and the information it is receiving from the other services inside the cluster.</span></span> 

<span data-ttu-id="eba24-167">어떤 기존 응용 프로그램에서 명명된 새 서비스 인스턴스를 만드는 대신 명명된 새 응용 프로그램 인스턴스를 만들어야 하나요?</span><span class="sxs-lookup"><span data-stu-id="eba24-167">When should creating a new named application instance be used instead of creating a new named service instances in some already existing application?</span></span> <span data-ttu-id="eba24-168">여기에는 다음 몇 가지 경우가 있습니다.</span><span class="sxs-lookup"><span data-stu-id="eba24-168">There's a few cases:</span></span>

  * <span data-ttu-id="eba24-169">새 응용 프로그램 인스턴스는 특정 ID 또는 보안 설정에 따라 코드를 실행해야 하는 고객을 위한 것입니다.</span><span class="sxs-lookup"><span data-stu-id="eba24-169">The new application instance is for a customer whose code needs to run under some particular identity or security settings.</span></span>
    * <span data-ttu-id="eba24-170">Service Fabric에서는 특정 ID로 실행되는 여러 코드 패키지를 정의할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="eba24-170">Service Fabric allows defining different code packages to run under particular identities.</span></span> <span data-ttu-id="eba24-171">서로 다른 ID로 동일한 코드 패키지를 실행하려면 여러 응용 프로그램 인스턴스에서 활성화 작업을 수행해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="eba24-171">In order to launch the same code package under different identities, the activations need to occur in different application instances.</span></span> <span data-ttu-id="eba24-172">기존 고객의 워크로드가 배포되는 경우를 고려합니다.</span><span class="sxs-lookup"><span data-stu-id="eba24-172">Consider a case where you have an existing customer's workloads deployed.</span></span> <span data-ttu-id="eba24-173">이러한 워크로드는 원격 데이터베이스 또는 다른 시스템과 같은 다른 리소스에 대한 액세스를 모니터링하고 제어할 수 있도록 특정 ID로 실행될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="eba24-173">These may be running under a particular identity so you can monitor and control their access to other resources, such as remote databases or other systems.</span></span> <span data-ttu-id="eba24-174">이 경우 새 고객이 등록할 때 동일한 컨텍스트(프로세스 공간)에서 코드를 활성화하지 않으려고 합니다.</span><span class="sxs-lookup"><span data-stu-id="eba24-174">In this case, when a new customer signs up, you probably don't want to activate their code in the same context (process space).</span></span> <span data-ttu-id="eba24-175">가능하더라도 이는 특정 ID의 컨텍스트 내에서 서비스 코드가 작동하는 것을 더 어렵게 만듭니다.</span><span class="sxs-lookup"><span data-stu-id="eba24-175">While you could, this makes it harder for your service code to act within the context of a particular identity.</span></span> <span data-ttu-id="eba24-176">일반적으로 더 많은 보안, 격리 및 ID 관리 코드가 있어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="eba24-176">You typically must have more security, isolation, and identity management code.</span></span> <span data-ttu-id="eba24-177">동일한 응용 프로그램 인스턴스 내에서 명명된 다른 서비스 인스턴스를 사용하고 이에 따라 동일한 프로세스 공간을 사용하는 대신, 명명된 다른 Service Fabric 응용 프로그램 인스턴스를 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="eba24-177">Instead of using different named service instances within the same application instance and hence the same process space, you can use different named Service Fabric Application instances.</span></span> <span data-ttu-id="eba24-178">이렇게 하면 다른 ID 컨텍스트를 더 쉽게 정의할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="eba24-178">This makes it easier to define different identity contexts.</span></span>
  * <span data-ttu-id="eba24-179">새 응용 프로그램 인스턴스는 구성 수단으로도 사용됩니다.</span><span class="sxs-lookup"><span data-stu-id="eba24-179">The new application instance also serves as a means of configuration</span></span>
    * <span data-ttu-id="eba24-180">기본적으로 응용 프로그램 인스턴스 내의 특정 서비스 유형의 명명된 서비스 인스턴스는 모두 지정된 노드에서 동일한 프로세스로 실행됩니다.</span><span class="sxs-lookup"><span data-stu-id="eba24-180">By default, all of the named service instances of a particular service type within an application instance will run in the same process on a given node.</span></span> <span data-ttu-id="eba24-181">즉 각 서비스 인스턴스마다 다르게 구성할 수 있지만 이 방법은 복잡합니다.</span><span class="sxs-lookup"><span data-stu-id="eba24-181">What this means is that while you can configure each service instance differently, doing so is complicated.</span></span> <span data-ttu-id="eba24-182">서비스에는 구성 패키지 내에서 구성을 조회하는 데 사용하는 토큰이 있어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="eba24-182">Services must have some token they use to look up their config within a configuration package.</span></span> <span data-ttu-id="eba24-183">일반적으로 이 토큰은 서비스의 이름입니다.</span><span class="sxs-lookup"><span data-stu-id="eba24-183">Usually this is just the service's name.</span></span> <span data-ttu-id="eba24-184">이는 정상적으로 작동하지만 해당 응용 프로그램 인스턴스 내의 명명된 개별 서비스 인스턴스 이름에 구성을 연결합니다.</span><span class="sxs-lookup"><span data-stu-id="eba24-184">This works fine, but it couples the configuration to the names of the individual named service instances within that application instance.</span></span> <span data-ttu-id="eba24-185">이렇게 하면 구성이 일반적으로 응용 프로그램 인스턴스별 특정 값이 있는 디자인 타임 아티팩트이므로 관리하기가 혼란스럽고 어려울 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="eba24-185">This can be confusing and hard to manage since configuration is normally a design time artifact with application instance specific values.</span></span> <span data-ttu-id="eba24-186">더 많은 서비스를 만들면 항상 구성 패키지 내의 정보를 변경하거나 새 패키지를 배포하여 더 많은 응용 프로그램을 업그레이드할 수 있으므로 새 서비스에서 특정 정보를 조회할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="eba24-186">Creating more services always means more application upgrades to change the information within the config packages or to deploy new ones so that the new services can look up their specific information.</span></span> <span data-ttu-id="eba24-187">종종 완전히 새로운 명명된 응용 프로그램 인스턴스를 만드는 것이 더 쉽습니다.</span><span class="sxs-lookup"><span data-stu-id="eba24-187">It's often easier to create a whole new named application instance.</span></span> <span data-ttu-id="eba24-188">그런 다음 응용 프로그램 매개 변수를 사용하여 서비스에 필요한 구성을 설정할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="eba24-188">Then you can use the application parameters to set whatever configuration is necessary for the services.</span></span> <span data-ttu-id="eba24-189">명명된 해당 응용 프로그램 인스턴스 내에서 이러한 방식으로 만든 모든 서비스는 특정 구성 설정을 상속할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="eba24-189">This way all of the services that are created within that named application instance can inherit particular configuration settings.</span></span> <span data-ttu-id="eba24-190">예를 들어 모든 고객에 대한 설정 및 사용자 지정(예: 비밀 또는 고객 리소스 제한별)이 포함된 단일 구성 파일을 갖추는 대신, 각 고객에 대해 이러한 설정이 재정의된 별도의 응용 프로그램 인스턴스를 대신 갖출 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="eba24-190">For example, instead of having a single configuration file with the settings and customizations for every customer, such as secrets or per customer resource limits, you'd instead have a different application instance for each customer with these settings overridden.</span></span> 
  * <span data-ttu-id="eba24-191">새 응용 프로그램은 업그레이드 경계 역할을 합니다.</span><span class="sxs-lookup"><span data-stu-id="eba24-191">The new application serves as an upgrade boundary</span></span>
    * <span data-ttu-id="eba24-192">Service Fabric 내에서 명명된 다른 응용 프로그램 인스턴스는 업그레이드를 위한 경계 역할을 합니다.</span><span class="sxs-lookup"><span data-stu-id="eba24-192">Within Service Fabric, different named application instances serve as boundaries for upgrade.</span></span> <span data-ttu-id="eba24-193">하나의 명명된 응용 프로그램 인스턴스를 업그레이드해도 명명된 다른 응용 프로그램 인스턴스에서 실행되는 코드에는 영향을 주지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="eba24-193">An upgrade of one named application instance will not impact the code that another named application instance is running.</span></span> <span data-ttu-id="eba24-194">다른 응용 프로그램은 동일한 노드에서 동일한 코드의 다른 버전을 실행하게 됩니다.</span><span class="sxs-lookup"><span data-stu-id="eba24-194">The different applications will end up running different versions of the same code on the same nodes.</span></span> <span data-ttu-id="eba24-195">새 코드에서 다른 서비스와 동일한 업그레이드를 수행하는지 여부를 선택할 수 있으므로 이는 크기 조정을 결정해야 할 때 필요한 요소일 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="eba24-195">This can be a factor when you need to make a scaling decision because you can choose whether the new code should follow the same upgrades as another service or not.</span></span> <span data-ttu-id="eba24-196">예를 들어 서비스를 동적으로 만들고 삭제하여 특정 고객의 워크로드 크기를 조정하는 작업을 담당하는 관리자 서비스에 호출이 도착했다고 가정합니다.</span><span class="sxs-lookup"><span data-stu-id="eba24-196">For example, say that a call arrives at the manager service that is responsible for scaling a particular customer's workloads by creating and deleting services dynamically.</span></span> <span data-ttu-id="eba24-197">그러나 이 경우 호출은 _새_ 고객과 관련된 워크로드에 대한 호출입니다.</span><span class="sxs-lookup"><span data-stu-id="eba24-197">In this case however, the call is for a workload associated with a _new_ customer.</span></span> <span data-ttu-id="eba24-198">대부분의 고객은 이전에 나열된 보안 및 구성상의 이유뿐만 아니라 특정 버전의 소프트웨어를 실행하고 업그레이드 시점을 선택하는 측면에서 더 많은 유연성도 제공하기 때문에 서로 격리되는 것을 선호합니다.</span><span class="sxs-lookup"><span data-stu-id="eba24-198">Most customers like being isolated from each other not just for the security and configuration reasons listed previously, but because it provides more flexibility in terms of running specific versions of the software and choosing when they get upgraded.</span></span> <span data-ttu-id="eba24-199">또한 새 응용 프로그램 인스턴스를 만들고 여기에 서비스를 간단히 만들어 하나의 업그레이드에서 사용할 서비스의 양을 더 자세히 분할할 수도 있습니다.</span><span class="sxs-lookup"><span data-stu-id="eba24-199">You may also create a new application instance and create the service there simply to further partition the amount of your services that any one upgrade will touch.</span></span> <span data-ttu-id="eba24-200">별도의 응용 프로그램 인스턴스에서 응용 프로그램 업그레이드를 수행할 때 더 자세한 세분성을 제공하며, A/B 테스트 및 파랑/녹색 배포도 가능하게 합니다.</span><span class="sxs-lookup"><span data-stu-id="eba24-200">Separate application instances provide greater granularity when doing application upgrades, and also enable A/B testing and Blue/Green deployments.</span></span> 
  * <span data-ttu-id="eba24-201">기존 응용 프로그램 인스턴스가 가득 찼습니다.</span><span class="sxs-lookup"><span data-stu-id="eba24-201">The existing application instance is full</span></span>
    * <span data-ttu-id="eba24-202">Service Fabric에서 [응용 프로그램 용량](service-fabric-cluster-resource-manager-application-groups.md)은 특정 응용 프로그램 인스턴스에 사용할 수 있는 리소스의 양을 제어하는 데 사용할 수 있는 개념입니다.</span><span class="sxs-lookup"><span data-stu-id="eba24-202">In Service Fabric, [application capacity](service-fabric-cluster-resource-manager-application-groups.md) is a concept that you can use to control the amount of resources available for particular application instances.</span></span> <span data-ttu-id="eba24-203">예를 들어 지정된 서비스에서 크기 조정을 위해 다른 인스턴스를 만들어야 한다고 결정할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="eba24-203">For example, you may decide that a given service needs to have another instance created in order to scale.</span></span> <span data-ttu-id="eba24-204">그러나 이 응용 프로그램 인스턴스에는 특정 메트릭에 대한 용량이 부족합니다.</span><span class="sxs-lookup"><span data-stu-id="eba24-204">However, this application instance is out of capacity for a certain metric.</span></span> <span data-ttu-id="eba24-205">이러한 특정 고객 또는 워크로드에 더 많은 리소스를 계속 부여해야 하는 경우 해당 응용 프로그램의 기존 용량을 늘리거나 새 응용 프로그램을 만들 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="eba24-205">If this particular customer or workload should still be granted more resources, then you could either increase the existing capacity for that application or create a new application.</span></span> 

## <a name="scaling-at-the-partition-level"></a><span data-ttu-id="eba24-206">파티션 수준에서 크기 조정</span><span class="sxs-lookup"><span data-stu-id="eba24-206">Scaling at the partition level</span></span>
<span data-ttu-id="eba24-207">Service Fabric은 파티션을 지원합니다.</span><span class="sxs-lookup"><span data-stu-id="eba24-207">Service Fabric supports partitioning.</span></span> <span data-ttu-id="eba24-208">분할은 서비스를 여러 논리적 및 물리적 섹션으로 나누며, 각 섹션은 독립적으로 작동합니다.</span><span class="sxs-lookup"><span data-stu-id="eba24-208">Partitioning splits a service into several logical and physical sections, each of which operates independently.</span></span> <span data-ttu-id="eba24-209">어떤 복제본 집합에서도 모든 호출을 처리하고 모든 상태를 한 번에 조작할 수 없기 때문에 이 기능은 상태 저장 서비스에 유용합니다.</span><span class="sxs-lookup"><span data-stu-id="eba24-209">This is useful with stateful services, since no one set of replicas has to handle all the calls and manipulate all of the state at once.</span></span> <span data-ttu-id="eba24-210">[분할 개요](service-fabric-concepts-partitioning.md) 는 지원되는 분할 체계의 유형에 대한 정보를 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="eba24-210">The [partitioning overview](service-fabric-concepts-partitioning.md) provides information on the types of partitioning schemes that are supported.</span></span> <span data-ttu-id="eba24-211">각 파티션의 복제본은 클러스터의 노드에 분산되어 해당 서비스의 로드를 분산하고 전체 또는 일부 파티션의 서비스가 단일 실패 지점을 갖지 않도록 합니다.</span><span class="sxs-lookup"><span data-stu-id="eba24-211">The replicas of each partition are spread across the nodes in a cluster, distributing that service's load and ensuring that neither the service as a whole or any partition has a single point of failure.</span></span> 

<span data-ttu-id="eba24-212">서비스가 0개의 하위 키, 99개의 상위 키 및 4개의 파티션 개수를 가진 범위 지정 파티션 구성표를 사용한다고 가정합니다.</span><span class="sxs-lookup"><span data-stu-id="eba24-212">Consider a service that uses a ranged partitioning scheme with a low key of 0, a high key of 99, and a partition count of 4.</span></span> <span data-ttu-id="eba24-213">3노드 클러스터에서 서비스는 다음과 같이 각 노드에서 리소스를 공유하는 4개의 복제본으로 배치될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="eba24-213">In a three-node cluster, the service might be laid out with four replicas that share the resources on each node as shown here:</span></span>

<span data-ttu-id="eba24-214"><center>
![3개의 노드가 있는 파티션 레이아웃](./media/service-fabric-concepts-scalability/layout-three-nodes.png)
</center></span><span class="sxs-lookup"><span data-stu-id="eba24-214"><center>
![Partition layout with three nodes](./media/service-fabric-concepts-scalability/layout-three-nodes.png)
</center></span></span>

<span data-ttu-id="eba24-215">노드 수를 늘리면 Service Fabric에서 기존 복제본 일부를 이 위치로 이동합니다.</span><span class="sxs-lookup"><span data-stu-id="eba24-215">If you increase the number of nodes, Service Fabric will move some of the existing replicas there.</span></span> <span data-ttu-id="eba24-216">예를 들어 노드 수가 4개로 늘어나고 복제본이 다시 배포된다고 가정해 보겠습니다.</span><span class="sxs-lookup"><span data-stu-id="eba24-216">For example, let's say the number of nodes increases to four and the replicas get redistributed.</span></span> <span data-ttu-id="eba24-217">이제 서비스에는 각 노드에서 실행되는 3개의 복제본이 있으며, 각 복제본은 각각 다른 파티션에 속합니다.</span><span class="sxs-lookup"><span data-stu-id="eba24-217">Now the service now has three replicas running on each node, each belonging to different partitions.</span></span> <span data-ttu-id="eba24-218">이렇게 하면 새 노드가 콜드가 되지 않기 때문에 리소스를 더 효율적으로 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="eba24-218">This allows better resource utilization since the new node isn't cold.</span></span> <span data-ttu-id="eba24-219">일반적으로 각 서비스에서 더 많은 리소스를 사용할 수 있게 됨에 따라 성능도 향상됩니다.</span><span class="sxs-lookup"><span data-stu-id="eba24-219">Typically, it also improves performance as each service has more resources available to it.</span></span>

<span data-ttu-id="eba24-220"><center>
![4개의 노드가 있는 파티션 레이아웃](./media/service-fabric-concepts-scalability/layout-four-nodes.png)
</center></span><span class="sxs-lookup"><span data-stu-id="eba24-220"><center>
![Partition layout with four nodes](./media/service-fabric-concepts-scalability/layout-four-nodes.png)
</center></span></span>

## <a name="scaling-by-using-the-service-fabric-cluster-resource-manager-and-metrics"></a><span data-ttu-id="eba24-221">크기 조정: Service Fabric 클러스터 리소스 관리자 및 메트릭 사용</span><span class="sxs-lookup"><span data-stu-id="eba24-221">Scaling by using the Service Fabric Cluster Resource Manager and metrics</span></span>
<span data-ttu-id="eba24-222">[메트릭](service-fabric-cluster-resource-manager-metrics.md)은 서비스에서 Service Fabric으로 리소스 사용량을 표현하는 방법입니다.</span><span class="sxs-lookup"><span data-stu-id="eba24-222">[Metrics](service-fabric-cluster-resource-manager-metrics.md) are how services express their resource consumption to Service Fabric.</span></span> <span data-ttu-id="eba24-223">메트릭을 사용하면 클러스터 리소스 관리자에서 클러스터 레이아웃을 다시 구성하고 최적화할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="eba24-223">Using metrics gives the Cluster Resource Manager an opportunity to reorganize and optimize the layout of the cluster.</span></span> <span data-ttu-id="eba24-224">예를 들어 클러스터에는 많은 리소스가 있을 수 있지만 현재 작업 중인 서비스에는 할당되지 않을 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="eba24-224">For example, there may be plenty of resources in the cluster, but they might not be allocated to the services that are currently doing work.</span></span> <span data-ttu-id="eba24-225">메트릭을 사용하면 클러스터 리소스 관리자에서 서비스가 사용 가능한 리소스에 액세스할 수 있도록 클러스터를 다시 구성할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="eba24-225">Using metrics allows the Cluster Resource Manager to reorganize the cluster to ensure that services have access to the available resources.</span></span> 


## <a name="scaling-by-adding-and-removing-nodes-from-the-cluster"></a><span data-ttu-id="eba24-226">크기 조정: 클러스터에서 노드 추가 및 제거</span><span class="sxs-lookup"><span data-stu-id="eba24-226">Scaling by adding and removing nodes from the cluster</span></span> 
<span data-ttu-id="eba24-227">Service Fabric을 사용하여 크기를 조정하는 또 다른 옵션은 클러스터의 크기를 변경하는 것입니다.</span><span class="sxs-lookup"><span data-stu-id="eba24-227">Another option for scaling with Service Fabric is to change the size of the cluster.</span></span> <span data-ttu-id="eba24-228">클러스터의 크기를 변경하면 클러스터에서 하나 이상의 노드 형식에 대한 노드를 추가하거나 제거합니다.</span><span class="sxs-lookup"><span data-stu-id="eba24-228">Changing the size of the cluster means adding or removing nodes for one or more of the node types in the cluster.</span></span> <span data-ttu-id="eba24-229">예를 들어 클러스터의 모든 노드가 핫인 경우를 고려합니다.</span><span class="sxs-lookup"><span data-stu-id="eba24-229">For example, consider a case where all of the nodes in the cluster are hot.</span></span> <span data-ttu-id="eba24-230">이는 클러스터의 리소스가 거의 모두 사용된다는 것을 의미합니다.</span><span class="sxs-lookup"><span data-stu-id="eba24-230">This means that the cluster's resources are almost all consumed.</span></span> <span data-ttu-id="eba24-231">이 경우 클러스터에 더 많은 노드를 추가하는 것이 가장 좋은 크기 조정 방법입니다.</span><span class="sxs-lookup"><span data-stu-id="eba24-231">In this case, adding more nodes to the cluster is the best way to scale.</span></span> <span data-ttu-id="eba24-232">새 노드가 클러스터에 조인하면 Service Fabric 클러스터 리소스 관리자에서 서비스를 이 노드로 이동하므로 기존 노드에 대한 총 로드가 줄어듭니다.</span><span class="sxs-lookup"><span data-stu-id="eba24-232">Once the new nodes join the cluster the Service Fabric Cluster Resource Manager moves services to them, resulting in less total load on the existing nodes.</span></span> <span data-ttu-id="eba24-233">인스턴스 수가 -1인 상태 비저장 서비스의 경우 더 많은 서비스 인스턴스가 자동으로 만들어집니다.</span><span class="sxs-lookup"><span data-stu-id="eba24-233">For stateless services with instance count = -1, more service instances are automatically created.</span></span> <span data-ttu-id="eba24-234">이렇게 하면 일부 호출이 기존 노드에서 새 노드로 이동할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="eba24-234">This allows some calls to move from the existing nodes to the new nodes.</span></span> 

<span data-ttu-id="eba24-235">클러스터에 노드를 추가하고 제거하는 작업은 Service Fabric Azure 리소스 관리자 PowerShell 모듈을 통해 수행할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="eba24-235">Adding and removing nodes to the cluster can be accomplished via the Service Fabric Azure Resource Manager PowerShell module.</span></span>

```posh
Add-AzureRmServiceFabricNode -ResourceGroupName $resourceGroupName -Name $clusterResourceName -NodeType $nodeTypeName  -NumberOfNodesToAdd 5 
Remove-AzureRmServiceFabricNode -ResourceGroupName $resourceGroupName -Name $clusterResourceName -NodeType $nodeTypeName -NumberOfNodesToRemove 5
```

## <a name="putting-it-all-together"></a><span data-ttu-id="eba24-236">모든 항목 요약</span><span class="sxs-lookup"><span data-stu-id="eba24-236">Putting it all together</span></span>
<span data-ttu-id="eba24-237">여기서 설명한 모든 아이디어를 이용하여 예를 통해 설명해 보겠습니다.</span><span class="sxs-lookup"><span data-stu-id="eba24-237">Let's take all the ideas that we've discussed here and talk through an example.</span></span> <span data-ttu-id="eba24-238">이름 및 연락처 정보를 가지고 주소록의 역할을 하는 서비스를 빌드하려고 하는 다음 예제를 고려합니다.</span><span class="sxs-lookup"><span data-stu-id="eba24-238">Consider the following service: you are trying to build a service that acts as an address book, holding on to names and contact information.</span></span> 

<span data-ttu-id="eba24-239">바로 앞에서 크기 조정과 관련된 질문이 많았습니다. 얼마나 많은 사용자가 있나요?</span><span class="sxs-lookup"><span data-stu-id="eba24-239">Right up front you have a bunch of questions related to scale: How many users are you going to have?</span></span> <span data-ttu-id="eba24-240">각 사용자가 연락처를 얼마나 많이 저장하나요?</span><span class="sxs-lookup"><span data-stu-id="eba24-240">How many contacts will each user store?</span></span> <span data-ttu-id="eba24-241">서비스를 처음 사용할 때 이러한 모든 사실을 파악하기는 어렵습니다.</span><span class="sxs-lookup"><span data-stu-id="eba24-241">Trying to figure this all out when you are standing up your service for the first time is difficult.</span></span> <span data-ttu-id="eba24-242">특정 파티션 수를 통해 단일 정적 서비스를 이동하려고 한다고 가정해 보겠습니다.</span><span class="sxs-lookup"><span data-stu-id="eba24-242">Let's say you were going to go with a single static service with a specific partition count.</span></span> <span data-ttu-id="eba24-243">잘못된 파티션 개수를 선택한 결과로 나중에 확장 문제가 발생할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="eba24-243">The consequences of picking the wrong partition count could cause you to have scale issues later.</span></span> <span data-ttu-id="eba24-244">마찬가지로, 올바른 수를 선택하더라도 필요한 모든 정보를 얻지 못할 수도 있습니다.</span><span class="sxs-lookup"><span data-stu-id="eba24-244">Similarly, even if you pick the right count you might not have all the information you need.</span></span> <span data-ttu-id="eba24-245">예를 들어 노드 수와 크기 측면에서 클러스터의 크기를 가장 먼저 결정해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="eba24-245">For example, you also have to decide the size of the cluster up front, both in terms of the number of nodes and their sizes.</span></span> <span data-ttu-id="eba24-246">일반적으로 서비스에서 수명 동안 사용할 리소스의 양을 예측하는 것은 어렵습니다.</span><span class="sxs-lookup"><span data-stu-id="eba24-246">It's usually hard to predict how many resources a service is going to consume over its lifetime.</span></span> <span data-ttu-id="eba24-247">또한 서비스에서 실제로 표시하는 트래픽 패턴을 미리 파악하는 것도 어려울 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="eba24-247">It can also be hard to know ahead of time the traffic pattern that the service actually sees.</span></span> <span data-ttu-id="eba24-248">예를 들어 사람들이 아침에 가장 먼저 연락처만 추가하거나 삭제할 수 있으며, 아니면 하루 종일 균등하게 배포할 수도 있습니다.</span><span class="sxs-lookup"><span data-stu-id="eba24-248">For example, maybe people add and remove their contacts only first thing in the morning, or maybe it's distributed evenly over the course of the day.</span></span> <span data-ttu-id="eba24-249">이 정보에 따라 규모를 동적으로 확장하거나 축소해야 할 수도 있습니다.</span><span class="sxs-lookup"><span data-stu-id="eba24-249">Based on this you might need to scale out and in dynamically.</span></span> <span data-ttu-id="eba24-250">규모를 확장하고 축소해야 하는 시기를 예측하기 위해 알아볼 수는 있지만, 어느 쪽이든 서비스를 통해 변화하는 리소스 사용량에 대응해야 할 것입니다.</span><span class="sxs-lookup"><span data-stu-id="eba24-250">Maybe you can learn to predict when you're going to need to scale out and in, but either way you're probably going to need to react to changing resource consumption by your service.</span></span> <span data-ttu-id="eba24-251">이에 따라 기존 리소스의 사용을 다시 구성하는 것만으로는 충분하지 않은 경우 더 많은 리소스를 제공하기 위해 클러스터의 크기를 변경해야 할 수도 있습니다.</span><span class="sxs-lookup"><span data-stu-id="eba24-251">This can involve changing the size of the cluster in order to provide more resources when reorganizing use of existing resources isn't enough.</span></span> 

<span data-ttu-id="eba24-252">그러나 모든 사용자에 대해 단일 파티션 구성표를 선택하려는 이유는 무엇인가요?</span><span class="sxs-lookup"><span data-stu-id="eba24-252">But why even try to pick a single partition scheme out for all users?</span></span> <span data-ttu-id="eba24-253">하나의 서비스와 하나의 정적 클러스터로 제한하는 이유는 무엇인가요?</span><span class="sxs-lookup"><span data-stu-id="eba24-253">Why limit yourself to one service and one static cluster?</span></span> <span data-ttu-id="eba24-254">실제 상황은 일반적으로 더 동적입니다.</span><span class="sxs-lookup"><span data-stu-id="eba24-254">The real situation is usually more dynamic.</span></span> 

<span data-ttu-id="eba24-255">규모에 맞게 빌드하는 경우 다음 동적 패턴을 고려합니다.</span><span class="sxs-lookup"><span data-stu-id="eba24-255">When building for scale, consider the following dynamic pattern.</span></span> <span data-ttu-id="eba24-256">상황에 맞게 조정해야 할 수도 있습니다.</span><span class="sxs-lookup"><span data-stu-id="eba24-256">You may need to adapt it to your situation:</span></span>

1. <span data-ttu-id="eba24-257">모든 사용자에 대한 파티션 구성표를 선택하지 않고 "관리자 서비스"를 빌드합니다.</span><span class="sxs-lookup"><span data-stu-id="eba24-257">Instead of trying to pick a partitioning scheme for everyone up front, build a "manager service".</span></span>
2. <span data-ttu-id="eba24-258">관리자 서비스의 작업은 서비스에 등록할 때 고객 정보를 확인하는 것입니다.</span><span class="sxs-lookup"><span data-stu-id="eba24-258">The job of the manager service is to look at customer information when they sign up for your service.</span></span> <span data-ttu-id="eba24-259">그런 다음 관리자 서비스에서 해당 정보에 따라 _해당 고객에 대해서만_ _실제_ 연락처 저장소 서비스의 인스턴스를 만듭니다.</span><span class="sxs-lookup"><span data-stu-id="eba24-259">Then depending on that information the manager service create an instance of your _actual_ contact-storage service _just for that customer_.</span></span> <span data-ttu-id="eba24-260">특정 구성, 격리 또는 업그레이드가 필요한 경우 이 고객에 대한 응용 프로그램 인스턴스를 회전하도록 결정할 수도 있습니다.</span><span class="sxs-lookup"><span data-stu-id="eba24-260">If they require particular configuration, isolation, or upgrades, you can also decide to spin up an Application instance for this customer.</span></span> 

<span data-ttu-id="eba24-261">이 동적 만들기 패턴은 다음과 같은 많은 이점을 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="eba24-261">This dynamic creation pattern many benefits:</span></span>

  - <span data-ttu-id="eba24-262">모든 사용자에 대해 올바른 파티션 수를 추측하거나 자체적으로 무한하게 확장할 수 있는 단일 서비스를 빌드하려는 것은 아닙니다.</span><span class="sxs-lookup"><span data-stu-id="eba24-262">You're not trying to guess the correct partition count for all users up front or build a single service that is infinitely scalable all on its own.</span></span> 
  - <span data-ttu-id="eba24-263">다른 사용자가 서비스 수준 또는 응용 프로그램 수준에서 지정된 동일한 파티션 수, 복제본 수, 배치 제약 조건, 메트릭, 기본 로드, 서비스 이름, DNS 설정 또는 다른 속성을 가지고 있을 필요가 없습니다.</span><span class="sxs-lookup"><span data-stu-id="eba24-263">Different users don't have to have the same partition count, replica count, placement constraints, metrics, default loads, service names, dns settings, or any of the other properties specified at the service or application level.</span></span> 
  - <span data-ttu-id="eba24-264">추가 데이터 조각화를 구성할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="eba24-264">You gain additional data segmentation.</span></span> <span data-ttu-id="eba24-265">각 고객이 서비스의 고유한 복사본을 갖고 있기 때문에 데이터 구분이 가능합니다.</span><span class="sxs-lookup"><span data-stu-id="eba24-265">Each customer has their own copy of the service</span></span>
    - <span data-ttu-id="eba24-266">각 고객 서비스마다 예상되는 규모에 따라 필요한 만큼 더 많거나 적은 파티션 또는 복제본으로 다르게 구성되어 더 많거나 적은 리소스가 허용될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="eba24-266">Each customer service can be configured differently and granted more or fewer resources, with more or fewer partitions or replicas as necessary based on their expected scale.</span></span>
      - <span data-ttu-id="eba24-267">예를 들어 고객이 "골드" 계층에 대한 요금을 지불한 경우 더 많은 복제본 또는 더 큰 파티션 수를 얻을 수 있으며, 잠재적으로 메트릭 및 응용 프로그램 용량을 통해 서비스 전용 리소스를 얻을 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="eba24-267">For example, say the customer paid for the "Gold" tier - they could get more replicas or greater partition count, and potentially resources dedicated to their services via metrics and application capacities.</span></span>
      - <span data-ttu-id="eba24-268">또는 필요한 계약 수가 "소량"임을 나타내는 정보를 제공한 경우 몇 개의 파티션만 얻거나 다른 고객과 공유하는 서비스 풀에 넣을 수도 있습니다.</span><span class="sxs-lookup"><span data-stu-id="eba24-268">Or say they provided information indicating the number of contacts they needed was "Small" - they would get only a few partitions, or could even be put into a shared service pool with other customers.</span></span>
  - <span data-ttu-id="eba24-269">고객이 나타나기를 기다리는 동안 다양한 서비스 인스턴스 또는 복제본을 실행하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="eba24-269">You're not running a bunch of service instances or replicas while you're waiting for customers to show up</span></span>
  - <span data-ttu-id="eba24-270">고객이 떠난 경우 서비스에서 해당 정보를 제거하는 작업은 관리자에서 만든 해당 서비스 또는 응용 프로그램을 삭제하는 것만큼 간단합니다.</span><span class="sxs-lookup"><span data-stu-id="eba24-270">If a customer ever leaves, then removing their information from your service is as simple as having the manager delete that service or application that it created.</span></span>

## <a name="next-steps"></a><span data-ttu-id="eba24-271">다음 단계</span><span class="sxs-lookup"><span data-stu-id="eba24-271">Next steps</span></span>
<span data-ttu-id="eba24-272">Service Fabric 개념에 대한 자세한 내용은 다음 문서를 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="eba24-272">For more information on Service Fabric concepts, see the following articles:</span></span>

* [<span data-ttu-id="eba24-273">서비스 패브릭 서비스의 가용성</span><span class="sxs-lookup"><span data-stu-id="eba24-273">Availability of Service Fabric services</span></span>](service-fabric-availability-services.md)
* [<span data-ttu-id="eba24-274">서비스 패브릭 서비스 분할</span><span class="sxs-lookup"><span data-stu-id="eba24-274">Partitioning Service Fabric services</span></span>](service-fabric-concepts-partitioning.md)
