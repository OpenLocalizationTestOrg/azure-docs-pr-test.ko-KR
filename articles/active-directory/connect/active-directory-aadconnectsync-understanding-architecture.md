---
title: "Azure AD Connect 동기화: 아키텍처 이해 | Microsoft Docs"
description: "이 항목에서는 Azure AD Connect 동기화의 아키텍처와 사용되는 용어에 대해 설명합니다."
services: active-directory
documentationcenter: 
author: andkjell
manager: femila
editor: 
ms.assetid: 465bcbe9-3bdd-4769-a8ca-f8905abf426d
ms.service: active-directory
ms.workload: identity
ms.tgt_pltfrm: na
ms.devlang: na
ms.topic: article
ms.date: 07/13/2017
ms.author: billmath
ms.openlocfilehash: 51082ad453d53f56f30f814b78578801c00f4827
ms.sourcegitcommit: 02e69c4a9d17645633357fe3d46677c2ff22c85a
ms.translationtype: MT
ms.contentlocale: ko-KR
ms.lasthandoff: 08/03/2017
---
# <a name="azure-ad-connect-sync-understanding-the-architecture"></a><span data-ttu-id="f979d-103">Azure AD Connect 동기화: 아키텍처 이해</span><span class="sxs-lookup"><span data-stu-id="f979d-103">Azure AD Connect sync: Understanding the architecture</span></span>
<span data-ttu-id="f979d-104">이 항목에서는 Azure AD Connect 동기화의 기본 아키텍처에 대해 설명합니다.</span><span class="sxs-lookup"><span data-stu-id="f979d-104">This topic covers the basic architecture for Azure AD Connect sync.</span></span> <span data-ttu-id="f979d-105">다양한 측면에서 이전 버전의 MIIS 2003, ILM 2007 및 FIM 2010과 비슷합니다.</span><span class="sxs-lookup"><span data-stu-id="f979d-105">In many aspects, it is similar to its predecessors MIIS 2003, ILM 2007, and FIM 2010.</span></span> <span data-ttu-id="f979d-106">Azure AD Connect 동기화는 이러한 기술이 진화된 모습입니다.</span><span class="sxs-lookup"><span data-stu-id="f979d-106">Azure AD Connect sync is the evolution of these technologies.</span></span> <span data-ttu-id="f979d-107">이러한 앞의 기술에 대해 잘 알고 있다면 이 항목의 내용 역시 이해하기 쉽습니다.</span><span class="sxs-lookup"><span data-stu-id="f979d-107">If you are familiar with any of these earlier technologies, the content of this topic will be familiar to you as well.</span></span> <span data-ttu-id="f979d-108">동기화를 처음 접하는 경우 이 항목이 도움이 될 것입니다.</span><span class="sxs-lookup"><span data-stu-id="f979d-108">If you are new to synchronization, then this topic is for you.</span></span> <span data-ttu-id="f979d-109">하지만 Azure AD Connect 동기화(이 토픽에서는 동기화 엔진이라고 함)를 성공적으로 사용자 지정하기 위해 이 항목의 세부 내용을 알 필요는 없습니다.</span><span class="sxs-lookup"><span data-stu-id="f979d-109">It is however not a requirement to know the details of this topic to be successful in making customizations to Azure AD Connect sync (called sync engine in this topic).</span></span>

## <a name="architecture"></a><span data-ttu-id="f979d-110">아키텍처</span><span class="sxs-lookup"><span data-stu-id="f979d-110">Architecture</span></span>
<span data-ttu-id="f979d-111">동기화 엔진은 연결된 여러 데이터 원본에 저장된 개체의 통합된 보기를 만들고 해당 데이터 원본에서 ID 정보를 관리합니다.</span><span class="sxs-lookup"><span data-stu-id="f979d-111">The sync engine creates an integrated view of objects that are stored in multiple connected data sources and manages identity information in those data sources.</span></span> <span data-ttu-id="f979d-112">이 통합된 보기는 연결된 데이터 원본에서 검색된 ID 정보와 이 정보를 처리하는 방법을 결정하는 규칙 집합에 의해 결정됩니다.</span><span class="sxs-lookup"><span data-stu-id="f979d-112">This integrated view is determined by the identity information retrieved from connected data sources and a set of rules that determine how to process this information.</span></span>

### <a name="connected-data-sources-and-connectors"></a><span data-ttu-id="f979d-113">연결된 데이터 원본 및 커넥터</span><span class="sxs-lookup"><span data-stu-id="f979d-113">Connected Data Sources and Connectors</span></span>
<span data-ttu-id="f979d-114">동기화 엔진은 Active Directory 또는 SQL Server 데이터베이스와 같은 다양한 데이터 리포지토리에서 ID 정보를 처리합니다.</span><span class="sxs-lookup"><span data-stu-id="f979d-114">The sync engine processes identity information from different data repositories, such as Active Directory or a SQL Server database.</span></span> <span data-ttu-id="f979d-115">데이터베이스와 유사한 형식으로 데이터를 구성하고 표준 데이터 액세스 방법을 제공하는 모든 데이터 리포지토리는 동기화 엔진을 위한 데이터 원본 후보가 될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="f979d-115">Every data repository that organizes its data in a database-like format and that provides standard data-access methods is a potential data source candidate for the sync engine.</span></span> <span data-ttu-id="f979d-116">동기화 엔진에 의해 동기화되는 데이터 리포지토리는 **연결된 데이터 원본** 또는 **연결된 디렉터리**(CD)라고 합니다.</span><span class="sxs-lookup"><span data-stu-id="f979d-116">The data repositories that are synchronized by sync engine are called **connected data sources** or **connected directories** (CD).</span></span>

<span data-ttu-id="f979d-117">동기화 엔진은 연결된 데이터 원본과 상호 작용을 **커넥터**라는 모듈 안으로 캡슐화합니다.</span><span class="sxs-lookup"><span data-stu-id="f979d-117">The sync engine encapsulates interaction with a connected data source within a module called a **Connector**.</span></span> <span data-ttu-id="f979d-118">각 유형의 연결된 데이터 원본은 특정 커넥터를 포함합니다.</span><span class="sxs-lookup"><span data-stu-id="f979d-118">Each type of connected data source has a specific Connector.</span></span> <span data-ttu-id="f979d-119">커넥터는 필요한 작업을 연결된 데이터 원본이 이해할 수 있는 형식으로 변환합니다.</span><span class="sxs-lookup"><span data-stu-id="f979d-119">The Connector translates a required operation into the format that the connected data source understands.</span></span>

<span data-ttu-id="f979d-120">커넥터는 API 호출을 통해 ID 정보(읽기 및 쓰기)를 연결된 데이터 원본과 교환합니다.</span><span class="sxs-lookup"><span data-stu-id="f979d-120">Connectors make API calls to exchange identity information (both read and write) with a connected data source.</span></span> <span data-ttu-id="f979d-121">또한 확장 가능한 연결 프레임워크를 사용하여 사용자 지정 커넥터를 추가할 수도 있습니다.</span><span class="sxs-lookup"><span data-stu-id="f979d-121">It is also possible to add a custom Connector using the extensible connectivity framework.</span></span> <span data-ttu-id="f979d-122">다음 그림에서는 커넥터가 연결된 데이터 원본을 동기화 엔진에 연결하는 방법을 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="f979d-122">The following illustration shows how a Connector connects a connected data source to the sync engine.</span></span>

![Arch1](./media/active-directory-aadconnectsync-understanding-architecture/arch1.png)

<span data-ttu-id="f979d-124">데이터는 어느 방향으로나 이동할 수 있지만 양방향으로 동시에 이동할 수는 없습니다.</span><span class="sxs-lookup"><span data-stu-id="f979d-124">Data can flow in either direction, but it cannot flow in both directions simultaneously.</span></span> <span data-ttu-id="f979d-125">즉, 연결된 데이터 원본에서 동기화 엔진으로 또는 동기화 엔진에서 연결된 데이터 원본으로 데이터가 이동하도록 커넥터를 구성할 수 있지만 한 개체 및 특성에 대해 한 번에 이러한 작업 중 하나만 발생할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="f979d-125">In other words, a Connector can be configured to allow data to flow from the connected data source to sync engine or from sync engine to the connected data source, but only one of those operations can occur at any one time for one object and attribute.</span></span> <span data-ttu-id="f979d-126">방향은 개체 및 특성마다 다를 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="f979d-126">The direction can be different for different objects and for different attributes.</span></span>

<span data-ttu-id="f979d-127">커넥터를 구성하려면 동기화할 개체 유형을 지정합니다.</span><span class="sxs-lookup"><span data-stu-id="f979d-127">To configure a Connector, you specify the object types that you want to synchronize.</span></span> <span data-ttu-id="f979d-128">개체 유형을 지정하면 동기화 프로세스에 포함되는 개체 범위가 정의됩니다.</span><span class="sxs-lookup"><span data-stu-id="f979d-128">Specifying the object types defines the scope of objects that are included in the synchronization process.</span></span> <span data-ttu-id="f979d-129">다음 단계로, 동기화할 특성을 선택하는데 이를 특성 포함 목록이라고 합니다.</span><span class="sxs-lookup"><span data-stu-id="f979d-129">The next step is to select the attributes to synchronize, which is known as an attribute inclusion list.</span></span> <span data-ttu-id="f979d-130">이러한 설정은 비즈니스 규칙이 변경됨에 따라 언제든지 변경할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="f979d-130">These settings can be changed any time in response to changes to your business rules.</span></span> <span data-ttu-id="f979d-131">Azure AD Connect 설치 마법사를 사용하면 이러한 설정이 구성됩니다.</span><span class="sxs-lookup"><span data-stu-id="f979d-131">When you use the Azure AD Connect installation wizard, these settings are configured for you.</span></span>

<span data-ttu-id="f979d-132">연결된 데이터 원본으로 개체를 내보내려면 연결된 데이터 원본에서 특정 개체 유형을 만드는 데 필요한 최소 특성이 특성 포함 목록에 포함되어 있어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="f979d-132">To export objects to a connected data source, the attribute inclusion list must include at least the minimum attributes required to create a specific object type in a connected data source.</span></span> <span data-ttu-id="f979d-133">예를 들어 사용자 개체를 Active Directory로 내보내기 위해서는 특성 포함 목록에 **sAMAccountName** 특성이 포함되어 있어야 합니다. Active Directory의 모든 사용자 개체에 **sAMAccountName** 특성이 정의되어 있기 때문입니다.</span><span class="sxs-lookup"><span data-stu-id="f979d-133">For example, the **sAMAccountName** attribute must be included in the attribute inclusion list to export a user object to Active Directory because all user objects in Active Directory must have a **sAMAccountName** attribute defined.</span></span> <span data-ttu-id="f979d-134">설치 마법사는 다시 이 구성을 수행합니다.</span><span class="sxs-lookup"><span data-stu-id="f979d-134">Again, the installation wizard does this configuration for you.</span></span>

<span data-ttu-id="f979d-135">연결된 데이터 원본에서 개체를 구성하는 데 파티션 또는 컨테이너와 같은 구조적 구성 요소를 사용하는 경우 지정된 솔루션에 사용되는 연결된 데이터 원본의 영역을 제한할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="f979d-135">If the connected data source uses structural components, such as partitions or containers to organize objects, you can limit the areas in the connected data source that are used for a given solution.</span></span>

### <a name="internal-structure-of-the-sync-engine-namespace"></a><span data-ttu-id="f979d-136">동기화 엔진 네임스페이스의 내부 구조</span><span class="sxs-lookup"><span data-stu-id="f979d-136">Internal structure of the sync engine namespace</span></span>
<span data-ttu-id="f979d-137">전체 시스템 엔진 네임스페이스는 ID 정보를 저장하는 두 개의 네임스페이스로 구성됩니다.</span><span class="sxs-lookup"><span data-stu-id="f979d-137">The entire sync engine namespace consists of two namespaces that store the identity information.</span></span> <span data-ttu-id="f979d-138">두 네임스페이스는 다음과 같습니다.</span><span class="sxs-lookup"><span data-stu-id="f979d-138">The two namespaces are:</span></span>

* <span data-ttu-id="f979d-139">커넥터 공간(CS)</span><span class="sxs-lookup"><span data-stu-id="f979d-139">The connector space (CS)</span></span>
* <span data-ttu-id="f979d-140">메타버스(MV)</span><span class="sxs-lookup"><span data-stu-id="f979d-140">The metaverse (MV)</span></span>

<span data-ttu-id="f979d-141">**커넥터 공간** 은 특성 포함 목록에 지정된 특성 및 연결된 데이터 원본에서 지정된 개체의 표현이 들어 있는 스테이징 영역입니다.</span><span class="sxs-lookup"><span data-stu-id="f979d-141">The **connector space** is a staging area that contains representations of the designated objects from a connected data source and the attributes specified in the attribute inclusion list.</span></span> <span data-ttu-id="f979d-142">동기화 엔진은 커넥터 공간을 사용하여 연결된 데이터 원본에서 변경된 내용을 확인하고 들어오는 변경 내용을 준비합니다.</span><span class="sxs-lookup"><span data-stu-id="f979d-142">The sync engine uses the connector space to determine what has changed in the connected data source and to stage incoming changes.</span></span> <span data-ttu-id="f979d-143">또한 동기화 엔진은 커넥터 공간을 사용하여 연결된 데이터 원본으로 내보내기 위해 나가는 변경 내용을 준비합니다.</span><span class="sxs-lookup"><span data-stu-id="f979d-143">The sync engine also uses the connector space to stage outgoing changes for export to the connected data source.</span></span> <span data-ttu-id="f979d-144">동기화 엔진은 각 커넥터에 대한 스테이징 영역으로 고유한 커넥터 공간을 유지합니다.</span><span class="sxs-lookup"><span data-stu-id="f979d-144">The sync engine maintains a distinct connector space as a staging area for each Connector.</span></span>

<span data-ttu-id="f979d-145">동기화 엔진은 스테이징 영역을 사용하여 연결된 데이터 원본과 독립적인 상태를 유지하고 데이터 원본의 가용성 및 접근성에 영향을 받지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="f979d-145">By using a staging area, the sync engine remains independent of the connected data sources and is not affected by their availability and accessibility.</span></span> <span data-ttu-id="f979d-146">결과적으로, 스테이징 영역에 데이터를 사용하여 언제든지 ID 정보를 처리할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="f979d-146">As a result, you can process identity information at any time by using the data in the staging area.</span></span> <span data-ttu-id="f979d-147">동기화 엔진은 마지막 통신 세션이 종료된 이후 연결된 데이터 원본 내에서 변경된 내용만 요청할 수 있으며 연결된 데이터 원본에서 아직 수신하지 않은 ID 정보의 변경 내용만 푸시할 수 있습니다. 따라서 동기화 엔진과 연결된 데이터 원본 간의 네트워크 트래픽이 감소합니다.</span><span class="sxs-lookup"><span data-stu-id="f979d-147">The sync engine can request only the changes made inside the connected data source since the last communication session terminated or push out only the changes to identity information that the connected data source has not yet received, which reduces the network traffic between the sync engine and the connected data source.</span></span>

<span data-ttu-id="f979d-148">또한 동기화 엔진은 준비하는 모든 개체에 대한 상태 정보를 커넥터 공간에 저장합니다.</span><span class="sxs-lookup"><span data-stu-id="f979d-148">In addition, sync engine stores status information about all objects that it stages in the connector space.</span></span> <span data-ttu-id="f979d-149">새 데이터를 수신하면 동기화 엔진이 항상 데이터가 이미 동기화되었는지 여부를 평가합니다.</span><span class="sxs-lookup"><span data-stu-id="f979d-149">When new data is received, sync engine always evaluates whether the data has already been synchronized.</span></span>

<span data-ttu-id="f979d-150">**메타버스** 는 여러 연결된 데이터 원본에서 집계된 ID 정보를 포함하는 저장소 영역으로, 결합된 모든 개체에 대해 하나의 글로벌 통합 보기를 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="f979d-150">The **metaverse** is a storage area that contains the aggregated identity information from multiple connected data sources, providing a single global, integrated view of all combined objects.</span></span> <span data-ttu-id="f979d-151">메타버스 개체는 연결된 데이터 원본에서 검색된 ID 정보와 동기화 프로세스를 사용자 지정하는 규칙 집합을 기반으로 만들어집니다.</span><span class="sxs-lookup"><span data-stu-id="f979d-151">Metaverse objects are created based on the identity information that is retrieved from the connected data sources and a set of rules that allow you to customize the synchronization process.</span></span>

<span data-ttu-id="f979d-152">다음 그림에서는 동기화 엔진 내에 있는 커넥터 공간 네임스페이스와 메타버스 네임스페이스를 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="f979d-152">The following illustration shows the connector space namespace and the metaverse namespace within the sync engine.</span></span>

![Arch2](./media/active-directory-aadconnectsync-understanding-architecture/arch2.png)

## <a name="sync-engine-identity-objects"></a><span data-ttu-id="f979d-154">동기화 엔진 ID 개체</span><span class="sxs-lookup"><span data-stu-id="f979d-154">Sync engine identity objects</span></span>
<span data-ttu-id="f979d-155">동기화 엔진의 개체는 연결된 데이터 원본의 개체 또는 동기화 엔진에서 이러한 개체 중에 통합된 보기를 만드는 개체를 표현합니다.</span><span class="sxs-lookup"><span data-stu-id="f979d-155">The objects in the sync engine are representations of either objects in the connected data source or the integrated view that sync engine has of those objects.</span></span> <span data-ttu-id="f979d-156">모든 동기화 엔진 개체에는 전역 고유 식별자(GUID)가 있어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="f979d-156">Every sync engine object must have a globally unique identifier (GUID).</span></span> <span data-ttu-id="f979d-157">GUID는 데이터 무결성을 제공하고 개체 간의 관계를 표현합니다.</span><span class="sxs-lookup"><span data-stu-id="f979d-157">GUIDs provide data integrity and express relationships between objects.</span></span>

### <a name="connector-space-objects"></a><span data-ttu-id="f979d-158">커넥터 공간 개체</span><span class="sxs-lookup"><span data-stu-id="f979d-158">Connector space objects</span></span>
<span data-ttu-id="f979d-159">동기화 엔진이 연결된 데이터 원본과 통신하는 경우 엔진이 연결된 데이터 원본에서 ID 정보를 읽고 이 정보를 사용하여 커넥터 공간에 ID 개체의 표현을 만듭니다.</span><span class="sxs-lookup"><span data-stu-id="f979d-159">When sync engine communicates with a connected data source, it reads the identity information in the connected data source and uses that information to create a representation of the identity object in the connector space.</span></span> <span data-ttu-id="f979d-160">이러한 개체는 개별적으로 만들거나 삭제할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="f979d-160">You cannot create or delete these objects individually.</span></span> <span data-ttu-id="f979d-161">그러나 커넥터 공간의 모든 개체를 수동으로 삭제할 수는 있습니다.</span><span class="sxs-lookup"><span data-stu-id="f979d-161">However, you can manually delete all objects in a connector space.</span></span>

<span data-ttu-id="f979d-162">커넥터 공간의 모든 개체에는 두 가지 특성이 있습니다.</span><span class="sxs-lookup"><span data-stu-id="f979d-162">All objects in the connector space have two attributes:</span></span>

* <span data-ttu-id="f979d-163">전역적으로 고유한 식별자(GUID)</span><span class="sxs-lookup"><span data-stu-id="f979d-163">A globally unique identifier (GUID)</span></span>
* <span data-ttu-id="f979d-164">고유 이름(DN이라고 함)</span><span class="sxs-lookup"><span data-stu-id="f979d-164">A distinguished name (also known as DN)</span></span>

<span data-ttu-id="f979d-165">연결된 데이터 원본이 개체에 대해 고유한 특성을 할당하는 경우 커넥터 공간의 개체는 앵커 특성을 포함할 수도 있습니다.</span><span class="sxs-lookup"><span data-stu-id="f979d-165">If the connected data source assigns a unique attribute to the object, then objects in the connector space can also have an anchor attribute.</span></span> <span data-ttu-id="f979d-166">앵커 특성은 연결된 데이터 원본에서 개체를 고유하게 식별합니다.</span><span class="sxs-lookup"><span data-stu-id="f979d-166">The anchor attribute uniquely identifies an object in the connected data source.</span></span> <span data-ttu-id="f979d-167">동기화 엔진은 앵커를 사용하여 연결된 데이터 원본에서 이 개체에 해당하는 표현을 찾습니다.</span><span class="sxs-lookup"><span data-stu-id="f979d-167">The sync engine uses the anchor to locate the corresponding representation of this object in the connected data source.</span></span> <span data-ttu-id="f979d-168">동기화 엔진은 개체의 앵커가 개체의 수명 동안 변경되지 않는다고 가정합니다.</span><span class="sxs-lookup"><span data-stu-id="f979d-168">Sync engine assumes that the anchor of an object never changes over the lifetime of the object.</span></span>

<span data-ttu-id="f979d-169">많은 커넥터가 개체를 가져올 때 알려진 고유한 식별자를 사용하여 각 개체에 대해 앵커를 자동으로 생성합니다.</span><span class="sxs-lookup"><span data-stu-id="f979d-169">Many of the Connectors use a known unique identifier to generate an anchor automatically for each object when it is imported.</span></span> <span data-ttu-id="f979d-170">예를 들어 Active Directory Connector는 **objectGUID** 앵커 특성을 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="f979d-170">For example, the Active Directory Connector uses the **objectGUID** attribute for an anchor.</span></span> <span data-ttu-id="f979d-171">명확하게 정의된 고유 식별자를 제공하지 않는 연결된 데이터 원본의 경우 커넥터 구성의 일부로 앵커 생성을 지정할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="f979d-171">For connected data sources that do not provide a clearly defined unique identifier, you can specify anchor generation as part of the Connector configuration.</span></span>

<span data-ttu-id="f979d-172">이 경우 앵커는 개체 유형에 대한 하나 이상의 고유 특성에서 작성되며 변경할 필요 없이 커넥터 공간에서 개체를 고유하게 식별합니다(예를 들어 직원 번호 또는 사용자 ID).</span><span class="sxs-lookup"><span data-stu-id="f979d-172">In that case, the anchor is built from one or more unique attributes of an object type, neither of which changes, and that uniquely identifies the object in the connector space (for example, an employee number or a user ID).</span></span>

<span data-ttu-id="f979d-173">커넥터 공간 개체는 다음 중 하나일 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="f979d-173">A connector space object can be one of the following:</span></span>

* <span data-ttu-id="f979d-174">스테이징 개체</span><span class="sxs-lookup"><span data-stu-id="f979d-174">A staging object</span></span>
* <span data-ttu-id="f979d-175">자리 표시자</span><span class="sxs-lookup"><span data-stu-id="f979d-175">A placeholder</span></span>

### <a name="staging-objects"></a><span data-ttu-id="f979d-176">스테이징 개체</span><span class="sxs-lookup"><span data-stu-id="f979d-176">Staging Objects</span></span>
<span data-ttu-id="f979d-177">스테이징 개체는 연결된 데이터 원본에서 지정된 개체 유형의 인스턴스를 나타냅니다.</span><span class="sxs-lookup"><span data-stu-id="f979d-177">A staging object represents an instance of the designated object types from the connected data source.</span></span> <span data-ttu-id="f979d-178">스테이징 개체는 GUID와 고유 이름 외에도 개체 유형을 나타내는 값을 항상 포함합니다.</span><span class="sxs-lookup"><span data-stu-id="f979d-178">In addition to the GUID and the distinguished name, a staging object always has a value that indicates the object type.</span></span>

<span data-ttu-id="f979d-179">가져온 스테이징 개체는 항상 앵커 특성에 대한 값을 포함합니다.</span><span class="sxs-lookup"><span data-stu-id="f979d-179">Staging objects that have been imported always have a value for the anchor attribute.</span></span> <span data-ttu-id="f979d-180">동기화 엔진에 의해 새로 프로비전되어 연결된 데이터 원본에 만들기 과정에 있는 스테이징 개체는 앵커 특성에 대한 값을 포함하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="f979d-180">Staging objects that have been newly provisioned by sync engine and are in the process of being created in the connected data source do not have a value for the anchor attribute.</span></span>

<span data-ttu-id="f979d-181">스테이징 개체는 또한 동기화 엔진이 동기화 프로세스를 수행하는 데 필요한 작업 정보와 비즈니스 특성에 대한 최신 값을 전달합니다.</span><span class="sxs-lookup"><span data-stu-id="f979d-181">Staging objects also carry current values of business attributes, and operational information needed by sync engine to perform the synchronization process.</span></span> <span data-ttu-id="f979d-182">작업 정보에는 스테이징 개체에서 준비되는 업데이트 유형을 나타내는 플래그가 포함됩니다.</span><span class="sxs-lookup"><span data-stu-id="f979d-182">Operational information includes flags that indicate the type of updates that are staged on the staging object.</span></span> <span data-ttu-id="f979d-183">스테이징 개체가 아직 처리되지 않은 연결된 데이터 원본에서 새 ID 정보를 수신하면 해당 개체는 **보류 중인 가져오기**로 플래그 지정됩니다.</span><span class="sxs-lookup"><span data-stu-id="f979d-183">If a staging object has received new identity information from the connected data source that has not yet been processed, the object is flagged as **pending import**.</span></span> <span data-ttu-id="f979d-184">스테이징 개체에 연결된 데이터 원본으로 아직 내보내지 않은 새 ID 정보가 있는 경우 **보류 중인 내보내기**로 플래그 지정됩니다.</span><span class="sxs-lookup"><span data-stu-id="f979d-184">If a staging object has new identity information that has not yet been exported to the connected data source, it is flagged as **pending export**.</span></span>

<span data-ttu-id="f979d-185">스테이징 개체는 가져오기 또는 내보내기 개체가 될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="f979d-185">A staging object can be an import object or an export object.</span></span> <span data-ttu-id="f979d-186">동기화 엔진은 연결된 데이터 원본에서 받은 개체 정보를 사용하여 가져오기 개체를 만듭니다.</span><span class="sxs-lookup"><span data-stu-id="f979d-186">The sync engine creates an import object by using object information received from the connected data source.</span></span> <span data-ttu-id="f979d-187">동기화 엔진이 커넥터에서 선택된 개체 유형 중 하나와 일치하는 새 개체의 존재에 대한 정보를 수신하면 연결된 데이터 원본에서 개체의 표현으로 커넥터 공간에 가져오기 개체를 만듭니다.</span><span class="sxs-lookup"><span data-stu-id="f979d-187">When sync engine receives information about the existence of a new object that matches one of the object types selected in the Connector, it creates an import object in the connector space as a representation of the object in the connected data source.</span></span>

<span data-ttu-id="f979d-188">다음 그림에서는 연결된 데이터 원본에 있는 개체를 나타내는 가져오기 개체를 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="f979d-188">The following illustration shows an import object that represents an object in the connected data source.</span></span>

![Arch3](./media/active-directory-aadconnectsync-understanding-architecture/arch3.png)

<span data-ttu-id="f979d-190">동기화 엔진은 메타버스의 개체 정보를 사용하여 내보내기 개체를 만듭니다.</span><span class="sxs-lookup"><span data-stu-id="f979d-190">The sync engine creates an export object by using object information in the metaverse.</span></span> <span data-ttu-id="f979d-191">내보내기 개체는 다음 통신 세션 동안 연결된 데이터 원본으로 내보내집니다.</span><span class="sxs-lookup"><span data-stu-id="f979d-191">Export objects are exported to the connected data source during the next communication session.</span></span> <span data-ttu-id="f979d-192">동기화 엔진의 관점에서 내보내기 개체는 연결된 데이터 원본에 아직 존재하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="f979d-192">From the perspective of the sync engine, export objects do not exist in the connected data source yet.</span></span> <span data-ttu-id="f979d-193">따라서 내보내기 개체에 대한 앵커 특성은 사용할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="f979d-193">Therefore, the anchor attribute for an export object is not available.</span></span> <span data-ttu-id="f979d-194">동기화 엔진에서 개체를 수신하면 연결된 데이터 원본은 개체의 앵커 특성으로 고유한 값을 만듭니다.</span><span class="sxs-lookup"><span data-stu-id="f979d-194">After it receives the object from sync engine, the connected data source creates a unique value for the anchor attribute of the object.</span></span>

<span data-ttu-id="f979d-195">다음 그림에서는 메타버스의 ID 정보를 사용하여 내보내기 개체가 어떻게 만들어지는지를 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="f979d-195">The following illustration shows how an export object is created by using identity information in the metaverse.</span></span>

![Arch4](./media/active-directory-aadconnectsync-understanding-architecture/arch4.png)

<span data-ttu-id="f979d-197">동기화 엔진은 연결된 데이터 원본에서 개체를 다시 가져와서 개체의 내보내기를 확인합니다.</span><span class="sxs-lookup"><span data-stu-id="f979d-197">The sync engine confirms the export of the object by reimporting the object from the connected data source.</span></span> <span data-ttu-id="f979d-198">해당 연결된 데이터 원본에서 다음 가져오는 동안 동기화 엔진이 개체를 수신하면 내보내기 개체는 가져오기 개체가 됩니다.</span><span class="sxs-lookup"><span data-stu-id="f979d-198">Export objects become import objects when sync engine receives them during the next import from that connected data source.</span></span>

### <a name="placeholders"></a><span data-ttu-id="f979d-199">자리 표시자</span><span class="sxs-lookup"><span data-stu-id="f979d-199">Placeholders</span></span>
<span data-ttu-id="f979d-200">동기화 엔진은 개체를 저장하는 데 단일 구조 네임스페이스를 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="f979d-200">The sync engine uses a flat namespace to store objects.</span></span> <span data-ttu-id="f979d-201">그러나 Active Directory와 같은 일부 연결된 데이터 원본은 계층 구조 네임스페이스를 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="f979d-201">However, some connected data sources such as Active Directory use a hierarchical namespace.</span></span> <span data-ttu-id="f979d-202">계층 구조 네임스페이스에서 단일 구조 네임스페이스로 정보를 변환할 때 동기화 엔진은 자리 표시자를 사용하여 계층 구조를 유지합니다.</span><span class="sxs-lookup"><span data-stu-id="f979d-202">To transform information from a hierarchical namespace into a flat namespace, sync engine uses placeholders to preserve the hierarchy.</span></span>

<span data-ttu-id="f979d-203">각 자리 표시자는 동기화 엔진으로 가져오지 않았지만 계층 구조 이름을 생성하는 데 필요한 개체의 계층 구조 이름에 대한 구성 요소(예를 들어, 조직 구성 단위)를 나타냅니다.</span><span class="sxs-lookup"><span data-stu-id="f979d-203">Each placeholder represents a component (for example, an organizational unit) of an object's hierarchical name that has not been imported into sync engine but is required to construct the hierarchical name.</span></span> <span data-ttu-id="f979d-204">연결된 데이터 원본에서 커넥터 공간의 스테이징 개체가 아닌 개체로의 참조에 의해 발생한 차이를 채웁니다.</span><span class="sxs-lookup"><span data-stu-id="f979d-204">They fill gaps created by references in the connected data source to objects that are not staging objects in the connector space.</span></span>

<span data-ttu-id="f979d-205">또한 동기화 엔진은 아직 가져오지 않은 참조된 개체를 저장하는 데도 자리 표시자를 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="f979d-205">The sync engine also uses placeholders to store referenced objects that have not yet been imported.</span></span> <span data-ttu-id="f979d-206">예를 들어, *Abbie Spencer* 개체에 대한 관리자 특성을 포함하도록 동기화가 구성되고 수신된 값이 아직 가져오지 않은 개체(예: *CN=Lee Sperry,CN=Users,DC=fabrikam,DC=com*)인 경우 관리자 정보는 커넥터 공간에 자리 표시자로 저장됩니다.</span><span class="sxs-lookup"><span data-stu-id="f979d-206">For example, if sync is configured to include the manager attribute for the *Abbie Spencer* object and the received value is an object that has not been imported yet, such as *CN=Lee Sperry,CN=Users,DC=fabrikam,DC=com*, the manager information is stored as placeholders in the connector space.</span></span> <span data-ttu-id="f979d-207">나중에 관리자 개체를 가져올 때 자리 표시자 개체를 관리자를 나타내는 스테이징 개체로 덮어씁니다.</span><span class="sxs-lookup"><span data-stu-id="f979d-207">If the manager object is later imported, the placeholder object is overwritten by the staging object that represents the manager.</span></span>

### <a name="metaverse-objects"></a><span data-ttu-id="f979d-208">메타버스 개체</span><span class="sxs-lookup"><span data-stu-id="f979d-208">Metaverse objects</span></span>
<span data-ttu-id="f979d-209">메타버스 개체는 동기화 엔진이 커넥터 공간의 스테이징 개체로 생성하는 집계 보기를 포함합니다.</span><span class="sxs-lookup"><span data-stu-id="f979d-209">A metaverse object contains the aggregated view that sync engine has of the staging objects in the connector space.</span></span> <span data-ttu-id="f979d-210">동기화 엔진은 가져오기 개체의 정보를 사용하여 메타버스 개체를 만듭니다.</span><span class="sxs-lookup"><span data-stu-id="f979d-210">Sync engine creates metaverse objects by using the information in import objects.</span></span> <span data-ttu-id="f979d-211">여러 커넥터 공간 개체가 단일 메타버스 개체에 연결될 수 있지만 하나의 커넥터 공간 개체를 둘 이상의 메타버스 개체에 연결할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="f979d-211">Several connector space objects can be linked to a single metaverse object, but a connector space object cannot be linked to more than one metaverse object.</span></span>

<span data-ttu-id="f979d-212">메타버스 개체는 수동으로 생성 또는 삭제할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="f979d-212">Metaverse objects cannot be manually created or deleted.</span></span> <span data-ttu-id="f979d-213">동기화 엔진은 커넥터 공간에서 어떠한 커넥터 공간 개체에 대한 링크도 포함하지 않는 메타버스 개체를 자동으로 삭제합니다.</span><span class="sxs-lookup"><span data-stu-id="f979d-213">The sync engine automatically deletes metaverse objects that do not have a link to any connector space object in the connector space.</span></span>

<span data-ttu-id="f979d-214">연결된 데이터 원본 내의 개체를 메타버스 내에서 해당하는 개체 유형으로 매핑하기 위해 동기화 엔진은 미리 정의된 개체 유형 집합과 관련 특성으로 확장 가능한 스키마를 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="f979d-214">To map objects within a connected data source to a corresponding object type within the metaverse, sync engine provides an extensible schema with a predefined set of object types and associated attributes.</span></span> <span data-ttu-id="f979d-215">메타버스 개체에 대해 새 개체 유형 및 특성을 만들 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="f979d-215">You can create new object types and attributes for metaverse objects.</span></span> <span data-ttu-id="f979d-216">특성은 단일 값 또는 다중 값일 수 있으며 특성 형식은 문자열, 참조, 숫자 및 부울 값일 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="f979d-216">Attributes can be single-valued or multivalued, and the attribute types can be strings, references, numbers, and Boolean values.</span></span>

### <a name="relationships-between-staging-objects-and-metaverse-objects"></a><span data-ttu-id="f979d-217">스테이징 개체 및 메타버스 개체 간의 관계</span><span class="sxs-lookup"><span data-stu-id="f979d-217">Relationships between staging objects and metaverse objects</span></span>
<span data-ttu-id="f979d-218">동기화 엔진 네임스페이스 내에서 스테이징 개체 및 메타버스 개체 간 링크 관계로 데이터 흐름이 가능합니다.</span><span class="sxs-lookup"><span data-stu-id="f979d-218">Within the sync engine namespace, the data flow is enabled by the link relationship between staging objects and metaverse objects.</span></span> <span data-ttu-id="f979d-219">메타버스 개체에 연결되는 스테이징 개체를 **조인된 개체**(또는 **커넥터 개체**)라고 합니다.</span><span class="sxs-lookup"><span data-stu-id="f979d-219">A staging object that is linked to a metaverse object is called a **joined object** (or **connector object**).</span></span> <span data-ttu-id="f979d-220">메타버스 개체에 연결되지 않는 스테이징 개체를 **조인되지 않은 개체**(또는 **디스커넥터 개체**)라고 합니다.</span><span class="sxs-lookup"><span data-stu-id="f979d-220">A staging object that is not linked to a metaverse object is called a **disjoined object** (or **disconnector object**).</span></span> <span data-ttu-id="f979d-221">연결된 디렉터리에서 데이터 가져오기 및 내보내기를 담당하는 커넥터와 혼동하지 않도록 '조인' 및 '조인되지 않은'이라는 용어를 선호합니다.</span><span class="sxs-lookup"><span data-stu-id="f979d-221">The terms joined and disjoined are preferred to not confuse with the Connectors responsible for importing and exporting data from a connected directory.</span></span>

<span data-ttu-id="f979d-222">자리 표시자는 메타버스 개체에 연결되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="f979d-222">Placeholders are never linked to a metaverse object</span></span>

<span data-ttu-id="f979d-223">조인된 개체는 스테이징 개체와 단일 메타버스 개체로의 연결된 관계를 구성합니다.</span><span class="sxs-lookup"><span data-stu-id="f979d-223">A joined object comprises a staging object and its linked relationship to a single metaverse object.</span></span> <span data-ttu-id="f979d-224">조인된 개체는 커넥터 공간 개체와 메타버스 개체 사이의 특성 값을 동기화하는 데 사용됩니다.</span><span class="sxs-lookup"><span data-stu-id="f979d-224">Joined objects are used to synchronize attribute values between a connector space object and a metaverse object.</span></span>

<span data-ttu-id="f979d-225">동기화 중에 스테이징 개체가 조인된 개체가 되면 스테이징 개체와 메타버스 개체 간에 특성이 전달될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="f979d-225">When a staging object becomes a joined object during synchronization, attributes can flow between the staging object and the metaverse object.</span></span> <span data-ttu-id="f979d-226">특성 흐름은 양방향으로 수행되며 가져오기 및 내보내기 특성 규칙을 사용하여 구성합니다.</span><span class="sxs-lookup"><span data-stu-id="f979d-226">Attribute flow is bidirectional and is configured by using import attribute rules and export attribute rules.</span></span>

<span data-ttu-id="f979d-227">단일 커넥터 공간 개체는 하나의 메타버스 개체에만 연결할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="f979d-227">A single connector space object can be linked to only one metaverse object.</span></span> <span data-ttu-id="f979d-228">그러나 다음 그림에 나와 있는 것처럼 각 메타 버스 개체를 동일한 또는 다른 커넥터 공간에 여러 커넥터 공간 개체에 연결할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="f979d-228">However, each metaverse object can be linked to multiple connector space objects in the same or in different connector spaces, as shown in the following illustration.</span></span>

![Arch5](./media/active-directory-aadconnectsync-understanding-architecture/arch5.png)

<span data-ttu-id="f979d-230">스테이징 개체와 메타버스 개체 간의 연결된 관계는 영구적이며 사용자가 지정한 규칙으로만 제거할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="f979d-230">The linked relationship between the staging object and a metaverse object is persistent and can be removed only by rules that you specify.</span></span>

<span data-ttu-id="f979d-231">조인되지 않은 개체는 어떠한 메타버스 개체에도 연결되지 않은 스테이징 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="f979d-231">A disjoined object is a staging object that is not linked to any metaverse object.</span></span> <span data-ttu-id="f979d-232">조인되지 않은 개체의 특성 값은 메타버스에서 더 이상 처리되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="f979d-232">The attribute values of a disjoined object are not processed any further within the metaverse.</span></span> <span data-ttu-id="f979d-233">연결된 데이터 원본에서 해당 개체의 특성 값은 동기화 엔진에 의해 업데이트되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="f979d-233">The attribute values of the corresponding object in the connected data source are not updated by sync engine.</span></span>

<span data-ttu-id="f979d-234">조인되지 않은 개체를 사용하여 ID 정보를 동기화 엔진에 저장하고 나중에 처리할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="f979d-234">By using disjoined objects, you can store identity information in sync engine and process it later.</span></span> <span data-ttu-id="f979d-235">스테이징 개체를 커넥터 공간에 조인되지 않은 개체로 유지할 경우 여러 가지 이점이 있습니다.</span><span class="sxs-lookup"><span data-stu-id="f979d-235">Keeping a staging object as a disjoined object in the connector space has many advantages.</span></span> <span data-ttu-id="f979d-236">시스템은 이 개체에 대해 필요한 정보를 이미 준비했으므로 다음에 연결된 데이터 원본에서 가져오는 동안 이 개체에 대한 표현을 다시 만들 필요가 없습니다.</span><span class="sxs-lookup"><span data-stu-id="f979d-236">Because the system has already staged the required information about this object, it is not necessary to create a representation of this object again during the next import from the connected data source.</span></span> <span data-ttu-id="f979d-237">이러한 방식으로 동기화 엔진은 연결된 데이터 원본에 대해 현재 연결이 없는 경우에도 연결된 데이터 원본에 대해 항상 완전한 스냅숏을 포함합니다.</span><span class="sxs-lookup"><span data-stu-id="f979d-237">This way, sync engine always has a complete snapshot of the connected data source, even if there is no current connection to the connected data source.</span></span> <span data-ttu-id="f979d-238">조인되지 않은 개체는 지정된 규칙에 따라 조인된 개체로, 또는 그 반대로 변환할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="f979d-238">Disjoined objects can be converted into joined objects, and vice versa, depending on the rules that you specify.</span></span>

<span data-ttu-id="f979d-239">가져오기 개체는 조인되지 않은 개체로 만들어집니다.</span><span class="sxs-lookup"><span data-stu-id="f979d-239">An import object is created as a disjoined object.</span></span> <span data-ttu-id="f979d-240">내보내기 개체에 조인된 개체여야 합니다.</span><span class="sxs-lookup"><span data-stu-id="f979d-240">An export object must be a joined object.</span></span> <span data-ttu-id="f979d-241">시스템 논리에서 이 규칙을 적용하고 조인된 개체가 아닌 모든 내보내기 개체를 삭제합니다.</span><span class="sxs-lookup"><span data-stu-id="f979d-241">The system logic enforces this rule and deletes every export object that is not a joined object.</span></span>

## <a name="sync-engine-identity-management-process"></a><span data-ttu-id="f979d-242">동기화 엔진 ID 관리 프로세스</span><span class="sxs-lookup"><span data-stu-id="f979d-242">Sync engine identity management process</span></span>
<span data-ttu-id="f979d-243">ID 관리 프로세스는 서로 다른 연결된 데이터 원본 간에 ID 정보가 업데이트되는 방식을 제어합니다.</span><span class="sxs-lookup"><span data-stu-id="f979d-243">The identity management process controls how identity information is updated between different connected data sources.</span></span> <span data-ttu-id="f979d-244">ID 관리는 세 가지 프로세스에서 발생합니다.</span><span class="sxs-lookup"><span data-stu-id="f979d-244">Identity management occurs in three processes:</span></span>

* <span data-ttu-id="f979d-245">가져오기</span><span class="sxs-lookup"><span data-stu-id="f979d-245">Import</span></span>
* <span data-ttu-id="f979d-246">동기화</span><span class="sxs-lookup"><span data-stu-id="f979d-246">Synchronization</span></span>
* <span data-ttu-id="f979d-247">내보내기</span><span class="sxs-lookup"><span data-stu-id="f979d-247">Export</span></span>

<span data-ttu-id="f979d-248">가져오기 프로세스 중에 동기화 엔진은 연결된 데이터 원본에서 들어오는 ID 정보를 평가합니다.</span><span class="sxs-lookup"><span data-stu-id="f979d-248">During the import process, sync engine evaluates the incoming identity information from a connected data source.</span></span> <span data-ttu-id="f979d-249">변경이 감지되면 커넥터 공간에서 동기화를 위해 새 스테이징 개체를 만들거나 기존 스테이징 개체를 업데이트합니다.</span><span class="sxs-lookup"><span data-stu-id="f979d-249">When changes are detected, it either creates new staging objects or updates existing staging objects in the connector space for synchronization.</span></span>

<span data-ttu-id="f979d-250">동기화 프로세스 중에 동기화 엔진은 커넥터 공간에서 발생한 변경 내용을 반영하도록 메타버스를 업데이트하고 메타버스에서 발생한 변경 내용을 반영하도록 커넥터 공간을 업데이트합니다.</span><span class="sxs-lookup"><span data-stu-id="f979d-250">During the synchronization process, sync engine updates the metaverse to reflect changes that have occurred in the connector space and updates the connector space to reflect changes that have occurred in the metaverse.</span></span>

<span data-ttu-id="f979d-251">내보내기 프로세스 중에 동기화 엔진은 스테이징 개체에서 준비된 변경 내용을 푸시하고 스테이징 개체는 보류 중인 내보내기로 플래그 지정됩니다.</span><span class="sxs-lookup"><span data-stu-id="f979d-251">During the export process, sync engine pushes out changes that are staged on staging objects and that are flagged as pending export.</span></span>

<span data-ttu-id="f979d-252">다음 그림에서는 연결된 데이터 원본 간에 ID 정보가 이동함에 따라 각각 어떤 프로세스가 발생하는지를 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="f979d-252">The following illustration shows where each of the processes occurs as identity information flows from one connected data source to another.</span></span>

![Arch6](./media/active-directory-aadconnectsync-understanding-architecture/arch6.png)

### <a name="import-process"></a><span data-ttu-id="f979d-254">가져오기 프로세스</span><span class="sxs-lookup"><span data-stu-id="f979d-254">Import process</span></span>
<span data-ttu-id="f979d-255">가져오기 프로세스 중에 동기화 엔진은 ID 정보에 대한 업데이트를 평가합니다.</span><span class="sxs-lookup"><span data-stu-id="f979d-255">During the import process, sync engine evaluates updates to identity information.</span></span> <span data-ttu-id="f979d-256">동기화 엔진은 연결된 데이터 원본에서 수신한 ID 정보를 스테이징 개체에 대한 ID 정보와 비교하고 스테이징 개체를 업데이트해야 할지 여부를 결정합니다.</span><span class="sxs-lookup"><span data-stu-id="f979d-256">Sync engine compares the identity information received from the connected data source with the identity information about a staging object and determines whether the staging object requires updates.</span></span> <span data-ttu-id="f979d-257">이 과정은 스테이징 개체를 새 데이터로 업데이트해야 하는 경우 필요하며 스테이징 개체는 보류 중인 내보내기로 플래그 지정됩니다.</span><span class="sxs-lookup"><span data-stu-id="f979d-257">If it is necessary to update the staging object with new data, the staging object is flagged as pending import.</span></span>

<span data-ttu-id="f979d-258">동기화 엔진은 동기화 전에 커넥터 공간에 개체를 준비하여 변경된 ID 정보만 처리할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="f979d-258">By staging objects in the connector space before synchronization, sync engine can process only the identity information that has changed.</span></span> <span data-ttu-id="f979d-259">이 프로세스는 다음과 같은 이점을 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="f979d-259">This process provides the following benefits:</span></span>

* <span data-ttu-id="f979d-260">**효율적인 동기화**.</span><span class="sxs-lookup"><span data-stu-id="f979d-260">**Efficient synchronization**.</span></span> <span data-ttu-id="f979d-261">동기화 중에 처리할 데이터의 양이 최소화됩니다.</span><span class="sxs-lookup"><span data-stu-id="f979d-261">The amount of data processed during synchronization is minimized.</span></span>
* <span data-ttu-id="f979d-262">**효율적인 재동기화**.</span><span class="sxs-lookup"><span data-stu-id="f979d-262">**Efficient resynchronization**.</span></span> <span data-ttu-id="f979d-263">동기화 엔진을 데이터 원본에 다시 연결하지 않고 동기화 엔진에서 ID 정보를 처리하는 방식을 변경할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="f979d-263">You can change how sync engine processes identity information without reconnecting the sync engine to the data source.</span></span>
* <span data-ttu-id="f979d-264">**동기화를 미리 보는 기회**.</span><span class="sxs-lookup"><span data-stu-id="f979d-264">**Opportunity to preview synchronization**.</span></span> <span data-ttu-id="f979d-265">동기화 미리 보기로 ID 관리 프로세스가 올바르다는 가정을 확인할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="f979d-265">You can preview synchronization to verify that your assumptions about the identity management process are correct.</span></span>

<span data-ttu-id="f979d-266">커넥터에 지정된 각 개체에 대해 동기화 엔진은 먼저 커넥터의 커넥터 공간에서 개체의 표현을 찾습니다.</span><span class="sxs-lookup"><span data-stu-id="f979d-266">For each object specified in the Connector, the sync engine first tries to locate a representation of the object in the connector space of the Connector.</span></span> <span data-ttu-id="f979d-267">동기화 엔진은 커넥터 공간에서 모든 스테이징 개체를 확인한 후 앵커 특성이 일치하는 해당 스테이징 개체를 찾으려고 합니다.</span><span class="sxs-lookup"><span data-stu-id="f979d-267">Sync engine examines all staging objects in the connector space and tries to find a corresponding staging object that has a matching anchor attribute.</span></span> <span data-ttu-id="f979d-268">앵커 특성이 일치하는 기존 스테이징 개체가 없으면 동기화 엔진은 동일한 고유 이름을 가진 해당 스테이징 개체를 찾습니다.</span><span class="sxs-lookup"><span data-stu-id="f979d-268">If no existing staging object has a matching anchor attribute, sync engine tries to find a corresponding staging object with the same distinguished name.</span></span>

<span data-ttu-id="f979d-269">동기화 엔진이 앵커가 아닌 고유 이름으로 일치하는 스테이징 개체를 찾으면 다음과 같은 특별한 동작이 발생합니다.</span><span class="sxs-lookup"><span data-stu-id="f979d-269">When sync engine finds a staging object that matches by distinguished name but not by anchor, the following special behavior occurs:</span></span>

* <span data-ttu-id="f979d-270">커넥터 공간에 있는 개체에 앵커가 없는 경우 동기화 엔진은 커넥터 공간에서 이 개체를 제거하고 여기에 연결된 메타버스 개체를 **다음 동기화 실행 시 프로비전 다시 시도**로 표시합니다.</span><span class="sxs-lookup"><span data-stu-id="f979d-270">If the object located in the connector space has no anchor, then sync engine removes this object from the connector space and marks the metaverse object it is linked to as **retry provisioning on next synchronization run**.</span></span> <span data-ttu-id="f979d-271">그런 다음 새 가져오기 개체를 만듭니다.</span><span class="sxs-lookup"><span data-stu-id="f979d-271">Then it creates the new import object.</span></span>
* <span data-ttu-id="f979d-272">커넥터 공간에 있는 개체에 앵커가 있는 경우 동기화 엔진은 이 개체가 이름이 변경되었거나 연결된 디렉터리에서 삭제되었다고 가정합니다.</span><span class="sxs-lookup"><span data-stu-id="f979d-272">If the object located in the connector space has an anchor, then sync engine assumes that this object has either been renamed or deleted in the connected directory.</span></span> <span data-ttu-id="f979d-273">커넥터 공간 개체에 대해 임시의 새 고유 이름을 할당하여 들어오는 개체를 준비할 수 있도록 합니다.</span><span class="sxs-lookup"><span data-stu-id="f979d-273">It assigns a temporary, new distinguished name for the connector space object so that it can stage the incoming object.</span></span> <span data-ttu-id="f979d-274">그러면 이전 개체는 **일시적인**개체가 되고 커넥터는 이름 변경되거나 삭제된 개체를 가져와 상황이 해결될 때까지 대기합니다.</span><span class="sxs-lookup"><span data-stu-id="f979d-274">The old object then becomes **transient**, waiting for the Connector to import the rename or deletion to resolve the situation.</span></span>

<span data-ttu-id="f979d-275">동기화 엔진이 커넥터에 지정된 개체에 해당하는 스테이징 개체를 찾은 경우 어떤 종류의 변경을 적용할지 결정합니다.</span><span class="sxs-lookup"><span data-stu-id="f979d-275">If sync engine locates a staging object that corresponds to the object specified in the Connector, it determines what kind of changes to apply.</span></span> <span data-ttu-id="f979d-276">예를 들어, 동기화 엔진이 연결된 데이터 원본에서 개체의 이름을 바꾸거나 삭제할 수 있으며 또는 개체의 특성 값을 업데이트만 할 수도 있습니다.</span><span class="sxs-lookup"><span data-stu-id="f979d-276">For example, sync engine might rename or delete the object in the connected data source, or it might only update the object’s attribute values.</span></span>

<span data-ttu-id="f979d-277">업데이트된 데이터가 있는 스테이징 개체는 보류 중인 가져오기로 표시됩니다.</span><span class="sxs-lookup"><span data-stu-id="f979d-277">Staging objects with updated data are marked as pending import.</span></span> <span data-ttu-id="f979d-278">다양한 유형의 보류 중인 가져오기가 제공됩니다.</span><span class="sxs-lookup"><span data-stu-id="f979d-278">Different types of pending imports are available.</span></span> <span data-ttu-id="f979d-279">가져오기 프로세스의 결과에 따라 커넥터 공간의 스테이징 개체에 다음 보류 중인 가져오기 유형 중 하나가 포함됩니다.</span><span class="sxs-lookup"><span data-stu-id="f979d-279">Depending on the result of the import process, a staging object in the connector space has one of the following pending import types:</span></span>

* <span data-ttu-id="f979d-280">**없음**.</span><span class="sxs-lookup"><span data-stu-id="f979d-280">**None**.</span></span> <span data-ttu-id="f979d-281">스테이징 개체의 특성에 어떠한 변경도 없습니다.</span><span class="sxs-lookup"><span data-stu-id="f979d-281">No changes to any of the attributes of the staging object are available.</span></span> <span data-ttu-id="f979d-282">동기화 엔진은 이 유형을 보류 중인 가져오기로 플래그 지정하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="f979d-282">Sync engine does not flag this type as pending import.</span></span>
* <span data-ttu-id="f979d-283">**추가**.</span><span class="sxs-lookup"><span data-stu-id="f979d-283">**Add**.</span></span> <span data-ttu-id="f979d-284">스테이징 개체는 커넥터 공간에서 새 가져오기 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="f979d-284">The staging object is a new import object in the connector space.</span></span> <span data-ttu-id="f979d-285">동기화 엔진은 메타버스에서 추가 처리를 위해 이 유형을 보류 중인 가져오기로 플래그 지정합니다.</span><span class="sxs-lookup"><span data-stu-id="f979d-285">Sync engine flags this type as pending import for additional processing in the metaverse.</span></span>
* <span data-ttu-id="f979d-286">**업데이트**.</span><span class="sxs-lookup"><span data-stu-id="f979d-286">**Update**.</span></span> <span data-ttu-id="f979d-287">동기화 엔진은 커넥터 공간에서 해당 스테이징 개체를 찾고 이 유형을 보류 중인 가져오기로 플래그 지정하여 메타버스에서 특성에 대한 업데이트를 처리할 수 있도록 합니다.</span><span class="sxs-lookup"><span data-stu-id="f979d-287">Sync engine finds a corresponding staging object in the connector space and flags this type as pending import so that updates to the attributes can be processed in the metaverse.</span></span> <span data-ttu-id="f979d-288">업데이트에는 개체 이름 바꾸기가 포함됩니다.</span><span class="sxs-lookup"><span data-stu-id="f979d-288">Updates include object renaming.</span></span>
* <span data-ttu-id="f979d-289">**삭제**.</span><span class="sxs-lookup"><span data-stu-id="f979d-289">**Delete**.</span></span> <span data-ttu-id="f979d-290">동기화 엔진은 커넥터 공간에서 해당 스테이징 개체를 찾고 이 유형을 보류 중인 가져오기로 플래그 지정하여 조인된 개체를 삭제할 수 있도록 합니다.</span><span class="sxs-lookup"><span data-stu-id="f979d-290">Sync engine finds a corresponding staging object in the connector space and flags this type as pending import so that the joined object can be deleted.</span></span>
* <span data-ttu-id="f979d-291">**삭제/추가**.</span><span class="sxs-lookup"><span data-stu-id="f979d-291">**Delete/Add**.</span></span> <span data-ttu-id="f979d-292">동기화 엔진은 커넥터 공간에서 해당 스테이징 개체를 찾지만 개체 유형이 일치하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="f979d-292">Sync engine finds a corresponding staging object in the connector space, but the object types do not match.</span></span> <span data-ttu-id="f979d-293">이 경우에 삭제-추가 수정을 준비합니다.</span><span class="sxs-lookup"><span data-stu-id="f979d-293">In this case, a delete-add modification is staged.</span></span> <span data-ttu-id="f979d-294">삭제-추가 수정은 개체 유형이 변경될 때 이 개체에 다른 규칙 집합을 적용하게 되므로 동기화 엔진에서 이 개체를 완전히 재동기화해야 함을 나타냅니다.</span><span class="sxs-lookup"><span data-stu-id="f979d-294">A delete-add modification indicates to the sync engine that a complete resynchronization of this object must occur because different sets of rules apply to this object when the object type changes.</span></span>

<span data-ttu-id="f979d-295">스테이징 개체의 보류 중인 가져오기 상태를 설정하면 시스템에서 업데이트된 데이터가 있는 개체만 처리할 수 있으므로 동기화 중에 처리되는 데이터 양을 크게 줄일 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="f979d-295">By setting the pending import status of a staging object, it is possible to reduce significantly the amount of data processed during synchronization because doing so allows the system to process only those objects that have updated data.</span></span>

### <a name="synchronization-process"></a><span data-ttu-id="f979d-296">동기화 프로세스</span><span class="sxs-lookup"><span data-stu-id="f979d-296">Synchronization process</span></span>
<span data-ttu-id="f979d-297">동기화는 두 개의 관련된 프로세스로 구성됩니다.</span><span class="sxs-lookup"><span data-stu-id="f979d-297">Synchronization consists of two related processes:</span></span>

* <span data-ttu-id="f979d-298">인바운드 동기화 - 메타버스의 콘텐츠가 커넥터 공간의 데이터를 사용하여 업데이트됩니다.</span><span class="sxs-lookup"><span data-stu-id="f979d-298">Inbound synchronization, when the content of the metaverse is updated by using the data in the connector space.</span></span>
* <span data-ttu-id="f979d-299">아웃바운드 동기화 - 커넥터 공간의 콘텐츠가 메타버스의 데이터를 사용하여 업데이트됩니다.</span><span class="sxs-lookup"><span data-stu-id="f979d-299">Outbound synchronization, when the content of the connector space is updated by using data in the metaverse.</span></span>

<span data-ttu-id="f979d-300">인바운드 동기화 프로세스는 커넥터 공간에서 준비된 정보를 사용하여 연결된 데이터 원본에 저장된 데이터에 대한 통합된 보기를 메타버스에 만듭니다.</span><span class="sxs-lookup"><span data-stu-id="f979d-300">By using the information staged in the connector space, the inbound synchronization process creates in the metaverse the integrated view of the data that is stored in the connected data sources.</span></span> <span data-ttu-id="f979d-301">규칙이 구성된 방식에 따라 모든 스테이징 개체가 집계되거나 보류 중인 가져오기 정보가 있는 개체만 집계됩니다.</span><span class="sxs-lookup"><span data-stu-id="f979d-301">Either all staging objects or only those with a pending import information are aggregated, depending on how the rules are configured.</span></span>

<span data-ttu-id="f979d-302">아웃바운드 동기화 프로세스는 메타버스 개체가 변경될 때 내보내기 개체를 업데이트합니다.</span><span class="sxs-lookup"><span data-stu-id="f979d-302">The outbound synchronization process updates export objects when metaverse objects change.</span></span>

<span data-ttu-id="f979d-303">인바운드 동기화는 연결된 데이터 원본에서 수신한 ID 정보의 통합된 보기를 메타버스에 만듭니다.</span><span class="sxs-lookup"><span data-stu-id="f979d-303">Inbound synchronization creates the integrated view in the metaverse of the identity information that is received from the connected data sources.</span></span> <span data-ttu-id="f979d-304">동기화 엔진은 연결된 데이터 원본에서 얻은 최신 ID 정보를 사용하여 언제든지 ID 정보를 처리할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="f979d-304">Sync engine can process identity information at any time by using the latest identity information that it has from the connected data source.</span></span>

<span data-ttu-id="f979d-305">**인바운드 동기화**</span><span class="sxs-lookup"><span data-stu-id="f979d-305">**Inbound synchronization**</span></span>

<span data-ttu-id="f979d-306">인바운드 동기화는 다음 프로세스를 포함합니다.</span><span class="sxs-lookup"><span data-stu-id="f979d-306">Inbound synchronization includes the following processes:</span></span>

* <span data-ttu-id="f979d-307">**프로비전**(이 프로세스를 아웃바운드 동기화 프로비전과 구분하는 것이 중요한 경우 **프로젝션**이라고도 함).</span><span class="sxs-lookup"><span data-stu-id="f979d-307">**Provision** (also called **Projection** if it is important to distinguish this process from outbound synchronization provisioning).</span></span> <span data-ttu-id="f979d-308">동기화 엔진은 스테이징 개체를 기반으로 새 메타버스 개체를 만들고 이를 연결합니다.</span><span class="sxs-lookup"><span data-stu-id="f979d-308">The Sync engine creates a new metaverse object based on a staging object and links them.</span></span> <span data-ttu-id="f979d-309">프로비전은 개체 수준의 작업입니다.</span><span class="sxs-lookup"><span data-stu-id="f979d-309">Provision is an object-level operation.</span></span>
* <span data-ttu-id="f979d-310">**조인**.</span><span class="sxs-lookup"><span data-stu-id="f979d-310">**Join**.</span></span> <span data-ttu-id="f979d-311">동기화 엔진은 스테이징 개체를 기존 메타버스 개체에 연결합니다.</span><span class="sxs-lookup"><span data-stu-id="f979d-311">The Sync engine links a staging object to an existing metaverse object.</span></span> <span data-ttu-id="f979d-312">조인은 개체 수준 작업입니다.</span><span class="sxs-lookup"><span data-stu-id="f979d-312">A join is an object-level operation.</span></span>
* <span data-ttu-id="f979d-313">**가져오기 특성 흐름**.</span><span class="sxs-lookup"><span data-stu-id="f979d-313">**Import attribute flow**.</span></span> <span data-ttu-id="f979d-314">동기화 엔진은 메타버스에 있는 개체의 특성 값(특성 흐름이라고 함)을 업데이트합니다.</span><span class="sxs-lookup"><span data-stu-id="f979d-314">Sync engine updates the attribute values, called attribute flow, of the object in the metaverse.</span></span> <span data-ttu-id="f979d-315">가져오기 특성 흐름은 스테이징 개체와 메타버스 개체 간의 연결이 필요한 특성 수준 작업입니다.</span><span class="sxs-lookup"><span data-stu-id="f979d-315">Import attribute flow is an attribute-level operation that requires a link between a staging object and a metaverse object.</span></span>

<span data-ttu-id="f979d-316">프로비전은 메타버스에 개체를 만드는 유일한 프로세스입니다.</span><span class="sxs-lookup"><span data-stu-id="f979d-316">Provision is the only process that creates objects in the metaverse.</span></span> <span data-ttu-id="f979d-317">프로비전은 조인되지 않은 개체인 가져오기 개체에만 영향을 줍니다.</span><span class="sxs-lookup"><span data-stu-id="f979d-317">Provision affects only import objects that are disjoined objects.</span></span> <span data-ttu-id="f979d-318">프로비전하는 동안 동기화 엔진은 가져오기 개체의 개체 유형에 해당하는 메타버스 개체를 만들고 두 개체 간의 연결을 설정하여 조인된 개체를 만듭니다.</span><span class="sxs-lookup"><span data-stu-id="f979d-318">During provision, sync engine creates a metaverse object that corresponds to the object type of the import object and establishes a link between both objects, thus creating a joined object.</span></span>

<span data-ttu-id="f979d-319">조인 프로세스는 또한 가져오기 개체와 메타버스 개체 간의 연결을 설정합니다.</span><span class="sxs-lookup"><span data-stu-id="f979d-319">The join process also establishes a link between import objects and a metaverse object.</span></span> <span data-ttu-id="f979d-320">조인과 프로비전의 차이점은 조인 프로세스는 가져오기 개체를 기존의 메타버스 개체에 연결해야 하는 반면 프로비전 프로세스는 새 메타버스 개체를 만듭니다.</span><span class="sxs-lookup"><span data-stu-id="f979d-320">The difference between join and provision is that the join process requires that the import object are linked to an existing metaverse object, where the provision process creates a new metaverse object.</span></span>

<span data-ttu-id="f979d-321">동기화 엔진은 동기화 규칙 구성에 지정된 기준을 사용하여 가져오기 개체를 메타버스 개체로 조인하려고 합니다.</span><span class="sxs-lookup"><span data-stu-id="f979d-321">Sync engine tries to join an import object to a metaverse object by using criteria that is specified in the Synchronization Rule configuration.</span></span>

<span data-ttu-id="f979d-322">동기화 엔진은 프로비전 및 조인 프로세스 중에 조인되지 않은 개체를 메타버스 개체에 연결하여 이들이 조인되도록 합니다.</span><span class="sxs-lookup"><span data-stu-id="f979d-322">During the provision and join processes, sync engine links a disjoined object to a metaverse object, making them joined.</span></span> <span data-ttu-id="f979d-323">이러한 개체 수준 작업이 완료되면 동기화 엔진은 연결된 메타버스 개체의 특성 값을 업데이트할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="f979d-323">After these object-level operations are completed, sync engine can update the attribute values of the associated metaverse object.</span></span> <span data-ttu-id="f979d-324">이 프로세스를 가져오기 특성 흐름이라고 합니다.</span><span class="sxs-lookup"><span data-stu-id="f979d-324">This process is called import attribute flow.</span></span>

<span data-ttu-id="f979d-325">가져오기 특성 흐름은 새 데이터를 전달하고 메타버스 개체에 연결되는 모든 가져오기 개체에서 발생합니다.</span><span class="sxs-lookup"><span data-stu-id="f979d-325">Import attribute flow occurs on all import objects that carry new data and are linked to a metaverse object.</span></span>

<span data-ttu-id="f979d-326">**아웃바운드 동기화**</span><span class="sxs-lookup"><span data-stu-id="f979d-326">**Outbound synchronization**</span></span>

<span data-ttu-id="f979d-327">아웃바운드 동기화는 메타버스 개체가 변경되지만 삭제되지 않은 경우 내보내기 개체를 업데이트합니다.</span><span class="sxs-lookup"><span data-stu-id="f979d-327">Outbound synchronization updates export objects when a metaverse object change but is not deleted.</span></span> <span data-ttu-id="f979d-328">아웃바운드 동기화의 목적은 메타버스 개체의 변경 내용을 커넥터 공간의 스테이징 개체에 업데이트해야 하는지 여부를 평가하는 것입니다.</span><span class="sxs-lookup"><span data-stu-id="f979d-328">The objective of outbound synchronization is to evaluate whether changes to metaverse objects require updates to staging objects in the connector spaces.</span></span> <span data-ttu-id="f979d-329">경우에 따라 이러한 변경 내용을 모든 커넥터 공간의 스테이징 개체에서 업데이트해야 할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="f979d-329">In some cases, the changes can require that staging objects in all connector spaces be updated.</span></span> <span data-ttu-id="f979d-330">변경된 스테이징 개체는 보류 중인 내보내기로 플래그 지정되어 내보내기 개체가 됩니다.</span><span class="sxs-lookup"><span data-stu-id="f979d-330">Staging objects that are changed are flagged as pending export, making them export objects.</span></span> <span data-ttu-id="f979d-331">이러한 내보내기 개체는 나중에 내보내기 프로세스 중에 연결된 데이터 원본에 푸시됩니다.</span><span class="sxs-lookup"><span data-stu-id="f979d-331">These export objects are later pushed out to the connected data source during the export process.</span></span>

<span data-ttu-id="f979d-332">아웃바운드 동기화에는 세 가지 프로세스가 있습니다.</span><span class="sxs-lookup"><span data-stu-id="f979d-332">Outbound synchronization has three processes:</span></span>

* <span data-ttu-id="f979d-333">**프로비전**</span><span class="sxs-lookup"><span data-stu-id="f979d-333">**Provisioning**</span></span>
* <span data-ttu-id="f979d-334">**프로비전 해제**</span><span class="sxs-lookup"><span data-stu-id="f979d-334">**Deprovisioning**</span></span>
* <span data-ttu-id="f979d-335">**내보내기 특성 흐름**</span><span class="sxs-lookup"><span data-stu-id="f979d-335">**Export attribute flow**</span></span>

<span data-ttu-id="f979d-336">프로비전 및 프로비전 해제는 모두 개체 수준 작업입니다.</span><span class="sxs-lookup"><span data-stu-id="f979d-336">Provisioning and deprovisioning are both object-level operations.</span></span> <span data-ttu-id="f979d-337">프로비전 해제는 프로비전에서만 시작할 수 있으므로 프로비전에 따라 결정됩니다.</span><span class="sxs-lookup"><span data-stu-id="f979d-337">Deprovisioning depends on provisioning because only provisioning can initiate it.</span></span> <span data-ttu-id="f979d-338">프로비전 해제는 프로비전에서 메타버스 개체와 내보내기 개체 간의 연결을 제거할 때 트리거됩니다.</span><span class="sxs-lookup"><span data-stu-id="f979d-338">Deprovisioning is triggered when provisioning removes the link between a metaverse object and an export object.</span></span>

<span data-ttu-id="f979d-339">프로비전은 변경 내용이 메타버스의 개체에 적용될 때 항상 트리거됩니다.</span><span class="sxs-lookup"><span data-stu-id="f979d-339">Provisioning is always triggered when changes are applied to objects in the metaverse.</span></span> <span data-ttu-id="f979d-340">메타버스 개체가 변경된 경우 동기화 엔진은 프로비전 프로세스의 일환으로 다음 작업을 수행할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="f979d-340">When changes are made to metaverse objects, sync engine can perform any of the following tasks as part of the provisioning process:</span></span>

* <span data-ttu-id="f979d-341">조인된 개체를 만듭니다. 이때 메타버스 개체는 새로 만들어진 내보내기 개체에 연결됩니다.</span><span class="sxs-lookup"><span data-stu-id="f979d-341">Create joined objects, where a metaverse object is linked to a newly created export object.</span></span>
* <span data-ttu-id="f979d-342">조인된 개체의 이름을 바꿉니다.</span><span class="sxs-lookup"><span data-stu-id="f979d-342">Rename a joined object.</span></span>
* <span data-ttu-id="f979d-343">메타버스 개체와 스테이징 개체 간의 연결을 조인 해제하여 조인되지 않은 개체가 만들어집니다.</span><span class="sxs-lookup"><span data-stu-id="f979d-343">Disjoin links between a metaverse object and staging objects, creating a disjoined object.</span></span>

<span data-ttu-id="f979d-344">프로비전 시 동기화 엔진이 새 커넥터 개체를 만들어야 하는 경우 개체가 연결된 데이터 원본에 아직 존재하지 않기 때문에 메타버스 개체가 연결되는 스테이징 개체는 항상 내보내기 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="f979d-344">If provisioning requires sync engine to create a new connector object, the staging object to which the metaverse object is linked is always an export object, because the object does not yet exist in the connected data source.</span></span>

<span data-ttu-id="f979d-345">프로비전에서 동기화 엔진이 조인된 개체를 조인 해제해야 하는 경우 조인되지 않은 개체가 만들어지고 프로비전 해제가 트리거됩니다.</span><span class="sxs-lookup"><span data-stu-id="f979d-345">If provisioning requires sync engine to disjoin a joined object, creating a disjoined object, deprovisioning is triggered.</span></span> <span data-ttu-id="f979d-346">프로비전 해제 프로세스는 개체를 삭제합니다.</span><span class="sxs-lookup"><span data-stu-id="f979d-346">The deprovisioning process deletes the object.</span></span>

<span data-ttu-id="f979d-347">프로비전 해제 중에 내보내기 개체를 삭제한다고 해서 실제로 개체가 삭제되는 것은 아닙니다.</span><span class="sxs-lookup"><span data-stu-id="f979d-347">During deprovisioning, deleting an export object does not physically delete the object.</span></span> <span data-ttu-id="f979d-348">개체는 **삭제됨**으로 플래그 지정되는데, 이것은 해당 개체에 삭제 작업이 준비됨을 의미합니다.</span><span class="sxs-lookup"><span data-stu-id="f979d-348">The object is flagged as **deleted**, which means that the delete operation is staged on the object.</span></span>

<span data-ttu-id="f979d-349">인바운드 동기화 중에 가져오기 특성 흐름이 발생한 것과 같은 방식으로 아웃바운드 동기화 프로세스 중에 내보내기 특성 흐름도 발생합니다.</span><span class="sxs-lookup"><span data-stu-id="f979d-349">Export attribute flow also occurs during the outbound synchronization process, similar to the way that import attribute flow occurs during inbound synchronization.</span></span> <span data-ttu-id="f979d-350">내보내기 특성 흐름은 조인된 메타버스와 내보내기 개체 간에만 발생합니다.</span><span class="sxs-lookup"><span data-stu-id="f979d-350">Export attribute flow occurs only between metaverse and export objects that are joined.</span></span>

### <a name="export-process"></a><span data-ttu-id="f979d-351">내보내기 프로세스</span><span class="sxs-lookup"><span data-stu-id="f979d-351">Export process</span></span>
<span data-ttu-id="f979d-352">동기화 엔진은 내보내기 프로세스 중에 커넥터 공간에서 보류 중인 내보내기로 플래그 지정된 모든 내보내기 개체를 확인한 후 업데이트를 연결된 데이터 원본으로 보냅니다.</span><span class="sxs-lookup"><span data-stu-id="f979d-352">During the export process, sync engine examines all export objects that are flagged as pending export in the connector space, and then sends updates to the connected data source.</span></span>

<span data-ttu-id="f979d-353">동기화 엔진은 내보내기의 성공 여부는 확인할 수 있지만 ID 관리 프로세스가 완료되었는지는 충분히 결정할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="f979d-353">The sync engine can determine the success of an export but it cannot sufficiently determine that the identity management process is complete.</span></span> <span data-ttu-id="f979d-354">연결된 데이터 원본에 있는 개체는 항상 다른 프로세스에 의해 변경될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="f979d-354">Objects in the connected data source can always be changed by other processes.</span></span> <span data-ttu-id="f979d-355">동기화 엔진은 연결된 데이터 원본에 대해 계속 연결되는 것이 아니므로 연결된 데이터 원본에 있는 개체의 속성을 내보내기 성공 알림만을 토대로 가정하는 것은 충분하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="f979d-355">Because sync engine does not have a persistent connection to the connected data source, it is not sufficient to make assumptions about the properties of an object in the connected data source based only on a successful export notification.</span></span>

<span data-ttu-id="f979d-356">예를 들어 연결된 데이터 원본의 프로세스가 개체의 특성을 다시 원래 값으로 변경할 수 있습니다(즉, 연결된 데이터 원본은 동기화 엔진에 의해 데이터가 푸시되고 연결된 데이터 원본에 성공적으로 적용되면 바로 값을 덮어쓸 수 있습니다).</span><span class="sxs-lookup"><span data-stu-id="f979d-356">For example, a process in the connected data source could change the object’s attributes back to their original values (that is, the connected data source could overwrite the values immediately after the data is pushed out by sync engine and successfully applied in the connected data source).</span></span>

<span data-ttu-id="f979d-357">동기화 엔진은 각 스테이징 개체에 대한 내보내기 및 가져오기 상태를 저장합니다.</span><span class="sxs-lookup"><span data-stu-id="f979d-357">The sync engine stores export and import status information about each staging object.</span></span> <span data-ttu-id="f979d-358">마지막 내보내기 이후 특성 포함 목록에 지정된 특성 값이 변경된 경우 가져오기 및 내보내기 상태 저장소를 통해 동기화 엔진은 적절하게 대응할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="f979d-358">If values of the attributes that are specified in the attribute inclusion list have changed since the last export, the storage of import and export status enables sync engine to react appropriately.</span></span> <span data-ttu-id="f979d-359">동기화 엔진은 가져오기 프로세스를 사용하여 연결된 데이터 원본으로 내보낸 특성 값을 확인합니다.</span><span class="sxs-lookup"><span data-stu-id="f979d-359">Sync engine uses the import process to confirm attribute values that have been exported to the connected data source.</span></span> <span data-ttu-id="f979d-360">다음 그림에 나와 있는 것처럼 동기화 엔진은 가져오고 내보낸 정보를 서로 비교하여 내보내기에 성공했는지, 반복해야 하는지를 결정할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="f979d-360">A comparison between the imported and exported information, as shown in the following illustration, enables sync engine to determine whether the export was successful or if it needs to be repeated.</span></span>

![Arch7](./media/active-directory-aadconnectsync-understanding-architecture/arch7.png)

<span data-ttu-id="f979d-362">예를 들어, 동기화 엔진이 값이 5인 특성 C를 연결된 데이터 원본에 내보내는 경우 해당 내보내기 상태 메모리에 C=5를 저장합니다.</span><span class="sxs-lookup"><span data-stu-id="f979d-362">For example, if sync engine exports attribute C, which has a value of 5, to a connected data source, it stores C=5 in its export status memory.</span></span> <span data-ttu-id="f979d-363">이 개체에서 내보내기를 추가로 수행할 때마다 동기화 엔진은 이 값이 개체에 영구적으로 적용되지 않았다고 가정하므로(즉, 연결된 데이터 원본에서 최근에 다른 값을 가져오지 않는 경우) 연결된 데이터 원본으로 C=5 내보내기가 다시 시도됩니다.</span><span class="sxs-lookup"><span data-stu-id="f979d-363">Each additional export on this object results in an attempt to export C=5 to the connected data source again because sync engine assumes that this value has not been persistently applied to the object (that is, unless a different value was imported recently from the connected data source).</span></span> <span data-ttu-id="f979d-364">개체에 대한 가져오기 작업 중에 C=5를 수신하면 내보내기 메모리가 지워집니다.</span><span class="sxs-lookup"><span data-stu-id="f979d-364">The export memory is cleared when C=5 is received during an import operation on the object.</span></span>

## <a name="next-steps"></a><span data-ttu-id="f979d-365">다음 단계</span><span class="sxs-lookup"><span data-stu-id="f979d-365">Next steps</span></span>
<span data-ttu-id="f979d-366">[Azure AD Connect 동기화](active-directory-aadconnectsync-whatis.md) 구성에 대해 자세히 알아봅니다.</span><span class="sxs-lookup"><span data-stu-id="f979d-366">Learn more about the [Azure AD Connect sync](active-directory-aadconnectsync-whatis.md) configuration.</span></span>

<span data-ttu-id="f979d-367">[Azure Active Directory와 온-프레미스 ID 통합](active-directory-aadconnect.md)에 대해 자세히 알아봅니다.</span><span class="sxs-lookup"><span data-stu-id="f979d-367">Learn more about [Integrating your on-premises identities with Azure Active Directory](active-directory-aadconnect.md).</span></span>

