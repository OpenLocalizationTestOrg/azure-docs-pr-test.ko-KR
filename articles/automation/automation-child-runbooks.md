---
title: "Azure 자동화의 runbook aaaChild | Microsoft Docs"
description: "다른 runbook에서 Azure 자동화에서 runbook을 시작 하 고 서로 정보를 공유 hello 다른 방법을 설명 합니다."
services: automation
documentationcenter: 
author: mgoedtel
manager: jwhit
editor: tysonn
ms.assetid: 919887b9-43e2-4c16-883c-f81807fe37db
ms.service: automation
ms.devlang: na
ms.topic: article
ms.tgt_pltfrm: na
ms.workload: infrastructure-services
ms.date: 02/02/2017
ms.author: magoedte;bwren
ms.openlocfilehash: d3d06818d344b565d53cc4f4705b41dcfcf9a376
ms.sourcegitcommit: 523283cc1b3c37c428e77850964dc1c33742c5f0
ms.translationtype: MT
ms.contentlocale: ko-KR
ms.lasthandoff: 10/06/2017
---
# <a name="child-runbooks-in-azure-automation"></a><span data-ttu-id="acdf9-103">Azure 자동화의 자식 runbook</span><span class="sxs-lookup"><span data-stu-id="acdf9-103">Child runbooks in Azure Automation</span></span>
<span data-ttu-id="acdf9-104">Azure 자동화 toowrite 재사용 가능한 모듈식 runbook 다른 runbook에서 사용할 수 있는 이산 함수 사용에 것이 좋습니다.</span><span class="sxs-lookup"><span data-stu-id="acdf9-104">It is a best practice in Azure Automation toowrite reusable, modular runbooks with a discrete function that can be used by other runbooks.</span></span> <span data-ttu-id="acdf9-105">부모 runbook은 종종 하나 이상의 자식 runbook을 호출 tooperform 필수 기능입니다.</span><span class="sxs-lookup"><span data-stu-id="acdf9-105">A parent runbook will often call one or more child runbooks tooperform required functionality.</span></span> <span data-ttu-id="acdf9-106">두 가지 방법으로 toocall 자식 runbook 있으며 각각에 서로 다른 특징을 이해 해야 하는 다양 한 시나리오에 대 한 최상의 될 결정할 수 있도록 합니다.</span><span class="sxs-lookup"><span data-stu-id="acdf9-106">There are two ways toocall a child runbook, and each has distinct differences that you should understand so that you can determine which will be best for your different scenarios.</span></span>

## <a name="invoking-a-child-runbook-using-inline-execution"></a><span data-ttu-id="acdf9-107">인라인 실행을 사용하여 자식 runbook 호출</span><span class="sxs-lookup"><span data-stu-id="acdf9-107">Invoking a child runbook using inline execution</span></span>
<span data-ttu-id="acdf9-108">tooinvoke 인라인으로 runbook 다른 runbook에서 hello runbook의 hello 이름을 사용 하 고이 활동이 나 cmdlet을 사용할 때와 정확히 해당 매개 변수의 값을 제공 합니다.</span><span class="sxs-lookup"><span data-stu-id="acdf9-108">tooinvoke a runbook inline from another runbook, you use hello name of hello runbook and provide values for its parameters exactly like you would use an activity or cmdlet.</span></span>  <span data-ttu-id="acdf9-109">모든 runbook에서 같은 자동화 계정의 hello도 사용할 수 있는 tooall toobe이 방식이으로 사용해 서 키워드가 있습니다.</span><span class="sxs-lookup"><span data-stu-id="acdf9-109">All runbooks in hello same Automation account are available tooall others toobe used in this manner.</span></span> <span data-ttu-id="acdf9-110">hello 부모 runbook은 toohello 다음 줄을 이동 하기 전에 자식 runbook toocomplete hello에 대 한 대기 하 고 어떤 출력도 직접 toohello 부모 반환 됩니다.</span><span class="sxs-lookup"><span data-stu-id="acdf9-110">hello parent runbook will wait for hello child runbook toocomplete before moving toohello next line, and any output is returned directly toohello parent.</span></span>

<span data-ttu-id="acdf9-111">인라인으로 runbook을 호출 하면 hello hello 부모 runbook과 같은 작업에서 실행 됩니다.</span><span class="sxs-lookup"><span data-stu-id="acdf9-111">When you invoke a runbook inline, it runs in hello same job as hello parent runbook.</span></span> <span data-ttu-id="acdf9-112">Hello 자식 runbook이 실행의 hello 작업 기록은 표시 되지 됩니다.</span><span class="sxs-lookup"><span data-stu-id="acdf9-112">There will be no indication in hello job history of hello child runbook that it ran.</span></span> <span data-ttu-id="acdf9-113">모든 예외와 스트림 hello 자식 runbook에서 출력 hello 부모와 연결 됩니다.</span><span class="sxs-lookup"><span data-stu-id="acdf9-113">Any exceptions and any stream output from hello child runbook will be associated with hello parent.</span></span> <span data-ttu-id="acdf9-114">이 따라서 작업 수가 감소 및 hello 자식 runbook에서 throw 된 예외가 이후 tootrack 쉽고 tootroubleshoot 유용 하 고의 모든 스트림 출력이 hello 부모 작업과 연결 합니다.</span><span class="sxs-lookup"><span data-stu-id="acdf9-114">This results in fewer jobs and makes them easier tootrack and tootroubleshoot since any exceptions thrown by hello child runbook and any of its stream output are associated with hello parent job.</span></span>

<span data-ttu-id="acdf9-115">runbook이 게시되면 호출하는 모든 자식 runbook은 이미 게시되어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="acdf9-115">When a runbook is published, any child runbooks that it calls must already be published.</span></span> <span data-ttu-id="acdf9-116">runbook이 컴파일될 때 Azure 자동화가 모든 자식 runbook과 연결을 빌드하기 때문입니다.</span><span class="sxs-lookup"><span data-stu-id="acdf9-116">This is because Azure Automation builds an association with any child runbooks when a runbook is compiled.</span></span> <span data-ttu-id="acdf9-117">그렇지 않은 경우 hello 부모 runbook은 toopublish 적절 하 게 나타나지만 시작 될 때 예외가 발생 합니다.</span><span class="sxs-lookup"><span data-stu-id="acdf9-117">If they aren’t, hello parent runbook will appear toopublish properly, but will generate an exception when it’s started.</span></span> <span data-ttu-id="acdf9-118">이 경우 순서 tooproperly 참조 hello 자식 runbook의 hello 부모 runbook을 다시 게시할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="acdf9-118">If this happens, you can republish hello parent runbook in order tooproperly reference hello child runbooks.</span></span> <span data-ttu-id="acdf9-119">Hello 자식 runbook이 변경 되어도 hello 연결이 이미 되었습니다 작성 하는 경우 toorepublish hello 부모 runbook이 필요 하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="acdf9-119">You do not need toorepublish hello parent runbook if any of hello child runbooks are changed because hello association will have already been created.</span></span>

<span data-ttu-id="acdf9-120">인라인으로 호출 하는 자식 runbook의 hello 매개 변수에는 복잡 한 개체를 비롯 한 모든 데이터 형식일 수 있으며는 없는 [JSON serialization](automation-starting-a-runbook.md#runbook-parameters) hello Azure 관리 포털을 사용 하 여 hello runbook을 시작할 때 이나 hello로 시작 AzureRmAutomationRunbook cmdlet을 사용 합니다.</span><span class="sxs-lookup"><span data-stu-id="acdf9-120">hello parameters of a child runbook called inline can be any data type including complex objects, and there is no [JSON serialization](automation-starting-a-runbook.md#runbook-parameters) as there is when you start hello runbook using hello Azure Management Portal or with hello Start-AzureRmAutomationRunbook cmdlet.</span></span>

### <a name="runbook-types"></a><span data-ttu-id="acdf9-121">Runbook 형식</span><span class="sxs-lookup"><span data-stu-id="acdf9-121">Runbook types</span></span>
<span data-ttu-id="acdf9-122">서로를 호출할 수 있는 형식:</span><span class="sxs-lookup"><span data-stu-id="acdf9-122">Which types can call each other:</span></span>

* <span data-ttu-id="acdf9-123">[PowerShell runbook](automation-runbook-types.md#powershell-runbooks) 및 [Graphical runbook](automation-runbook-types.md#graphical-runbooks)은 인라인으로 서로를 호출할 수 있습니다(둘 다 PowerShell 기반임).</span><span class="sxs-lookup"><span data-stu-id="acdf9-123">A [PowerShell runbook](automation-runbook-types.md#powershell-runbooks) and [Graphical runbooks](automation-runbook-types.md#graphical-runbooks) can call each other inline (both are PowerShell based).</span></span>
* <span data-ttu-id="acdf9-124">[PowerShell 워크플로 Runbook](automation-runbook-types.md#powershell-workflow-runbooks) 및 그래픽 PowerShell 워크플로 Runbook은 인라인으로 서로를 호출할 수 있습니다(둘 다 PowerShell 워크플로 기반임).</span><span class="sxs-lookup"><span data-stu-id="acdf9-124">A [PowerShell Workflow runbook](automation-runbook-types.md#powershell-workflow-runbooks) and Graphical PowerShell Workflow runbooks can call each other inline (both are PowerShell Workflow based)</span></span>
* <span data-ttu-id="acdf9-125">PowerShell 형식 hello 및 PowerShell 워크플로 형식을 hello 서로 인라인을 호출할 수 없습니다 시작 AzureRmAutomationRunbook를 사용 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="acdf9-125">hello PowerShell types and hello PowerShell Workflow types can’t call each other inline, and must use Start-AzureRmAutomationRunbook.</span></span>

<span data-ttu-id="acdf9-126">게시 순서가 중요한 경우:</span><span class="sxs-lookup"><span data-stu-id="acdf9-126">When does publish order matter:</span></span>

* <span data-ttu-id="acdf9-127">hello의 순서가 runbook만 중요 PowerShell 워크플로 및 그래픽 PowerShell 워크플로 runbook에 대 한 게시 합니다.</span><span class="sxs-lookup"><span data-stu-id="acdf9-127">hello publish order of runbooks only matters for PowerShell Workflow and Graphical PowerShell Workflow runbooks.</span></span>

<span data-ttu-id="acdf9-128">인라인 실행을 사용 하 여 그래픽 또는 PowerShell 워크플로 자식 runbook을 호출할 때 hello hello runbook 이름을 사용할 것입니다.</span><span class="sxs-lookup"><span data-stu-id="acdf9-128">When you call a Graphical or PowerShell Workflow child runbook using inline execution, you just use hello name of hello runbook.</span></span>  <span data-ttu-id="acdf9-129">PowerShell 자식 runbook을 호출할 때 사용 하 여 이름을 오는 *.\\*  스크립트 hello toospecify hello 로컬 디렉터리에 위치 합니다.</span><span class="sxs-lookup"><span data-stu-id="acdf9-129">When you call a PowerShell child runbook, you must preceded its name with *.\\* toospecify that hello script is located in hello local directory.</span></span> 

### <a name="example"></a><span data-ttu-id="acdf9-130">예제</span><span class="sxs-lookup"><span data-stu-id="acdf9-130">Example</span></span>
<span data-ttu-id="acdf9-131">다음 예제는 hello 세 개의 매개 변수, 복잡 한 개체, 정수 및 부울 값을 허용 하는 테스트 자식 runbook을 호출 합니다.</span><span class="sxs-lookup"><span data-stu-id="acdf9-131">hello following example invokes a test child runbook that accepts three parameters, a complex object, an integer, and a boolean.</span></span> <span data-ttu-id="acdf9-132">hello 자식 runbook의 hello 출력 tooa 변수에 할당 됩니다.</span><span class="sxs-lookup"><span data-stu-id="acdf9-132">hello output of hello child runbook is assigned tooa variable.</span></span>  <span data-ttu-id="acdf9-133">이 경우 hello 자식 runbook은 PowerShell 워크플로 runbook</span><span class="sxs-lookup"><span data-stu-id="acdf9-133">In this case, hello child runbook is a PowerShell Workflow runbook</span></span>

    $vm = Get-AzureRmVM –ResourceGroupName "LabRG" –Name "MyVM"
    $output = PSWF-ChildRunbook –VM $vm –RepeatCount 2 –Restart $true

<span data-ttu-id="acdf9-134">다음은 hello PowerShell runbook을 사용 하 여 hello 자식으로 동일한 예입니다.</span><span class="sxs-lookup"><span data-stu-id="acdf9-134">Following is hello same example using a PowerShell runbook as hello child.</span></span>

    $vm = Get-AzureRmVM –ResourceGroupName "LabRG" –Name "MyVM"
    $output = .\PS-ChildRunbook.ps1 –VM $vm –RepeatCount 2 –Restart $true


## <a name="starting-a-child-runbook-using-cmdlet"></a><span data-ttu-id="acdf9-135">cmdlet을 사용하여 자식 runbook 시작</span><span class="sxs-lookup"><span data-stu-id="acdf9-135">Starting a child runbook using cmdlet</span></span>
<span data-ttu-id="acdf9-136">Hello를 사용할 수 있습니다 [시작 AzureRmAutomationRunbook](https://msdn.microsoft.com/library/mt603661.aspx) cmdlet toostart에 설명 된 대로 runbook [toostart Windows PowerShell로 runbook](automation-starting-a-runbook.md#starting-a-runbook-with-windows-powershell)합니다.</span><span class="sxs-lookup"><span data-stu-id="acdf9-136">You can use hello [Start-AzureRmAutomationRunbook](https://msdn.microsoft.com/library/mt603661.aspx) cmdlet toostart a runbook as described in [toostart a runbook with Windows PowerShell](automation-starting-a-runbook.md#starting-a-runbook-with-windows-powershell).</span></span> <span data-ttu-id="acdf9-137">이 cmdlet에 사용할 두 가지 모드가 있습니다.</span><span class="sxs-lookup"><span data-stu-id="acdf9-137">There are two modes of use for this cmdlet.</span></span>  <span data-ttu-id="acdf9-138">하나의 모드로 hello cmdlet hello 자식 runbook에 대해 hello 자식 작업이 만들어지는 즉시 hello 작업 id를 반환 합니다.</span><span class="sxs-lookup"><span data-stu-id="acdf9-138">In one mode, hello cmdlet returns hello job id as soon as hello child job is created for hello child runbook.</span></span>  <span data-ttu-id="acdf9-139">Hello hello를 지정 하 여 사용할 수 있는 다른 모드에서 **-대기** 매개 변수를 hello cmdlet hello 자식 될 때까지 대기 작업이 완료 될 하 고 hello 출력 hello 자식 runbook에서 반환 됩니다.</span><span class="sxs-lookup"><span data-stu-id="acdf9-139">In hello other mode, which you enable by specifying hello **-wait** parameter, hello cmdlet will wait until hello child job finishes and will return hello output from hello child runbook.</span></span>

<span data-ttu-id="acdf9-140">cmdlet으로 시작 하는 자식 runbook에서 작업을 hello hello 부모 runbook에서 별도 작업에서 실행 됩니다.</span><span class="sxs-lookup"><span data-stu-id="acdf9-140">hello job from a child runbook started with a cmdlet will run in a separate job from hello parent runbook.</span></span> <span data-ttu-id="acdf9-141">이 작업이 hello 인라인으로 runbook을 호출 하는 보다 이며 더 어렵게 tootrack 유용 합니다.</span><span class="sxs-lookup"><span data-stu-id="acdf9-141">This results in more jobs than invoking hello runbook inline and makes them more difficult tootrack.</span></span> <span data-ttu-id="acdf9-142">hello 부모는 각 toocomplete까지 기다리지 않고 여러 자식 runbook 작업을 비동기적으로 시작할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="acdf9-142">hello parent can start multiple child runbooks asynchronously without waiting for each toocomplete.</span></span> <span data-ttu-id="acdf9-143">같은 종류의 hello 자식 runbook을 인라인으로 호출 하는 병렬 실행을에 대 한 hello 부모 runbook toouse hello 필요 [병렬 키워드](automation-powershell-workflow.md#parallel-processing)합니다.</span><span class="sxs-lookup"><span data-stu-id="acdf9-143">For that same kind of parallel execution calling hello child runbooks inline, hello parent runbook would need toouse hello [parallel keyword](automation-powershell-workflow.md#parallel-processing).</span></span>

<span data-ttu-id="acdf9-144">[Runbook 매개 변수](automation-starting-a-runbook.md#runbook-parameters)에서 설명한 대로 cmdlet을 사용하여 시작된 자식 Runbook에 대한 매개 변수는 해시 테이블로 제공됩니다.</span><span class="sxs-lookup"><span data-stu-id="acdf9-144">Parameters for a child runbook started with a cmdlet are provided as a hashtable as described in [Runbook Parameters](automation-starting-a-runbook.md#runbook-parameters).</span></span> <span data-ttu-id="acdf9-145">단순한 데이터 형식만 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="acdf9-145">Only simple data types can be used.</span></span> <span data-ttu-id="acdf9-146">Hello runbook은 복잡 한 데이터 형식과 매개 변수를 다음 그 인라인으로 호출 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="acdf9-146">If hello runbook has a parameter with a complex data type, then it must be called inline.</span></span>

### <a name="example"></a><span data-ttu-id="acdf9-147">예제</span><span class="sxs-lookup"><span data-stu-id="acdf9-147">Example</span></span>
<span data-ttu-id="acdf9-148">hello 다음 예제에서는 시작 하는 자식 runbook 매개 변수 및 다음 기다립니다 toocomplete 시작 AzureRmAutomationRunbook hello를 사용 하 여-매개 변수를 대기 합니다.</span><span class="sxs-lookup"><span data-stu-id="acdf9-148">hello following example starts a child runbook with parameters and then waits for it toocomplete using hello Start-AzureRmAutomationRunbook -wait parameter.</span></span> <span data-ttu-id="acdf9-149">완료 되 면 hello 자식 runbook에서 해당 출력을 수집 합니다.</span><span class="sxs-lookup"><span data-stu-id="acdf9-149">Once completed, its output is collected from hello child runbook.</span></span>

    $params = @{"VMName"="MyVM";"RepeatCount"=2;"Restart"=$true} 
    $joboutput = Start-AzureRmAutomationRunbook –AutomationAccountName "MyAutomationAccount" –Name "Test-ChildRunbook" -ResourceGroupName "LabRG" –Parameters $params –wait


## <a name="comparison-of-methods-for-calling-a-child-runbook"></a><span data-ttu-id="acdf9-150">자식 runbook을 호출하기 위한 방법 비교</span><span class="sxs-lookup"><span data-stu-id="acdf9-150">Comparison of methods for calling a child runbook</span></span>
<span data-ttu-id="acdf9-151">hello 다음 표에 요약 되어 다른 runbook에서 runbook을 호출 하는 것에 대 한 hello 두 방법 간의 hello 차이점이 있습니다.</span><span class="sxs-lookup"><span data-stu-id="acdf9-151">hello following table summarizes hello differences between hello two methods for calling a runbook from another runbook.</span></span>

|  | <span data-ttu-id="acdf9-152">인라인</span><span class="sxs-lookup"><span data-stu-id="acdf9-152">Inline</span></span> | <span data-ttu-id="acdf9-153">Cmdlet</span><span class="sxs-lookup"><span data-stu-id="acdf9-153">Cmdlet</span></span> |
|:--- |:--- |:--- |
| <span data-ttu-id="acdf9-154">작업</span><span class="sxs-lookup"><span data-stu-id="acdf9-154">Job</span></span> |<span data-ttu-id="acdf9-155">자식 runbook hello hello 부모와 동일한 작업에서 실행 합니다.</span><span class="sxs-lookup"><span data-stu-id="acdf9-155">Child runbooks run in hello same job as hello parent.</span></span> |<span data-ttu-id="acdf9-156">Hello 자식 runbook에 대해 별도 작업이 만들어집니다.</span><span class="sxs-lookup"><span data-stu-id="acdf9-156">A separate job is created for hello child runbook.</span></span> |
| <span data-ttu-id="acdf9-157">실행</span><span class="sxs-lookup"><span data-stu-id="acdf9-157">Execution</span></span> |<span data-ttu-id="acdf9-158">부모 runbook은 계속 하기 전에 자식 runbook toocomplete hello에 대 한 대기합니다.</span><span class="sxs-lookup"><span data-stu-id="acdf9-158">Parent runbook waits for hello child runbook toocomplete before continuing.</span></span> |<span data-ttu-id="acdf9-159">자식 runbook이 시작 된 후에 즉시 부모 runbook을 계속 *또는* 부모 runbook이 자식 작업 toofinish hello에 대 한 대기 합니다.</span><span class="sxs-lookup"><span data-stu-id="acdf9-159">Parent runbook continues immediately after child runbook is started *or* parent runbook waits for hello child job toofinish.</span></span> |
| <span data-ttu-id="acdf9-160">출력</span><span class="sxs-lookup"><span data-stu-id="acdf9-160">Output</span></span> |<span data-ttu-id="acdf9-161">부모 runbook은 자식 runbook에서 출력을 직접 가져올 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="acdf9-161">Parent runbook can directly get output from child runbook.</span></span> |<span data-ttu-id="acdf9-162">부모 Runbook은 자식 Runbook 작업에서 출력을 검색하거나 *또는* 자식 Runbook에서 출력을 직접 가져올 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="acdf9-162">Parent runbook must retrieve output from child runbook job *or* parent runbook can directly get output from child runbook.</span></span> |
| <span data-ttu-id="acdf9-163">매개 변수</span><span class="sxs-lookup"><span data-stu-id="acdf9-163">Parameters</span></span> |<span data-ttu-id="acdf9-164">Hello 자식 runbook 매개 변수의 값은 별도로 지정 되며 및 모든 데이터 형식을 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="acdf9-164">Values for hello child runbook parameters are specified separately and can use any data type.</span></span> |<span data-ttu-id="acdf9-165">Hello 자식 runbook 매개 변수는 단일 해시 테이블에 결합 해야 하며 단순 하 고 포함할 수 있습니다에 대 한 값 배열 및 데이터 형식을 JSON serialization을 사용 하는 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="acdf9-165">Values for hello child runbook parameters must be combined into a single hashtable and can only include simple, array, and object data types that leverage JSON serialization.</span></span> |
| <span data-ttu-id="acdf9-166">자동화 계정</span><span class="sxs-lookup"><span data-stu-id="acdf9-166">Automation Account</span></span> |<span data-ttu-id="acdf9-167">부모 runbook hello에 자식 runbook만 사용할 수 같은 자동화 계정의 합니다.</span><span class="sxs-lookup"><span data-stu-id="acdf9-167">Parent runbook can only use child runbook in hello same automation account.</span></span> |<span data-ttu-id="acdf9-168">부모 runbook hello에서 모든 자동화 계정에서 자식 runbook צ ְ ײ 동일한 Azure 구독과 연결 tooit 있으면도 다른 구독 합니다.</span><span class="sxs-lookup"><span data-stu-id="acdf9-168">Parent runbook can use child runbook from any automation account from hello same Azure subscription and even a different subscription if you have a connection tooit.</span></span> |
| <span data-ttu-id="acdf9-169">게시</span><span class="sxs-lookup"><span data-stu-id="acdf9-169">Publishing</span></span> |<span data-ttu-id="acdf9-170">부모 runbook을 게시하기 전에 자식 runbook을 게시해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="acdf9-170">Child runbook must be published before parent runbook is published.</span></span> |<span data-ttu-id="acdf9-171">부모 runbook을 시작하기 전 언제든 자식 runbook을 게시해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="acdf9-171">Child runbook must be published any time before parent runbook is started.</span></span> |

## <a name="next-steps"></a><span data-ttu-id="acdf9-172">다음 단계</span><span class="sxs-lookup"><span data-stu-id="acdf9-172">Next steps</span></span>
* [<span data-ttu-id="acdf9-173">Azure 자동화에서 Runbook 시작</span><span class="sxs-lookup"><span data-stu-id="acdf9-173">Starting a runbook in Azure Automation</span></span>](automation-starting-a-runbook.md)
* [<span data-ttu-id="acdf9-174">Azure 자동화에서 Runbook 출력 및 메시지</span><span class="sxs-lookup"><span data-stu-id="acdf9-174">Runbook output and messages in Azure Automation</span></span>](automation-runbook-output-and-messages.md)

