---
title: "aaaAzure SQL 데이터베이스 벤치 마크 개요"
description: "이 항목에서는 Azure SQL 데이터베이스 벤치 마크를 Azure SQL 데이터베이스의 hello 성능을 측정에 사용 된 hello를 설명 합니다."
services: sql-database
documentationcenter: na
author: jan-eng
manager: jhubbard
editor: monicar
ms.assetid: e26f8a66-2c12-49d7-8297-45b4d48a5c01
ms.service: sql-database
ms.custom: DBs & servers
ms.devlang: na
ms.topic: article
ms.tgt_pltfrm: na
ms.workload: data-management
ms.date: 06/21/2016
ms.author: janeng
ms.openlocfilehash: 1024e9ada511935f911cb1345b4dc5508997c702
ms.sourcegitcommit: 523283cc1b3c37c428e77850964dc1c33742c5f0
ms.translationtype: MT
ms.contentlocale: ko-KR
ms.lasthandoff: 10/06/2017
---
# <a name="azure-sql-database-benchmark-overview"></a><span data-ttu-id="3679b-103">Azure SQL 데이터베이스 벤치마크 개요</span><span class="sxs-lookup"><span data-stu-id="3679b-103">Azure SQL Database benchmark overview</span></span>
## <a name="overview"></a><span data-ttu-id="3679b-104">개요</span><span class="sxs-lookup"><span data-stu-id="3679b-104">Overview</span></span>
<span data-ttu-id="3679b-105">Microsoft Azure SQL 데이터베이스는 여러 성능 수준의 3가지 [서비스 계층](sql-database-service-tiers.md) 을 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="3679b-105">Microsoft Azure SQL Database offers three [service tiers](sql-database-service-tiers.md) with multiple performance levels.</span></span> <span data-ttu-id="3679b-106">각 성능 수준은 증가 집합이 자원 또는 '전원' 설계 toodeliver 높은 처리량을 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="3679b-106">Each performance level provides an increasing set of resources, or ‘power’, designed toodeliver increasingly higher throughput.</span></span>

<span data-ttu-id="3679b-107">것이 중요 한 toobe 수 tooquantify 높아지는 데이터베이스 성능이 hello 각 성능 수준의 기능 증가가 변환 하는 방법을 합니다.</span><span class="sxs-lookup"><span data-stu-id="3679b-107">It is important toobe able tooquantify how hello increasing power of each performance level translates into increased database performance.</span></span> <span data-ttu-id="3679b-108">이 Microsoft 개발 했습니다 toodo hello SQL 데이터베이스 벤치 마크 ASDB (Azure).</span><span class="sxs-lookup"><span data-stu-id="3679b-108">toodo this Microsoft has developed hello Azure SQL Database Benchmark (ASDB).</span></span> <span data-ttu-id="3679b-109">hello 모든 OLTP 작업에 기본적인 작업 조합을 수행 합니다.</span><span class="sxs-lookup"><span data-stu-id="3679b-109">hello benchmark exercises a mix of basic operations found in all OLTP workloads.</span></span> <span data-ttu-id="3679b-110">각 성능 수준에서 실행 되는 데이터베이스에 대 한 hello 처리량을 측정 합니다.</span><span class="sxs-lookup"><span data-stu-id="3679b-110">We measure hello throughput achieved for databases running in each performance level.</span></span>

<span data-ttu-id="3679b-111">hello 리소스와 각 서비스 계층과 성능 수준의 표현의 측면에서 [데이터베이스 트랜잭션 단위 (DTUs)](sql-database-what-is-a-dtu.md)합니다.</span><span class="sxs-lookup"><span data-stu-id="3679b-111">hello resources and power of each service tier and performance level are expressed in terms of [Database Transaction Units (DTUs)](sql-database-what-is-a-dtu.md).</span></span> <span data-ttu-id="3679b-112">Dtu를 통해 toodescribe hello 성능 수준의 상대적 용량 CPU, 메모리의 복합된 측정에 기반 하 고 읽고 쓸 각 성능 수준에서 제공 되는 속도입니다.</span><span class="sxs-lookup"><span data-stu-id="3679b-112">DTUs provide a way toodescribe hello relative capacity of a performance level based on a blended measure of CPU, memory, and read and write rates offered by each performance level.</span></span> <span data-ttu-id="3679b-113">데이터베이스의 DTU 등급이 hello 더블링 toodoubling hello 데이터베이스 기능도를 같습니다.</span><span class="sxs-lookup"><span data-stu-id="3679b-113">Doubling hello DTU rating of a database equates toodoubling hello database power.</span></span> <span data-ttu-id="3679b-114">hello 벤치 마크를 통해 tooassess hello 영향 비례하여에서 데이터베이스 크기, 사용자 및 트랜잭션 속도 확장할 수를 크기 조정 하는 동안 실제 데이터베이스 작업을 실행 하 여 각 성능 수준에서 제공 되는 기능을 늘리면 hello 데이터베이스 성능에 toohello 리소스 toohello 데이터베이스를 제공 합니다.</span><span class="sxs-lookup"><span data-stu-id="3679b-114">hello benchmark allows us tooassess hello impact on database performance of hello increasing power offered by each performance level by exercising actual database operations, while scaling database size, number of users, and transaction rates in proportion toohello resources provided toohello database.</span></span>

<span data-ttu-id="3679b-115">트랜잭션을 시간당을 사용 하 여 hello Basic 서비스 계층의 hello 처리량 나타내어 분당 트랜잭션, 및 초당을 보다 쉽게 tooquickly 이렇게 하면 트랜잭션을 사용 하 여 hello Premium 서비스 계층을 사용 하 여 hello Standard 서비스 계층 관련 hello 각 응용 프로그램의 서비스 계층 toohello 요구 사항 성능 가능성이 있습니다.</span><span class="sxs-lookup"><span data-stu-id="3679b-115">By expressing hello throughput of hello Basic service tier using transactions per-hour, hello Standard service tier using transactions per-minute, and hello Premium service tier using transactions per-second, it makes it easier tooquickly relate hello performance potential of each service tier toohello requirements of an application.</span></span>

## <a name="correlating-benchmark-results-tooreal-world-database-performance"></a><span data-ttu-id="3679b-116">상관 관계 자동 연결 벤치 마크 결과 tooreal 세계 데이터베이스 성능</span><span class="sxs-lookup"><span data-stu-id="3679b-116">Correlating benchmark results tooreal world database performance</span></span>
<span data-ttu-id="3679b-117">중요 한 toounderstand 모든 벤치 마크와 같은 해당 ASDB 되만 한정 되며 암시적 됩니다.</span><span class="sxs-lookup"><span data-stu-id="3679b-117">It is important toounderstand that ASDB, like all benchmarks, is representative and indicative only.</span></span> <span data-ttu-id="3679b-118">안녕 트랜잭션 hello 벤치 마크 응용 프로그램을 사용 하 여 수행 하는 속도 다른 응용 프로그램과 얻을 수 있는 것과 동일한 hello 되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="3679b-118">hello transaction rates achieved with hello benchmark application will not be hello same as those that might be achieved with other applications.</span></span> <span data-ttu-id="3679b-119">hello 벤치 마크는 종류의 테이블 및 데이터 형식 범위를 포함 하는 스키마에 대해 실행 하는 다른 트랜잭션의 컬렉션을 구성 합니다.</span><span class="sxs-lookup"><span data-stu-id="3679b-119">hello benchmark comprises a collection of different transaction types run against a schema containing a range of tables and data types.</span></span> <span data-ttu-id="3679b-120">Hello 벤치 마크 연습 hello 일반적인 tooall OLTP 워크 로드는 동일한 기본 작업을 하는 동안 데이터베이스 또는 응용 프로그램의 특정 클래스를 나타내지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="3679b-120">While hello benchmark exercises hello same basic operations that are common tooall OLTP workloads, it does not represent any specific class of database or application.</span></span> <span data-ttu-id="3679b-121">hello hello 벤치 마크의 목적은 tooprovide 예상 되는 확장 또는 축소 하는 경우 성능 수준 간에 데이터베이스의 적절 한 지침 toohello 상대적인 성능입니다.</span><span class="sxs-lookup"><span data-stu-id="3679b-121">hello goal of hello benchmark is tooprovide a reasonable guide toohello relative performance of a database that might be expected when scaling up or down between performance levels.</span></span> <span data-ttu-id="3679b-122">실제로, 각 데이터베이스는 크기와 복잡성이 다르고 다양하게 혼합된 워크로드를 처리할 수 있으며 각각 다른 방식으로 대응합니다.</span><span class="sxs-lookup"><span data-stu-id="3679b-122">In reality, databases are of different sizes and complexity, encounter different mixes of workloads, and will respond in different ways.</span></span> <span data-ttu-id="3679b-123">예를 들어, IO를 많이 사용하는 응용 프로그램은 IO 임계값에 빠르게 도달할 수 있고 CPU를 많이 사용하는 응용 프로그램은 CPU 한도에 빠르게 도달할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="3679b-123">For example, an IO-intensive application may hit IO thresholds sooner, or a CPU-intensive application may hit CPU limits sooner.</span></span> <span data-ttu-id="3679b-124">했더라도 특정 데이터베이스가 동일한 방식으로 hello 증가 시 벤치 마크로 로드 하는 hello에 확장할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="3679b-124">There is no guarantee that any particular database will scale in hello same way as hello benchmark under increasing load.</span></span>

<span data-ttu-id="3679b-125">hello 벤치 마크와 해당 방법 설명 아래에 자세히 합니다.</span><span class="sxs-lookup"><span data-stu-id="3679b-125">hello benchmark and its methodology are described in more detail below.</span></span>

## <a name="benchmark-summary"></a><span data-ttu-id="3679b-126">벤치마크 요약</span><span class="sxs-lookup"><span data-stu-id="3679b-126">Benchmark summary</span></span>
<span data-ttu-id="3679b-127">ASDB는 온라인 트랜잭션 처리 (OLTP) 워크 로드에서에서 가장 자주 발생 하는 기본적인 데이터베이스 작업 조합의 hello 성능을 측정 합니다.</span><span class="sxs-lookup"><span data-stu-id="3679b-127">ASDB measures hello performance of a mix of basic database operations which occur most frequently in online transaction processing (OLTP) workloads.</span></span> <span data-ttu-id="3679b-128">Hello 벤치 마크는 클라우드 컴퓨팅을 염두에 두고 설계, 있지만 hello 데이터베이스 스키마, 데이터 채우기 및 트랜잭션이 된 디자인 된 toobe OLTP 워크 로드에 가장 많이 사용 하는 hello 기본 요소를 광범위 하 게 반영 합니다.</span><span class="sxs-lookup"><span data-stu-id="3679b-128">Although hello benchmark is designed with cloud computing in mind, hello database schema, data population, and transactions have been designed toobe broadly representative of hello basic elements most commonly used in OLTP workloads.</span></span>

## <a name="schema"></a><span data-ttu-id="3679b-129">스키마</span><span class="sxs-lookup"><span data-stu-id="3679b-129">Schema</span></span>
<span data-ttu-id="3679b-130">hello 스키마가 디자인 된 toohave 충분 한 다양 하 고 복잡 toosupport 폭넓은 작업 합니다.</span><span class="sxs-lookup"><span data-stu-id="3679b-130">hello schema is designed toohave enough variety and complexity toosupport a broad range of operations.</span></span> <span data-ttu-id="3679b-131">hello 벤치 마크는 6 개 테이블로 구성 된 데이터베이스에 대해 실행 됩니다.</span><span class="sxs-lookup"><span data-stu-id="3679b-131">hello benchmark runs against a database comprised of six tables.</span></span> <span data-ttu-id="3679b-132">hello 테이블 세 범주로: 고정 크기, 확장 및 증가 합니다.</span><span class="sxs-lookup"><span data-stu-id="3679b-132">hello tables fall into three categories: fixed-size, scaling, and growing.</span></span> <span data-ttu-id="3679b-133">2개의 고정 크기 테이블, 3개의 확장 테이블, 1개의 증가 테이블이 있습니다.</span><span class="sxs-lookup"><span data-stu-id="3679b-133">There are two fixed-size tables; three scaling tables; and one growing table.</span></span> <span data-ttu-id="3679b-134">고정 크기 테이블에는 고정된 수의 행이 있습니다.</span><span class="sxs-lookup"><span data-stu-id="3679b-134">Fixed-size tables have a constant number of rows.</span></span> <span data-ttu-id="3679b-135">크기 조정 테이블 카디널리티가 비례 toodatabase 성능 이지만 hello 벤치 마크 하는 동안 변경 되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="3679b-135">Scaling tables have a cardinality that is proportional toodatabase performance, but doesn’t change during hello benchmark.</span></span> <span data-ttu-id="3679b-136">hello 테이블 증가 하 고 초기 로드 시 확장 테이블과 같이 크기가 지정 하지만 hello 카디널리티 hello 행을 삽입 / 삭제 하는 대로 hello 벤치 마크 실행 과정에서 변경 합니다.</span><span class="sxs-lookup"><span data-stu-id="3679b-136">hello growing table is sized like a scaling table on initial load, but then hello cardinality changes in hello course of running hello benchmark as rows are inserted and deleted.</span></span>

<span data-ttu-id="3679b-137">hello 스키마에는 다양 한 데이터 형식에 정수, 숫자, 문자 및 날짜/시간입니다.</span><span class="sxs-lookup"><span data-stu-id="3679b-137">hello schema includes a mix of data types, including integer, numeric, character, and date/time.</span></span> <span data-ttu-id="3679b-138">hello 기본 및 보조 키를 포함 되지만 포함 외래 키는-즉, 테이블 간에 참조 무결성 제약 조건이 없으면 있습니다는 합니다.</span><span class="sxs-lookup"><span data-stu-id="3679b-138">hello schema includes primary and secondary keys, but not any foreign keys - that is, there are no referential integrity constraints between tables.</span></span>

<span data-ttu-id="3679b-139">데이터 생성 프로그램이 초기 데이터베이스 hello에 대 한 hello 데이터를 생성합니다.</span><span class="sxs-lookup"><span data-stu-id="3679b-139">A data generation program generates hello data for hello initial database.</span></span> <span data-ttu-id="3679b-140">정수 및 숫자 데이터는 다양한 전략으로 생성됩니다.</span><span class="sxs-lookup"><span data-stu-id="3679b-140">Integer and numeric data is generated with various strategies.</span></span> <span data-ttu-id="3679b-141">값이 범위에 무작위로 분포되는 경우도 있습니다.</span><span class="sxs-lookup"><span data-stu-id="3679b-141">In some cases, values are distributed randomly over a range.</span></span> <span data-ttu-id="3679b-142">다른 경우에는 값 집합이 임의로 변경한 tooensure 특정 배포 유지 관리 됩니다.</span><span class="sxs-lookup"><span data-stu-id="3679b-142">In other cases, a set of values is randomly permuted tooensure that a specific distribution is maintained.</span></span> <span data-ttu-id="3679b-143">텍스트 필드는 가중치가 적용 된 목록이 단어 tooproduce 실제와 같은 데이터에서 생성 됩니다.</span><span class="sxs-lookup"><span data-stu-id="3679b-143">Text fields are generated from a weighted list of words tooproduce realistic looking data.</span></span>

<span data-ttu-id="3679b-144">hello 데이터베이스 크기 기반으로 "배율 인수"입니다.</span><span class="sxs-lookup"><span data-stu-id="3679b-144">hello database is sized based on a “scale factor.”</span></span> <span data-ttu-id="3679b-145">hello 배율 (약어 SF) hello 확장 및 증가 테이블의 hello 카디널리티를 결정 합니다.</span><span class="sxs-lookup"><span data-stu-id="3679b-145">hello scale factor (abbreviated as SF) determines hello cardinality of hello scaling and growing tables.</span></span> <span data-ttu-id="3679b-146">아래에 설명 된 대로 hello 섹션 사용자 및 속도 hello 데이터베이스 크기, 사용자 및 다른 비율 tooeach로 모든 크기를 조정 하는 최대 성능을 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="3679b-146">As described below in hello section Users and Pacing, hello database size, number of users, and maximum performance all scale in proportion tooeach other.</span></span>

## <a name="transactions"></a><span data-ttu-id="3679b-147">트랜잭션</span><span class="sxs-lookup"><span data-stu-id="3679b-147">Transactions</span></span>
<span data-ttu-id="3679b-148">hello 작업 hello 테이블 아래에 나와 있는 것 처럼 9 개 트랜잭션 유형으로 구성 됩니다.</span><span class="sxs-lookup"><span data-stu-id="3679b-148">hello workload consists of nine transaction types, as shown in hello table below.</span></span> <span data-ttu-id="3679b-149">각 트랜잭션에 특정 시스템 특징 집합을 hello 데이터베이스 엔진과 시스템 하드웨어의 디자인 된 toohighlight를 hello 다른 트랜잭션이 크게 다릅니다.</span><span class="sxs-lookup"><span data-stu-id="3679b-149">Each transaction is designed toohighlight a particular set of system characteristics in hello database engine and system hardware, with high contrast from hello other transactions.</span></span> <span data-ttu-id="3679b-150">이러한 방식을 통해 다양 한 구성 요소 toooverall 성능을 보다 쉽게 tooassess hello 영향입니다.</span><span class="sxs-lookup"><span data-stu-id="3679b-150">This approach makes it easier tooassess hello impact of different components toooverall performance.</span></span> <span data-ttu-id="3679b-151">예를 들어 "읽기 중형" hello 트랜잭션 수가 디스크에서 읽기 작업을 생성합니다.</span><span class="sxs-lookup"><span data-stu-id="3679b-151">For example, hello transaction “Read Heavy” produces a significant number of read operations from disk.</span></span>

| <span data-ttu-id="3679b-152">트랜잭션 유형</span><span class="sxs-lookup"><span data-stu-id="3679b-152">Transaction Type</span></span> | <span data-ttu-id="3679b-153">설명</span><span class="sxs-lookup"><span data-stu-id="3679b-153">Description</span></span> |
| --- | --- |
| <span data-ttu-id="3679b-154">적은 읽기 작업</span><span class="sxs-lookup"><span data-stu-id="3679b-154">Read Lite</span></span> |<span data-ttu-id="3679b-155">SELECT, 메모리 내, 읽기 전용</span><span class="sxs-lookup"><span data-stu-id="3679b-155">SELECT; in-memory; read-only</span></span> |
| <span data-ttu-id="3679b-156">중간 읽기 작업</span><span class="sxs-lookup"><span data-stu-id="3679b-156">Read Medium</span></span> |<span data-ttu-id="3679b-157">SELECT, 대부분 메모리 내, 읽기 전용</span><span class="sxs-lookup"><span data-stu-id="3679b-157">SELECT; mostly in-memory; read-only</span></span> |
| <span data-ttu-id="3679b-158">많은 읽기 작업</span><span class="sxs-lookup"><span data-stu-id="3679b-158">Read Heavy</span></span> |<span data-ttu-id="3679b-159">SELECT, 대부분 메모리 외, 읽기 전용</span><span class="sxs-lookup"><span data-stu-id="3679b-159">SELECT; mostly not in-memory; read-only</span></span> |
| <span data-ttu-id="3679b-160">적은 업데이트 작업</span><span class="sxs-lookup"><span data-stu-id="3679b-160">Update Lite</span></span> |<span data-ttu-id="3679b-161">UPDATE, 메모리 내, 읽기-쓰기</span><span class="sxs-lookup"><span data-stu-id="3679b-161">UPDATE; in-memory; read-write</span></span> |
| <span data-ttu-id="3679b-162">많은 업데이트 작업</span><span class="sxs-lookup"><span data-stu-id="3679b-162">Update Heavy</span></span> |<span data-ttu-id="3679b-163">UPDATE, 대부분 메모리 외, 읽기-쓰기</span><span class="sxs-lookup"><span data-stu-id="3679b-163">UPDATE; mostly not in-memory; read-write</span></span> |
| <span data-ttu-id="3679b-164">적은 삽입 작업</span><span class="sxs-lookup"><span data-stu-id="3679b-164">Insert Lite</span></span> |<span data-ttu-id="3679b-165">INSERT, 메모리 내, 읽기-쓰기</span><span class="sxs-lookup"><span data-stu-id="3679b-165">INSERT; in-memory; read-write</span></span> |
| <span data-ttu-id="3679b-166">많은 삽입 작업</span><span class="sxs-lookup"><span data-stu-id="3679b-166">Insert Heavy</span></span> |<span data-ttu-id="3679b-167">INSERT, 대부분 메모리 외, 읽기-쓰기</span><span class="sxs-lookup"><span data-stu-id="3679b-167">INSERT; mostly not in-memory; read-write</span></span> |
| <span data-ttu-id="3679b-168">삭제</span><span class="sxs-lookup"><span data-stu-id="3679b-168">Delete</span></span> |<span data-ttu-id="3679b-169">DELETE, 메모리 내 및 메모리 외 혼합, 읽기-쓰기</span><span class="sxs-lookup"><span data-stu-id="3679b-169">DELETE; mix of in-memory and not in-memory; read-write</span></span> |
| <span data-ttu-id="3679b-170">많은 CPU 사용</span><span class="sxs-lookup"><span data-stu-id="3679b-170">CPU Heavy</span></span> |<span data-ttu-id="3679b-171">SELECT, 메모리 내, 상대적으로 많은 CPU 부하, 읽기 전용</span><span class="sxs-lookup"><span data-stu-id="3679b-171">SELECT; in-memory; relatively heavy CPU load; read-only</span></span> |

## <a name="workload-mix"></a><span data-ttu-id="3679b-172">워크로드 혼합</span><span class="sxs-lookup"><span data-stu-id="3679b-172">Workload mix</span></span>
<span data-ttu-id="3679b-173">트랜잭션은 다음 전체 조합의 hello로 가중치가 적용 된 분산에서 임의로 선택 됩니다.</span><span class="sxs-lookup"><span data-stu-id="3679b-173">Transactions are selected at random from a weighted distribution with hello following overall mix.</span></span> <span data-ttu-id="3679b-174">hello 전체 조합의 약 2: 1의 읽기/쓰기 비율은 있습니다.</span><span class="sxs-lookup"><span data-stu-id="3679b-174">hello overall mix has a read/write ratio of approximately 2:1.</span></span>

| <span data-ttu-id="3679b-175">트랜잭션 유형</span><span class="sxs-lookup"><span data-stu-id="3679b-175">Transaction Type</span></span> | <span data-ttu-id="3679b-176">혼합 비율</span><span class="sxs-lookup"><span data-stu-id="3679b-176">% of Mix</span></span> |
| --- | --- |
| <span data-ttu-id="3679b-177">적은 읽기 작업</span><span class="sxs-lookup"><span data-stu-id="3679b-177">Read Lite</span></span> |<span data-ttu-id="3679b-178">35</span><span class="sxs-lookup"><span data-stu-id="3679b-178">35</span></span> |
| <span data-ttu-id="3679b-179">중간 읽기 작업</span><span class="sxs-lookup"><span data-stu-id="3679b-179">Read Medium</span></span> |<span data-ttu-id="3679b-180">20</span><span class="sxs-lookup"><span data-stu-id="3679b-180">20</span></span> |
| <span data-ttu-id="3679b-181">많은 읽기 작업</span><span class="sxs-lookup"><span data-stu-id="3679b-181">Read Heavy</span></span> |<span data-ttu-id="3679b-182">5</span><span class="sxs-lookup"><span data-stu-id="3679b-182">5</span></span> |
| <span data-ttu-id="3679b-183">적은 업데이트 작업</span><span class="sxs-lookup"><span data-stu-id="3679b-183">Update Lite</span></span> |<span data-ttu-id="3679b-184">20</span><span class="sxs-lookup"><span data-stu-id="3679b-184">20</span></span> |
| <span data-ttu-id="3679b-185">많은 업데이트 작업</span><span class="sxs-lookup"><span data-stu-id="3679b-185">Update Heavy</span></span> |<span data-ttu-id="3679b-186">3</span><span class="sxs-lookup"><span data-stu-id="3679b-186">3</span></span> |
| <span data-ttu-id="3679b-187">적은 삽입 작업</span><span class="sxs-lookup"><span data-stu-id="3679b-187">Insert Lite</span></span> |<span data-ttu-id="3679b-188">3</span><span class="sxs-lookup"><span data-stu-id="3679b-188">3</span></span> |
| <span data-ttu-id="3679b-189">많은 삽입 작업</span><span class="sxs-lookup"><span data-stu-id="3679b-189">Insert Heavy</span></span> |<span data-ttu-id="3679b-190">2</span><span class="sxs-lookup"><span data-stu-id="3679b-190">2</span></span> |
| <span data-ttu-id="3679b-191">삭제</span><span class="sxs-lookup"><span data-stu-id="3679b-191">Delete</span></span> |<span data-ttu-id="3679b-192">2</span><span class="sxs-lookup"><span data-stu-id="3679b-192">2</span></span> |
| <span data-ttu-id="3679b-193">많은 CPU 사용</span><span class="sxs-lookup"><span data-stu-id="3679b-193">CPU Heavy</span></span> |<span data-ttu-id="3679b-194">10</span><span class="sxs-lookup"><span data-stu-id="3679b-194">10</span></span> |

## <a name="users-and-pacing"></a><span data-ttu-id="3679b-195">사용자 및 속도</span><span class="sxs-lookup"><span data-stu-id="3679b-195">Users and pacing</span></span>
<span data-ttu-id="3679b-196">hello 벤치 마크의 작업 수의 동시 사용자의 연결 toosimulate hello 동작의 집합을 통해 트랜잭션을 전송 하는 도구에서 생성 됩니다.</span><span class="sxs-lookup"><span data-stu-id="3679b-196">hello benchmark workload is driven from a tool that submits transactions across a set of connections toosimulate hello behavior of a number of concurrent users.</span></span> <span data-ttu-id="3679b-197">모두 hello 연결과 트랜잭션은 컴퓨터에서 생성 되 면 하지만 편의상 언급할 toothese 연결을 "사용자"</span><span class="sxs-lookup"><span data-stu-id="3679b-197">Although all of hello connections and transactions are machine generated, for simplicity we refer toothese connections as “users.”</span></span> <span data-ttu-id="3679b-198">모든 사용자가 수행할 hello 각 사용자의 다른 모든 사용자와 독립적으로 작동 하지만 동일한 단계 주기를 아래에 나와 있습니다.</span><span class="sxs-lookup"><span data-stu-id="3679b-198">Although each user operates independently of all other users, all users perform hello same cycle of steps shown below:</span></span>

1. <span data-ttu-id="3679b-199">데이터베이스에 연결합니다.</span><span class="sxs-lookup"><span data-stu-id="3679b-199">Establish a database connection.</span></span>
2. <span data-ttu-id="3679b-200">신호를 받은 tooexit 될 때까지 반복 합니다.</span><span class="sxs-lookup"><span data-stu-id="3679b-200">Repeat until signaled tooexit:</span></span>
   * <span data-ttu-id="3679b-201">(가중치가 적용된 분포에서) 무작위로 트랜잭션을 선택합니다.</span><span class="sxs-lookup"><span data-stu-id="3679b-201">Select a transaction at random (from a weighted distribution).</span></span>
   * <span data-ttu-id="3679b-202">선택한 hello 트랜잭션과 hello 응답 시간을 측정을 수행 합니다.</span><span class="sxs-lookup"><span data-stu-id="3679b-202">Perform hello selected transaction and measure hello response time.</span></span>
   * <span data-ttu-id="3679b-203">속도 지연을 기다립니다.</span><span class="sxs-lookup"><span data-stu-id="3679b-203">Wait for a pacing delay.</span></span>
3. <span data-ttu-id="3679b-204">Hello 데이터베이스 연결을 닫습니다.</span><span class="sxs-lookup"><span data-stu-id="3679b-204">Close hello database connection.</span></span>
4. <span data-ttu-id="3679b-205">끝내기를 클릭합니다.</span><span class="sxs-lookup"><span data-stu-id="3679b-205">Exit.</span></span>

<span data-ttu-id="3679b-206">속도 지연 시간 (단계 2 c) hello를 임의로 선택 하지만 1.0 초 평균 분포 크기가 합니다.</span><span class="sxs-lookup"><span data-stu-id="3679b-206">hello pacing delay (in step 2c) is selected at random, but with a distribution that has an average of 1.0 second.</span></span> <span data-ttu-id="3679b-207">따라서 각 사용자는 평균적으로 1초당 최대 1개의 트랜잭션을 생성할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="3679b-207">Thus each user can, on average, generate at most one transaction per second.</span></span>

## <a name="scaling-rules"></a><span data-ttu-id="3679b-208">확장 규칙</span><span class="sxs-lookup"><span data-stu-id="3679b-208">Scaling rules</span></span>
<span data-ttu-id="3679b-209">사용자 수가 hello hello 데이터베이스 크기 (배율 단위)에 의해 결정 됩니다.</span><span class="sxs-lookup"><span data-stu-id="3679b-209">hello number of users is determined by hello database size (in scale-factor units).</span></span> <span data-ttu-id="3679b-210">5개의 배율 단위당 1명의 사용자가 있습니다.</span><span class="sxs-lookup"><span data-stu-id="3679b-210">There is one user for every five scale-factor units.</span></span> <span data-ttu-id="3679b-211">속도 지연 hello, 때문에 한 명의 사용자에서 초당 트랜잭션을 최대 하나만 평균 생성할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="3679b-211">Because of hello pacing delay, one user can generate at most one transaction per second, on average.</span></span>

<span data-ttu-id="3679b-212">예를 들어, 배율이 500(SF=500)인 데이터베이스는 사용자가 100명이며 최대 100TPS의 속도를 달성할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="3679b-212">For example, a scale-factor of 500 (SF=500) database will have 100 users and can achieve a maximum rate of 100 TPS.</span></span> <span data-ttu-id="3679b-213">더 높은 TPS 속도 toodrive 더 많은 사용자와 더 큰 데이터베이스가 필요합니다.</span><span class="sxs-lookup"><span data-stu-id="3679b-213">toodrive a higher TPS rate requires more users and a larger database.</span></span>

<span data-ttu-id="3679b-214">hello 표에서 hello 실제로 각 서비스 계층과 성능 수준에 대해 지 원하는 사용자 수를 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="3679b-214">hello table below shows hello number of users actually sustained for each service tier and performance level.</span></span>

| <span data-ttu-id="3679b-215">서비스 계층(성능 수준)</span><span class="sxs-lookup"><span data-stu-id="3679b-215">Service Tier (Performance Level)</span></span> | <span data-ttu-id="3679b-216">사용자</span><span class="sxs-lookup"><span data-stu-id="3679b-216">Users</span></span> | <span data-ttu-id="3679b-217">데이터베이스 크기</span><span class="sxs-lookup"><span data-stu-id="3679b-217">Database Size</span></span> |
| --- | --- | --- |
| <span data-ttu-id="3679b-218">Basic</span><span class="sxs-lookup"><span data-stu-id="3679b-218">Basic</span></span> |<span data-ttu-id="3679b-219">5</span><span class="sxs-lookup"><span data-stu-id="3679b-219">5</span></span> |<span data-ttu-id="3679b-220">720MB</span><span class="sxs-lookup"><span data-stu-id="3679b-220">720 MB</span></span> |
| <span data-ttu-id="3679b-221">Standard(S0)</span><span class="sxs-lookup"><span data-stu-id="3679b-221">Standard (S0)</span></span> |<span data-ttu-id="3679b-222">10</span><span class="sxs-lookup"><span data-stu-id="3679b-222">10</span></span> |<span data-ttu-id="3679b-223">1 GB</span><span class="sxs-lookup"><span data-stu-id="3679b-223">1 GB</span></span> |
| <span data-ttu-id="3679b-224">Standard(S1)</span><span class="sxs-lookup"><span data-stu-id="3679b-224">Standard (S1)</span></span> |<span data-ttu-id="3679b-225">20</span><span class="sxs-lookup"><span data-stu-id="3679b-225">20</span></span> |<span data-ttu-id="3679b-226">2.1GB</span><span class="sxs-lookup"><span data-stu-id="3679b-226">2.1 GB</span></span> |
| <span data-ttu-id="3679b-227">Standard(S2)</span><span class="sxs-lookup"><span data-stu-id="3679b-227">Standard (S2)</span></span> |<span data-ttu-id="3679b-228">50</span><span class="sxs-lookup"><span data-stu-id="3679b-228">50</span></span> |<span data-ttu-id="3679b-229">7.1GB</span><span class="sxs-lookup"><span data-stu-id="3679b-229">7.1 GB</span></span> |
| <span data-ttu-id="3679b-230">Premium(P1)</span><span class="sxs-lookup"><span data-stu-id="3679b-230">Premium (P1)</span></span> |<span data-ttu-id="3679b-231">100</span><span class="sxs-lookup"><span data-stu-id="3679b-231">100</span></span> |<span data-ttu-id="3679b-232">14 GB</span><span class="sxs-lookup"><span data-stu-id="3679b-232">14 GB</span></span> |
| <span data-ttu-id="3679b-233">Premium(P2)</span><span class="sxs-lookup"><span data-stu-id="3679b-233">Premium (P2)</span></span> |<span data-ttu-id="3679b-234">200</span><span class="sxs-lookup"><span data-stu-id="3679b-234">200</span></span> |<span data-ttu-id="3679b-235">28GB</span><span class="sxs-lookup"><span data-stu-id="3679b-235">28 GB</span></span> |
| <span data-ttu-id="3679b-236">Premium(P6/P3)</span><span class="sxs-lookup"><span data-stu-id="3679b-236">Premium (P6/P3)</span></span> |<span data-ttu-id="3679b-237">800</span><span class="sxs-lookup"><span data-stu-id="3679b-237">800</span></span> |<span data-ttu-id="3679b-238">114GB</span><span class="sxs-lookup"><span data-stu-id="3679b-238">114 GB</span></span> |

## <a name="measurement-duration"></a><span data-ttu-id="3679b-239">측정 기간</span><span class="sxs-lookup"><span data-stu-id="3679b-239">Measurement duration</span></span>
<span data-ttu-id="3679b-240">유효한 벤치마크를 실행하려면 한 시간 이상의 안정적 측정 기간이 필요합니다.</span><span class="sxs-lookup"><span data-stu-id="3679b-240">A valid benchmark run requires a steady-state measurement duration of at least one hour.</span></span>

## <a name="metrics"></a><span data-ttu-id="3679b-241">메트릭</span><span class="sxs-lookup"><span data-stu-id="3679b-241">Metrics</span></span>
<span data-ttu-id="3679b-242">hello 키 hello 벤치 마크에 메트릭은 처리량과 응답 시간입니다.</span><span class="sxs-lookup"><span data-stu-id="3679b-242">hello key metrics in hello benchmark are throughput and response time.</span></span>

* <span data-ttu-id="3679b-243">처리량은 벤치 마크 hello에에서 hello 필수 성능 측정값입니다.</span><span class="sxs-lookup"><span data-stu-id="3679b-243">Throughput is hello essential performance measure in hello benchmark.</span></span> <span data-ttu-id="3679b-244">처리량은 모든 트랜잭션 유형을 세는 단위 시간당 트랜잭션 수로 보고됩니다.</span><span class="sxs-lookup"><span data-stu-id="3679b-244">Throughput is reported in transactions per unit-of-time, counting all transaction types.</span></span>
* <span data-ttu-id="3679b-245">응답 시간은 성능 예측 가능성에 대한 측정값입니다.</span><span class="sxs-lookup"><span data-stu-id="3679b-245">Response time is a measure of performance predictability.</span></span> <span data-ttu-id="3679b-246">hello 응답 시간 제약 조건은 서비스 클래스 일수록 아래와 같이 보다 엄격한 응답 시간 요구 사항을, 일수록 클래스와 다릅니다.</span><span class="sxs-lookup"><span data-stu-id="3679b-246">hello response time constraint varies with class of service, with higher classes of service having a more stringent response time requirement, as shown below.</span></span>

| <span data-ttu-id="3679b-247">서비스 클래스</span><span class="sxs-lookup"><span data-stu-id="3679b-247">Class of Service</span></span> | <span data-ttu-id="3679b-248">처리량 측정</span><span class="sxs-lookup"><span data-stu-id="3679b-248">Throughput Measure</span></span> | <span data-ttu-id="3679b-249">응답 시간 요구 사항</span><span class="sxs-lookup"><span data-stu-id="3679b-249">Response Time Requirement</span></span> |
| --- | --- | --- |
| <span data-ttu-id="3679b-250">Premium</span><span class="sxs-lookup"><span data-stu-id="3679b-250">Premium</span></span> |<span data-ttu-id="3679b-251">초당 트랜잭션 수</span><span class="sxs-lookup"><span data-stu-id="3679b-251">Transactions per second</span></span> |<span data-ttu-id="3679b-252">0.5초에서 95 백분위수</span><span class="sxs-lookup"><span data-stu-id="3679b-252">95th percentile at 0.5 seconds</span></span> |
| <span data-ttu-id="3679b-253">Standard</span><span class="sxs-lookup"><span data-stu-id="3679b-253">Standard</span></span> |<span data-ttu-id="3679b-254">분당 트랜잭션 수</span><span class="sxs-lookup"><span data-stu-id="3679b-254">Transactions per minute</span></span> |<span data-ttu-id="3679b-255">1.0초에서 90 백분위수</span><span class="sxs-lookup"><span data-stu-id="3679b-255">90th percentile at 1.0 seconds</span></span> |
| <span data-ttu-id="3679b-256">Basic</span><span class="sxs-lookup"><span data-stu-id="3679b-256">Basic</span></span> |<span data-ttu-id="3679b-257">시간당 트랜잭션 수</span><span class="sxs-lookup"><span data-stu-id="3679b-257">Transactions per hour</span></span> |<span data-ttu-id="3679b-258">2.0초에서 80 백분위수</span><span class="sxs-lookup"><span data-stu-id="3679b-258">80th percentile at 2.0 seconds</span></span> |

## <a name="conclusion"></a><span data-ttu-id="3679b-259">결론</span><span class="sxs-lookup"><span data-stu-id="3679b-259">Conclusion</span></span>
<span data-ttu-id="3679b-260">Azure SQL 데이터베이스 벤치 마크 hello hello hello 사용 가능한 서비스 계층 및 성능 수준 범위에서 실행 되는 Azure SQL 데이터베이스의 상대 성능을 측정 합니다.</span><span class="sxs-lookup"><span data-stu-id="3679b-260">hello Azure SQL Database Benchmark measures hello relative performance of Azure SQL Database running across hello range of available service tiers and performance levels.</span></span> <span data-ttu-id="3679b-261">hello는 온라인 트랜잭션 처리 (OLTP) 워크 로드에서에서 가장 자주 발생 하는 기본적인 데이터베이스 작업 조합을 수행 합니다.</span><span class="sxs-lookup"><span data-stu-id="3679b-261">hello benchmark exercises a mix of basic database operations which occur most frequently in online transaction processing (OLTP) workloads.</span></span> <span data-ttu-id="3679b-262">Hello 벤치 마크가만 CPU 속도, 메모리 크기 및 IOPS 등 각 수준에서 제공 하는 hello 리소스를 나열 하 여 hello 성능 수준 변경이 처리량에 대 한 보다 의미 있는 hello 영향을 평가 하는 제공 실제 성능을 측정 하므로 .</span><span class="sxs-lookup"><span data-stu-id="3679b-262">By measuring actual performance, hello benchmark provides a more meaningful assessment of hello impact on throughput of changing hello performance level than is possible by just listing hello resources provided by each level such as CPU speed, memory size, and IOPS.</span></span> <span data-ttu-id="3679b-263">Hello 이후에서 계속 tooevolve hello 벤치 마크 toobroaden 해당 범위 하 고 제공 된 hello 데이터를 확장 합니다.</span><span class="sxs-lookup"><span data-stu-id="3679b-263">In hello future, we will continue tooevolve hello benchmark toobroaden its scope and expand hello data provided.</span></span>

## <a name="resources"></a><span data-ttu-id="3679b-264">리소스</span><span class="sxs-lookup"><span data-stu-id="3679b-264">Resources</span></span>
[<span data-ttu-id="3679b-265">소개 tooSQL 데이터베이스</span><span class="sxs-lookup"><span data-stu-id="3679b-265">Introduction tooSQL Database</span></span>](sql-database-technical-overview.md)

[<span data-ttu-id="3679b-266">서비스 계층 및 성능 수준</span><span class="sxs-lookup"><span data-stu-id="3679b-266">Service tiers and performance levels</span></span>](sql-database-service-tiers.md)

[<span data-ttu-id="3679b-267">단일 데이터베이스의 성능 지침</span><span class="sxs-lookup"><span data-stu-id="3679b-267">Performance guidance for single databases</span></span>](sql-database-performance-guidance.md)
