---
title: "Azure SQL 데이터베이스 벤치마크 개요"
description: "이 항목은 Azure SQL 데이터베이스의 성능 측정에 사용된 Azure SQL 데이터베이스 벤치마크에 대해 설명합니다."
services: sql-database
documentationcenter: na
author: jan-eng
manager: jhubbard
editor: monicar
ms.assetid: e26f8a66-2c12-49d7-8297-45b4d48a5c01
ms.service: sql-database
ms.custom: DBs & servers
ms.devlang: na
ms.topic: article
ms.tgt_pltfrm: na
ms.workload: data-management
ms.date: 06/21/2016
ms.author: janeng
ms.openlocfilehash: 57178352e0a402f3559c94ce25f125dcbefd1374
ms.sourcegitcommit: f537befafb079256fba0529ee554c034d73f36b0
ms.translationtype: MT
ms.contentlocale: ko-KR
ms.lasthandoff: 07/11/2017
---
# <a name="azure-sql-database-benchmark-overview"></a><span data-ttu-id="c1f0e-103">Azure SQL 데이터베이스 벤치마크 개요</span><span class="sxs-lookup"><span data-stu-id="c1f0e-103">Azure SQL Database benchmark overview</span></span>
## <a name="overview"></a><span data-ttu-id="c1f0e-104">개요</span><span class="sxs-lookup"><span data-stu-id="c1f0e-104">Overview</span></span>
<span data-ttu-id="c1f0e-105">Microsoft Azure SQL 데이터베이스는 여러 성능 수준의 3가지 [서비스 계층](sql-database-service-tiers.md) 을 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="c1f0e-105">Microsoft Azure SQL Database offers three [service tiers](sql-database-service-tiers.md) with multiple performance levels.</span></span> <span data-ttu-id="c1f0e-106">각 성능 수준은 증가된 리소스 집합 또는 더욱 높은 처리량을 제공하도록 설계된 '성능'을 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="c1f0e-106">Each performance level provides an increasing set of resources, or ‘power’, designed to deliver increasingly higher throughput.</span></span>

<span data-ttu-id="c1f0e-107">각 성능 수준별 증가된 성능으로 데이터베이스 성능이 얼마나 증가되는지 수량화하는 것이 중요합니다.</span><span class="sxs-lookup"><span data-stu-id="c1f0e-107">It is important to be able to quantify how the increasing power of each performance level translates into increased database performance.</span></span> <span data-ttu-id="c1f0e-108">이를 위해 Microsoft는 ASDB(Azure SQL Database Benchmark)를 개발했습니다.</span><span class="sxs-lookup"><span data-stu-id="c1f0e-108">To do this Microsoft has developed the Azure SQL Database Benchmark (ASDB).</span></span> <span data-ttu-id="c1f0e-109">벤치마크는 모든 OLTP 워크로드에서 찾을 수 있는 혼합된 기본 작업을 실행합니다.</span><span class="sxs-lookup"><span data-stu-id="c1f0e-109">The benchmark exercises a mix of basic operations found in all OLTP workloads.</span></span> <span data-ttu-id="c1f0e-110">Microsoft는 각 성능 수준에서 실행되는 데이터베이스에 대해 달성된 처리량을 측정합니다.</span><span class="sxs-lookup"><span data-stu-id="c1f0e-110">We measure the throughput achieved for databases running in each performance level.</span></span>

<span data-ttu-id="c1f0e-111">각 서비스 계층의 리소스 및 파워, 성능 수준은 [데이터베이스 트랜잭션 단위(DTU)](sql-database-what-is-a-dtu.md)로 나타냅니다.</span><span class="sxs-lookup"><span data-stu-id="c1f0e-111">The resources and power of each service tier and performance level are expressed in terms of [Database Transaction Units (DTUs)](sql-database-what-is-a-dtu.md).</span></span> <span data-ttu-id="c1f0e-112">DTU는 각 성능 수준에서 제공하는 읽기/쓰기 속도, 메모리, CPU의 혼합 측정치를 기준으로 성능 수준의 상대적 용량을 설명하는 방법을 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="c1f0e-112">DTUs provide a way to describe the relative capacity of a performance level based on a blended measure of CPU, memory, and read and write rates offered by each performance level.</span></span> <span data-ttu-id="c1f0e-113">데이터베이스의 DTU 등급을 두 배로 높일 경우 데이터베이스 성능이 두 배 증가하는 것과 같습니다.</span><span class="sxs-lookup"><span data-stu-id="c1f0e-113">Doubling the DTU rating of a database equates to doubling the database power.</span></span> <span data-ttu-id="c1f0e-114">이 벤치마크를 사용하면 데이터베이스에 제공된 리소스와 비례하여 데이터베이스 크기, 사용자 수, 트랜잭션 속도를 조정하는 동시에, 실제 데이터 작업을 실행하여 각 성능 수준에서 제공하는 성능을 향상시킬 경우 데이터베이스 성능에 어떤 영향을 미치는지 평가할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="c1f0e-114">The benchmark allows us to assess the impact on database performance of the increasing power offered by each performance level by exercising actual database operations, while scaling database size, number of users, and transaction rates in proportion to the resources provided to the database.</span></span>

<span data-ttu-id="c1f0e-115">시간단 트랜잭션 수를 사용하는 Basic 서비스 계층, 분당 트랜잭션 수를 사용하는 Standard 서비스 계층, 초당 트랜잭션 수를 사용하는 Premium 서비스 계층으로 처리량을 표현함으로써 각 서비스 계층의 성능 잠재력과 응용 프로그램의 요구 사항 간 관계를 쉽고 빠르게 파악할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="c1f0e-115">By expressing the throughput of the Basic service tier using transactions per-hour, the Standard service tier using transactions per-minute, and the Premium service tier using transactions per-second, it makes it easier to quickly relate the performance potential of each service tier to the requirements of an application.</span></span>

## <a name="correlating-benchmark-results-to-real-world-database-performance"></a><span data-ttu-id="c1f0e-116">벤치마크 결과와 실제 데이터베이스 성능 간 상관 관계 분석</span><span class="sxs-lookup"><span data-stu-id="c1f0e-116">Correlating benchmark results to real world database performance</span></span>
<span data-ttu-id="c1f0e-117">ASDB는 모든 벤치마크와 마찬가지로 대표적, 암시적 수치임을 이해하는 것이 중요합니다.</span><span class="sxs-lookup"><span data-stu-id="c1f0e-117">It is important to understand that ASDB, like all benchmarks, is representative and indicative only.</span></span> <span data-ttu-id="c1f0e-118">벤치마크 응용 프로그램에서 달성한 트랜잭션 속도는 다른 응용 프로그램에서 달성할 수 있는 속도와 동일하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="c1f0e-118">The transaction rates achieved with the benchmark application will not be the same as those that might be achieved with other applications.</span></span> <span data-ttu-id="c1f0e-119">벤치마크는 다양한 테이블 및 데이터 유형이 포함된 스키마에 대해 실행되는 다양한 트랜잭션 유형의 컬렉션으로 구성되어 있습니다.</span><span class="sxs-lookup"><span data-stu-id="c1f0e-119">The benchmark comprises a collection of different transaction types run against a schema containing a range of tables and data types.</span></span> <span data-ttu-id="c1f0e-120">벤치마크는 모든 OLTP 워크로드에 공통적이고 동일한 기본 작업을 실행하며 특정 클래스의 데이터베이스 또는 응용 프로그램을 나타내지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="c1f0e-120">While the benchmark exercises the same basic operations that are common to all OLTP workloads, it does not represent any specific class of database or application.</span></span> <span data-ttu-id="c1f0e-121">벤치마크의 목표는 성능 수준 사이에서 확장 또는 축소할 경우 예상할 수 있는 데이터베이스의 상대적 성능에 대한 합리적 지침을 제공하는 것입니다.</span><span class="sxs-lookup"><span data-stu-id="c1f0e-121">The goal of the benchmark is to provide a reasonable guide to the relative performance of a database that might be expected when scaling up or down between performance levels.</span></span> <span data-ttu-id="c1f0e-122">실제로, 각 데이터베이스는 크기와 복잡성이 다르고 다양하게 혼합된 워크로드를 처리할 수 있으며 각각 다른 방식으로 대응합니다.</span><span class="sxs-lookup"><span data-stu-id="c1f0e-122">In reality, databases are of different sizes and complexity, encounter different mixes of workloads, and will respond in different ways.</span></span> <span data-ttu-id="c1f0e-123">예를 들어, IO를 많이 사용하는 응용 프로그램은 IO 임계값에 빠르게 도달할 수 있고 CPU를 많이 사용하는 응용 프로그램은 CPU 한도에 빠르게 도달할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="c1f0e-123">For example, an IO-intensive application may hit IO thresholds sooner, or a CPU-intensive application may hit CPU limits sooner.</span></span> <span data-ttu-id="c1f0e-124">부하가 증가할 때 특정 데이터베이스가 벤치마크와 동일하게 확장된다는 보장이 없습니다.</span><span class="sxs-lookup"><span data-stu-id="c1f0e-124">There is no guarantee that any particular database will scale in the same way as the benchmark under increasing load.</span></span>

<span data-ttu-id="c1f0e-125">벤치마크와 그 방법론은 아래에서 더 자세히 설명합니다.</span><span class="sxs-lookup"><span data-stu-id="c1f0e-125">The benchmark and its methodology are described in more detail below.</span></span>

## <a name="benchmark-summary"></a><span data-ttu-id="c1f0e-126">벤치마크 요약</span><span class="sxs-lookup"><span data-stu-id="c1f0e-126">Benchmark summary</span></span>
<span data-ttu-id="c1f0e-127">ASDB는 OLTP(온라인 트랜잭션 처리) 워크로드에서 가장 빈번하게 발생하는 기본 데이터베이스 작업의 성능을 측정합니다.</span><span class="sxs-lookup"><span data-stu-id="c1f0e-127">ASDB measures the performance of a mix of basic database operations which occur most frequently in online transaction processing (OLTP) workloads.</span></span> <span data-ttu-id="c1f0e-128">클라우드 컴퓨팅을 예상하고 벤치마크를 설계했지만, 데이터베이스 스키마, 데이터 채우기, 트랜잭션은 OLTP 워크로드에서 가장 일반적으로 사용되는 기본 요소를 광범위하게 나타내도록 설계되었습니다.</span><span class="sxs-lookup"><span data-stu-id="c1f0e-128">Although the benchmark is designed with cloud computing in mind, the database schema, data population, and transactions have been designed to be broadly representative of the basic elements most commonly used in OLTP workloads.</span></span>

## <a name="schema"></a><span data-ttu-id="c1f0e-129">스키마</span><span class="sxs-lookup"><span data-stu-id="c1f0e-129">Schema</span></span>
<span data-ttu-id="c1f0e-130">스키마는 다양한 작업을 지원하도록 다양하고 복잡하게 설계되었습니다.</span><span class="sxs-lookup"><span data-stu-id="c1f0e-130">The schema is designed to have enough variety and complexity to support a broad range of operations.</span></span> <span data-ttu-id="c1f0e-131">벤치마크는 6개의 테이블로 구성된 데이터베이스에 실행합니다.</span><span class="sxs-lookup"><span data-stu-id="c1f0e-131">The benchmark runs against a database comprised of six tables.</span></span> <span data-ttu-id="c1f0e-132">테이블은 고정 크기, 확장, 증가의 세 범주로 구분됩니다.</span><span class="sxs-lookup"><span data-stu-id="c1f0e-132">The tables fall into three categories: fixed-size, scaling, and growing.</span></span> <span data-ttu-id="c1f0e-133">2개의 고정 크기 테이블, 3개의 확장 테이블, 1개의 증가 테이블이 있습니다.</span><span class="sxs-lookup"><span data-stu-id="c1f0e-133">There are two fixed-size tables; three scaling tables; and one growing table.</span></span> <span data-ttu-id="c1f0e-134">고정 크기 테이블에는 고정된 수의 행이 있습니다.</span><span class="sxs-lookup"><span data-stu-id="c1f0e-134">Fixed-size tables have a constant number of rows.</span></span> <span data-ttu-id="c1f0e-135">확장 테이블에는 데이터베이스 성능에 비례하는 카디널리티가 있지만 벤치마크 중에는 변경되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="c1f0e-135">Scaling tables have a cardinality that is proportional to database performance, but doesn’t change during the benchmark.</span></span> <span data-ttu-id="c1f0e-136">증가 테이블은 초기 로드 시 확장 테이블과 같은 크기이지만, 행을 삽입 및 증가하면서 벤치마크를 실행하는 동안 카디널리티가 변경됩니다.</span><span class="sxs-lookup"><span data-stu-id="c1f0e-136">The growing table is sized like a scaling table on initial load, but then the cardinality changes in the course of running the benchmark as rows are inserted and deleted.</span></span>

<span data-ttu-id="c1f0e-137">스키마에는 정수, 숫자, 문자, 날짜/시간 등 혼합된 데이터 유형이 포함되어 있습니다.</span><span class="sxs-lookup"><span data-stu-id="c1f0e-137">The schema includes a mix of data types, including integer, numeric, character, and date/time.</span></span> <span data-ttu-id="c1f0e-138">스키마에는 기본 및 보조 키가 포함되어 있지만 외부 키가 없습니다. 즉, 테이블 간 참조 무결성 제약 조건이 없습니다.</span><span class="sxs-lookup"><span data-stu-id="c1f0e-138">The schema includes primary and secondary keys, but not any foreign keys - that is, there are no referential integrity constraints between tables.</span></span>

<span data-ttu-id="c1f0e-139">데이터 생성 프로그램은 초기 데이터베이스의 데이터를 생성합니다.</span><span class="sxs-lookup"><span data-stu-id="c1f0e-139">A data generation program generates the data for the initial database.</span></span> <span data-ttu-id="c1f0e-140">정수 및 숫자 데이터는 다양한 전략으로 생성됩니다.</span><span class="sxs-lookup"><span data-stu-id="c1f0e-140">Integer and numeric data is generated with various strategies.</span></span> <span data-ttu-id="c1f0e-141">값이 범위에 무작위로 분포되는 경우도 있습니다.</span><span class="sxs-lookup"><span data-stu-id="c1f0e-141">In some cases, values are distributed randomly over a range.</span></span> <span data-ttu-id="c1f0e-142">또한 특정 분포를 유지하기 위해 값 집합을 무작위로 변경하는 경우도 있습니다.</span><span class="sxs-lookup"><span data-stu-id="c1f0e-142">In other cases, a set of values is randomly permuted to ensure that a specific distribution is maintained.</span></span> <span data-ttu-id="c1f0e-143">가중치를 적용한 단어 목록에서 텍스트 필드를 생성하여 현실적 데이터를 만듭니다.</span><span class="sxs-lookup"><span data-stu-id="c1f0e-143">Text fields are generated from a weighted list of words to produce realistic looking data.</span></span>

<span data-ttu-id="c1f0e-144">데이터베이스는 "배율"을 기준으로 크기를 조정합니다.</span><span class="sxs-lookup"><span data-stu-id="c1f0e-144">The database is sized based on a “scale factor.”</span></span> <span data-ttu-id="c1f0e-145">배율(약어: SF)은 확장 및 증가 테이블의 카디널리티를 결정합니다.</span><span class="sxs-lookup"><span data-stu-id="c1f0e-145">The scale factor (abbreviated as SF) determines the cardinality of the scaling and growing tables.</span></span> <span data-ttu-id="c1f0e-146">아래의 사용자 및 속도 섹션에 설명된 대로 데이터베이스 크기, 사용자 수, 최대 성능은 모두 서로에 비례하여 확장됩니다.</span><span class="sxs-lookup"><span data-stu-id="c1f0e-146">As described below in the section Users and Pacing, the database size, number of users, and maximum performance all scale in proportion to each other.</span></span>

## <a name="transactions"></a><span data-ttu-id="c1f0e-147">트랜잭션</span><span class="sxs-lookup"><span data-stu-id="c1f0e-147">Transactions</span></span>
<span data-ttu-id="c1f0e-148">워크로드는 아래 표와 같이 9가지 트랜잭션 유형으로 구성되어 있습니다.</span><span class="sxs-lookup"><span data-stu-id="c1f0e-148">The workload consists of nine transaction types, as shown in the table below.</span></span> <span data-ttu-id="c1f0e-149">각 트랜잭션은 다른 트랜잭션과 크게 대비되도록 데이터베이스 엔진 및 시스템 하드웨어에서 특정 시스템 집합의 특성을 강조하도록 설계되었습니다.</span><span class="sxs-lookup"><span data-stu-id="c1f0e-149">Each transaction is designed to highlight a particular set of system characteristics in the database engine and system hardware, with high contrast from the other transactions.</span></span> <span data-ttu-id="c1f0e-150">이 방식에서는 다양한 구성 요소가 전반적 성능에 미치는 영향을 쉽게 평가할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="c1f0e-150">This approach makes it easier to assess the impact of different components to overall performance.</span></span> <span data-ttu-id="c1f0e-151">예를 들어 "읽기 작업이 많은" 트랜잭션은 디스크에서 많은 읽기 작업을 만듭니다.</span><span class="sxs-lookup"><span data-stu-id="c1f0e-151">For example, the transaction “Read Heavy” produces a significant number of read operations from disk.</span></span>

| <span data-ttu-id="c1f0e-152">트랜잭션 유형</span><span class="sxs-lookup"><span data-stu-id="c1f0e-152">Transaction Type</span></span> | <span data-ttu-id="c1f0e-153">설명</span><span class="sxs-lookup"><span data-stu-id="c1f0e-153">Description</span></span> |
| --- | --- |
| <span data-ttu-id="c1f0e-154">적은 읽기 작업</span><span class="sxs-lookup"><span data-stu-id="c1f0e-154">Read Lite</span></span> |<span data-ttu-id="c1f0e-155">SELECT, 메모리 내, 읽기 전용</span><span class="sxs-lookup"><span data-stu-id="c1f0e-155">SELECT; in-memory; read-only</span></span> |
| <span data-ttu-id="c1f0e-156">중간 읽기 작업</span><span class="sxs-lookup"><span data-stu-id="c1f0e-156">Read Medium</span></span> |<span data-ttu-id="c1f0e-157">SELECT, 대부분 메모리 내, 읽기 전용</span><span class="sxs-lookup"><span data-stu-id="c1f0e-157">SELECT; mostly in-memory; read-only</span></span> |
| <span data-ttu-id="c1f0e-158">많은 읽기 작업</span><span class="sxs-lookup"><span data-stu-id="c1f0e-158">Read Heavy</span></span> |<span data-ttu-id="c1f0e-159">SELECT, 대부분 메모리 외, 읽기 전용</span><span class="sxs-lookup"><span data-stu-id="c1f0e-159">SELECT; mostly not in-memory; read-only</span></span> |
| <span data-ttu-id="c1f0e-160">적은 업데이트 작업</span><span class="sxs-lookup"><span data-stu-id="c1f0e-160">Update Lite</span></span> |<span data-ttu-id="c1f0e-161">UPDATE, 메모리 내, 읽기-쓰기</span><span class="sxs-lookup"><span data-stu-id="c1f0e-161">UPDATE; in-memory; read-write</span></span> |
| <span data-ttu-id="c1f0e-162">많은 업데이트 작업</span><span class="sxs-lookup"><span data-stu-id="c1f0e-162">Update Heavy</span></span> |<span data-ttu-id="c1f0e-163">UPDATE, 대부분 메모리 외, 읽기-쓰기</span><span class="sxs-lookup"><span data-stu-id="c1f0e-163">UPDATE; mostly not in-memory; read-write</span></span> |
| <span data-ttu-id="c1f0e-164">적은 삽입 작업</span><span class="sxs-lookup"><span data-stu-id="c1f0e-164">Insert Lite</span></span> |<span data-ttu-id="c1f0e-165">INSERT, 메모리 내, 읽기-쓰기</span><span class="sxs-lookup"><span data-stu-id="c1f0e-165">INSERT; in-memory; read-write</span></span> |
| <span data-ttu-id="c1f0e-166">많은 삽입 작업</span><span class="sxs-lookup"><span data-stu-id="c1f0e-166">Insert Heavy</span></span> |<span data-ttu-id="c1f0e-167">INSERT, 대부분 메모리 외, 읽기-쓰기</span><span class="sxs-lookup"><span data-stu-id="c1f0e-167">INSERT; mostly not in-memory; read-write</span></span> |
| <span data-ttu-id="c1f0e-168">삭제</span><span class="sxs-lookup"><span data-stu-id="c1f0e-168">Delete</span></span> |<span data-ttu-id="c1f0e-169">DELETE, 메모리 내 및 메모리 외 혼합, 읽기-쓰기</span><span class="sxs-lookup"><span data-stu-id="c1f0e-169">DELETE; mix of in-memory and not in-memory; read-write</span></span> |
| <span data-ttu-id="c1f0e-170">많은 CPU 사용</span><span class="sxs-lookup"><span data-stu-id="c1f0e-170">CPU Heavy</span></span> |<span data-ttu-id="c1f0e-171">SELECT, 메모리 내, 상대적으로 많은 CPU 부하, 읽기 전용</span><span class="sxs-lookup"><span data-stu-id="c1f0e-171">SELECT; in-memory; relatively heavy CPU load; read-only</span></span> |

## <a name="workload-mix"></a><span data-ttu-id="c1f0e-172">워크로드 혼합</span><span class="sxs-lookup"><span data-stu-id="c1f0e-172">Workload mix</span></span>
<span data-ttu-id="c1f0e-173">가중치를 적용한 분포에서 다음과 같은 전반적 혼합을 적용하여 무작위로 트랜잭션을 선택합니다.</span><span class="sxs-lookup"><span data-stu-id="c1f0e-173">Transactions are selected at random from a weighted distribution with the following overall mix.</span></span> <span data-ttu-id="c1f0e-174">전반적 혼합은 읽기/쓰기 비율이 약 2:1입니다.</span><span class="sxs-lookup"><span data-stu-id="c1f0e-174">The overall mix has a read/write ratio of approximately 2:1.</span></span>

| <span data-ttu-id="c1f0e-175">트랜잭션 유형</span><span class="sxs-lookup"><span data-stu-id="c1f0e-175">Transaction Type</span></span> | <span data-ttu-id="c1f0e-176">혼합 비율</span><span class="sxs-lookup"><span data-stu-id="c1f0e-176">% of Mix</span></span> |
| --- | --- |
| <span data-ttu-id="c1f0e-177">적은 읽기 작업</span><span class="sxs-lookup"><span data-stu-id="c1f0e-177">Read Lite</span></span> |<span data-ttu-id="c1f0e-178">35</span><span class="sxs-lookup"><span data-stu-id="c1f0e-178">35</span></span> |
| <span data-ttu-id="c1f0e-179">중간 읽기 작업</span><span class="sxs-lookup"><span data-stu-id="c1f0e-179">Read Medium</span></span> |<span data-ttu-id="c1f0e-180">20</span><span class="sxs-lookup"><span data-stu-id="c1f0e-180">20</span></span> |
| <span data-ttu-id="c1f0e-181">많은 읽기 작업</span><span class="sxs-lookup"><span data-stu-id="c1f0e-181">Read Heavy</span></span> |<span data-ttu-id="c1f0e-182">5</span><span class="sxs-lookup"><span data-stu-id="c1f0e-182">5</span></span> |
| <span data-ttu-id="c1f0e-183">적은 업데이트 작업</span><span class="sxs-lookup"><span data-stu-id="c1f0e-183">Update Lite</span></span> |<span data-ttu-id="c1f0e-184">20</span><span class="sxs-lookup"><span data-stu-id="c1f0e-184">20</span></span> |
| <span data-ttu-id="c1f0e-185">많은 업데이트 작업</span><span class="sxs-lookup"><span data-stu-id="c1f0e-185">Update Heavy</span></span> |<span data-ttu-id="c1f0e-186">3</span><span class="sxs-lookup"><span data-stu-id="c1f0e-186">3</span></span> |
| <span data-ttu-id="c1f0e-187">적은 삽입 작업</span><span class="sxs-lookup"><span data-stu-id="c1f0e-187">Insert Lite</span></span> |<span data-ttu-id="c1f0e-188">3</span><span class="sxs-lookup"><span data-stu-id="c1f0e-188">3</span></span> |
| <span data-ttu-id="c1f0e-189">많은 삽입 작업</span><span class="sxs-lookup"><span data-stu-id="c1f0e-189">Insert Heavy</span></span> |<span data-ttu-id="c1f0e-190">2</span><span class="sxs-lookup"><span data-stu-id="c1f0e-190">2</span></span> |
| <span data-ttu-id="c1f0e-191">삭제</span><span class="sxs-lookup"><span data-stu-id="c1f0e-191">Delete</span></span> |<span data-ttu-id="c1f0e-192">2</span><span class="sxs-lookup"><span data-stu-id="c1f0e-192">2</span></span> |
| <span data-ttu-id="c1f0e-193">많은 CPU 사용</span><span class="sxs-lookup"><span data-stu-id="c1f0e-193">CPU Heavy</span></span> |<span data-ttu-id="c1f0e-194">10</span><span class="sxs-lookup"><span data-stu-id="c1f0e-194">10</span></span> |

## <a name="users-and-pacing"></a><span data-ttu-id="c1f0e-195">사용자 및 속도</span><span class="sxs-lookup"><span data-stu-id="c1f0e-195">Users and pacing</span></span>
<span data-ttu-id="c1f0e-196">벤치마크 워크로드는 연결 집합에 트랜잭션을 제출하는 도구를 기반으로 많은 동시 사용자의 동작을 시뮬레이션합니다.</span><span class="sxs-lookup"><span data-stu-id="c1f0e-196">The benchmark workload is driven from a tool that submits transactions across a set of connections to simulate the behavior of a number of concurrent users.</span></span> <span data-ttu-id="c1f0e-197">모든 연결과 트랜잭션이 시스템에서 생성된 것이지만, 간단히 이러한 연결을 "사용자"로 지칭합니다.</span><span class="sxs-lookup"><span data-stu-id="c1f0e-197">Although all of the connections and transactions are machine generated, for simplicity we refer to these connections as “users.”</span></span> <span data-ttu-id="c1f0e-198">각 사용자는 나머지 사용자와 독립적으로 운영하지만, 모든 사용자는 아래와 같이 동일한 단계의 주기를 수행합니다.</span><span class="sxs-lookup"><span data-stu-id="c1f0e-198">Although each user operates independently of all other users, all users perform the same cycle of steps shown below:</span></span>

1. <span data-ttu-id="c1f0e-199">데이터베이스에 연결합니다.</span><span class="sxs-lookup"><span data-stu-id="c1f0e-199">Establish a database connection.</span></span>
2. <span data-ttu-id="c1f0e-200">끝내라는 메시지가 표시될 때까지 계속 반복합니다.</span><span class="sxs-lookup"><span data-stu-id="c1f0e-200">Repeat until signaled to exit:</span></span>
   * <span data-ttu-id="c1f0e-201">(가중치가 적용된 분포에서) 무작위로 트랜잭션을 선택합니다.</span><span class="sxs-lookup"><span data-stu-id="c1f0e-201">Select a transaction at random (from a weighted distribution).</span></span>
   * <span data-ttu-id="c1f0e-202">선택한 트랜잭션을 수행하고 응답 시간을 측정합니다.</span><span class="sxs-lookup"><span data-stu-id="c1f0e-202">Perform the selected transaction and measure the response time.</span></span>
   * <span data-ttu-id="c1f0e-203">속도 지연을 기다립니다.</span><span class="sxs-lookup"><span data-stu-id="c1f0e-203">Wait for a pacing delay.</span></span>
3. <span data-ttu-id="c1f0e-204">데이터베이스 연결을 종료합니다.</span><span class="sxs-lookup"><span data-stu-id="c1f0e-204">Close the database connection.</span></span>
4. <span data-ttu-id="c1f0e-205">끝내기를 클릭합니다.</span><span class="sxs-lookup"><span data-stu-id="c1f0e-205">Exit.</span></span>

<span data-ttu-id="c1f0e-206">(2c 단계에서) 무작위이지만 평균 1.0초의 분포가 있는 속도 지연을 선택합니다.</span><span class="sxs-lookup"><span data-stu-id="c1f0e-206">The pacing delay (in step 2c) is selected at random, but with a distribution that has an average of 1.0 second.</span></span> <span data-ttu-id="c1f0e-207">따라서 각 사용자는 평균적으로 1초당 최대 1개의 트랜잭션을 생성할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="c1f0e-207">Thus each user can, on average, generate at most one transaction per second.</span></span>

## <a name="scaling-rules"></a><span data-ttu-id="c1f0e-208">확장 규칙</span><span class="sxs-lookup"><span data-stu-id="c1f0e-208">Scaling rules</span></span>
<span data-ttu-id="c1f0e-209">사용자 수는 데이터베이스 크기로 결정됩니다(배율 단위).</span><span class="sxs-lookup"><span data-stu-id="c1f0e-209">The number of users is determined by the database size (in scale-factor units).</span></span> <span data-ttu-id="c1f0e-210">5개의 배율 단위당 1명의 사용자가 있습니다.</span><span class="sxs-lookup"><span data-stu-id="c1f0e-210">There is one user for every five scale-factor units.</span></span> <span data-ttu-id="c1f0e-211">속도 지연으로 인해 1명의 사용자는 평균적으로 초당 최대 1개의 트랜잭션을 생성할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="c1f0e-211">Because of the pacing delay, one user can generate at most one transaction per second, on average.</span></span>

<span data-ttu-id="c1f0e-212">예를 들어, 배율이 500(SF=500)인 데이터베이스는 사용자가 100명이며 최대 100TPS의 속도를 달성할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="c1f0e-212">For example, a scale-factor of 500 (SF=500) database will have 100 users and can achieve a maximum rate of 100 TPS.</span></span> <span data-ttu-id="c1f0e-213">TPS 속도를 높이려면 더 많은 사용자와 더 큰 데이터베이스가 필요합니다.</span><span class="sxs-lookup"><span data-stu-id="c1f0e-213">To drive a higher TPS rate requires more users and a larger database.</span></span>

<span data-ttu-id="c1f0e-214">아래 표는 각 서비스 계층 및 성능 수준에서 실제로 유지된 사용자 수를 보여줍니다.</span><span class="sxs-lookup"><span data-stu-id="c1f0e-214">The table below shows the number of users actually sustained for each service tier and performance level.</span></span>

| <span data-ttu-id="c1f0e-215">서비스 계층(성능 수준)</span><span class="sxs-lookup"><span data-stu-id="c1f0e-215">Service Tier (Performance Level)</span></span> | <span data-ttu-id="c1f0e-216">사용자</span><span class="sxs-lookup"><span data-stu-id="c1f0e-216">Users</span></span> | <span data-ttu-id="c1f0e-217">데이터베이스 크기</span><span class="sxs-lookup"><span data-stu-id="c1f0e-217">Database Size</span></span> |
| --- | --- | --- |
| <span data-ttu-id="c1f0e-218">Basic</span><span class="sxs-lookup"><span data-stu-id="c1f0e-218">Basic</span></span> |<span data-ttu-id="c1f0e-219">5</span><span class="sxs-lookup"><span data-stu-id="c1f0e-219">5</span></span> |<span data-ttu-id="c1f0e-220">720MB</span><span class="sxs-lookup"><span data-stu-id="c1f0e-220">720 MB</span></span> |
| <span data-ttu-id="c1f0e-221">Standard(S0)</span><span class="sxs-lookup"><span data-stu-id="c1f0e-221">Standard (S0)</span></span> |<span data-ttu-id="c1f0e-222">10</span><span class="sxs-lookup"><span data-stu-id="c1f0e-222">10</span></span> |<span data-ttu-id="c1f0e-223">1 GB</span><span class="sxs-lookup"><span data-stu-id="c1f0e-223">1 GB</span></span> |
| <span data-ttu-id="c1f0e-224">Standard(S1)</span><span class="sxs-lookup"><span data-stu-id="c1f0e-224">Standard (S1)</span></span> |<span data-ttu-id="c1f0e-225">20</span><span class="sxs-lookup"><span data-stu-id="c1f0e-225">20</span></span> |<span data-ttu-id="c1f0e-226">2.1GB</span><span class="sxs-lookup"><span data-stu-id="c1f0e-226">2.1 GB</span></span> |
| <span data-ttu-id="c1f0e-227">Standard(S2)</span><span class="sxs-lookup"><span data-stu-id="c1f0e-227">Standard (S2)</span></span> |<span data-ttu-id="c1f0e-228">50</span><span class="sxs-lookup"><span data-stu-id="c1f0e-228">50</span></span> |<span data-ttu-id="c1f0e-229">7.1GB</span><span class="sxs-lookup"><span data-stu-id="c1f0e-229">7.1 GB</span></span> |
| <span data-ttu-id="c1f0e-230">Premium(P1)</span><span class="sxs-lookup"><span data-stu-id="c1f0e-230">Premium (P1)</span></span> |<span data-ttu-id="c1f0e-231">100</span><span class="sxs-lookup"><span data-stu-id="c1f0e-231">100</span></span> |<span data-ttu-id="c1f0e-232">14 GB</span><span class="sxs-lookup"><span data-stu-id="c1f0e-232">14 GB</span></span> |
| <span data-ttu-id="c1f0e-233">Premium(P2)</span><span class="sxs-lookup"><span data-stu-id="c1f0e-233">Premium (P2)</span></span> |<span data-ttu-id="c1f0e-234">200</span><span class="sxs-lookup"><span data-stu-id="c1f0e-234">200</span></span> |<span data-ttu-id="c1f0e-235">28GB</span><span class="sxs-lookup"><span data-stu-id="c1f0e-235">28 GB</span></span> |
| <span data-ttu-id="c1f0e-236">Premium(P6/P3)</span><span class="sxs-lookup"><span data-stu-id="c1f0e-236">Premium (P6/P3)</span></span> |<span data-ttu-id="c1f0e-237">800</span><span class="sxs-lookup"><span data-stu-id="c1f0e-237">800</span></span> |<span data-ttu-id="c1f0e-238">114GB</span><span class="sxs-lookup"><span data-stu-id="c1f0e-238">114 GB</span></span> |

## <a name="measurement-duration"></a><span data-ttu-id="c1f0e-239">측정 기간</span><span class="sxs-lookup"><span data-stu-id="c1f0e-239">Measurement duration</span></span>
<span data-ttu-id="c1f0e-240">유효한 벤치마크를 실행하려면 한 시간 이상의 안정적 측정 기간이 필요합니다.</span><span class="sxs-lookup"><span data-stu-id="c1f0e-240">A valid benchmark run requires a steady-state measurement duration of at least one hour.</span></span>

## <a name="metrics"></a><span data-ttu-id="c1f0e-241">메트릭</span><span class="sxs-lookup"><span data-stu-id="c1f0e-241">Metrics</span></span>
<span data-ttu-id="c1f0e-242">벤치마크의 핵심 메트릭은 처리량과 응답 시간입니다.</span><span class="sxs-lookup"><span data-stu-id="c1f0e-242">The key metrics in the benchmark are throughput and response time.</span></span>

* <span data-ttu-id="c1f0e-243">처리량은 벤치마크의 필수 성능 측정값입니다.</span><span class="sxs-lookup"><span data-stu-id="c1f0e-243">Throughput is the essential performance measure in the benchmark.</span></span> <span data-ttu-id="c1f0e-244">처리량은 모든 트랜잭션 유형을 세는 단위 시간당 트랜잭션 수로 보고됩니다.</span><span class="sxs-lookup"><span data-stu-id="c1f0e-244">Throughput is reported in transactions per unit-of-time, counting all transaction types.</span></span>
* <span data-ttu-id="c1f0e-245">응답 시간은 성능 예측 가능성에 대한 측정값입니다.</span><span class="sxs-lookup"><span data-stu-id="c1f0e-245">Response time is a measure of performance predictability.</span></span> <span data-ttu-id="c1f0e-246">응답 시간 제약 조건은 서비스 클래스에 따라 달라지며, 다음과 같이 서비스 클래스가 높을수록 응답 시간 요구 사항이 더욱 까다로워집니다.</span><span class="sxs-lookup"><span data-stu-id="c1f0e-246">The response time constraint varies with class of service, with higher classes of service having a more stringent response time requirement, as shown below.</span></span>

| <span data-ttu-id="c1f0e-247">서비스 클래스</span><span class="sxs-lookup"><span data-stu-id="c1f0e-247">Class of Service</span></span> | <span data-ttu-id="c1f0e-248">처리량 측정</span><span class="sxs-lookup"><span data-stu-id="c1f0e-248">Throughput Measure</span></span> | <span data-ttu-id="c1f0e-249">응답 시간 요구 사항</span><span class="sxs-lookup"><span data-stu-id="c1f0e-249">Response Time Requirement</span></span> |
| --- | --- | --- |
| <span data-ttu-id="c1f0e-250">Premium</span><span class="sxs-lookup"><span data-stu-id="c1f0e-250">Premium</span></span> |<span data-ttu-id="c1f0e-251">초당 트랜잭션 수</span><span class="sxs-lookup"><span data-stu-id="c1f0e-251">Transactions per second</span></span> |<span data-ttu-id="c1f0e-252">0.5초에서 95 백분위수</span><span class="sxs-lookup"><span data-stu-id="c1f0e-252">95th percentile at 0.5 seconds</span></span> |
| <span data-ttu-id="c1f0e-253">Standard</span><span class="sxs-lookup"><span data-stu-id="c1f0e-253">Standard</span></span> |<span data-ttu-id="c1f0e-254">분당 트랜잭션 수</span><span class="sxs-lookup"><span data-stu-id="c1f0e-254">Transactions per minute</span></span> |<span data-ttu-id="c1f0e-255">1.0초에서 90 백분위수</span><span class="sxs-lookup"><span data-stu-id="c1f0e-255">90th percentile at 1.0 seconds</span></span> |
| <span data-ttu-id="c1f0e-256">Basic</span><span class="sxs-lookup"><span data-stu-id="c1f0e-256">Basic</span></span> |<span data-ttu-id="c1f0e-257">시간당 트랜잭션 수</span><span class="sxs-lookup"><span data-stu-id="c1f0e-257">Transactions per hour</span></span> |<span data-ttu-id="c1f0e-258">2.0초에서 80 백분위수</span><span class="sxs-lookup"><span data-stu-id="c1f0e-258">80th percentile at 2.0 seconds</span></span> |

## <a name="conclusion"></a><span data-ttu-id="c1f0e-259">결론</span><span class="sxs-lookup"><span data-stu-id="c1f0e-259">Conclusion</span></span>
<span data-ttu-id="c1f0e-260">Azure SQL 데이터베이스 벤치마크는 사용 가능한 다양한 서비스 계층과 성능 수준에서 실행되는 Azure SQL 데이터베이스의 상대적 성능을 측정합니다.</span><span class="sxs-lookup"><span data-stu-id="c1f0e-260">The Azure SQL Database Benchmark measures the relative performance of Azure SQL Database running across the range of available service tiers and performance levels.</span></span> <span data-ttu-id="c1f0e-261">벤치마크는 OLTP(온라인 트랜잭션 처리) 워크로드에서 가장 빈번하게 발생하는 기본 데이터베이스 작업의 혼합을 실행합니다.</span><span class="sxs-lookup"><span data-stu-id="c1f0e-261">The benchmark exercises a mix of basic database operations which occur most frequently in online transaction processing (OLTP) workloads.</span></span> <span data-ttu-id="c1f0e-262">벤치마크는 실제 성능을 측정함으로써, 각 수준에서 단순히 CPU 속도, 메모리 크기, IOPS와 같은 리소스를 나열하는 경우에 비해 성능 수준의 변화가 처리량에 미치는 영향을 더욱 의미 있는 평가를 제공할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="c1f0e-262">By measuring actual performance, the benchmark provides a more meaningful assessment of the impact on throughput of changing the performance level than is possible by just listing the resources provided by each level such as CPU speed, memory size, and IOPS.</span></span> <span data-ttu-id="c1f0e-263">Microsoft는 앞으로 계속해서 벤치마크의 범위를 넓히고 제공하는 데이터를 확대할 것입니다.</span><span class="sxs-lookup"><span data-stu-id="c1f0e-263">In the future, we will continue to evolve the benchmark to broaden its scope and expand the data provided.</span></span>

## <a name="resources"></a><span data-ttu-id="c1f0e-264">리소스</span><span class="sxs-lookup"><span data-stu-id="c1f0e-264">Resources</span></span>
[<span data-ttu-id="c1f0e-265">SQL 데이터베이스 소개</span><span class="sxs-lookup"><span data-stu-id="c1f0e-265">Introduction to SQL Database</span></span>](sql-database-technical-overview.md)

[<span data-ttu-id="c1f0e-266">서비스 계층 및 성능 수준</span><span class="sxs-lookup"><span data-stu-id="c1f0e-266">Service tiers and performance levels</span></span>](sql-database-service-tiers.md)

[<span data-ttu-id="c1f0e-267">단일 데이터베이스의 성능 지침</span><span class="sxs-lookup"><span data-stu-id="c1f0e-267">Performance guidance for single databases</span></span>](sql-database-performance-guidance.md)
