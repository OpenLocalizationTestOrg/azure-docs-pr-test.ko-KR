---
title: "Azure 웹앱에서 노드 응용 프로그램에 대한 모범 사례 및 문제 해결 가이드"
description: "Azure 웹앱에서 노드 응용 프로그램에 대한 모범 사례 및 문제 해결 단계에 대해 알아봅니다."
services: app-service\web
documentationcenter: nodejs
author: ranjithr
manager: wadeh
editor: 
ms.assetid: 387ea217-7910-4468-8987-9a1022a99bef
ms.service: app-service-web
ms.workload: web
ms.tgt_pltfrm: na
ms.devlang: nodejs
ms.topic: article
ms.date: 06/06/2016
ms.author: ranjithr
ms.openlocfilehash: d820ef3438e13332657641b06b57fa277e79f811
ms.sourcegitcommit: 18ad9bc049589c8e44ed277f8f43dcaa483f3339
ms.translationtype: MT
ms.contentlocale: ko-KR
ms.lasthandoff: 08/29/2017
---
# <a name="best-practices-and-troubleshooting-guide-for-node-applications-on-azure-web-apps"></a><span data-ttu-id="a359a-103">Azure 웹앱에서 노드 응용 프로그램에 대한 모범 사례 및 문제 해결 가이드</span><span class="sxs-lookup"><span data-stu-id="a359a-103">Best practices and troubleshooting guide for node applications on Azure Web Apps</span></span>
[!INCLUDE [tabs](../../includes/app-service-web-get-started-nav-tabs.md)]

<span data-ttu-id="a359a-104">이 문서에서는 Azure 웹앱에서 실행되는 [노드 응용 프로그램](app-service-web-get-started-nodejs.md) ([iisnode](https://github.com/azure/iisnode) 사용)에 대한 모범 사례 및 문제 해결 단계에 대해 배워봅니다.</span><span class="sxs-lookup"><span data-stu-id="a359a-104">In this article, you will learn the best practices and troubleshooting steps for [node applications](app-service-web-get-started-nodejs.md) running on Azure Webapps (with [iisnode](https://github.com/azure/iisnode)).</span></span>

> [!WARNING]
> <span data-ttu-id="a359a-105">프로덕션 사이트에서 문제 해결 단계를 사용할 때는 주의하세요.</span><span class="sxs-lookup"><span data-stu-id="a359a-105">Use caution when using troubleshooting steps on your production site.</span></span> <span data-ttu-id="a359a-106">비프로덕션 설정(예: 스테이징 슬롯)에서 앱의 문제를 해결하는 것이 좋으며 문제가 해결되면 스테이징 슬롯을 프로덕션 슬롯으로 교환하는 것이 좋습니다.</span><span class="sxs-lookup"><span data-stu-id="a359a-106">Recommendation is to troubleshoot your app on a non-production setup for example your staging slot and when the issue is fixed, swap your staging slot with your production slot.</span></span>
> 
> 

## <a name="iisnode-configuration"></a><span data-ttu-id="a359a-107">IISNODE 구성</span><span class="sxs-lookup"><span data-stu-id="a359a-107">IISNODE configuration</span></span>
<span data-ttu-id="a359a-108">이 [스키마 파일](https://github.com/Azure/iisnode/blob/master/src/config/iisnode_schema_x64.xml) 에서는 iisnode에 대해 구성할 수 있는 모든 설정을 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="a359a-108">This [schema file](https://github.com/Azure/iisnode/blob/master/src/config/iisnode_schema_x64.xml) shows all the settings that can be configured for iisnode.</span></span> <span data-ttu-id="a359a-109">응용 프로그램에 대해 유용할 일부 설정은 다음과 같습니다.</span><span class="sxs-lookup"><span data-stu-id="a359a-109">Some of the settings that will be useful for your application are:</span></span>

* <span data-ttu-id="a359a-110">nodeProcessCountPerApplication</span><span class="sxs-lookup"><span data-stu-id="a359a-110">nodeProcessCountPerApplication</span></span>
  
    <span data-ttu-id="a359a-111">이 설정은 IIS 응용프로그램마다 실행되는 노드 프로세스 수를 제어합니다.</span><span class="sxs-lookup"><span data-stu-id="a359a-111">This setting controls the number of node processes that are launched per IIS application.</span></span> <span data-ttu-id="a359a-112">기본값은 1입니다.</span><span class="sxs-lookup"><span data-stu-id="a359a-112">Default value is 1.</span></span> <span data-ttu-id="a359a-113">0으로 설정하면 VM 코어 개수 만큼 node.exe를 실행할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="a359a-113">You can launch as many node.exe’s as your VM core count by setting this to 0.</span></span> <span data-ttu-id="a359a-114">권장되는 값은 대부분의 응용 프로그램에서 0이므로 컴퓨터에서 모든 코어를 활용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="a359a-114">Recommended value is 0 for most application so you can utilize all of the cores on your machine.</span></span> <span data-ttu-id="a359a-115">Node.exe는 단일 스레드이므로 하나의 node.exe에서 최대 1개의 코어를 사용하며 노드 응용 프로그램에서 최대 성능을 얻기 위해 모든 코어를 활용하길 원합니다.</span><span class="sxs-lookup"><span data-stu-id="a359a-115">Node.exe is single threaded so one node.exe will consume a maximum of 1 core and to get maximum performance out of your node application you would want to utilize all cores.</span></span>
* <span data-ttu-id="a359a-116">nodeProcessCommandLine</span><span class="sxs-lookup"><span data-stu-id="a359a-116">nodeProcessCommandLine</span></span>
  
    <span data-ttu-id="a359a-117">이 설정은 node.exe에 대한 경로를 제어합니다.</span><span class="sxs-lookup"><span data-stu-id="a359a-117">This setting controls the path to the node.exe.</span></span> <span data-ttu-id="a359a-118">node.exe 버전을 가리키도록 이 값을 설정할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="a359a-118">You can set this value to point to your node.exe version.</span></span>
* <span data-ttu-id="a359a-119">maxConcurrentRequestsPerProcess</span><span class="sxs-lookup"><span data-stu-id="a359a-119">maxConcurrentRequestsPerProcess</span></span>
  
    <span data-ttu-id="a359a-120">이 설정은 iisnode에서 각 node.exe로 보내는 최대 동시 요청 수를 제어합니다.</span><span class="sxs-lookup"><span data-stu-id="a359a-120">This setting controls the maximum number of concurrent requests sent by iisnode to each node.exe.</span></span> <span data-ttu-id="a359a-121">azure 웹앱에서 기본값은 무한입니다.</span><span class="sxs-lookup"><span data-stu-id="a359a-121">On azure webapps, the default value for this is Infinite.</span></span> <span data-ttu-id="a359a-122">이 설정에 대해 걱정하지 않아도 됩니다.</span><span class="sxs-lookup"><span data-stu-id="a359a-122">You will not have to worry about this setting.</span></span> <span data-ttu-id="a359a-123">azure 웹앱 이외에서는 기본값이 1024입니다.</span><span class="sxs-lookup"><span data-stu-id="a359a-123">Outside azure webapps, the default value is 1024.</span></span> <span data-ttu-id="a359a-124">응용 프로그램이 받는 요청 수와 응용 프로그램이 각 요청을 처리하는 속도에 따라 이를 구성할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="a359a-124">You might want to configure this depending on how many requests your application gets and how fast your application processes each request.</span></span>
* <span data-ttu-id="a359a-125">maxNamedPipeConnectionRetry</span><span class="sxs-lookup"><span data-stu-id="a359a-125">maxNamedPipeConnectionRetry</span></span>
  
    <span data-ttu-id="a359a-126">이 설정은 요청을 node.exe에 전송하기 위해 iisnode에서 명명된 파이프에 연결을 재시도하는 최대 횟수를 제어합니다.</span><span class="sxs-lookup"><span data-stu-id="a359a-126">This setting controls the maximum number of times iisnode will retry making connection on the named pipe to send the request over to node.exe.</span></span> <span data-ttu-id="a359a-127">이 설정과 namedPipeConnectionRetryDelay를 조합하면 iisnode 내에서 각 요청의 총 시간 제한이 결정됩니다.</span><span class="sxs-lookup"><span data-stu-id="a359a-127">This setting in combination with namedPipeConnectionRetryDelay determines the total timeout of each request within iisnode.</span></span> <span data-ttu-id="a359a-128">azure 웹앱에서 기본값이 200입니다.</span><span class="sxs-lookup"><span data-stu-id="a359a-128">Default value is 200 on Azure Webapps.</span></span> <span data-ttu-id="a359a-129">총 시간 제한(초) = (maxNamedPipeConnectionRetry \* namedPipeConnectionRetryDelay) / 1000</span><span class="sxs-lookup"><span data-stu-id="a359a-129">Total Timeout in seconds = (maxNamedPipeConnectionRetry \* namedPipeConnectionRetryDelay) / 1000</span></span>
* <span data-ttu-id="a359a-130">namedPipeConnectionRetryDelay</span><span class="sxs-lookup"><span data-stu-id="a359a-130">namedPipeConnectionRetryDelay</span></span>
  
    <span data-ttu-id="a359a-131">이 설정은 명명된 파이프를 통해 node.exe로 요청을 전송하기 위해 iisnode가 각 재시도 간에 대기하는 시간(ms)을 제어합니다.</span><span class="sxs-lookup"><span data-stu-id="a359a-131">This setting controls the amount of time (in ms) iisnode will wait for between each retry to send request to node.exe over the named pipe.</span></span> <span data-ttu-id="a359a-132">기본값은 250ms입니다.</span><span class="sxs-lookup"><span data-stu-id="a359a-132">Default value is 250ms.</span></span>
    <span data-ttu-id="a359a-133">총 시간 제한(초) = (maxNamedPipeConnectionRetry \* namedPipeConnectionRetryDelay) / 1000</span><span class="sxs-lookup"><span data-stu-id="a359a-133">Total Timeout in seconds = (maxNamedPipeConnectionRetry \* namedPipeConnectionRetryDelay) / 1000</span></span>
  
    <span data-ttu-id="a359a-134">기본적으로 azure 웹앱의 iisnode에서 총 시간 제한은 200 \* 250ms = 50초입니다.</span><span class="sxs-lookup"><span data-stu-id="a359a-134">By default the total timeout in iisnode on azure webapps is 200 \* 250ms = 50 seconds.</span></span>
* <span data-ttu-id="a359a-135">logDirectory</span><span class="sxs-lookup"><span data-stu-id="a359a-135">logDirectory</span></span>
  
    <span data-ttu-id="a359a-136">이 설정은 iisnode에서 stdout/stderr를 로깅할 디렉터리를 제어합니다.</span><span class="sxs-lookup"><span data-stu-id="a359a-136">This setting controls the directory where iisnode will log stdout/stderr.</span></span> <span data-ttu-id="a359a-137">기본값은 주 스크립트 디렉터리(기본 server.js가 있는 디렉터리)를 기준으로 iisnode입니다.</span><span class="sxs-lookup"><span data-stu-id="a359a-137">Default value is iisnode which is relative to the main script directory (directory where main server.js is present)</span></span>
* <span data-ttu-id="a359a-138">debuggerExtensionDll</span><span class="sxs-lookup"><span data-stu-id="a359a-138">debuggerExtensionDll</span></span>
  
    <span data-ttu-id="a359a-139">이 설정은 노드 응용 프로그램을 디버깅할 때 node-inspector iisnode가 사용할 버전을 제어합니다.</span><span class="sxs-lookup"><span data-stu-id="a359a-139">This setting controls what version of node-inspector iisnode will use when debugging your node application.</span></span> <span data-ttu-id="a359a-140">현재 iisnode-inspector-0.7.3.dll 및 iisnode-inspector.dll은 이 설정에 대해 2가지 값만 유효합니다.</span><span class="sxs-lookup"><span data-stu-id="a359a-140">Currently iisnode-inspector-0.7.3.dll and iisnode-inspector.dll are the only 2 valid values for this setting.</span></span> <span data-ttu-id="a359a-141">기본값은 iisnode-inspector-0.7.3.dll입니다.</span><span class="sxs-lookup"><span data-stu-id="a359a-141">Default value is iisnode-inspector-0.7.3.dll.</span></span> <span data-ttu-id="a359a-142">iisnode-inspector-0.7.3.dll 버전에서는 node-inspector-0.7.3 및 WebSocket을 사용하므로 이 버전을 사용하려면 azure 웹앱에서 WebSocket을 사용하도록 설정해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="a359a-142">iisnode-inspector-0.7.3.dll version uses node-inspector-0.7.3 and uses websockets, so you will need to enable websockets on your azure webapp to use this version.</span></span> <span data-ttu-id="a359a-143">새 node-inspector를 사용하도록 iisnode를 구성하는 방법에 대한 자세한 내용은 <http://www.ranjithr.com/?p=98>을 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="a359a-143">See <http://www.ranjithr.com/?p=98> for more details on how to configure iisnode to use the new node-inspector.</span></span>
* <span data-ttu-id="a359a-144">flushResponse</span><span class="sxs-lookup"><span data-stu-id="a359a-144">flushResponse</span></span>
  
    <span data-ttu-id="a359a-145">IIS는 기본적으로 플러시하기 전에 또는 응답이 끝날 때까지 응답 데이터를 4MB까지 버퍼링합니다.</span><span class="sxs-lookup"><span data-stu-id="a359a-145">The default behavior of IIS is that it buffers response data up to 4MB before flushing, or until the end of the response, whichever comes first.</span></span> <span data-ttu-id="a359a-146">iisnode는 이 동작을 재정의하는 구성 설정을 제공합니다. iisnode가 node.exe에서 수신하는 즉시 응답 엔터티 본문의 일부를 플러시하려면 web.config에서 iisnode/@flushResponse 특성을 'true'로 설정해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="a359a-146">iisnode offers a configuration setting to override this behavior: to flush a fragment of the response entity body as soon as iisnode receives it from node.exe, you need to set the iisnode/@flushResponse attribute in web.config to 'true':</span></span>
  
    ```
    <configuration>    
        <system.webServer>    
            <!-- ... -->    
            <iisnode flushResponse="true" />    
        </system.webServer>    
    </configuration>
    ```
  
    <span data-ttu-id="a359a-147">응답 엔터티 본문의 모든 조각을 플러시하도록 설정하면 성능 오버헤드가 추가되어 시스템 처리량이 ~5%(v0.1.13 기준)까지 줄어들며 이 설정을 응답 스트리밍이 필요한 끝점으로만 국한하는 데 적합합니다(예: web.config에서 <location> 요소 사용).</span><span class="sxs-lookup"><span data-stu-id="a359a-147">Enabling flushing of every fragment of the response entity body adds performance overhead that reduces the throughput of the system by ~5% (as of v0.1.13), so it is best to scope this setting only to endpoints that require response streaming (e.g. using the <location> element in the web.config)</span></span>
  
    <span data-ttu-id="a359a-148">이 외에도 스트리밍 응용 프로그램의 경우 iisnode 처리기의 responseBufferLimit를 0으로 설정해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="a359a-148">In addition to this, for streaming applications, you will need to also set responseBufferLimit of your iisnode handler to 0.</span></span>
  
    ```
    <handlers>    
        <add name="iisnode" path="app.js" verb="\*" modules="iisnode" responseBufferLimit="0"/>    
    </handlers>
    ```
* <span data-ttu-id="a359a-149">watchedFiles</span><span class="sxs-lookup"><span data-stu-id="a359a-149">watchedFiles</span></span>
  
    <span data-ttu-id="a359a-150">변경 내용을 감시하는 세미콜론으로 구분된 파일 목록입니다.</span><span class="sxs-lookup"><span data-stu-id="a359a-150">This is a semi-colon separated list of files that will be watched for changes.</span></span> <span data-ttu-id="a359a-151">파일에 대한 변경 내용으로 인해 응용 프로그램 재활용이 발생합니다.</span><span class="sxs-lookup"><span data-stu-id="a359a-151">A change to a file causes the application to recycle.</span></span> <span data-ttu-id="a359a-152">각 항목은 주 응용 프로그램 진입점이 있는 디렉터리를 기준으로 선택적 디렉터리 이름 및 필수 파일 이름으로 구성됩니다.</span><span class="sxs-lookup"><span data-stu-id="a359a-152">Each entry consists of an optional directory name plus required file name which are relative to the directory where the main application entry point is located.</span></span> <span data-ttu-id="a359a-153">파일 이름 부분에만 와일드 카드가 허용됩니다.</span><span class="sxs-lookup"><span data-stu-id="a359a-153">Wild cards are allowed in the file name portion only.</span></span> <span data-ttu-id="a359a-154">기본값은 "\*.js;web.config"입니다.</span><span class="sxs-lookup"><span data-stu-id="a359a-154">Default value is “\*.js;web.config”</span></span>
* <span data-ttu-id="a359a-155">recycleSignalEnabled</span><span class="sxs-lookup"><span data-stu-id="a359a-155">recycleSignalEnabled</span></span>
  
    <span data-ttu-id="a359a-156">기본값은 False입니다.</span><span class="sxs-lookup"><span data-stu-id="a359a-156">Default value is false.</span></span> <span data-ttu-id="a359a-157">설정된 경우 노드 응용 프로그램에서 명명된 파이프(환경 변수 IISNODE\_CONTROL\_PIPE)에 연결할 수 있으며 "재활용" 메시지를 보낼 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="a359a-157">If enabled, your node application can connect to a named pipe (environment variable IISNODE\_CONTROL\_PIPE) and send a “recycle” message.</span></span> <span data-ttu-id="a359a-158">그러면 w3wp가 정상적으로 재활용됩니다.</span><span class="sxs-lookup"><span data-stu-id="a359a-158">This will cause the w3wp to recycle gracefully.</span></span>
* <span data-ttu-id="a359a-159">idlePageOutTimePeriod</span><span class="sxs-lookup"><span data-stu-id="a359a-159">idlePageOutTimePeriod</span></span>
  
    <span data-ttu-id="a359a-160">기본값은 이 기능을 사용하지 않는다는 의미의 0입니다.</span><span class="sxs-lookup"><span data-stu-id="a359a-160">Default value is 0 which means this feature is disabled.</span></span> <span data-ttu-id="a359a-161">0보다 큰 값으로 설정되면 iisnode에서 모든 하위 프로세스를 'idlePageOutTimePeriod' 밀리초마다 페이지 아웃합니다.</span><span class="sxs-lookup"><span data-stu-id="a359a-161">When set to some value greater than 0, iisnode will page out all its child processes every ‘idlePageOutTimePeriod’ milliseconds.</span></span> <span data-ttu-id="a359a-162">페이지 아웃에 대해 알아보려면 이 [설명서](https://msdn.microsoft.com/library/windows/desktop/ms682606.aspx)를 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="a359a-162">To understand what page out means, please refer to this [documentation](https://msdn.microsoft.com/library/windows/desktop/ms682606.aspx).</span></span> <span data-ttu-id="a359a-163">이 설정은 대량의 메모리를 사용하고 간혹 메모리를 디스크로 페이지 아웃하여 일부 RAM을 확보하려는 경우 유용합니다.</span><span class="sxs-lookup"><span data-stu-id="a359a-163">This setting will be useful for applications that consume a lot of memory and want to pageout memory to disk occasionally to free up some RAM.</span></span>

> [!WARNING]
> <span data-ttu-id="a359a-164">프로덕션 응용 프로그램에서 다음 구성 설정을 사용하도록 설정할 대는 주의하세요.</span><span class="sxs-lookup"><span data-stu-id="a359a-164">Use caution when enabling the following configuration settings on production applications.</span></span> <span data-ttu-id="a359a-165">라이브 프로덕션 응용 프로그램에서 사용하지 않도록 설정하는 것이 좋습니다.</span><span class="sxs-lookup"><span data-stu-id="a359a-165">Recommendation is to not enable them on live production applications.</span></span>
> 
> 

* <span data-ttu-id="a359a-166">debugHeaderEnabled</span><span class="sxs-lookup"><span data-stu-id="a359a-166">debugHeaderEnabled</span></span>
  
    <span data-ttu-id="a359a-167">기본값은 False입니다.</span><span class="sxs-lookup"><span data-stu-id="a359a-167">The default value is false.</span></span> <span data-ttu-id="a359a-168">true로 설정되면 iisnode에서 HTTP 응답 헤더 iisnode-debug를 보내는 모든 HTTP 응답에 추가하고 iisnode-debug 헤더 값은 URL입니다.</span><span class="sxs-lookup"><span data-stu-id="a359a-168">If set to true, iisnode will add an HTTP response header iisnode-debug to every HTTP response it sends the iisnode-debug header value is a URL.</span></span> <span data-ttu-id="a359a-169">개별 진단 정보 조각은 URL 조각을 확인하여 얻을 수 있지만 브라우저에서 URL을 열면 훨씬 향상된 시각화를 달성할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="a359a-169">Individual pieces of diagnostic information can be gleaned by looking at the URL fragment, but a much better visualization is achieved by opening the URL in the browser.</span></span>
* <span data-ttu-id="a359a-170">loggingEnabled</span><span class="sxs-lookup"><span data-stu-id="a359a-170">loggingEnabled</span></span>
  
    <span data-ttu-id="a359a-171">이 설정은 iisnode에 의한 stdout 및 stderr의 로깅을 제어합니다.</span><span class="sxs-lookup"><span data-stu-id="a359a-171">This setting controls the logging of stdout and stderr by iisnode.</span></span> <span data-ttu-id="a359a-172">Iisnode는 시작된 노드 프로세스에서 stdout/stderr을 캡처하여 'logDirectory' 설정에 지정된 디렉터리에 씁니다.</span><span class="sxs-lookup"><span data-stu-id="a359a-172">Iisnode will capture stdout/stderr from node processes it launches and write to the directory specified in the ‘logDirectory’ setting.</span></span> <span data-ttu-id="a359a-173">사용하도록 설정하면 응용 프로그램에서 로그를 파일 시스템에 기록하고 응용 프로그램에서 완료한 로깅 양에 따라 성능 저하가 발생할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="a359a-173">Once this is enable, your application will be writing logs to the file system and depending on the amount of logging done by the application, there could be performance implications.</span></span>
* <span data-ttu-id="a359a-174">devErrorsEnabled</span><span class="sxs-lookup"><span data-stu-id="a359a-174">devErrorsEnabled</span></span>
  
    <span data-ttu-id="a359a-175">기본값은 False입니다.</span><span class="sxs-lookup"><span data-stu-id="a359a-175">Default value is false.</span></span> <span data-ttu-id="a359a-176">true로 설정하면 iisnode에서 HTTP 상태 코드 및 Win32 오류 코드가 브라우저에 표시됩니다.</span><span class="sxs-lookup"><span data-stu-id="a359a-176">When set to true, iisnode will display the HTTP status code and Win32 error code on your browser.</span></span> <span data-ttu-id="a359a-177">win32 코드는 특정 유형의 문제를 디버깅하는 데 유용합니다.</span><span class="sxs-lookup"><span data-stu-id="a359a-177">The win32 code will be helpful in debugging certain types of issues.</span></span>
* <span data-ttu-id="a359a-178">debuggingEnabled(라이브 프로덕션 사이트에서 사용 안 함)</span><span class="sxs-lookup"><span data-stu-id="a359a-178">debuggingEnabled (do not enable on live production site)</span></span>
  
    <span data-ttu-id="a359a-179">이 설정은 디버깅 기능을 제어합니다.</span><span class="sxs-lookup"><span data-stu-id="a359a-179">This setting controls debugging feature.</span></span> <span data-ttu-id="a359a-180">Iisnode는 node-inspector에 통합됩니다.</span><span class="sxs-lookup"><span data-stu-id="a359a-180">Iisnode is integrated with node-inspector.</span></span> <span data-ttu-id="a359a-181">이 설정을 사용하여 노드 응용 프로그램의 디버깅을 사용하도록 설정합니다.</span><span class="sxs-lookup"><span data-stu-id="a359a-181">By enabling this setting, you enable debugging of your node application.</span></span> <span data-ttu-id="a359a-182">이 설정을 사용하도록 설정하면 iisnode가 필요한 'debuggerVirtualDir' 디렉터리의 node-inspector 파일을 노드 응용 프로그램에 대한 첫 번째 디버그 요청에 배치합니다.</span><span class="sxs-lookup"><span data-stu-id="a359a-182">Once this setting is enabled, iisnode will layout the necessary node-inspector files in ‘debuggerVirtualDir’ directory on the first debug request to your node application.</span></span> <span data-ttu-id="a359a-183">요청을 http://yoursite/server.js/debug로 전송하여 node-inspector를 로드할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="a359a-183">You can load the node-inspector by sending a request to http://yoursite/server.js/debug.</span></span> <span data-ttu-id="a359a-184">‘debuggerPathSegment’ 설정으로 디버그 URL 세그먼트를 제어할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="a359a-184">You can control the debug URL segment with ‘debuggerPathSegment’ setting.</span></span> <span data-ttu-id="a359a-185">기본적으로 debuggerPathSegment='debug'입니다.</span><span class="sxs-lookup"><span data-stu-id="a359a-185">By default debuggerPathSegment=’debug’.</span></span> <span data-ttu-id="a359a-186">예를 들어 이 값을 GUID로 설정할 수 있으므로 다른 사람이 검색하기 더 어렵습니다.</span><span class="sxs-lookup"><span data-stu-id="a359a-186">You can set this to a GUID for example so that it is more difficult to be discovered by others.</span></span>
  
    <span data-ttu-id="a359a-187">디버깅에 대한 자세한 내용은 이 [링크](https://tomasz.janczuk.org/2011/11/debug-nodejs-applications-on-windows.html) 를 확인하세요.</span><span class="sxs-lookup"><span data-stu-id="a359a-187">Check this [link](https://tomasz.janczuk.org/2011/11/debug-nodejs-applications-on-windows.html) for more details on debugging.</span></span>

## <a name="scenarios-and-recommendationstroubleshooting"></a><span data-ttu-id="a359a-188">시나리오 및 권장 사항/문제 해결</span><span class="sxs-lookup"><span data-stu-id="a359a-188">Scenarios and recommendations/troubleshooting</span></span>
### <a name="my-node-application-is-making-too-many-outbound-calls"></a><span data-ttu-id="a359a-189">내 노드 응용 프로그램에서 너무 많은 아웃바운드 호출을 생성합니다.</span><span class="sxs-lookup"><span data-stu-id="a359a-189">My node application is making too many outbound calls.</span></span>
<span data-ttu-id="a359a-190">많은 응용 프로그램에서 일반 작업의 일부로 아웃바운드 연결을 생성하려고 합니다.</span><span class="sxs-lookup"><span data-stu-id="a359a-190">Many applications would want to make outbound connections as part of their regular operation.</span></span> <span data-ttu-id="a359a-191">예를 들어 요청이 들어오면 노드 앱은 다른 위치에서 REST API에 연결하고 요청을 처리할 일부 정보를 얻습니다.</span><span class="sxs-lookup"><span data-stu-id="a359a-191">For example, when a request comes in, your node app would want to contact a REST API elsewhere and get some information to process the request.</span></span> <span data-ttu-id="a359a-192">http 또는 https 호출을 수행할 때 연결 유지 에이전트를 사용하려고 합니다.</span><span class="sxs-lookup"><span data-stu-id="a359a-192">You would want to use a keep alive agent when making http or https calls.</span></span> <span data-ttu-id="a359a-193">예를 들어 이러한 아웃바운드 호출을 수행할 때 연결 유지 에이전트로 agentkeepalive 모듈을 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="a359a-193">For example, you could use the agentkeepalive module as your keep alive agent when making these outbound calls.</span></span> <span data-ttu-id="a359a-194">이렇게 하면 azure 웹앱 VM에서 소켓이 재사용되어 모든 아웃바운드 요청에 대해 새 소켓을 만드는 오버헤드가 감소합니다.</span><span class="sxs-lookup"><span data-stu-id="a359a-194">This makes sure that the sockets are reused on your azure webapp VM and reducing the overhead of creating new sockets for every outbound request.</span></span> <span data-ttu-id="a359a-195">또한 이렇게 하면 적은 수의 소켓을 사용하여 많은 아웃바운드 요청을 만들 수 있으므로 VM당 할당된 maxSockets를 초과하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="a359a-195">Also, this makes sure that you are using less number of sockets to make many outbound requests and therefore you don’t exceed the maxSockets that are allocated per VM.</span></span> <span data-ttu-id="a359a-196">Azure 웹앱에 대한 권장 사항은 agentKeepAlive maxSockets 값을 VM당 총 160개 소켓으로 설정합니다.</span><span class="sxs-lookup"><span data-stu-id="a359a-196">Recommendation on Azure Webapps would be to set the agentKeepAlive maxSockets value to a total of 160 sockets per VM.</span></span> <span data-ttu-id="a359a-197">VM에서 실행되는 4개의 node.exe가 있는 경우 agentKeepAlive maxSockets를 node.exe당 40(VM당 총 160)으로 설정합니다.</span><span class="sxs-lookup"><span data-stu-id="a359a-197">This means that if you have 4 node.exe running on the VM, you would want to set the agentKeepAlive maxSockets to 40 per node.exe which is 160 total per VM.</span></span>

<span data-ttu-id="a359a-198">[agentKeepALive](https://www.npmjs.com/package/agentkeepalive) 구성 예제:</span><span class="sxs-lookup"><span data-stu-id="a359a-198">Example [agentKeepALive](https://www.npmjs.com/package/agentkeepalive) configuration:</span></span>

```
var keepaliveAgent = new Agent({    
    maxSockets: 40,    
    maxFreeSockets: 10,    
    timeout: 60000,    
    keepAliveTimeout: 300000    
});
```

<span data-ttu-id="a359a-199">이 예에서는 VM에서 4개의 node.exe를 실행 중이라고 가정합니다.</span><span class="sxs-lookup"><span data-stu-id="a359a-199">This example assumes you have 4 node.exe running on your VM.</span></span> <span data-ttu-id="a359a-200">VM에서 다른 수의 node.exe가 실행 중인 경우 maxSockets 설정을 적절하게 수정해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="a359a-200">If you have a different number of node.exe running on the VM, you will have to modify the maxSockets setting accordingly.</span></span>

### <a name="my-node-application-is-consuming-too-much-cpu"></a><span data-ttu-id="a359a-201">내 노드 응용 프로그램이 너무 많은 CPU를 사용하고 있습니다.</span><span class="sxs-lookup"><span data-stu-id="a359a-201">My node application is consuming too much CPU.</span></span>
<span data-ttu-id="a359a-202">포털의 Azure 웹앱에서 높은 cpu 사용량에 대한 권장 사항을 받게 됩니다.</span><span class="sxs-lookup"><span data-stu-id="a359a-202">You will probably get a recommendation from Azure Webapps on your portal about high cpu consumption.</span></span> <span data-ttu-id="a359a-203">또한 특정 [메트릭](web-sites-monitor.md)을 감시하도록 모니터를 설정할 수도 있습니다.</span><span class="sxs-lookup"><span data-stu-id="a359a-203">You can also setup monitors to watch for certain [metrics](web-sites-monitor.md).</span></span> <span data-ttu-id="a359a-204">[Azure 포털 대시보드](../application-insights/app-insights-web-monitor-performance.md)에서 CPU 사용량을 확인할 때는 최고값을 놓치지 않도록 CPU에 대한 MAX 값을 확인하세요.</span><span class="sxs-lookup"><span data-stu-id="a359a-204">When checking the CPU usage on the [Azure Portal Dashboard](../application-insights/app-insights-web-monitor-performance.md), please check the MAX values for CPU so you don’t miss out the peak values.</span></span>
<span data-ttu-id="a359a-205">응용 프로그램에서 CPU를 너무 많이 사용한다고 생각되고 그 이유를 설명할 수 없는 경우 노드 응용 프로그램을 프로파일링해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="a359a-205">In cases where you think your application is consuming too much CPU and you cannot explain why, you will need to profile your node application.</span></span>

### 
#### <a name="profiling-your-node-application-on-azure-webapps-with-v8-profiler"></a><span data-ttu-id="a359a-206">azure 웹앱에서 V8-Profiler로 노드 응용 프로그램 프로파일링</span><span class="sxs-lookup"><span data-stu-id="a359a-206">Profiling your node application on azure webapps with V8-Profiler</span></span>
<span data-ttu-id="a359a-207">예를 들어 아래와 같이 프로파일링할 hello world 앱이 있다고 가정해 보겠습니다.</span><span class="sxs-lookup"><span data-stu-id="a359a-207">For example, lets say you have a hello world app that you want to profile as shown below:</span></span>

```
var http = require('http');    
function WriteConsoleLog() {    
    for(var i=0;i<99999;++i) {    
        console.log('hello world');    
    }    
}

function HandleRequest() {    
    WriteConsoleLog();    
}

http.createServer(function (req, res) {    
    res.writeHead(200, {'Content-Type': 'text/html'});    
    HandleRequest();    
    res.end('Hello world!');    
}).listen(process.env.PORT);
```

<span data-ttu-id="a359a-208">scm 사이트 https://yoursite.scm.azurewebsites.net/DebugConsole로 이동합니다.</span><span class="sxs-lookup"><span data-stu-id="a359a-208">Go to your scm site https://yoursite.scm.azurewebsites.net/DebugConsole</span></span>

<span data-ttu-id="a359a-209">아래와 같이 명령 프롬프트가 표시됩니다.</span><span class="sxs-lookup"><span data-stu-id="a359a-209">You will see a command prompt as shown below.</span></span> <span data-ttu-id="a359a-210">site/wwwroot 디렉터리로 이동합니다.</span><span class="sxs-lookup"><span data-stu-id="a359a-210">Go into your site/wwwroot directory</span></span>

![](./media/app-service-web-nodejs-best-practices-and-troubleshoot-guide/scm_install_v8.png)

<span data-ttu-id="a359a-211">"npm install v8-profiler" 명령을 실행합니다.</span><span class="sxs-lookup"><span data-stu-id="a359a-211">Run the command “npm install v8-profiler”</span></span>

<span data-ttu-id="a359a-212">그러면 node\_modules 디렉터리 아래에 v8-profiler와 모든 종속성이 설치됩니다.</span><span class="sxs-lookup"><span data-stu-id="a359a-212">This should install v8-profiler under node\_modules directory and all of its dependencies.</span></span>
<span data-ttu-id="a359a-213">이제 server.js를 편집하여 응용 프로그램을 프로파일링합니다.</span><span class="sxs-lookup"><span data-stu-id="a359a-213">Now, edit your server.js to profile your application.</span></span>

```
var http = require('http');    
var profiler = require('v8-profiler');    
var fs = require('fs');

function WriteConsoleLog() {    
    for(var i=0;i<99999;++i) {    
        console.log('hello world');    
    }    
}

function HandleRequest() {    
    profiler.startProfiling('HandleRequest');    
    WriteConsoleLog();    
    fs.writeFileSync('profile.cpuprofile', JSON.stringify(profiler.stopProfiling('HandleRequest')));    
}

http.createServer(function (req, res) {    
    res.writeHead(200, {'Content-Type': 'text/html'});    
    HandleRequest();    
    res.end('Hello world!');    
}).listen(process.env.PORT);
```

<span data-ttu-id="a359a-214">위의 변경 내용은 WriteConsoleLog 함수를 프로파일링한 후 프로파일 출력을 사이트의 wwwroot 아래 'profile.cpuprofile' 파일에 기록합니다.</span><span class="sxs-lookup"><span data-stu-id="a359a-214">The above changes will profile the WriteConsoleLog function and then write the profile output to ‘profile.cpuprofile’ file under your site wwwroot.</span></span> <span data-ttu-id="a359a-215">응용 프로그램에 요청 보내기</span><span class="sxs-lookup"><span data-stu-id="a359a-215">Send a request to your application.</span></span> <span data-ttu-id="a359a-216">사이트의 wwwroot 아래에 'profile.cpuprofile' 파일이 생성된 것을 확인할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="a359a-216">You will see a ‘profile.cpuprofile’ file created under your site wwwroot.</span></span>

![](./media/app-service-web-nodejs-best-practices-and-troubleshoot-guide/scm_profile.cpuprofile.png)

<span data-ttu-id="a359a-217">이 파일을 다운로드하고 Chrome F12 Tools에서 이 파일을 열어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="a359a-217">Download this file and you will need to open this file with Chrome F12 Tools.</span></span> <span data-ttu-id="a359a-218">chrome에서 F12 키를 누른 후 "Profiles 탭"을 클릭합니다.</span><span class="sxs-lookup"><span data-stu-id="a359a-218">Hit F12 on chrome, then click on the “Profiles Tab”.</span></span> <span data-ttu-id="a359a-219">"로드" 단추를 클릭합니다.</span><span class="sxs-lookup"><span data-stu-id="a359a-219">Click on “Load” Button.</span></span> <span data-ttu-id="a359a-220">방금 다운로드한 profile.cpuprofile 파일을 선택합니다.</span><span class="sxs-lookup"><span data-stu-id="a359a-220">Select your profile.cpuprofile file that you just downloaded.</span></span> <span data-ttu-id="a359a-221">방금 로드한 프로파일을 클릭합니다.</span><span class="sxs-lookup"><span data-stu-id="a359a-221">Click on the profile you just loaded.</span></span>

![](./media/app-service-web-nodejs-best-practices-and-troubleshoot-guide/chrome_tools_view.png)

<span data-ttu-id="a359a-222">아래와 같이 WriteConsoleLog 함수에 의해 95%의 시간이 소요되었다는 내용이 표시됩니다.</span><span class="sxs-lookup"><span data-stu-id="a359a-222">You will see that 95% of the time was consumed by WriteConsoleLog function as shown below.</span></span> <span data-ttu-id="a359a-223">또한 이 문제를 발생시킨 정확한 줄 번호와 소스 파일도 표시됩니다.</span><span class="sxs-lookup"><span data-stu-id="a359a-223">This also shows you the exact line numbers and source files that cause the issue.</span></span>

### <a name="my-node-application-is-consuming-too-much-memory"></a><span data-ttu-id="a359a-224">내 노드 응용 프로그램이 너무 많은 메모리를 사용하고 있습니다.</span><span class="sxs-lookup"><span data-stu-id="a359a-224">My node application is consuming too much memory.</span></span>
<span data-ttu-id="a359a-225">포털의 Azure 웹앱에서 높은 메모리 사용량에 대한 권장 사항을 받게 됩니다.</span><span class="sxs-lookup"><span data-stu-id="a359a-225">You will probably get a recommendation from Azure Webapps on your portal about high memory consumption.</span></span> <span data-ttu-id="a359a-226">또한 특정 [메트릭](web-sites-monitor.md)을 감시하도록 모니터를 설정할 수도 있습니다.</span><span class="sxs-lookup"><span data-stu-id="a359a-226">You can also setup monitors to watch for certain [metrics](web-sites-monitor.md).</span></span> <span data-ttu-id="a359a-227">[Azure 포털 대시보드](../application-insights/app-insights-web-monitor-performance.md)에서 메모리 사용량을 확인할 때는 최고값을 놓치지 않도록 메모리에 대한 MAX 값을 확인하세요.</span><span class="sxs-lookup"><span data-stu-id="a359a-227">When checking the memory usage on the [Azure Portal Dashboard](../application-insights/app-insights-web-monitor-performance.md), please check the MAX values for memory so you don’t miss out the peak values.</span></span>

#### <a name="leak-detection-and-heap-diffing-for-nodejs"></a><span data-ttu-id="a359a-228">node.js에 대한 누수 감지 및 힙 Diff</span><span class="sxs-lookup"><span data-stu-id="a359a-228">Leak detection and Heap Diffing for node.js</span></span>
<span data-ttu-id="a359a-229">[node-memwatch](https://github.com/lloyd/node-memwatch) 를 사용하여 메모리 누수를 확인할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="a359a-229">You could use [node-memwatch](https://github.com/lloyd/node-memwatch) to help you identify memory leaks.</span></span>
<span data-ttu-id="a359a-230">You can install memwatch just like v8-profiler처럼 memwatch를 설치하고 힙을 캡처 및 diff하는 코드를 편집하여 응용 프로그램에서 메모리 누수를 확인할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="a359a-230">You can install memwatch just like v8-profiler and edit your code to capture and diff heaps to identify the memory leaks in your application.</span></span>

### <a name="my-nodeexes-are-getting-killed-randomly"></a><span data-ttu-id="a359a-231">내 node.exe가 임의로 중지됨</span><span class="sxs-lookup"><span data-stu-id="a359a-231">My node.exe’s are getting killed randomly</span></span>
<span data-ttu-id="a359a-232">이러한 현상이 발생하는 몇 가지 이유가 있습니다.</span><span class="sxs-lookup"><span data-stu-id="a359a-232">There are a few reasons why this could be happening:</span></span>

1. <span data-ttu-id="a359a-233">응용 프로그램에서 catch되지 않는 예외를 throw합니다. throw된 예외에 대한 자세한 내용은 d:\\home\\LogFiles\\Application\\logging-errors.txt 파일을 확인하세요.</span><span class="sxs-lookup"><span data-stu-id="a359a-233">Your application is throwing uncaught exceptions – Please check d:\\home\\LogFiles\\Application\\logging-errors.txt file for the details on the exception thrown.</span></span> <span data-ttu-id="a359a-234">이 파일에는 스택 추적이 있으므로 이에 따라 응용 프로그램을 수정할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="a359a-234">This file has the stack trace so you can fix your application based on this.</span></span>
2. <span data-ttu-id="a359a-235">응용 프로그램에서 너무 많은 메모리를 사용하여 다른 프로세스가 시작되는 데 영향을 줍니다.</span><span class="sxs-lookup"><span data-stu-id="a359a-235">Your application is consuming too much memory which is affecting other processes from getting started.</span></span> <span data-ttu-id="a359a-236">총 VM 메모리가 100%에 근접한 경우 프로세스 관리자는 다른 프로세스가 작업을 수행할 수 있도록 node.exe를 중지할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="a359a-236">If the total VM memory is close to 100%, your node.exe’s could be killed by the process manager to let other processes get a chance to do some work.</span></span> <span data-ttu-id="a359a-237">이 문제를 해결하려면 응용 프로그램에서 메모리 누수가 발생하지 않는지, 응용 프로그램에서 실제로 많은 메모리를 사용해야 하는지 확인합니다. 또는 훨씬 많은 RAM이 있는 큰 VM으로 강화하세요.</span><span class="sxs-lookup"><span data-stu-id="a359a-237">To fix this, either make sure your application is not leaking memory OR if you application really needs to use a lot of memory, please scale up to a larger VM with a lot more RAM.</span></span>

### <a name="my-node-application-does-not-start"></a><span data-ttu-id="a359a-238">내 노드 응용 프로그램이 시작되지 않음</span><span class="sxs-lookup"><span data-stu-id="a359a-238">My node application does not start</span></span>
<span data-ttu-id="a359a-239">응용 프로그램 시작 시 500 오류를 반환하는 경우 몇 가지 원인이 있을 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="a359a-239">If your application is returning 500 Errors at startup, there could be a few reasons:</span></span>

1. <span data-ttu-id="a359a-240">Node.exe가 올바른 위치에 없습니다.</span><span class="sxs-lookup"><span data-stu-id="a359a-240">Node.exe is not present at the correct location.</span></span> <span data-ttu-id="a359a-241">nodeProcessCommandLine 설정을 확인합니다.</span><span class="sxs-lookup"><span data-stu-id="a359a-241">Check nodeProcessCommandLine setting.</span></span>
2. <span data-ttu-id="a359a-242">기본 스크립트 파일이 올바른 위치에 없습니다.</span><span class="sxs-lookup"><span data-stu-id="a359a-242">Main script file is not present at the correct location.</span></span> <span data-ttu-id="a359a-243">web.config를 확인하고 처리기 섹션에서 기본 스크립트 파일의 이름이 기본 스크립트 파일과 일치하는지 확인합니다.</span><span class="sxs-lookup"><span data-stu-id="a359a-243">Check web.config and make sure the name of the main script file in the handlers section matches the main script file.</span></span>
3. <span data-ttu-id="a359a-244">Web.config 구성이 잘못되었습니다. 설정 이름/값을 확인하세요.</span><span class="sxs-lookup"><span data-stu-id="a359a-244">Web.config configuration is not correct – check the settings names/values.</span></span>
4. <span data-ttu-id="a359a-245">콜드 부팅 – 응용 프로그램을 시작하는 데 너무 오래 걸립니다.</span><span class="sxs-lookup"><span data-stu-id="a359a-245">Cold Start – Your application is taking too long to startup.</span></span> <span data-ttu-id="a359a-246">응용 프로그램이 (maxNamedPipeConnectionRetry \* namedPipeConnectionRetryDelay) / 1000초보다 오래 걸리면 iisnode에서 500 오류를 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="a359a-246">If your application takes longer than (maxNamedPipeConnectionRetry \* namedPipeConnectionRetryDelay) / 1000 seconds, iisnode will return 500 error.</span></span> <span data-ttu-id="a359a-247">응용 프로그램 시작 시간과 일치하도록 이러한 설정 값을 늘리면 iisnode의 제한 시간 초과와 500 오류 반환을 방지할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="a359a-247">Increase the values of these settings to match your application start time to prevent iisnode from timing out and returning the 500 error.</span></span>

### <a name="my-node-application-crashed"></a><span data-ttu-id="a359a-248">내 노드 응용 프로그램에 충돌 발생</span><span class="sxs-lookup"><span data-stu-id="a359a-248">My node application crashed</span></span>
<span data-ttu-id="a359a-249">응용 프로그램에서 catch되지 않는 예외를 throw합니다. throw된 예외에 대한 자세한 내용은 d:\\home\\LogFiles\\Application\\logging-errors.txt 파일을 확인하세요.</span><span class="sxs-lookup"><span data-stu-id="a359a-249">Your application is throwing uncaught exceptions – Please check d:\\home\\LogFiles\\Application\\logging-errors.txt file for the details on the exception thrown.</span></span> <span data-ttu-id="a359a-250">이 파일에는 스택 추적이 있으므로 이에 따라 응용 프로그램을 수정할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="a359a-250">This file has the stack trace so you can fix your application based on this.</span></span>

### <a name="my-node-application-takes-too-much-time-to-startup-cold-start"></a><span data-ttu-id="a359a-251">내 노드 응용 프로그램을 시작하는 데 너무 많은 시간이 소요됨(콜드 부팅)</span><span class="sxs-lookup"><span data-stu-id="a359a-251">My node application takes too much time to startup (Cold Start)</span></span>
<span data-ttu-id="a359a-252">가장 일반적인 이유는 응용 프로그램의 node\_modules에 너무 많은 파일이 있고 응용 프로그램에서 시작 중에 이러한 파일 중 대부분을 로드하려고 시도하는 경우입니다.</span><span class="sxs-lookup"><span data-stu-id="a359a-252">Most common reason for this is that the application has a lot of files in the node\_modules and the application tries to load most of these files during startup.</span></span> <span data-ttu-id="a359a-253">기본적으로 파일은 Azure 웹앱의 네트워크 공유에 상주하므로 많은 파일을 로드하면 다소 시간이 소요될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="a359a-253">By default, since your files reside on the network share on Azure Webapps, loading so many files can take some time.</span></span>
<span data-ttu-id="a359a-254">이 작업을 빠르게 하기 위한 몇 가지 해결 방법은 다음과 같습니다.</span><span class="sxs-lookup"><span data-stu-id="a359a-254">Some solutions to make this faster are:</span></span>

1. <span data-ttu-id="a359a-255">npm3을 사용하여 플랫 종속성 구조가 있고 중복 종속성이 없는지 확인하고 모듈을 설치합니다.</span><span class="sxs-lookup"><span data-stu-id="a359a-255">Make sure you have a flat dependency structure and no duplicate dependencies by using npm3 to install your modules.</span></span>
2. <span data-ttu-id="a359a-256">node\_modules의 지연 로드를 시도하면 시작 시 모든 모듈을 로드하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="a359a-256">Try to lazy load your node\_modules and not load all of the modules at startup.</span></span> <span data-ttu-id="a359a-257">따라서 모듈을 사용하려는 함수 내에서 실제로 필요할 때 필요한 호출('모듈')이 완료됩니다.</span><span class="sxs-lookup"><span data-stu-id="a359a-257">This means that the call to require(‘module’) should be done when you actually need it within the function you try to use the module.</span></span>
3. <span data-ttu-id="a359a-258">Azure 웹앱은 로컬 캐시라는 기능을 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="a359a-258">Azure Webapps offers a feature called local cache.</span></span> <span data-ttu-id="a359a-259">이 기능은 네트워크 공유에서 VM의 로컬 디스크로 콘텐츠를 복사합니다.</span><span class="sxs-lookup"><span data-stu-id="a359a-259">This feature copies your content from the network share to the local disk on the VM.</span></span> <span data-ttu-id="a359a-260">파일이 로컬 파일이므로 node\_modules의 로드 시간이 훨씬 더 빠릅니다.</span><span class="sxs-lookup"><span data-stu-id="a359a-260">Since the files are local, the load time of node\_modules is much faster.</span></span> <span data-ttu-id="a359a-261">이 [설명서](../app-service/app-service-local-cache.md) 에서는 로컬 캐시를 사용하는 방법을 자세히 설명합니다.</span><span class="sxs-lookup"><span data-stu-id="a359a-261">- This [documentation](../app-service/app-service-local-cache.md) explains how to use Local Cache in more detail.</span></span>

## <a name="iisnode-http-status-and-substatus"></a><span data-ttu-id="a359a-262">IISNODE http 상태 및 하위 상태</span><span class="sxs-lookup"><span data-stu-id="a359a-262">IISNODE http status and substatus</span></span>
<span data-ttu-id="a359a-263">이 [소스 파일](https://github.com/Azure/iisnode/blob/master/src/iisnode/cnodeconstants.h) 은 iisnode에서 오류 발생 시 반환할 수 있는 모든 가능한 상태/하위 상태의 조합을 나열합니다.</span><span class="sxs-lookup"><span data-stu-id="a359a-263">This [source file](https://github.com/Azure/iisnode/blob/master/src/iisnode/cnodeconstants.h) lists all the possible status/substatus combination iisnode can return in case of error.</span></span>

<span data-ttu-id="a359a-264">win32 오류 코드를 표시하도록 응용 프로그램에 대해 FREB를 사용하도록 설정합니다(성능상의 이유로 비프로덕션 사이트에서만 FREB를 사용하도록 설정하세요).</span><span class="sxs-lookup"><span data-stu-id="a359a-264">Enable FREB for your application to see the win32 error code (please make sure you enable FREB only on non-production sites for performance reasons).</span></span>

| <span data-ttu-id="a359a-265">HTTP 상태</span><span class="sxs-lookup"><span data-stu-id="a359a-265">Http Status</span></span> | <span data-ttu-id="a359a-266">HTTP 하위 상태</span><span class="sxs-lookup"><span data-stu-id="a359a-266">Http SubStatus</span></span> | <span data-ttu-id="a359a-267">가능한 원인</span><span class="sxs-lookup"><span data-stu-id="a359a-267">Possible Reason?</span></span> |
| --- | --- | --- |
| <span data-ttu-id="a359a-268">500</span><span class="sxs-lookup"><span data-stu-id="a359a-268">500</span></span> |<span data-ttu-id="a359a-269">1000</span><span class="sxs-lookup"><span data-stu-id="a359a-269">1000</span></span> |<span data-ttu-id="a359a-270">요청을 IISNODE로 디스패치하는 몇 가지 문제가 있습니다. node.exe가 시작되었는지 확인하세요.</span><span class="sxs-lookup"><span data-stu-id="a359a-270">There was some issue dispatching the request to IISNODE – check if node.exe was started up.</span></span> <span data-ttu-id="a359a-271">Node.exe가 시작 시 충돌되었을 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="a359a-271">Node.exe could have crashed on startup.</span></span> <span data-ttu-id="a359a-272">web.config 구성에 오류가 있는지 확인하세요.</span><span class="sxs-lookup"><span data-stu-id="a359a-272">Check your web.config configuration for errors.</span></span> |
| <span data-ttu-id="a359a-273">500</span><span class="sxs-lookup"><span data-stu-id="a359a-273">500</span></span> |<span data-ttu-id="a359a-274">1001</span><span class="sxs-lookup"><span data-stu-id="a359a-274">1001</span></span> |<span data-ttu-id="a359a-275">- Win32Error 0x2 - 앱이 URL에 응답하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="a359a-275">- Win32Error 0x2 - App is not responding to the URL.</span></span> <span data-ttu-id="a359a-276">URL 다시 쓰기 규칙이나 Express 앱에 올바른 경로가 정의되어 있는지 확인하세요.</span><span class="sxs-lookup"><span data-stu-id="a359a-276">Check URL rewrite rules or if your express app has the correct routes defined.</span></span> <span data-ttu-id="a359a-277">- Win32Error 0x6d – 명명된 파이프를 사용 중 – 파이프를 사용 중이므로 Node.exe에서 요청을 수락하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="a359a-277">- Win32Error 0x6d – named pipe is busy – Node.exe is not accepting requests because the pipe is busy.</span></span> <span data-ttu-id="a359a-278">높은 cpu 사용량을 확인하세요.</span><span class="sxs-lookup"><span data-stu-id="a359a-278">Check high cpu usage.</span></span> <span data-ttu-id="a359a-279">- 기타 오류 – node.exe가 충돌되었는지 확인하세요.</span><span class="sxs-lookup"><span data-stu-id="a359a-279">- Other errors – check if node.exe crashed.</span></span> |
| <span data-ttu-id="a359a-280">500</span><span class="sxs-lookup"><span data-stu-id="a359a-280">500</span></span> |<span data-ttu-id="a359a-281">1002</span><span class="sxs-lookup"><span data-stu-id="a359a-281">1002</span></span> |<span data-ttu-id="a359a-282">Node.exe가 충돌됨 – d:\\home\\LogFiles\\logging-errors.txt에서 스택 추적을 확인하세요.</span><span class="sxs-lookup"><span data-stu-id="a359a-282">Node.exe crashed – check d:\\home\\LogFiles\\logging-errors.txt for stack trace.</span></span> |
| <span data-ttu-id="a359a-283">500</span><span class="sxs-lookup"><span data-stu-id="a359a-283">500</span></span> |<span data-ttu-id="a359a-284">1003</span><span class="sxs-lookup"><span data-stu-id="a359a-284">1003</span></span> |<span data-ttu-id="a359a-285">파이프 구성 문제 – 이 내용은 표시되지 않지만 표시되는 경우 명명된 파이프 구성이 잘못되었습니다.</span><span class="sxs-lookup"><span data-stu-id="a359a-285">Pipe configuration Issue – You should never see this but if you do, the named pipe configuration is incorrect.</span></span> |
| <span data-ttu-id="a359a-286">500</span><span class="sxs-lookup"><span data-stu-id="a359a-286">500</span></span> |<span data-ttu-id="a359a-287">1004-1018</span><span class="sxs-lookup"><span data-stu-id="a359a-287">1004-1018</span></span> |<span data-ttu-id="a359a-288">node.exe 간에 요청을 보내거나 응답을 처리하는 동안 일부 오류가 발생했습니다.</span><span class="sxs-lookup"><span data-stu-id="a359a-288">There was some error while sending the request or processing the response to/from node.exe.</span></span> <span data-ttu-id="a359a-289">Node.exe가 충돌되었는지 확인하세요.</span><span class="sxs-lookup"><span data-stu-id="a359a-289">Check if node.exe crashed.</span></span> <span data-ttu-id="a359a-290">d:\\home\\LogFiles\\logging-errors.txt에서 스택 추적을 확인하세요.</span><span class="sxs-lookup"><span data-stu-id="a359a-290">check d:\\home\\LogFiles\\logging-errors.txt for stack trace.</span></span> |
| <span data-ttu-id="a359a-291">503</span><span class="sxs-lookup"><span data-stu-id="a359a-291">503</span></span> |<span data-ttu-id="a359a-292">1000</span><span class="sxs-lookup"><span data-stu-id="a359a-292">1000</span></span> |<span data-ttu-id="a359a-293">메모리가 부족하여 추가 명명된 파이프 연결을 할당할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="a359a-293">Not enough memory to allocate more named pipe connections.</span></span> <span data-ttu-id="a359a-294">앱에서 많은 메모리를 사용하는 이유를 확인하세요.</span><span class="sxs-lookup"><span data-stu-id="a359a-294">Check why your app is consuming so much memory.</span></span> <span data-ttu-id="a359a-295">maxConcurrentRequestsPerProcess 설정 값을 확인하세요.</span><span class="sxs-lookup"><span data-stu-id="a359a-295">Check maxConcurrentRequestsPerProcess setting value.</span></span> <span data-ttu-id="a359a-296">무한이 아니고 많은 요청이 있는 경우 이 값을 늘려야 이 오류를 피할 수 잇습니다.</span><span class="sxs-lookup"><span data-stu-id="a359a-296">If its not infinite and you have a lot of requests, increase this value to prevent this error.</span></span> |
| <span data-ttu-id="a359a-297">503</span><span class="sxs-lookup"><span data-stu-id="a359a-297">503</span></span> |<span data-ttu-id="a359a-298">1001</span><span class="sxs-lookup"><span data-stu-id="a359a-298">1001</span></span> |<span data-ttu-id="a359a-299">응용 프로그램을 재활용 중이므로 요청을 node.exe로 디스패치할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="a359a-299">Request could not be dispatched to node.exe because the application is recycling.</span></span> <span data-ttu-id="a359a-300">응용 프로그램이 재활용된 후에야 요청이 정상적으로 처리됩니다.</span><span class="sxs-lookup"><span data-stu-id="a359a-300">After the application has recycled, requests should be served normally.</span></span> |
| <span data-ttu-id="a359a-301">503</span><span class="sxs-lookup"><span data-stu-id="a359a-301">503</span></span> |<span data-ttu-id="a359a-302">1002</span><span class="sxs-lookup"><span data-stu-id="a359a-302">1002</span></span> |<span data-ttu-id="a359a-303">win32 오류 코드로 실제 원인을 확인하세요. – 요청을 node.exe로 디스패치할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="a359a-303">Check win32 error code for actual reason – Request could not be dispatched to a node.exe.</span></span> |
| <span data-ttu-id="a359a-304">503</span><span class="sxs-lookup"><span data-stu-id="a359a-304">503</span></span> |<span data-ttu-id="a359a-305">1003</span><span class="sxs-lookup"><span data-stu-id="a359a-305">1003</span></span> |<span data-ttu-id="a359a-306">명명된 파이프 사용량이 너무 많음 – 노드에서 많은 CPU를 사용 중인지 확인하세요.</span><span class="sxs-lookup"><span data-stu-id="a359a-306">Named pipe is too Busy – Check if node is consuming a lot of CPU</span></span> |

<span data-ttu-id="a359a-307">NODE.exe 내에 NODE\_PENDING\_PIPE\_INSTANCES라는 설정이 있습니다.</span><span class="sxs-lookup"><span data-stu-id="a359a-307">There is a setting within NODE.exe called NODE\_PENDING\_PIPE\_INSTANCES.</span></span> <span data-ttu-id="a359a-308">기본적으로 azure 웹앱 이외에서는 이 값은 4입니다.</span><span class="sxs-lookup"><span data-stu-id="a359a-308">By default outside of azure webapps this value is 4.</span></span> <span data-ttu-id="a359a-309">따라서 node.exe는 명명된 파이프에서 한 번에 4개의 요청만 받아들일 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="a359a-309">This means that node.exe can only accept 4 requests at a time on the named pipe.</span></span> <span data-ttu-id="a359a-310">Azure 웹앱에서 이 값은 5000으로 설정되고 이 값은 azure 웹앱에서 실행 중인 대부분의 노드 응용 프로그램에서 충분합니다.</span><span class="sxs-lookup"><span data-stu-id="a359a-310">On Azure Webapps, this value is set to 5000 and this value should be good enough for most node applications running on azure webapps.</span></span> <span data-ttu-id="a359a-311">NODE\_PENDING\_PIPE\_INSTANCES에 대한 값이 높으므로 azure 웹앱에서 503.1003이 표시되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="a359a-311">You should not see 503.1003 on azure webapps because we have a high value for the NODE\_PENDING\_PIPE\_INSTANCES.</span></span>  |

## <a name="more-resources"></a><span data-ttu-id="a359a-312">추가 리소스</span><span class="sxs-lookup"><span data-stu-id="a359a-312">More resources</span></span>
<span data-ttu-id="a359a-313">Azure 앱 서비스에서 다음 링크를 따라 node.js 응용 프로그램에 대해 자세히 알아보세요.</span><span class="sxs-lookup"><span data-stu-id="a359a-313">Follow these links to learn more about node.js applications on Azure App Service.</span></span>

* [<span data-ttu-id="a359a-314">Azure 앱 서비스에서 Node.js 웹앱 시작</span><span class="sxs-lookup"><span data-stu-id="a359a-314">Get started with Node.js web apps in Azure App Service</span></span>](app-service-web-get-started-nodejs.md)
* [<span data-ttu-id="a359a-315">Azure 앱 서비스에서 Node.js 웹 앱을 디버그하는 방법</span><span class="sxs-lookup"><span data-stu-id="a359a-315">How to debug a Node.js web app in Azure App Service</span></span>](web-sites-nodejs-debug.md)
* [<span data-ttu-id="a359a-316">Azure 응용 프로그램에 Node.js 모듈 사용</span><span class="sxs-lookup"><span data-stu-id="a359a-316">Using Node.js Modules with Azure applications</span></span>](../nodejs-use-node-modules-azure-apps.md)
* [<span data-ttu-id="a359a-317">Azure 앱 서비스 웹앱: Node.js</span><span class="sxs-lookup"><span data-stu-id="a359a-317">Azure App Service Web Apps: Node.js</span></span>](https://blogs.msdn.microsoft.com/silverlining/2012/06/14/windows-azure-websites-node-js/)
* [<span data-ttu-id="a359a-318">Node.js 개발자 센터</span><span class="sxs-lookup"><span data-stu-id="a359a-318">Node.js Developer Center</span></span>](../nodejs-use-node-modules-azure-apps.md)
* [<span data-ttu-id="a359a-319">Super 암호 Kudu 디버그 콘솔 탐색</span><span class="sxs-lookup"><span data-stu-id="a359a-319">Exploring the Super Secret Kudu Debug Console</span></span>](https://azure.microsoft.com/documentation/videos/super-secret-kudu-debug-console-for-azure-web-sites/)

