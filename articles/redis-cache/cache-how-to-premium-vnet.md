---
title: "aaaConfigure Premium Azure Redis Cache에 대 한 가상 네트워크 | Microsoft Docs"
description: "자세한 내용은 어떻게 toocreate 및 프리미엄 계층 Azure Redis 캐시 인스턴스에 대 한 지원 가상 네트워크를 관리 합니다."
services: redis-cache
documentationcenter: 
author: steved0x
manager: douge
editor: 
ms.assetid: 8b1e43a0-a70e-41e6-8994-0ac246d8bf7f
ms.service: cache
ms.workload: tbd
ms.tgt_pltfrm: cache-redis
ms.devlang: na
ms.topic: article
ms.date: 05/15/2017
ms.author: sdanie
ms.openlocfilehash: fab715f4d9365ee4c2f8b89d2e2e58768c25b671
ms.sourcegitcommit: 523283cc1b3c37c428e77850964dc1c33742c5f0
ms.translationtype: MT
ms.contentlocale: ko-KR
ms.lasthandoff: 10/06/2017
---
# <a name="how-tooconfigure-virtual-network-support-for-a-premium-azure-redis-cache"></a><span data-ttu-id="0dc9f-103">가상 네트워크를 tooconfigure Premium Azure Redis Cache에 대해 지원 되는 방법</span><span class="sxs-lookup"><span data-stu-id="0dc9f-103">How tooconfigure Virtual Network Support for a Premium Azure Redis Cache</span></span>
<span data-ttu-id="0dc9f-104">Azure Redis 캐시 캐시 크기 및 기능, 프리미엄 계층 기능 클러스터링, 지 속성 및 가상 네트워크 지원 등을 포함 하 여 hello 선택에서 유연성을 제공 하는 다른 캐시 기능에 있습니다.</span><span class="sxs-lookup"><span data-stu-id="0dc9f-104">Azure Redis Cache has different cache offerings, which provide flexibility in hello choice of cache size and features, including Premium tier features such as clustering, persistence, and virtual network support.</span></span> <span data-ttu-id="0dc9f-105">VNet은 hello 클라우드에서 개인 네트워크입니다.</span><span class="sxs-lookup"><span data-stu-id="0dc9f-105">A VNet is a private network in hello cloud.</span></span> <span data-ttu-id="0dc9f-106">Azure Redis Cache 인스턴스 VNet를 구성 된 경우 공개적으로 주소 지정 가능한 아니며 가상 컴퓨터 및 hello VNet 내에서 응용 프로그램에서 액세스할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="0dc9f-106">When an Azure Redis Cache instance is configured with a VNet, it is not publicly addressable and can only be accessed from virtual machines and applications within hello VNet.</span></span> <span data-ttu-id="0dc9f-107">이 문서에서는 tooconfigure 가상 네트워크는 프리미엄 Azure Redis 캐시 인스턴스에 대 한 지원 되는 방법을 설명 합니다.</span><span class="sxs-lookup"><span data-stu-id="0dc9f-107">This article describes how tooconfigure virtual network support for a premium Azure Redis Cache instance.</span></span>

> [!NOTE]
> <span data-ttu-id="0dc9f-108">Azure Redis Cache는 클래식 및 Resource Manager VNet을 둘 다 지원합니다.</span><span class="sxs-lookup"><span data-stu-id="0dc9f-108">Azure Redis Cache supports both classic and Resource Manager VNets.</span></span>
> 
> 

<span data-ttu-id="0dc9f-109">다른 프리미엄 캐시 기능에 대 한 자세한 내용은 참조 [toohello Azure Redis Cache 프리미엄 계층 소개](cache-premium-tier-intro.md)합니다.</span><span class="sxs-lookup"><span data-stu-id="0dc9f-109">For information on other premium cache features, see [Introduction toohello Azure Redis Cache Premium tier](cache-premium-tier-intro.md).</span></span>

## <a name="why-vnet"></a><span data-ttu-id="0dc9f-110">VNet을 사용하는 이유</span><span class="sxs-lookup"><span data-stu-id="0dc9f-110">Why VNet?</span></span>
<span data-ttu-id="0dc9f-111">[Azure 가상 네트워크 (VNet)](https://azure.microsoft.com/services/virtual-network/) 배포에서는 강화 된 보안 및 액세스 제어 정책 서브넷 뿐 Azure Redis Cache에 대 한 격리 및 기타 기능 toofurther 액세스를 제한 합니다.</span><span class="sxs-lookup"><span data-stu-id="0dc9f-111">[Azure Virtual Network (VNet)](https://azure.microsoft.com/services/virtual-network/) deployment provides enhanced security and isolation for your Azure Redis Cache, as well as subnets, access control policies, and other features toofurther restrict access.</span></span>

## <a name="virtual-network-support"></a><span data-ttu-id="0dc9f-112">가상 네트워크 지원</span><span class="sxs-lookup"><span data-stu-id="0dc9f-112">Virtual network support</span></span>
<span data-ttu-id="0dc9f-113">가상 네트워크 (VNet) 지원이 hello에 구성 된 **새 Redis 캐시** 블레이드 캐시 만들기 중입니다.</span><span class="sxs-lookup"><span data-stu-id="0dc9f-113">Virtual Network (VNet) support is configured on hello **New Redis Cache** blade during cache creation.</span></span> 

[!INCLUDE [redis-cache-create](../../includes/redis-cache-premium-create.md)]

<span data-ttu-id="0dc9f-114">Hello에 있는 VNet을 선택 하 여 Redis VNet 통합을 구성할 수는 프리미엄 가격 책정 계층을 선택 하면 동일한 구독 및 캐시에 위치 합니다.</span><span class="sxs-lookup"><span data-stu-id="0dc9f-114">Once you have selected a premium pricing tier, you can configure Redis VNet integration by selecting a VNet that is in hello same subscription and location as your cache.</span></span> <span data-ttu-id="0dc9f-115">toouse 새 VNet에 hello 단계에 따라 것을 먼저 만든 [hello Azure 포털을 사용 하 여 가상 네트워크를 만들고](../virtual-network/virtual-networks-create-vnet-arm-pportal.md) 또는 [hello Azure 포털을 사용 하 여 가상 네트워크 (클래식)를 만들](../virtual-network/virtual-networks-create-vnet-classic-pportal.md) toohello 다음 다시 돌아와 **새 Redis 캐시** 블레이드 toocreate 및 프리미엄 캐시를 구성 합니다.</span><span class="sxs-lookup"><span data-stu-id="0dc9f-115">toouse a new VNet, create it first by following hello steps in [Create a virtual network using hello Azure portal](../virtual-network/virtual-networks-create-vnet-arm-pportal.md) or [Create a virtual network (classic) by using hello Azure portal](../virtual-network/virtual-networks-create-vnet-classic-pportal.md) and then return toohello **New Redis Cache** blade toocreate and configure your premium cache.</span></span>

<span data-ttu-id="0dc9f-116">새 캐시에 대 한 tooconfigure hello VNet 클릭 **가상 네트워크** hello에 **새 Redis 캐시** 블레이드에서 하 고 선택 hello VNet hello 드롭 다운 목록에서 원하는 합니다.</span><span class="sxs-lookup"><span data-stu-id="0dc9f-116">tooconfigure hello VNet for your new cache, click **Virtual Network** on hello **New Redis Cache** blade, and select hello desired VNet from hello drop-down list.</span></span>

![가상 네트워크][redis-cache-vnet]

<span data-ttu-id="0dc9f-118">선택 hello hello에서 원하는 서브넷 **서브넷** 드롭 다운 목록 및 원하는 hello 지정 **고정 IP 주소**합니다.</span><span class="sxs-lookup"><span data-stu-id="0dc9f-118">Select hello desired subnet from hello **Subnet** drop-down list, and specify hello desired **Static IP address**.</span></span> <span data-ttu-id="0dc9f-119">클래식 VNet hello를 사용 하는 경우 **고정 IP 주소** 필드는 선택 사항이 고 지정 되지 않은 경우 선택한 hello 서브넷에서 선택 됩니다 하나입니다.</span><span class="sxs-lookup"><span data-stu-id="0dc9f-119">If you are using a classic VNet hello **Static IP address** field is optional, and if none is specified, one is chosen from hello selected subnet.</span></span>

> [!IMPORTANT]
> <span data-ttu-id="0dc9f-120">Azure Redis Cache tooa 리소스 관리자 VNet을 배포할 때는 hello 캐시 Azure Redis 캐시 인스턴스를 제외 하 고 다른 리소스가 없는 포함 하는 전용된 서브넷에 있어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="0dc9f-120">When deploying an Azure Redis Cache tooa Resource Manager VNet, hello cache must be in a dedicated subnet that contains no other resources except for Azure Redis Cache instances.</span></span> <span data-ttu-id="0dc9f-121">Toodeploy 하려고 시도 하는 경우 Azure Redis Cache tooa 다른 리소스, hello 배포를 포함 하는 리소스 관리자 VNet tooa 서브넷 실패 합니다.</span><span class="sxs-lookup"><span data-stu-id="0dc9f-121">If an attempt is made toodeploy an Azure Redis Cache tooa Resource Manager VNet tooa subnet that contains other resources, hello deployment fails.</span></span>
> 
> 

![가상 네트워크][redis-cache-vnet-ip]

> [!IMPORTANT]
> <span data-ttu-id="0dc9f-123">Azure는 각 서브넷 내의 일부 IP 주소를 예약하며, 이러한 주소는 사용할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="0dc9f-123">Azure reserves some IP addresses within each subnet, and these addresses can't be used.</span></span> <span data-ttu-id="0dc9f-124">hello hello 서브넷의 첫 번째 및 마지막 IP 주소가 예약 되어 Azure 서비스에 사용 되는 3 개 더 많은 주소와 함께 프로토콜 적합성을 위해 있습니다.</span><span class="sxs-lookup"><span data-stu-id="0dc9f-124">hello first and last IP addresses of hello subnets are reserved for protocol conformance, along with three more addresses used for Azure services.</span></span> <span data-ttu-id="0dc9f-125">자세한 내용은 [이러한 서브넷 내에서 IP 주소를 사용하는데 제한 사항이 있습니까?](../virtual-network/virtual-networks-faq.md#are-there-any-restrictions-on-using-ip-addresses-within-these-subnets)</span><span class="sxs-lookup"><span data-stu-id="0dc9f-125">For more information, see [Are there any restrictions on using IP addresses within these subnets?](../virtual-network/virtual-networks-faq.md#are-there-any-restrictions-on-using-ip-addresses-within-these-subnets)</span></span>
> 
> <span data-ttu-id="0dc9f-126">또한 toohello IP 주소에서 hello Azure VNET 인프라에서 사용 하는 각 Redis 영역당 hello 서브넷 2 사용 하 여 IP 주소 및 hello 부하 분산 장치에 대 한 하나의 추가 IP 주소 인스턴스.</span><span class="sxs-lookup"><span data-stu-id="0dc9f-126">In addition toohello IP addresses used by hello Azure VNET infrastructure, each Redis instance in hello subnet uses two IP addresses per shard and one additional IP address for hello load balancer.</span></span> <span data-ttu-id="0dc9f-127">클러스터 되지 않은 캐시 toohave 하나의 분할 영역으로 간주 됩니다.</span><span class="sxs-lookup"><span data-stu-id="0dc9f-127">A non-clustered cache is considered toohave one shard.</span></span>
> 
> 

<span data-ttu-id="0dc9f-128">Hello 캐시를 만든 후를 클릭 하 여 hello VNet에 대 한 hello 구성을 볼 수 있습니다 **가상 네트워크** hello에서 **리소스 메뉴**합니다.</span><span class="sxs-lookup"><span data-stu-id="0dc9f-128">After hello cache is created, you can view hello configuration for hello VNet by clicking **Virtual Network** from hello **Resource menu**.</span></span>

![가상 네트워크][redis-cache-vnet-info]

<span data-ttu-id="0dc9f-130">다음 예제는 hello와 같이 hello 연결 문자열에 hello 호스트 이름 캐시를 지정 하는 tooconnect tooyour Azure Redis 캐시 인스턴스에 VNet을 사용 하는 경우:</span><span class="sxs-lookup"><span data-stu-id="0dc9f-130">tooconnect tooyour Azure Redis cache instance when using a VNet, specify hello host name of your cache in hello connection string as shown in hello following example:</span></span>

    private static Lazy<ConnectionMultiplexer> lazyConnection = new Lazy<ConnectionMultiplexer>(() =>
    {
        return ConnectionMultiplexer.Connect("contoso5premium.redis.cache.windows.net,abortConnect=false,ssl=true,password=password");
    });

    public static ConnectionMultiplexer Connection
    {
        get
        {
            return lazyConnection.Value;
        }
    }

## <a name="azure-redis-cache-vnet-faq"></a><span data-ttu-id="0dc9f-131">Azure Redis Cache VNet FAQ</span><span class="sxs-lookup"><span data-stu-id="0dc9f-131">Azure Redis Cache VNet FAQ</span></span>
<span data-ttu-id="0dc9f-132">다음 목록 hello hello Azure Redis 캐시 크기 조정에 대 한 질문과 대답 toocommonly 포함 되어 있습니다.</span><span class="sxs-lookup"><span data-stu-id="0dc9f-132">hello following list contains answers toocommonly asked questions about hello Azure Redis Cache scaling.</span></span>

* [<span data-ttu-id="0dc9f-133">Azure Redis Cache 및 VNet의 몇 가지 일반적인 구성 오류 문제는 무엇인가요?</span><span class="sxs-lookup"><span data-stu-id="0dc9f-133">What are some common misconfiguration issues with Azure Redis Cache and VNets?</span></span>](#what-are-some-common-misconfiguration-issues-with-azure-redis-cache-and-vnets)
* [<span data-ttu-id="0dc9f-134">캐시가 VNET에서 작동하는지 확인하려면 어떻게 해야 하나요?</span><span class="sxs-lookup"><span data-stu-id="0dc9f-134">How can I verify that my cache is working in a VNET?</span></span>](#how-can-i-verify-that-my-cache-is-working-in-a-vnet)
* [<span data-ttu-id="0dc9f-135">표준 또는 기본 캐시에 VNet을 사용할 수 있나요?</span><span class="sxs-lookup"><span data-stu-id="0dc9f-135">Can I use VNets with a standard or basic cache?</span></span>](#can-i-use-vnets-with-a-standard-or-basic-cache)
* [<span data-ttu-id="0dc9f-136">일부 서브넷에서만 Redis Cache 생성이 실패하는 이유는 무엇인가요?</span><span class="sxs-lookup"><span data-stu-id="0dc9f-136">Why does creating a Redis cache fail in some subnets but not others?</span></span>](#why-does-creating-a-redis-cache-fail-in-some-subnets-but-not-others)
* [<span data-ttu-id="0dc9f-137">Hello 서브넷 주소 공간 요구 사항은 무엇입니까?</span><span class="sxs-lookup"><span data-stu-id="0dc9f-137">What are hello subnet address space requirements?</span></span>](#what-are-the-subnet-address-space-requirements)
* [<span data-ttu-id="0dc9f-138">VNET에서 캐시를 호스팅하는 경우 모든 캐시 기능이 작동하나요?</span><span class="sxs-lookup"><span data-stu-id="0dc9f-138">Do all cache features work when hosting a cache in a VNET?</span></span>](#do-all-cache-features-work-when-hosting-a-cache-in-a-vnet)

## <a name="what-are-some-common-misconfiguration-issues-with-azure-redis-cache-and-vnets"></a><span data-ttu-id="0dc9f-139">Azure Redis Cache 및 VNet의 몇 가지 일반적인 구성 오류 문제는 무엇인가요?</span><span class="sxs-lookup"><span data-stu-id="0dc9f-139">What are some common misconfiguration issues with Azure Redis Cache and VNets?</span></span>
<span data-ttu-id="0dc9f-140">Azure Redis Cache는 VNet에서 호스트 되는 경우 다음 표는 hello에 hello 포트 사용 됩니다.</span><span class="sxs-lookup"><span data-stu-id="0dc9f-140">When Azure Redis Cache is hosted in a VNet, hello ports in hello following tables are used.</span></span> 

>[!IMPORTANT]
><span data-ttu-id="0dc9f-141">다음 표에서 hello에서 hello 포트 차단 되 면 hello 캐시 제대로 작동 하지 않을 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="0dc9f-141">If hello ports in hello following tables are blocked, hello cache may not function correctly.</span></span> <span data-ttu-id="0dc9f-142">VNet에서 Azure Redis Cache를 사용 하는 경우 hello 가장 일반적인 구성 오류 문제는 하나 또는이 포트를 차단 합니다.</span><span class="sxs-lookup"><span data-stu-id="0dc9f-142">Having one or more of these ports blocked is hello most common misconfiguration issue when using Azure Redis Cache in a VNet.</span></span>
> 
> 

- [<span data-ttu-id="0dc9f-143">아웃바운드 포트 요구 사항</span><span class="sxs-lookup"><span data-stu-id="0dc9f-143">Outbound port requirements</span></span>](#outbound-port-requirements)
- [<span data-ttu-id="0dc9f-144">인바운드 포트 요구 사항</span><span class="sxs-lookup"><span data-stu-id="0dc9f-144">Inbound port requirements</span></span>](#inbound-port-requirements)

### <a name="outbound-port-requirements"></a><span data-ttu-id="0dc9f-145">아웃바운드 포트 요구 사항</span><span class="sxs-lookup"><span data-stu-id="0dc9f-145">Outbound port requirements</span></span>

<span data-ttu-id="0dc9f-146">7가지 아웃바운드 포트 요구 사항이 있습니다.</span><span class="sxs-lookup"><span data-stu-id="0dc9f-146">There are seven outbound port requirements.</span></span>

- <span data-ttu-id="0dc9f-147">원하는 경우 인터넷 클라이언트의를 통해 가능 모든 아웃 바운드 연결 toohello 온-프레미스 감사 장치입니다.</span><span class="sxs-lookup"><span data-stu-id="0dc9f-147">If desired, all outbound connections toohello internet can be made through a client's on-premises auditing device.</span></span>
- <span data-ttu-id="0dc9f-148">Azure 저장소 및 Azure DNS 서비스는 트래픽을 tooAzure 끝점 경로 hello 포트 중 3 개.</span><span class="sxs-lookup"><span data-stu-id="0dc9f-148">Three of hello ports route traffic tooAzure endpoints servicing Azure Storage and Azure DNS.</span></span>
- <span data-ttu-id="0dc9f-149">포트 범위를 남은 hello 및 내부 Redis 서브넷 통신에 대 한 합니다.</span><span class="sxs-lookup"><span data-stu-id="0dc9f-149">hello remaining port ranges and for internal Redis subnet communications.</span></span> <span data-ttu-id="0dc9f-150">내부 Redis 서브넷 통신에 필요한 서브넷 NSG 규칙은 없습니다.</span><span class="sxs-lookup"><span data-stu-id="0dc9f-150">No subnet NSG rules are required for internal Redis subnet communications.</span></span>

| <span data-ttu-id="0dc9f-151">포트</span><span class="sxs-lookup"><span data-stu-id="0dc9f-151">Port(s)</span></span> | <span data-ttu-id="0dc9f-152">방향</span><span class="sxs-lookup"><span data-stu-id="0dc9f-152">Direction</span></span> | <span data-ttu-id="0dc9f-153">전송 프로토콜</span><span class="sxs-lookup"><span data-stu-id="0dc9f-153">Transport Protocol</span></span> | <span data-ttu-id="0dc9f-154">목적</span><span class="sxs-lookup"><span data-stu-id="0dc9f-154">Purpose</span></span> | <span data-ttu-id="0dc9f-155">로컬 IP</span><span class="sxs-lookup"><span data-stu-id="0dc9f-155">Local IP</span></span> | <span data-ttu-id="0dc9f-156">원격 IP</span><span class="sxs-lookup"><span data-stu-id="0dc9f-156">Remote IP</span></span> |
| --- | --- | --- | --- | --- | --- |
| <span data-ttu-id="0dc9f-157">80, 443</span><span class="sxs-lookup"><span data-stu-id="0dc9f-157">80, 443</span></span> |<span data-ttu-id="0dc9f-158">아웃바운드</span><span class="sxs-lookup"><span data-stu-id="0dc9f-158">Outbound</span></span> |<span data-ttu-id="0dc9f-159">TCP</span><span class="sxs-lookup"><span data-stu-id="0dc9f-159">TCP</span></span> |<span data-ttu-id="0dc9f-160">Azure 저장소/PKI(인터넷)에 대한 Redis 종속성</span><span class="sxs-lookup"><span data-stu-id="0dc9f-160">Redis dependencies on Azure Storage/PKI (Internet)</span></span> | <span data-ttu-id="0dc9f-161">(Redis 서브넷)</span><span class="sxs-lookup"><span data-stu-id="0dc9f-161">(Redis subnet)</span></span> |* |
| <span data-ttu-id="0dc9f-162">53</span><span class="sxs-lookup"><span data-stu-id="0dc9f-162">53</span></span> |<span data-ttu-id="0dc9f-163">아웃바운드</span><span class="sxs-lookup"><span data-stu-id="0dc9f-163">Outbound</span></span> |<span data-ttu-id="0dc9f-164">TCP/UDP</span><span class="sxs-lookup"><span data-stu-id="0dc9f-164">TCP/UDP</span></span> |<span data-ttu-id="0dc9f-165">DNS(인터넷/VNet)에 대한 Redis 종속성</span><span class="sxs-lookup"><span data-stu-id="0dc9f-165">Redis dependencies on DNS (Internet/VNet)</span></span> | <span data-ttu-id="0dc9f-166">(Redis 서브넷)</span><span class="sxs-lookup"><span data-stu-id="0dc9f-166">(Redis subnet)</span></span> |* |
| <span data-ttu-id="0dc9f-167">8443</span><span class="sxs-lookup"><span data-stu-id="0dc9f-167">8443</span></span> |<span data-ttu-id="0dc9f-168">아웃바운드</span><span class="sxs-lookup"><span data-stu-id="0dc9f-168">Outbound</span></span> |<span data-ttu-id="0dc9f-169">TCP</span><span class="sxs-lookup"><span data-stu-id="0dc9f-169">TCP</span></span> |<span data-ttu-id="0dc9f-170">Redis에 대한 내부 통신</span><span class="sxs-lookup"><span data-stu-id="0dc9f-170">Internal communications for Redis</span></span> | <span data-ttu-id="0dc9f-171">(Redis 서브넷)</span><span class="sxs-lookup"><span data-stu-id="0dc9f-171">(Redis subnet)</span></span> | <span data-ttu-id="0dc9f-172">(Redis 서브넷)</span><span class="sxs-lookup"><span data-stu-id="0dc9f-172">(Redis subnet)</span></span> |
| <span data-ttu-id="0dc9f-173">10221-10231</span><span class="sxs-lookup"><span data-stu-id="0dc9f-173">10221-10231</span></span> |<span data-ttu-id="0dc9f-174">아웃바운드</span><span class="sxs-lookup"><span data-stu-id="0dc9f-174">Outbound</span></span> |<span data-ttu-id="0dc9f-175">TCP</span><span class="sxs-lookup"><span data-stu-id="0dc9f-175">TCP</span></span> |<span data-ttu-id="0dc9f-176">Redis에 대한 내부 통신</span><span class="sxs-lookup"><span data-stu-id="0dc9f-176">Internal communications for Redis</span></span> | <span data-ttu-id="0dc9f-177">(Redis 서브넷)</span><span class="sxs-lookup"><span data-stu-id="0dc9f-177">(Redis subnet)</span></span> | <span data-ttu-id="0dc9f-178">(Redis 서브넷)</span><span class="sxs-lookup"><span data-stu-id="0dc9f-178">(Redis subnet)</span></span> |
| <span data-ttu-id="0dc9f-179">20226</span><span class="sxs-lookup"><span data-stu-id="0dc9f-179">20226</span></span> |<span data-ttu-id="0dc9f-180">아웃바운드</span><span class="sxs-lookup"><span data-stu-id="0dc9f-180">Outbound</span></span> |<span data-ttu-id="0dc9f-181">TCP</span><span class="sxs-lookup"><span data-stu-id="0dc9f-181">TCP</span></span> |<span data-ttu-id="0dc9f-182">Redis에 대한 내부 통신</span><span class="sxs-lookup"><span data-stu-id="0dc9f-182">Internal communications for Redis</span></span> | <span data-ttu-id="0dc9f-183">(Redis 서브넷)</span><span class="sxs-lookup"><span data-stu-id="0dc9f-183">(Redis subnet)</span></span> |<span data-ttu-id="0dc9f-184">(Redis 서브넷)</span><span class="sxs-lookup"><span data-stu-id="0dc9f-184">(Redis subnet)</span></span> |
| <span data-ttu-id="0dc9f-185">13000-13999</span><span class="sxs-lookup"><span data-stu-id="0dc9f-185">13000-13999</span></span> |<span data-ttu-id="0dc9f-186">아웃바운드</span><span class="sxs-lookup"><span data-stu-id="0dc9f-186">Outbound</span></span> |<span data-ttu-id="0dc9f-187">TCP</span><span class="sxs-lookup"><span data-stu-id="0dc9f-187">TCP</span></span> |<span data-ttu-id="0dc9f-188">Redis에 대한 내부 통신</span><span class="sxs-lookup"><span data-stu-id="0dc9f-188">Internal communications for Redis</span></span> | <span data-ttu-id="0dc9f-189">(Redis 서브넷)</span><span class="sxs-lookup"><span data-stu-id="0dc9f-189">(Redis subnet)</span></span> |<span data-ttu-id="0dc9f-190">(Redis 서브넷)</span><span class="sxs-lookup"><span data-stu-id="0dc9f-190">(Redis subnet)</span></span> |
| <span data-ttu-id="0dc9f-191">15000-15999</span><span class="sxs-lookup"><span data-stu-id="0dc9f-191">15000-15999</span></span> |<span data-ttu-id="0dc9f-192">아웃바운드</span><span class="sxs-lookup"><span data-stu-id="0dc9f-192">Outbound</span></span> |<span data-ttu-id="0dc9f-193">TCP</span><span class="sxs-lookup"><span data-stu-id="0dc9f-193">TCP</span></span> |<span data-ttu-id="0dc9f-194">Redis에 대한 내부 통신</span><span class="sxs-lookup"><span data-stu-id="0dc9f-194">Internal communications for Redis</span></span> | <span data-ttu-id="0dc9f-195">(Redis 서브넷)</span><span class="sxs-lookup"><span data-stu-id="0dc9f-195">(Redis subnet)</span></span> |<span data-ttu-id="0dc9f-196">(Redis 서브넷)</span><span class="sxs-lookup"><span data-stu-id="0dc9f-196">(Redis subnet)</span></span> |


### <a name="inbound-port-requirements"></a><span data-ttu-id="0dc9f-197">인바운드 포트 요구 사항</span><span class="sxs-lookup"><span data-stu-id="0dc9f-197">Inbound port requirements</span></span>

<span data-ttu-id="0dc9f-198">8개의 인바운드 포트 범위 요구 사항이 있습니다.</span><span class="sxs-lookup"><span data-stu-id="0dc9f-198">There are eight inbound port range requirements.</span></span> <span data-ttu-id="0dc9f-199">이 범위에 대 한 인바운드 요청은 인바운드 hello에서 호스팅되는 다른 서비스를 같은 VNET 또는 내부 toohello Redis 서브넷 통신 합니다.</span><span class="sxs-lookup"><span data-stu-id="0dc9f-199">Inbound requests in these ranges are either inbound from other services hosted in hello same VNET or internal toohello Redis subnet communications.</span></span>

| <span data-ttu-id="0dc9f-200">포트</span><span class="sxs-lookup"><span data-stu-id="0dc9f-200">Port(s)</span></span> | <span data-ttu-id="0dc9f-201">방향</span><span class="sxs-lookup"><span data-stu-id="0dc9f-201">Direction</span></span> | <span data-ttu-id="0dc9f-202">전송 프로토콜</span><span class="sxs-lookup"><span data-stu-id="0dc9f-202">Transport Protocol</span></span> | <span data-ttu-id="0dc9f-203">목적</span><span class="sxs-lookup"><span data-stu-id="0dc9f-203">Purpose</span></span> | <span data-ttu-id="0dc9f-204">로컬 IP</span><span class="sxs-lookup"><span data-stu-id="0dc9f-204">Local IP</span></span> | <span data-ttu-id="0dc9f-205">원격 IP</span><span class="sxs-lookup"><span data-stu-id="0dc9f-205">Remote IP</span></span> |
| --- | --- | --- | --- | --- | --- |
| <span data-ttu-id="0dc9f-206">6379, 6380</span><span class="sxs-lookup"><span data-stu-id="0dc9f-206">6379, 6380</span></span> |<span data-ttu-id="0dc9f-207">인바운드</span><span class="sxs-lookup"><span data-stu-id="0dc9f-207">Inbound</span></span> |<span data-ttu-id="0dc9f-208">TCP</span><span class="sxs-lookup"><span data-stu-id="0dc9f-208">TCP</span></span> |<span data-ttu-id="0dc9f-209">클라이언트 통신 tooRedis Azure 부하 분산</span><span class="sxs-lookup"><span data-stu-id="0dc9f-209">Client communication tooRedis, Azure load balancing</span></span> | <span data-ttu-id="0dc9f-210">(Redis 서브넷)</span><span class="sxs-lookup"><span data-stu-id="0dc9f-210">(Redis subnet)</span></span> |<span data-ttu-id="0dc9f-211">가상 네트워크, Azure Load Balancer</span><span class="sxs-lookup"><span data-stu-id="0dc9f-211">Virtual Network, Azure Load Balancer</span></span> |
| <span data-ttu-id="0dc9f-212">8443</span><span class="sxs-lookup"><span data-stu-id="0dc9f-212">8443</span></span> |<span data-ttu-id="0dc9f-213">인바운드</span><span class="sxs-lookup"><span data-stu-id="0dc9f-213">Inbound</span></span> |<span data-ttu-id="0dc9f-214">TCP</span><span class="sxs-lookup"><span data-stu-id="0dc9f-214">TCP</span></span> |<span data-ttu-id="0dc9f-215">Redis에 대한 내부 통신</span><span class="sxs-lookup"><span data-stu-id="0dc9f-215">Internal communications for Redis</span></span> | <span data-ttu-id="0dc9f-216">(Redis 서브넷)</span><span class="sxs-lookup"><span data-stu-id="0dc9f-216">(Redis subnet)</span></span> |<span data-ttu-id="0dc9f-217">(Redis 서브넷)</span><span class="sxs-lookup"><span data-stu-id="0dc9f-217">(Redis subnet)</span></span> |
| <span data-ttu-id="0dc9f-218">8500</span><span class="sxs-lookup"><span data-stu-id="0dc9f-218">8500</span></span> |<span data-ttu-id="0dc9f-219">인바운드</span><span class="sxs-lookup"><span data-stu-id="0dc9f-219">Inbound</span></span> |<span data-ttu-id="0dc9f-220">TCP/UDP</span><span class="sxs-lookup"><span data-stu-id="0dc9f-220">TCP/UDP</span></span> |<span data-ttu-id="0dc9f-221">Azure 부하 분산</span><span class="sxs-lookup"><span data-stu-id="0dc9f-221">Azure load balancing</span></span> | <span data-ttu-id="0dc9f-222">(Redis 서브넷)</span><span class="sxs-lookup"><span data-stu-id="0dc9f-222">(Redis subnet)</span></span> |<span data-ttu-id="0dc9f-223">Azure Load Balancer</span><span class="sxs-lookup"><span data-stu-id="0dc9f-223">Azure Load Balancer</span></span> |
| <span data-ttu-id="0dc9f-224">10221-10231</span><span class="sxs-lookup"><span data-stu-id="0dc9f-224">10221-10231</span></span> |<span data-ttu-id="0dc9f-225">인바운드</span><span class="sxs-lookup"><span data-stu-id="0dc9f-225">Inbound</span></span> |<span data-ttu-id="0dc9f-226">TCP</span><span class="sxs-lookup"><span data-stu-id="0dc9f-226">TCP</span></span> |<span data-ttu-id="0dc9f-227">Redis에 대한 내부 통신</span><span class="sxs-lookup"><span data-stu-id="0dc9f-227">Internal communications for Redis</span></span> | <span data-ttu-id="0dc9f-228">(Redis 서브넷)</span><span class="sxs-lookup"><span data-stu-id="0dc9f-228">(Redis subnet)</span></span> |<span data-ttu-id="0dc9f-229">(Redis 서브넷), Azure Load Balancer</span><span class="sxs-lookup"><span data-stu-id="0dc9f-229">(Redis subnet), Azure Load Balancer</span></span> |
| <span data-ttu-id="0dc9f-230">13000-13999</span><span class="sxs-lookup"><span data-stu-id="0dc9f-230">13000-13999</span></span> |<span data-ttu-id="0dc9f-231">인바운드</span><span class="sxs-lookup"><span data-stu-id="0dc9f-231">Inbound</span></span> |<span data-ttu-id="0dc9f-232">TCP</span><span class="sxs-lookup"><span data-stu-id="0dc9f-232">TCP</span></span> |<span data-ttu-id="0dc9f-233">클라이언트 통신 tooRedis Azure 부하 분산 클러스터</span><span class="sxs-lookup"><span data-stu-id="0dc9f-233">Client communication tooRedis Clusters, Azure load balancing</span></span> | <span data-ttu-id="0dc9f-234">(Redis 서브넷)</span><span class="sxs-lookup"><span data-stu-id="0dc9f-234">(Redis subnet)</span></span> |<span data-ttu-id="0dc9f-235">가상 네트워크, Azure Load Balancer</span><span class="sxs-lookup"><span data-stu-id="0dc9f-235">Virtual Network, Azure Load Balancer</span></span> |
| <span data-ttu-id="0dc9f-236">15000-15999</span><span class="sxs-lookup"><span data-stu-id="0dc9f-236">15000-15999</span></span> |<span data-ttu-id="0dc9f-237">인바운드</span><span class="sxs-lookup"><span data-stu-id="0dc9f-237">Inbound</span></span> |<span data-ttu-id="0dc9f-238">TCP</span><span class="sxs-lookup"><span data-stu-id="0dc9f-238">TCP</span></span> |<span data-ttu-id="0dc9f-239">클라이언트 통신 tooRedis 클러스터의 경우 Azure 부하 분산</span><span class="sxs-lookup"><span data-stu-id="0dc9f-239">Client communication tooRedis Clusters, Azure load Balancing</span></span> | <span data-ttu-id="0dc9f-240">(Redis 서브넷)</span><span class="sxs-lookup"><span data-stu-id="0dc9f-240">(Redis subnet)</span></span> |<span data-ttu-id="0dc9f-241">가상 네트워크, Azure Load Balancer</span><span class="sxs-lookup"><span data-stu-id="0dc9f-241">Virtual Network, Azure Load Balancer</span></span> |
| <span data-ttu-id="0dc9f-242">16001</span><span class="sxs-lookup"><span data-stu-id="0dc9f-242">16001</span></span> |<span data-ttu-id="0dc9f-243">인바운드</span><span class="sxs-lookup"><span data-stu-id="0dc9f-243">Inbound</span></span> |<span data-ttu-id="0dc9f-244">TCP/UDP</span><span class="sxs-lookup"><span data-stu-id="0dc9f-244">TCP/UDP</span></span> |<span data-ttu-id="0dc9f-245">Azure 부하 분산</span><span class="sxs-lookup"><span data-stu-id="0dc9f-245">Azure load balancing</span></span> | <span data-ttu-id="0dc9f-246">(Redis 서브넷)</span><span class="sxs-lookup"><span data-stu-id="0dc9f-246">(Redis subnet)</span></span> |<span data-ttu-id="0dc9f-247">Azure Load Balancer</span><span class="sxs-lookup"><span data-stu-id="0dc9f-247">Azure Load Balancer</span></span> |
| <span data-ttu-id="0dc9f-248">20226</span><span class="sxs-lookup"><span data-stu-id="0dc9f-248">20226</span></span> |<span data-ttu-id="0dc9f-249">인바운드</span><span class="sxs-lookup"><span data-stu-id="0dc9f-249">Inbound</span></span> |<span data-ttu-id="0dc9f-250">TCP</span><span class="sxs-lookup"><span data-stu-id="0dc9f-250">TCP</span></span> |<span data-ttu-id="0dc9f-251">Redis에 대한 내부 통신</span><span class="sxs-lookup"><span data-stu-id="0dc9f-251">Internal communications for Redis</span></span> | <span data-ttu-id="0dc9f-252">(Redis 서브넷)</span><span class="sxs-lookup"><span data-stu-id="0dc9f-252">(Redis subnet)</span></span> |<span data-ttu-id="0dc9f-253">(Redis 서브넷)</span><span class="sxs-lookup"><span data-stu-id="0dc9f-253">(Redis subnet)</span></span> |

### <a name="additional-vnet-network-connectivity-requirements"></a><span data-ttu-id="0dc9f-254">추가 VNET 네트워크 연결 요구 사항</span><span class="sxs-lookup"><span data-stu-id="0dc9f-254">Additional VNET network connectivity requirements</span></span>

<span data-ttu-id="0dc9f-255">가상 네트워크에서 처음에 충족되지 않는 Azure Redis Cache에 대한 네트워크 연결 요구 사항이 있습니다.</span><span class="sxs-lookup"><span data-stu-id="0dc9f-255">There are network connectivity requirements for Azure Redis Cache that may not be initially met in a virtual network.</span></span> <span data-ttu-id="0dc9f-256">Azure Redis Cache는 가상 네트워크에서 사용 될 때 제대로 항목 toofunction 다음 hello 모두 필요 합니다.</span><span class="sxs-lookup"><span data-stu-id="0dc9f-256">Azure Redis Cache requires all hello following items toofunction properly when used within a virtual network.</span></span>

* <span data-ttu-id="0dc9f-257">아웃 바운드 네트워크 연결 tooAzure 저장소 끝점 전 세계입니다.</span><span class="sxs-lookup"><span data-stu-id="0dc9f-257">Outbound network connectivity tooAzure Storage endpoints worldwide.</span></span> <span data-ttu-id="0dc9f-258">Hello에 있는 끝점 여기에 동일한 지역에 있는 저장소 끝점 뿐만 아니라 hello Azure Redis Cache 인스턴스 **다른** Azure 지역입니다.</span><span class="sxs-lookup"><span data-stu-id="0dc9f-258">This includes endpoints located in hello same region as hello Azure Redis Cache instance, as well as storage endpoints located in **other** Azure regions.</span></span> <span data-ttu-id="0dc9f-259">Azure 저장소 끝점 hello 다음 DNS 도메인에서 해결: *table.core.windows.net*, *blob.core.windows.net*, *queue.core.windows.net*, 및 *file.core.windows.net*합니다.</span><span class="sxs-lookup"><span data-stu-id="0dc9f-259">Azure Storage endpoints resolve under hello following DNS domains: *table.core.windows.net*, *blob.core.windows.net*, *queue.core.windows.net*, and *file.core.windows.net*.</span></span> 
* <span data-ttu-id="0dc9f-260">아웃 바운드 네트워크 연결이 너무*ocsp.msocsp.com*, *mscrl.microsoft.com*, 및 *crl.microsoft.com*합니다. 이 연결이 필요한 toosupport SSL 기능에 설명 합니다.</span><span class="sxs-lookup"><span data-stu-id="0dc9f-260">Outbound network connectivity too*ocsp.msocsp.com*, *mscrl.microsoft.com*, and *crl.microsoft.com*. This connectivity is needed toosupport SSL functionality.</span></span>
* <span data-ttu-id="0dc9f-261">hello 가상 네트워크에 대 한 DNS 구성을 hello 모든 hello 끝점 확인 가능한 수 있어야 하며 도메인에 언급 된 hello 이전 포인트입니다.</span><span class="sxs-lookup"><span data-stu-id="0dc9f-261">hello DNS configuration for hello virtual network must be capable of resolving all of hello endpoints and domains mentioned in hello earlier points.</span></span> <span data-ttu-id="0dc9f-262">유효한 DNS 인프라를 구성 하 고 hello 가상 네트워크에 대 한 유지 관리 함으로써 이러한 DNS 요구 사항은 충족할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="0dc9f-262">These DNS requirements can be met by ensuring a valid DNS infrastructure is configured and maintained for hello virtual network.</span></span>
* <span data-ttu-id="0dc9f-263">다음 DNS 도메인 hello에서 해결 하는 Azure 모니터링 끝점을 다음 아웃 바운드 네트워크 연결 toohello: shoebox2 black.shoebox2.metrics.nsatc.net, 북부-prod2.prod2.metrics.nsatc.net azglobal black.azglobal.metrics.nsatc.net, shoebox2-red.shoebox2.metrics.nsatc.net 동부-prod2.prod2.metrics.nsatc.net azglobal red.azglobal.metrics.nsatc.net 합니다.</span><span class="sxs-lookup"><span data-stu-id="0dc9f-263">Outbound network connectivity toohello following Azure Monitoring endpoints, which resolve under hello following DNS domains: shoebox2-black.shoebox2.metrics.nsatc.net, north-prod2.prod2.metrics.nsatc.net, azglobal-black.azglobal.metrics.nsatc.net, shoebox2-red.shoebox2.metrics.nsatc.net, east-prod2.prod2.metrics.nsatc.net, azglobal-red.azglobal.metrics.nsatc.net.</span></span>

### <a name="how-can-i-verify-that-my-cache-is-working-in-a-vnet"></a><span data-ttu-id="0dc9f-264">캐시가 VNET에서 작동하는지 확인하려면 어떻게 해야 하나요?</span><span class="sxs-lookup"><span data-stu-id="0dc9f-264">How can I verify that my cache is working in a VNET?</span></span>

>[!IMPORTANT]
><span data-ttu-id="0dc9f-265">VNET에 호스트 된 tooan Azure Redis 캐시 인스턴스를 연결할 때 캐시 클라이언트에 있어야 합니다. 모든 테스트 응용 프로그램 또는 핑 진단 도구를 포함 하 여 동일한 VNET hello 합니다.</span><span class="sxs-lookup"><span data-stu-id="0dc9f-265">When connecting tooan Azure Redis Cache instance that is hosted in a VNET, your cache clients must be in hello same VNET, including any test applications or diagnostic pinging tools.</span></span>
>
>

<span data-ttu-id="0dc9f-266">Hello 포트 요구 사항 hello 이전 섹션에 설명 된 대로 구성 되 면 캐시 hello 다음 단계를 수행 하 여 작동 하는지 확인할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="0dc9f-266">Once hello port requirements are configured as described in hello previous section, you can verify that your cache is working by performing hello following steps.</span></span>

- <span data-ttu-id="0dc9f-267">[다시 부팅](cache-administration.md#reboot) hello의 모든 노드를 캐시 합니다.</span><span class="sxs-lookup"><span data-stu-id="0dc9f-267">[Reboot](cache-administration.md#reboot) all of hello cache nodes.</span></span> <span data-ttu-id="0dc9f-268">Hello의 모든 필수 캐시 종속성에 연결할 수 없습니다 (에 설명 된 대로 [인바운드 포트 요구 사항](cache-how-to-premium-vnet.md#inbound-port-requirements) 및 [아웃 바운드 포트 요구 사항](cache-how-to-premium-vnet.md#outbound-port-requirements)), hello 캐시 수 toorestart를 확인할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="0dc9f-268">If all of hello required cache dependencies can't be reached (as documented in [Inbound port requirements](cache-how-to-premium-vnet.md#inbound-port-requirements) and [Outbound port requirements](cache-how-to-premium-vnet.md#outbound-port-requirements)), hello cache won't be able toorestart successfully.</span></span>
- <span data-ttu-id="0dc9f-269">Hello 캐시 노드를 다시 시작한 (대로 hello Azure 포털에서에서 hello 캐시 상태 보고) 되 면 hello 다음 테스트를 수행할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="0dc9f-269">Once hello cache nodes have restarted (as reported by hello cache status in hello Azure portal), you can perform hello following tests:</span></span>
  - <span data-ttu-id="0dc9f-270">hello 캐시 끝점 (포트 6380 사용) hello 내에 있는 컴퓨터에서 ping 동일한 VNET hello로 사용 하 여 캐시 [tcping](https://www.elifulkerson.com/projects/tcping.php)합니다.</span><span class="sxs-lookup"><span data-stu-id="0dc9f-270">ping hello cache endpoint (using port 6380) from a machine that is within hello same VNET as hello cache, using [tcping](https://www.elifulkerson.com/projects/tcping.php).</span></span> <span data-ttu-id="0dc9f-271">예:</span><span class="sxs-lookup"><span data-stu-id="0dc9f-271">For example:</span></span>
    
    `tcping.exe contosocache.redis.cache.windows.net 6380`
    
    <span data-ttu-id="0dc9f-272">경우 hello `tcping` hello 포트가 열려, hello 캐시는 hello VNET에 있는 클라이언트에서 연결에 사용할 수 있는 도구를 보고 합니다.</span><span class="sxs-lookup"><span data-stu-id="0dc9f-272">If hello `tcping` tool reports that hello port is open, hello cache is available for connection from clients in hello VNET.</span></span>

  - <span data-ttu-id="0dc9f-273">또 다른 방법은 tootest toocreate 테스트 캐시 클라이언트는 (간단한 될 수 있는 StackExchange.Redis를 사용 하 여 콘솔 응용 프로그램) toohello 캐시 연결 하 고 추가 하 고 hello 캐시에서 일부 항목을 검색 합니다.</span><span class="sxs-lookup"><span data-stu-id="0dc9f-273">Another way tootest is toocreate a test cache client (which could be a simple console application using StackExchange.Redis) that connects toohello cache and adds and retrieves some items from hello cache.</span></span> <span data-ttu-id="0dc9f-274">Hello 샘플 클라이언트 응용 프로그램에 있는 VM에 설치 hello 캐시로 동일한 VNET hello 및 tooverify 연결 toohello 캐시를 실행 합니다.</span><span class="sxs-lookup"><span data-stu-id="0dc9f-274">Install hello sample client application onto a VM that is in hello same VNET as hello cache and run it tooverify connectivity toohello cache.</span></span>


### <a name="can-i-use-vnets-with-a-standard-or-basic-cache"></a><span data-ttu-id="0dc9f-275">표준 또는 기본 캐시에 VNet을 사용할 수 있나요?</span><span class="sxs-lookup"><span data-stu-id="0dc9f-275">Can I use VNets with a standard or basic cache?</span></span>
<span data-ttu-id="0dc9f-276">VNet은 프리미엄 캐시에만 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="0dc9f-276">VNets can only be used with premium caches.</span></span>

### <a name="why-does-creating-a-redis-cache-fail-in-some-subnets-but-not-others"></a><span data-ttu-id="0dc9f-277">일부 서브넷에서만 Redis Cache 생성이 실패하는 이유는 무엇인가요?</span><span class="sxs-lookup"><span data-stu-id="0dc9f-277">Why does creating a Redis cache fail in some subnets but not others?</span></span>
<span data-ttu-id="0dc9f-278">Azure Redis Cache tooa 리소스 관리자 VNet에 배포 하는 경우에 hello 캐시 다른 리소스 형식을 포함 하는 전용된 서브넷에 있어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="0dc9f-278">If you are deploying an Azure Redis Cache tooa Resource Manager VNet, hello cache must be in a dedicated subnet that contains no other resource type.</span></span> <span data-ttu-id="0dc9f-279">Toodeploy 하려고 시도 하는 경우 Azure Redis Cache tooa 다른 리소스, hello 배포를 포함 하는 리소스 관리자 VNet 서브넷 실패 합니다.</span><span class="sxs-lookup"><span data-stu-id="0dc9f-279">If an attempt is made toodeploy an Azure Redis Cache tooa Resource Manager VNet subnet that contains other resources, hello deployment fails.</span></span> <span data-ttu-id="0dc9f-280">새 Redis 캐시를 만들기 전에 hello hello 서브넷 내의 기존 리소스를 삭제 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="0dc9f-280">You must delete hello existing resources inside hello subnet before you can create a new Redis cache.</span></span>

<span data-ttu-id="0dc9f-281">여러 유형을 배포할 수의 리소스 tooa 클래식 VNet으로 충분 한 IP는 사용할 수 있는 주소입니다.</span><span class="sxs-lookup"><span data-stu-id="0dc9f-281">You can deploy multiple types of resources tooa classic VNet as long as you have enough IP addresses available.</span></span>

### <a name="what-are-hello-subnet-address-space-requirements"></a><span data-ttu-id="0dc9f-282">Hello 서브넷 주소 공간 요구 사항은 무엇입니까?</span><span class="sxs-lookup"><span data-stu-id="0dc9f-282">What are hello subnet address space requirements?</span></span>
<span data-ttu-id="0dc9f-283">Azure는 각 서브넷 내의 일부 IP 주소를 예약하며, 이러한 주소는 사용할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="0dc9f-283">Azure reserves some IP addresses within each subnet, and these addresses can't be used.</span></span> <span data-ttu-id="0dc9f-284">hello hello 서브넷의 첫 번째 및 마지막 IP 주소가 예약 되어 Azure 서비스에 사용 되는 3 개 더 많은 주소와 함께 프로토콜 적합성을 위해 있습니다.</span><span class="sxs-lookup"><span data-stu-id="0dc9f-284">hello first and last IP addresses of hello subnets are reserved for protocol conformance, along with three more addresses used for Azure services.</span></span> <span data-ttu-id="0dc9f-285">자세한 내용은 [이러한 서브넷 내에서 IP 주소를 사용하는데 제한 사항이 있습니까?](../virtual-network/virtual-networks-faq.md#are-there-any-restrictions-on-using-ip-addresses-within-these-subnets)</span><span class="sxs-lookup"><span data-stu-id="0dc9f-285">For more information, see [Are there any restrictions on using IP addresses within these subnets?](../virtual-network/virtual-networks-faq.md#are-there-any-restrictions-on-using-ip-addresses-within-these-subnets)</span></span>

<span data-ttu-id="0dc9f-286">또한 toohello IP 주소에서 hello Azure VNET 인프라에서 사용 하는 각 Redis 영역당 hello 서브넷 2 사용 하 여 IP 주소 및 hello 부하 분산 장치에 대 한 하나의 추가 IP 주소 인스턴스.</span><span class="sxs-lookup"><span data-stu-id="0dc9f-286">In addition toohello IP addresses used by hello Azure VNET infrastructure, each Redis instance in hello subnet uses two IP addresses per shard and one additional IP address for hello load balancer.</span></span> <span data-ttu-id="0dc9f-287">클러스터 되지 않은 캐시 toohave 하나의 분할 영역으로 간주 됩니다.</span><span class="sxs-lookup"><span data-stu-id="0dc9f-287">A non-clustered cache is considered toohave one shard.</span></span>

### <a name="do-all-cache-features-work-when-hosting-a-cache-in-a-vnet"></a><span data-ttu-id="0dc9f-288">VNET에서 캐시를 호스팅하는 경우 모든 캐시 기능이 작동하나요?</span><span class="sxs-lookup"><span data-stu-id="0dc9f-288">Do all cache features work when hosting a cache in a VNET?</span></span>
<span data-ttu-id="0dc9f-289">캐시는 VNET의 일부 이면 hello 캐시 hello VNET에서에서 클라이언트에만 액세스할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="0dc9f-289">When your cache is part of a VNET, only clients in hello VNET can access hello cache.</span></span> <span data-ttu-id="0dc9f-290">결과적으로, hello 다음 캐시 관리 기능이 작동 하지 않는이 이번에 있습니다.</span><span class="sxs-lookup"><span data-stu-id="0dc9f-290">As a result, hello following cache management features don't work at this time.</span></span>

* <span data-ttu-id="0dc9f-291">Redis 콘솔-tooyour 캐시 Redis 콘솔 hello VNET 외부에 있는 로컬 브라우저에서 실행 되기 때문에 연결할 수 없는 합니다.</span><span class="sxs-lookup"><span data-stu-id="0dc9f-291">Redis Console - Because Redis Console runs in your local browser, which is outside hello VNET, it can't connect tooyour cache.</span></span>

## <a name="use-expressroute-with-azure-redis-cache"></a><span data-ttu-id="0dc9f-292">Azure Redis Cache에서 Express 경로 사용</span><span class="sxs-lookup"><span data-stu-id="0dc9f-292">Use ExpressRoute with Azure Redis Cache</span></span>
<span data-ttu-id="0dc9f-293">고객 연결할 수는 [Azure ExpressRoute](https://azure.microsoft.com/services/expressroute/) 회로 tootheir 가상 네트워크 인프라를 해당 온-프레미스 네트워크 tooAzure 기능을 확장할 합니다.</span><span class="sxs-lookup"><span data-stu-id="0dc9f-293">Customers can connect an [Azure ExpressRoute](https://azure.microsoft.com/services/expressroute/) circuit tootheir virtual network infrastructure, thus extending their on-premises network tooAzure.</span></span> 

<span data-ttu-id="0dc9f-294">기본적으로 새로 만든 ExpressRoute 회로는 VNET에서 강제 터널링(0.0.0.0/0 기본 경로 보급 알림)을 수행하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="0dc9f-294">By default, a newly created ExpressRoute circuit does not perform forced tunneling (advertisement of a default route, 0.0.0.0/0) on a VNET.</span></span> <span data-ttu-id="0dc9f-295">따라서 아웃 바운드 인터넷 연결 hello VNET에서 직접 수 있으며 클라이언트 응용 프로그램은 Azure 수 tooconnect tooother 끝점 Azure Redis Cache를 포함 합니다.</span><span class="sxs-lookup"><span data-stu-id="0dc9f-295">As a result, outbound Internet connectivity is allowed directly from hello VNET and client applications are able tooconnect tooother Azure endpoints including Azure Redis Cache.</span></span>

<span data-ttu-id="0dc9f-296">그러나 일반적인 고객 구성은 강제 터널링 toouse (기본 경로 보급)는 아웃 바운드 인터넷 트래픽을 tooinstead 흐름 온-프레미스를 강제로 수행 합니다.</span><span class="sxs-lookup"><span data-stu-id="0dc9f-296">However a common customer configuration is toouse forced tunneling (advertise a default route) which forces outbound Internet traffic tooinstead flow on-premises.</span></span> <span data-ttu-id="0dc9f-297">이 트래픽 흐름 hello 아웃 바운드 트래픽이 되는 경우 Azure Redis Cache와의 연결을 중단 한 다음을 hello Azure Redis 캐시 인스턴스에 없는 종속성과 함께 수 toocommunicate 온-프레미스를 차단 합니다.</span><span class="sxs-lookup"><span data-stu-id="0dc9f-297">This traffic flow breaks connectivity with Azure Redis Cache if hello outbound traffic is then blocked on-premises such that hello Azure Redis Cache instance is not able toocommunicate with its dependencies.</span></span>

<span data-ttu-id="0dc9f-298">hello 방법은 toodefine 하나 이상의 사용자 정의 된 경로 (UDRs) hello Azure Redis Cache를 포함 하는 hello 서브넷에 있습니다.</span><span class="sxs-lookup"><span data-stu-id="0dc9f-298">hello solution is toodefine one (or more) user-defined routes (UDRs) on hello subnet that contains hello Azure Redis Cache.</span></span> <span data-ttu-id="0dc9f-299">UDR hello 기본 경로 대신 허용 되어야 하는 서브넷 별 경로 정의 합니다.</span><span class="sxs-lookup"><span data-stu-id="0dc9f-299">A UDR defines subnet-specific routes that will be honored instead of hello default route.</span></span>

<span data-ttu-id="0dc9f-300">가능 하면 같은 구성이 toouse hello를 좋습니다.</span><span class="sxs-lookup"><span data-stu-id="0dc9f-300">If possible, it is recommended toouse hello following configuration:</span></span>

* <span data-ttu-id="0dc9f-301">0.0.0.0/0을 보급 하는 hello ExpressRoute 구성 하 고 기본적으로 강제 터널링 모든 아웃 바운드 트래픽을 온-프레미스 키를 누릅니다.</span><span class="sxs-lookup"><span data-stu-id="0dc9f-301">hello ExpressRoute configuration advertises 0.0.0.0/0 and by default force tunnels all outbound traffic on-premises.</span></span>
* <span data-ttu-id="0dc9f-302">hello UDR 적용 toohello 서브넷 hello Azure Redis Cache를 포함 하 정의 된 TCP/IP 트래픽 toohello에 대 한 작업 경로 0.0.0.0/0은 공용 인터넷; 예를 들어 hello 설정 하 여 다음 홉 형식 too'Internet'.</span><span class="sxs-lookup"><span data-stu-id="0dc9f-302">hello UDR applied toohello subnet containing hello Azure Redis Cache defines 0.0.0.0/0 with a working route for TCP/IP traffic toohello public internet; for example by setting hello next hop type too'Internet'.</span></span>

<span data-ttu-id="0dc9f-303">hello 결합 된 효과 이러한 단계는 hello 서브넷 수준은 UDR 우선 hello hello Azure Redis Cache에서에서 아웃 바운드 인터넷에 액세스 하는 데 ExpressRoute 강제 터널링 합니다.</span><span class="sxs-lookup"><span data-stu-id="0dc9f-303">hello combined effect of these steps is that hello subnet level UDR takes precedence over hello ExpressRoute forced tunneling, thus ensuring outbound Internet access from hello Azure Redis Cache.</span></span>

<span data-ttu-id="0dc9f-304">ExpressRoute를 사용 하는 온-프레미스 응용 프로그램에서 연결 tooan Azure Redis Cache 인스턴스 tooperformance 이유로 인해 일반적인 사용 시나리오는 되지 않습니다 (최상의 성능을 얻으려면 Azure Redis Cache에 대 한 클라이언트 hello에 있어야 hello Azure Redis Cache와 동일한 지역).</span><span class="sxs-lookup"><span data-stu-id="0dc9f-304">Connecting tooan Azure Redis Cache instance from an on-premises application using ExpressRoute is not a typical usage scenario due tooperformance reasons (for best performance Azure Redis Cache clients should be in hello same region as hello Azure Redis Cache).</span></span>

>[!IMPORTANT] 
><span data-ttu-id="0dc9f-305">UDR에 정의 된 경로 hello **해야** hello ExpressRoute 구성에서 보급 하는 모든 경로 통해 모호한 tootake 우선 순위 수 있도록 합니다.</span><span class="sxs-lookup"><span data-stu-id="0dc9f-305">hello routes defined in a UDR **must** be specific enough tootake precedence over any routes advertised by hello ExpressRoute configuration.</span></span> <span data-ttu-id="0dc9f-306">hello 다음 예제에서는 hello 광범위 한 0.0.0.0/0 주소 범위를 사용 하 여 및 따라서 경로 알림이 더 구체적인 주소 범위를 사용 하 여 실수로 재정의 잠재적으로 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="0dc9f-306">hello following example uses hello broad 0.0.0.0/0 address range, and as such can potentially be accidentally overridden by route advertisements using more specific address ranges.</span></span>

>[!WARNING]  
><span data-ttu-id="0dc9f-307">Azure Redis 캐시 된 express 경로 구성 지원 되지 않습니다는 **hello 공용 피어 링 경로 toohello 개인 피어 링 경로에서 경로 크로스-보급할 잘못**합니다.</span><span class="sxs-lookup"><span data-stu-id="0dc9f-307">Azure Redis Cache is not supported with ExpressRoute configurations that **incorrectly cross-advertise routes from hello public peering path toohello private peering path**.</span></span> <span data-ttu-id="0dc9f-308">구성된 공용 피어링이 있는 ExpressRoute 구성은 다양한 Microsoft Azure IP 주소 범위 집합에 대해 Microsoft에서 경로 보급을 받습니다.</span><span class="sxs-lookup"><span data-stu-id="0dc9f-308">ExpressRoute configurations that have public peering configured, receive route advertisements from Microsoft for a large set of Microsoft Azure IP address ranges.</span></span> <span data-ttu-id="0dc9f-309">이러한 주소 범위가 잘못 크로스-에 보급 hello 개인 피어 링 경로 hello 결과 hello Azure Redis 캐시 인스턴스의 서브넷의 모든 아웃 바운드 네트워크 패킷이 됩니다 tooa 잘못 강제 터널링 된 고객의 온-프레미스 네트워크 인프라입니다.</span><span class="sxs-lookup"><span data-stu-id="0dc9f-309">If these address ranges are incorrectly cross-advertised on hello private peering path, hello result is that all outbound network packets from hello Azure Redis Cache instance's subnet are incorrectly force-tunneled tooa customer's on-premises network infrastructure.</span></span> <span data-ttu-id="0dc9f-310">이 네트워크 흐름은 Azure Redis Cache를 중단합니다.</span><span class="sxs-lookup"><span data-stu-id="0dc9f-310">This network flow breaks Azure Redis Cache.</span></span> <span data-ttu-id="0dc9f-311">hello 솔루션 toothis 문제는 hello 공용 피어 링 경로 toohello 개인 피어 링 경로에서 toostop 간 광고 경로입니다.</span><span class="sxs-lookup"><span data-stu-id="0dc9f-311">hello solution toothis problem is toostop cross-advertising routes from hello public peering path toohello private peering path.</span></span>


<span data-ttu-id="0dc9f-312">사용자 정의 경로에 대한 배경 정보는 [개요](../virtual-network/virtual-networks-udr-overview.md)를 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="0dc9f-312">Background information on user-defined routes is available in this [overview](../virtual-network/virtual-networks-udr-overview.md).</span></span>

<span data-ttu-id="0dc9f-313">ExpressRoute에 대한 자세한 내용은 [ExpressRoute 기술 개요](../expressroute/expressroute-introduction.md)를 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="0dc9f-313">For more information about ExpressRoute, see [ExpressRoute technical overview](../expressroute/expressroute-introduction.md).</span></span>

## <a name="next-steps"></a><span data-ttu-id="0dc9f-314">다음 단계</span><span class="sxs-lookup"><span data-stu-id="0dc9f-314">Next steps</span></span>
<span data-ttu-id="0dc9f-315">Toouse 더 프리미엄 기능을 캐시 하는 방법에 대해 알아봅니다.</span><span class="sxs-lookup"><span data-stu-id="0dc9f-315">Learn how toouse more premium cache features.</span></span>

* [<span data-ttu-id="0dc9f-316">Toohello Azure Redis Cache 프리미엄 계층 소개</span><span class="sxs-lookup"><span data-stu-id="0dc9f-316">Introduction toohello Azure Redis Cache Premium tier</span></span>](cache-premium-tier-intro.md)

<!-- IMAGES -->

[redis-cache-vnet]: ./media/cache-how-to-premium-vnet/redis-cache-vnet.png

[redis-cache-vnet-ip]: ./media/cache-how-to-premium-vnet/redis-cache-vnet-ip.png

[redis-cache-vnet-info]: ./media/cache-how-to-premium-vnet/redis-cache-vnet-info.png

