---
title: "Azure Redis Cache 문제를 해결하는 방법 | Microsoft Docs"
description: "Azure Redis Cache와 관련된 일반적인 문제를 해결하는 방법을 알아봅니다."
services: redis-cache
documentationcenter: 
author: steved0x
manager: douge
editor: 
ms.assetid: 928b9b9c-d64f-4252-884f-af7ba8309af6
ms.service: cache
ms.workload: tbd
ms.tgt_pltfrm: cache-redis
ms.devlang: na
ms.topic: article
ms.date: 01/06/2017
ms.author: sdanie
ms.openlocfilehash: 2e9d1b644f1e80c7d916a261a6c47fcc11a1ffe0
ms.sourcegitcommit: f537befafb079256fba0529ee554c034d73f36b0
ms.translationtype: MT
ms.contentlocale: ko-KR
ms.lasthandoff: 07/11/2017
---
# <a name="how-to-troubleshoot-azure-redis-cache"></a><span data-ttu-id="c58f3-103">Azure Redis Cache 문제를 해결하는 방법</span><span class="sxs-lookup"><span data-stu-id="c58f3-103">How to troubleshoot Azure Redis Cache</span></span>
<span data-ttu-id="c58f3-104">이 문서에서는 다음 범주의 Azure Redis Cache 문제를 해결하는 것에 대한 지침을 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="c58f3-104">This article provides guidance for troubleshooting the following categories of Azure Redis Cache issues.</span></span>

* <span data-ttu-id="c58f3-105">[클라이언트 쪽 문제 해결](#client-side-troubleshooting) - 이 섹션에서는 Azure Redis Cache에 연결하는 응용 프로그램으로 인해 발생하는 문제를 파악하고 해결하는 것에 대한 지침을 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="c58f3-105">[Client side troubleshooting](#client-side-troubleshooting) - This section provides guidelines on identifying and resolving issues caused by the application connecting to Azure Redis Cache.</span></span>
* <span data-ttu-id="c58f3-106">[서버 쪽 문제 해결](#server-side-troubleshooting) - 이 섹션에서는 Azure Redis Cache 서버 쪽에서 일어난 문제를 파악하고 해결하는 것에 대한 지침을 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="c58f3-106">[Server side troubleshooting](#server-side-troubleshooting) - This section provides guidelines on identifying and resolving issues caused on the Azure Redis Cache server side.</span></span>
* <span data-ttu-id="c58f3-107">[StackExchange.Redis 시간 제한 예외 조사](#stackexchangeredis-timeout-exceptions) -이 섹션에서는 StackExchange.Redis 클라이언트를 사용할 때의 문제 해결에 관한 정보를 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="c58f3-107">[StackExchange.Redis timeout exceptions](#stackexchangeredis-timeout-exceptions) - This section provides information on troubleshooting issues when using the StackExchange.Redis client.</span></span>

> [!NOTE]
> <span data-ttu-id="c58f3-108">이 가이드에 나오는 문제 해결 단계 중 몇 가지는 Redis 명령을 실행하고 다양한 성능 메트릭을 모니터링하는 것을 포함합니다.</span><span class="sxs-lookup"><span data-stu-id="c58f3-108">Several of the troubleshooting steps in this guide include instructions to run Redis commands and monitor various performance metrics.</span></span> <span data-ttu-id="c58f3-109">자세한 내용 및 지침은 [추가 정보](#additional-information) 섹션의 문서를 참조합니다.</span><span class="sxs-lookup"><span data-stu-id="c58f3-109">For more information and instructions, see the articles in the [Additional information](#additional-information) section.</span></span>
> 
> 

## <a name="client-side-troubleshooting"></a><span data-ttu-id="c58f3-110">클라이언트 쪽 문제 해결</span><span class="sxs-lookup"><span data-stu-id="c58f3-110">Client side troubleshooting</span></span>
<span data-ttu-id="c58f3-111">이 섹션에서는 클라이언트 응용 프로그램에 부가된 조건 때문에 발생하는 문제 해결에 대해 알아봅니다.</span><span class="sxs-lookup"><span data-stu-id="c58f3-111">This section discusses troubleshooting issues that occur because of a condition on the client application.</span></span>

* [<span data-ttu-id="c58f3-112">클라이언트 쪽의 메모리 부족</span><span class="sxs-lookup"><span data-stu-id="c58f3-112">Memory pressure on the client</span></span>](#memory-pressure-on-the-client)
* [<span data-ttu-id="c58f3-113">트래픽 폭주</span><span class="sxs-lookup"><span data-stu-id="c58f3-113">Burst of traffic</span></span>](#burst-of-traffic)
* [<span data-ttu-id="c58f3-114">클라이언트의 높은 CPU 사용량</span><span class="sxs-lookup"><span data-stu-id="c58f3-114">High client CPU usage</span></span>](#high-client-cpu-usage)
* [<span data-ttu-id="c58f3-115">클라이언트 쪽 대역폭 초과</span><span class="sxs-lookup"><span data-stu-id="c58f3-115">Client Side Bandwidth Exceeded</span></span>](#client-side-bandwidth-exceeded)
* [<span data-ttu-id="c58f3-116">큰 요청/응답 크기</span><span class="sxs-lookup"><span data-stu-id="c58f3-116">Large Request/Response Size</span></span>](#large-requestresponse-size)
* [<span data-ttu-id="c58f3-117">내 Redis 데이터에서 무엇이 변경되었나요?</span><span class="sxs-lookup"><span data-stu-id="c58f3-117">What happened to my data in Redis?</span></span>](#what-happened-to-my-data-in-redis)

### <a name="memory-pressure-on-the-client"></a><span data-ttu-id="c58f3-118">클라이언트 쪽의 메모리 부족</span><span class="sxs-lookup"><span data-stu-id="c58f3-118">Memory pressure on the client</span></span>
#### <a name="problem"></a><span data-ttu-id="c58f3-119">문제</span><span class="sxs-lookup"><span data-stu-id="c58f3-119">Problem</span></span>
<span data-ttu-id="c58f3-120">클라이언트 컴퓨터의 메모리 부족은 Redis 인스턴스에서 지연없이 보낸 데이터 처리를 지연시킬 수 있는 온갖 종류의 성능 문제를 일으킵니다.</span><span class="sxs-lookup"><span data-stu-id="c58f3-120">Memory pressure on the client machine leads to all kinds of performance problems that can delay processing of data that was sent by the Redis instance without any delay.</span></span> <span data-ttu-id="c58f3-121">메모리가 부족해지면 시스템은 일반적으로 데이터를 실제 메모리로부터 디스크에 있는 가상 메모리로 페이지합니다.</span><span class="sxs-lookup"><span data-stu-id="c58f3-121">When memory pressure hits, the system typically has to page data from physical memory to virtual memory which is on disk.</span></span> <span data-ttu-id="c58f3-122">이 *페이지 폴트* 가 시스템이 크게 느려진 원인입니다.</span><span class="sxs-lookup"><span data-stu-id="c58f3-122">This *page faulting* causes the system to slow down significantly.</span></span>

#### <a name="measurement"></a><span data-ttu-id="c58f3-123">측정</span><span class="sxs-lookup"><span data-stu-id="c58f3-123">Measurement</span></span>
1. <span data-ttu-id="c58f3-124">사용 가능한 메모리를 초과하지 않는지 확인하기 위해 컴퓨터에서의 메모리 사용량을 모니터링합니다.</span><span class="sxs-lookup"><span data-stu-id="c58f3-124">Monitor memory usage on machine to make sure that it does not exceed available memory.</span></span> 
2. <span data-ttu-id="c58f3-125">`Page Faults/Sec` 성능 카운터를 모니터링합니다.</span><span class="sxs-lookup"><span data-stu-id="c58f3-125">Monitor the `Page Faults/Sec` performance counter.</span></span> <span data-ttu-id="c58f3-126">대부분의 시스템은 정상 작동을 하는 중에도 약간의 페이지 폴트가 있으므로 시간 제한에 해당하는 이 페이지 폴트 성능 카운터에서의 급증을 확인합니다.</span><span class="sxs-lookup"><span data-stu-id="c58f3-126">Most systems will have some page faults even during normal operation, so watch for spikes in this page faults performance counter which correspond with timeouts.</span></span>

#### <a name="resolution"></a><span data-ttu-id="c58f3-127">해결 방법</span><span class="sxs-lookup"><span data-stu-id="c58f3-127">Resolution</span></span>
<span data-ttu-id="c58f3-128">클라이언트를 더 많은 메모를 가진 더 큰 클라이언트 VM 크기로 그레이드하거나 메모리 소비를 줄이기 위해 메모리 사용 패턴을 자세히 알아봅니다.</span><span class="sxs-lookup"><span data-stu-id="c58f3-128">Upgrade your client to a larger client VM size with more memory or dig into your memory usage patterns to reduce memory consuption.</span></span>

### <a name="burst-of-traffic"></a><span data-ttu-id="c58f3-129">트래픽 폭주</span><span class="sxs-lookup"><span data-stu-id="c58f3-129">Burst of traffic</span></span>
#### <a name="problem"></a><span data-ttu-id="c58f3-130">문제</span><span class="sxs-lookup"><span data-stu-id="c58f3-130">Problem</span></span>
<span data-ttu-id="c58f3-131">나쁜 `ThreadPool` 설정과 결합된 트래픽 폭주는 Redis 서버에서 이미 보냈으나 클라이언트 쪽에서 아직 소비되지 않은 데이타의 처리 지연이 발생할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="c58f3-131">Bursts of traffic combined with poor `ThreadPool` settings can result in delays in processing data already sent by the Redis Server but not yet consumed on the client side.</span></span>

#### <a name="measurement"></a><span data-ttu-id="c58f3-132">측정</span><span class="sxs-lookup"><span data-stu-id="c58f3-132">Measurement</span></span>
<span data-ttu-id="c58f3-133">[다음과 같은](https://github.com/JonCole/SampleCode/blob/master/ThreadPoolMonitor/ThreadPoolLogger.cs) 코드를 사용할 때 `ThreadPool` 통계가 시간에 따라 어떻게 바뀌는지 모니터링합니다.</span><span class="sxs-lookup"><span data-stu-id="c58f3-133">Monitor how your `ThreadPool` statistics change over time using code [like this](https://github.com/JonCole/SampleCode/blob/master/ThreadPoolMonitor/ThreadPoolLogger.cs).</span></span> <span data-ttu-id="c58f3-134">또한 StackExchange.Redis에서 `TimeoutException` 메시지를 살펴볼 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="c58f3-134">You can also look at the `TimeoutException` message from StackExchange.Redis.</span></span> <span data-ttu-id="c58f3-135">다음은 예제입니다:</span><span class="sxs-lookup"><span data-stu-id="c58f3-135">Here is an example :</span></span>

    System.TimeoutException: Timeout performing EVAL, inst: 8, mgr: Inactive, queue: 0, qu: 0, qs: 0, qc: 0, wr: 0, wq: 0, in: 64221, ar: 0, 
    IOCP: (Busy=6,Free=999,Min=2,Max=1000), WORKER: (Busy=7,Free=8184,Min=2,Max=8191)

<span data-ttu-id="c58f3-136">위의 메시지에는 몇 가지 흥미로운 문제가 있습니다.</span><span class="sxs-lookup"><span data-stu-id="c58f3-136">In the above message, there are several issues that are interesting:</span></span>

1. <span data-ttu-id="c58f3-137">`IOCP` 섹션과 `WORKER` 섹션에 `Min` 값보다 큰 `Busy` 값이 있습니다.</span><span class="sxs-lookup"><span data-stu-id="c58f3-137">Notice that in the `IOCP` section and the `WORKER` section you have a `Busy` value that is greater than the `Min` value.</span></span> <span data-ttu-id="c58f3-138">이는 `ThreadPool` 설정이 조정을 필요로 한다는 의미입니다.</span><span class="sxs-lookup"><span data-stu-id="c58f3-138">This means that your `ThreadPool` settings need adjusting.</span></span>
2. <span data-ttu-id="c58f3-139">또한 `in: 64221`도 볼 수 있습니다:</span><span class="sxs-lookup"><span data-stu-id="c58f3-139">You can also see `in: 64221`.</span></span> <span data-ttu-id="c58f3-140">이는 64211 바이트를 커널 소켓 계층에서 받았지만 응용 프로그램 (예: StackExchange.Redis)에서 아직 읽지 않았음을 나타냅니다.</span><span class="sxs-lookup"><span data-stu-id="c58f3-140">This indicates that 64211 bytes have been received at the kernel socket layer but haven't yet been read by the application (e.g. StackExchange.Redis).</span></span> <span data-ttu-id="c58f3-141">이는 일반적으로 응용 프로그램이 데이터를 서버에서 보내는 만큼 빠르게 서버로부터 읽지 못하고 있음을 의미합니다.</span><span class="sxs-lookup"><span data-stu-id="c58f3-141">This typically means that your application isn't reading data from the network as quickly as the server is sending it to you.</span></span>

#### <a name="resolution"></a><span data-ttu-id="c58f3-142">해결 방법</span><span class="sxs-lookup"><span data-stu-id="c58f3-142">Resolution</span></span>
<span data-ttu-id="c58f3-143">버스트 시나리오 하에서 스레드 풀이 신속하게 규모 확장을 하도록 [스레드 풀 설정](https://gist.github.com/JonCole/e65411214030f0d823cb) 을 구성합니다.</span><span class="sxs-lookup"><span data-stu-id="c58f3-143">Configure your [ThreadPool Settings](https://gist.github.com/JonCole/e65411214030f0d823cb) to make sure that your thread pool will scale up quickly under burst scenarios.</span></span>

### <a name="high-client-cpu-usage"></a><span data-ttu-id="c58f3-144">클라이언트의 높은 CPU 사용량</span><span class="sxs-lookup"><span data-stu-id="c58f3-144">High client CPU usage</span></span>
#### <a name="problem"></a><span data-ttu-id="c58f3-145">문제</span><span class="sxs-lookup"><span data-stu-id="c58f3-145">Problem</span></span>
<span data-ttu-id="c58f3-146">클라이언트 쪽에서의 높은 CPU 사용량은 수행하도록 요청된 작업을 시스템이 처리할 수 없음을 나타냅니다.</span><span class="sxs-lookup"><span data-stu-id="c58f3-146">High CPU usage on the client is an indication that the system cannot keep up with the work that it has been asked to perform.</span></span> <span data-ttu-id="c58f3-147">이는 Redis가 응답을 매우 신속하게 전송하더라도 클라이언트가 Redis의 응답을 적시에 처리하지 못할 수도 있음을 의미합니다.</span><span class="sxs-lookup"><span data-stu-id="c58f3-147">This means that the client may fail to process a response from Redis in a timely fashion even though Redis sent the response very quickly.</span></span>

#### <a name="measurement"></a><span data-ttu-id="c58f3-148">측정</span><span class="sxs-lookup"><span data-stu-id="c58f3-148">Measurement</span></span>
<span data-ttu-id="c58f3-149">Azure 포털을 통해 또는 연결된 성능 카운터를 통해 시스템 전반 CPU 사용량을 모니터링합니다.</span><span class="sxs-lookup"><span data-stu-id="c58f3-149">Monitor the System Wide CPU usage through the Azure Portal or through the associated performance counter.</span></span> <span data-ttu-id="c58f3-150">단일 프로세스는 CUP 사용량이 낮은 동시에 전체 시스템 CPU 사룡량을 높을 수 있기 때문에 *프로세스* CPU를 모니터링 하지 않도록 주의합니다.</span><span class="sxs-lookup"><span data-stu-id="c58f3-150">Be careful not to monitor *process* CPU because a single process can have low CPU usage at the same time that overall system CPU can be high.</span></span> <span data-ttu-id="c58f3-151">CPU 사용량에서 제한 시간에 해당 하는 급증을 확인합니다.</span><span class="sxs-lookup"><span data-stu-id="c58f3-151">Watch for spikes in CPU usage that correspond with timeouts.</span></span> <span data-ttu-id="c58f3-152">높은 CPU 사용량으로 인해 [트래픽 폭주](#burst-of-traffic) 섹션에서 설명한 대로 `TimeoutException` 오류 메시지에서 높은 `in: XXX` 값을 보게 될 것입니다.</span><span class="sxs-lookup"><span data-stu-id="c58f3-152">As a result of high CPU, you may also see high `in: XXX` values in `TimeoutException` error messages as described in the [Burst of traffic](#burst-of-traffic) section.</span></span>

> [!NOTE]
> <span data-ttu-id="c58f3-153">StackExchange.Redis 1.1.603 이상은 `TimeoutException` 오류 메시지에 `local-cpu` 매트릭을 포함합니다.</span><span class="sxs-lookup"><span data-stu-id="c58f3-153">StackExchange.Redis 1.1.603 and later includes the `local-cpu` metric in `TimeoutException` error messages.</span></span> <span data-ttu-id="c58f3-154">[StackExchange.Redis NuGet 패키지](https://www.nuget.org/packages/StackExchange.Redis/)최신 버전을 사용 중인지 확인합니다.</span><span class="sxs-lookup"><span data-stu-id="c58f3-154">Ensure you using the latest version of the [StackExchange.Redis NuGet package](https://www.nuget.org/packages/StackExchange.Redis/).</span></span> <span data-ttu-id="c58f3-155">제한 시간에 더욱 견고하도록 만들기 위해 코드 속의 버그를 지속적으로 수정하고 있으므로 최신 버전을 갖는 것이 중요합니다.</span><span class="sxs-lookup"><span data-stu-id="c58f3-155">There are bugs constantly being fixed in the code to make it more robust to timeouts so having the latest version is important.</span></span>
> 
> 

#### <a name="resolution"></a><span data-ttu-id="c58f3-156">해결 방법</span><span class="sxs-lookup"><span data-stu-id="c58f3-156">Resolution</span></span>
<span data-ttu-id="c58f3-157">더 많은 CPU 용량을 가진 더 큰 VM 크기로 업그레이드하거나 CPU 스파이크의 원인이 무엇인지 확인합니다.</span><span class="sxs-lookup"><span data-stu-id="c58f3-157">Upgrade to a larger VM size with more CPU capacity or investigate what is causing CPU spikes.</span></span> 

### <a name="client-side-bandwidth-exceeded"></a><span data-ttu-id="c58f3-158">클라이언트 쪽 대역폭 초과</span><span class="sxs-lookup"><span data-stu-id="c58f3-158">Client side bandwidth exceeded</span></span>
#### <a name="problem"></a><span data-ttu-id="c58f3-159">문제</span><span class="sxs-lookup"><span data-stu-id="c58f3-159">Problem</span></span>
<span data-ttu-id="c58f3-160">크기가 다른 클라이언트 컴퓨터는 어느 정도의 네트워크 대역폭을 사용할 수 있는지에 제한이 있습니다.</span><span class="sxs-lookup"><span data-stu-id="c58f3-160">Different sized client machines have limitations on how much network bandwidth they have available.</span></span> <span data-ttu-id="c58f3-161">클라이언트가 사용 가능한 대역폭을 초과하면 서버에서 보내는 만큼 신속하게 클라이언트 쪽에서 데이터가 처리되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="c58f3-161">If the client exceeds the available bandwidth, then data will not be processed on the client side as quickly as the server is sending it.</span></span> <span data-ttu-id="c58f3-162">이 때문에 시간 제한에 걸릴 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="c58f3-162">This can lead to timeouts.</span></span>

#### <a name="measurement"></a><span data-ttu-id="c58f3-163">측정</span><span class="sxs-lookup"><span data-stu-id="c58f3-163">Measurement</span></span>
<span data-ttu-id="c58f3-164">[다음과 같은](https://github.com/JonCole/SampleCode/blob/master/BandWidthMonitor/BandwidthLogger.cs)코드를 사용할 때 대역폭 사용량이 시간에 따라 어떻게 바뀌는지 모니터링합니다.</span><span class="sxs-lookup"><span data-stu-id="c58f3-164">Monitor how your Bandwidth usage change over time using code [like this](https://github.com/JonCole/SampleCode/blob/master/BandWidthMonitor/BandwidthLogger.cs).</span></span> <span data-ttu-id="c58f3-165">이 코드는 (Azure 웹 사이트와 같이) 권한이 제한된 일부 환경에서 성공적으로 실행되지 않을 수도 있습니다.</span><span class="sxs-lookup"><span data-stu-id="c58f3-165">Note that this code may not run successfully in some environments with restricted permissions (like Azure web sites).</span></span>

#### <a name="resolution"></a><span data-ttu-id="c58f3-166">해결 방법</span><span class="sxs-lookup"><span data-stu-id="c58f3-166">Resolution</span></span>
<span data-ttu-id="c58f3-167">클라이언트 VM 크기를 늘리거나 네트워크 대역폭 사용량을 줄입니다.</span><span class="sxs-lookup"><span data-stu-id="c58f3-167">Increase Client VM size or reduce network bandwidth consumption.</span></span>

### <a name="large-requestresponse-size"></a><span data-ttu-id="c58f3-168">큰 요청/응답 크기</span><span class="sxs-lookup"><span data-stu-id="c58f3-168">Large Request/Response Size</span></span>
#### <a name="problem"></a><span data-ttu-id="c58f3-169">문제</span><span class="sxs-lookup"><span data-stu-id="c58f3-169">Problem</span></span>
<span data-ttu-id="c58f3-170">큰 요청/응답으로 시간 초과가 발생할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="c58f3-170">A large request/response can cause timeouts.</span></span> <span data-ttu-id="c58f3-171">예를 들어 클라이언트에 구성된 시간 제한 값이 1초라고 가정합시다.</span><span class="sxs-lookup"><span data-stu-id="c58f3-171">As an example, Suppose your timeout value configured on your client is 1 second.</span></span> <span data-ttu-id="c58f3-172">응용 프로그램이 (동일한 실제 네트워크 연결을 사용하여)  동시에 두 키(예:'A'와 'B')를 요청합니다 </span><span class="sxs-lookup"><span data-stu-id="c58f3-172">Your application requests two keys (e.g. 'A' and 'B') at the same time (using the same physical network connection).</span></span> <span data-ttu-id="c58f3-173">대부분 클라이언트는 두 요청 ‘A’와 ‘B’를 응답을 기다리지 않고 연달아 서버에 전송되는 것과 같은 요청 “파이프라인”을 지원합니다.</span><span class="sxs-lookup"><span data-stu-id="c58f3-173">Most clients support "Pipelining" of requests, such that both requests 'A' and 'B' are sent on the wire to the server one after the other without waiting for the responses.</span></span> <span data-ttu-id="c58f3-174">서버는 응답을 동일한 순서로 전송합니다.</span><span class="sxs-lookup"><span data-stu-id="c58f3-174">The server will send the responses back in the same order.</span></span> <span data-ttu-id="c58f3-175">응답 'A'가 큰 경우 후속 요청을 위한 제한 시간 대부분을 다 써버릴 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="c58f3-175">If response 'A' is large enough it can eat up most of the timeout for subsequent requests.</span></span> 

<span data-ttu-id="c58f3-176">다음 예제에서는 이 시나리오를 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="c58f3-176">The following example demonstrates this scenario.</span></span> <span data-ttu-id="c58f3-177">이 시나리오에서는 요청 'A'와 'B'가 신속하게 전송되고, 서버가 응답 'A'와 'B'를 신속하게 보내기 시작하지만, 데이터 전송 시간 때문에 서버가 신속하게 응답했어도 'B'가 다른 요청 뒤에 갇혀 꼼짝 못하고 시간이 초과되어 버립니다.</span><span class="sxs-lookup"><span data-stu-id="c58f3-177">In this scenario, Request 'A' and 'B' are sent quickly, the server starts sending responses 'A' and 'B' quickly, but because of data transfer times, 'B' get stuck behind the other request and times out even though the server responded quickly.</span></span>

    |-------- 1 Second Timeout (A)----------|
    |-Request A-|
         |-------- 1 Second Timeout (B) ----------|
         |-Request B-|
                |- Read Response A --------|
                                           |- Read Response B-| (**TIMEOUT**)



#### <a name="measurement"></a><span data-ttu-id="c58f3-178">측정</span><span class="sxs-lookup"><span data-stu-id="c58f3-178">Measurement</span></span>
<span data-ttu-id="c58f3-179">이것은 측정하기 어렵습니다.</span><span class="sxs-lookup"><span data-stu-id="c58f3-179">This is a difficult one to measure.</span></span> <span data-ttu-id="c58f3-180">기본적으로 큰 요청 및 응답을 추적하도록 클라이언트 코드를 계측해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="c58f3-180">You basically have to instrument your client code to track large requests and responses.</span></span> 

#### <a name="resolution"></a><span data-ttu-id="c58f3-181">해결 방법</span><span class="sxs-lookup"><span data-stu-id="c58f3-181">Resolution</span></span>
1. <span data-ttu-id="c58f3-182">Redis는 몇 개의 큰 값보다는 많은 수의 작은 값에 대해 최적화됩니다.</span><span class="sxs-lookup"><span data-stu-id="c58f3-182">Redis is optimized for a large number of small values, rather than a few large values.</span></span> <span data-ttu-id="c58f3-183">선호하는 해결 방법은 데이터를 더 작은 값으로 분할하는 것입니다.</span><span class="sxs-lookup"><span data-stu-id="c58f3-183">The preferred solution is to break up your data into related smaller values.</span></span> <span data-ttu-id="c58f3-184">왜 더 작은 값이 추천되는지에 대한 상세한 내용은 [redis를 위한 이상적인 값 크기 범위는 무엇입니까? 100KB는 너무 큽니다?](https://groups.google.com/forum/#!searchin/redis-db/size/redis-db/n7aa2A4DZDs/3OeEPHSQBAAJ)게시물을 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="c58f3-184">See the [What is the ideal value size range for redis? Is 100KB too large?](https://groups.google.com/forum/#!searchin/redis-db/size/redis-db/n7aa2A4DZDs/3OeEPHSQBAAJ) post for details around why smaller values are recommended.</span></span>
2. <span data-ttu-id="c58f3-185">더 높은 대역폭 기능을 얻어 더 큰 응답에 대한 데이터 전송 시간을 줄이기 위해 (클라이언트와 Redis 캐시 서버에 대해) VM의 크기를 늘립니다.</span><span class="sxs-lookup"><span data-stu-id="c58f3-185">Increase the size of your VM (for client and Redis Cache Server), to get higher bandwidth capabilities, reducing data transfer times for larger responses.</span></span> <span data-ttu-id="c58f3-186">서버에만 또는 클라이언트에만 대역폭을 늘리는 것은 충분하지 않을 수도 있음을 유의하세요.</span><span class="sxs-lookup"><span data-stu-id="c58f3-186">Note that getting more bandwidth on just the server or just on the client may not be enough.</span></span> <span data-ttu-id="c58f3-187">대역폭 사용량을 측정하고 현재 VM 크기의 용량과 비교합니다.</span><span class="sxs-lookup"><span data-stu-id="c58f3-187">Measure your bandwidth usage and compare it to the capabilities of the size of VM you currently have.</span></span>
3. <span data-ttu-id="c58f3-188">사용하는 `ConnectionMultiplexer` 개체의 수와 다른 연결을 통해 라운드 로빈 요청을 늘립니다.</span><span class="sxs-lookup"><span data-stu-id="c58f3-188">Increase the number of `ConnectionMultiplexer` objects you use and round-robin requests over different connections.</span></span>

### <a name="what-happened-to-my-data-in-redis"></a><span data-ttu-id="c58f3-189">내 Redis 데이터에서 무엇이 변경되었나요?</span><span class="sxs-lookup"><span data-stu-id="c58f3-189">What happened to my data in Redis?</span></span>
#### <a name="problem"></a><span data-ttu-id="c58f3-190">문제</span><span class="sxs-lookup"><span data-stu-id="c58f3-190">Problem</span></span>
<span data-ttu-id="c58f3-191">특정 데이터가 Azure Redis Cache 인스턴스에 있을 것이라 예상했지만 그곳에 없는 듯이 보입니다.</span><span class="sxs-lookup"><span data-stu-id="c58f3-191">I expected for certain data to be in my Azure Redis Cache instance but it didn't seem to be there.</span></span>

#### <a name="resolution"></a><span data-ttu-id="c58f3-192">해결 방법</span><span class="sxs-lookup"><span data-stu-id="c58f3-192">Resolution</span></span>
<span data-ttu-id="c58f3-193">가능한 원인 및 해결 방법은 [내 Redis 데이터에서 무엇이 변경되었나요?](https://gist.github.com/JonCole/b6354d92a2d51c141490f10142884ea4#file-whathappenedtomydatainredis-md) 를 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="c58f3-193">See [What happened to my data in Redis?](https://gist.github.com/JonCole/b6354d92a2d51c141490f10142884ea4#file-whathappenedtomydatainredis-md) for possible causes and resolutions.</span></span>

## <a name="server-side-troubleshooting"></a><span data-ttu-id="c58f3-194">서버 쪽 문제 해결</span><span class="sxs-lookup"><span data-stu-id="c58f3-194">Server side troubleshooting</span></span>
<span data-ttu-id="c58f3-195">이 섹션에서는 캐시 서버에 부가된 조건 때문에 발생하는 문제 해결에 대해 알아봅니다.</span><span class="sxs-lookup"><span data-stu-id="c58f3-195">This section discusses troubleshooting issues that occur because of a condition on the cache server.</span></span>

* [<span data-ttu-id="c58f3-196">서버 쪽의 메모리 부족</span><span class="sxs-lookup"><span data-stu-id="c58f3-196">Memory Pressure on the server</span></span>](#memory-pressure-on-the-server)
* [<span data-ttu-id="c58f3-197">높은 CPU 사용량 / 서버 부하</span><span class="sxs-lookup"><span data-stu-id="c58f3-197">High CPU usage / Server Load</span></span>](#high-cpu-usage-server-load)
* [<span data-ttu-id="c58f3-198">서버 쪽 대역폭 초과</span><span class="sxs-lookup"><span data-stu-id="c58f3-198">Server Side Bandwidth Exceeded</span></span>](#server-side-bandwidth-exceeded)

### <a name="memory-pressure-on-the-server"></a><span data-ttu-id="c58f3-199">서버 쪽의 메모리 부족</span><span class="sxs-lookup"><span data-stu-id="c58f3-199">Memory Pressure on the server</span></span>
#### <a name="problem"></a><span data-ttu-id="c58f3-200">문제</span><span class="sxs-lookup"><span data-stu-id="c58f3-200">Problem</span></span>
<span data-ttu-id="c58f3-201">서버 쪽의 메모리 부족은 요청 처리를 지연시킬 수 있는 온갖 종류의 성능 문제를 일으킵니다.</span><span class="sxs-lookup"><span data-stu-id="c58f3-201">Memory pressure on the server side leads to all kinds of performance problems that can delay processing of requests.</span></span> <span data-ttu-id="c58f3-202">메모리가 부족해지면 시스템은 일반적으로 데이터를 실제 메모리로부터 디스크에 있는 가상 메모리로 페이지합니다.</span><span class="sxs-lookup"><span data-stu-id="c58f3-202">When memory pressure hits, the system typically has to page data from physical memory to virtual memory which is on disk.</span></span> <span data-ttu-id="c58f3-203">이 *페이지 폴트* 가 시스템이 크게 느려진 원인입니다.</span><span class="sxs-lookup"><span data-stu-id="c58f3-203">This *page faulting* causes the system to slow down significantly.</span></span> <span data-ttu-id="c58f3-204">이 메모리 부족의 몇 가지 가능한 원인은 다음과 같습니다.</span><span class="sxs-lookup"><span data-stu-id="c58f3-204">There are several possible causes of this memory pressure:</span></span> 

1. <span data-ttu-id="c58f3-205">캐시를 데이터로 최대 용량까지 채웠습니다.</span><span class="sxs-lookup"><span data-stu-id="c58f3-205">You have filled the cache to full capacity with data.</span></span> 
2. <span data-ttu-id="c58f3-206">Redis가 높은 메모리 조각화를 보입니다-큰 개체 저장이 원인이 되어 일어나는 경우가 가장 많습니다.(Redis 작은 개체에 대해 최적화됩니다-상세한 내용은 [redis를 위한 이상적인 값 크기 범위는 무엇입니까? 100KB는 너무 큽니다?](https://groups.google.com/forum/#!searchin/redis-db/size/redis-db/n7aa2A4DZDs/3OeEPHSQBAAJ)게시물을 참조하세요)</span><span class="sxs-lookup"><span data-stu-id="c58f3-206">Redis is seeing high memory fragmentation - most often caused by storing large objects (Redis is optimized for a small objects - See the [What is the ideal value size range for redis? Is 100KB too large?](https://groups.google.com/forum/#!searchin/redis-db/size/redis-db/n7aa2A4DZDs/3OeEPHSQBAAJ) post for details).</span></span> 

#### <a name="measurement"></a><span data-ttu-id="c58f3-207">측정</span><span class="sxs-lookup"><span data-stu-id="c58f3-207">Measurement</span></span>
<span data-ttu-id="c58f3-208">Redis는 이 문제를 식별하는 데 도움이 되는 두 개의 메트릭을 노출합니다.</span><span class="sxs-lookup"><span data-stu-id="c58f3-208">Redis exposes two metrics that can help you identify this issue.</span></span> <span data-ttu-id="c58f3-209">첫째는 `used_memory`이고 다른 하나는 `used_memory_rss`입니다.</span><span class="sxs-lookup"><span data-stu-id="c58f3-209">The first is `used_memory` and the other is `used_memory_rss`.</span></span> <span data-ttu-id="c58f3-210">[이러한 메트릭](cache-how-to-monitor.md#available-metrics-and-reporting-intervals)은 Azure Portal에서 또는 [Redis INFO](http://redis.io/commands/info) 명령을 통해 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="c58f3-210">[These metrics](cache-how-to-monitor.md#available-metrics-and-reporting-intervals) are available in the Azure Portal or through the [Redis INFO](http://redis.io/commands/info) command.</span></span>

#### <a name="resolution"></a><span data-ttu-id="c58f3-211">해결 방법</span><span class="sxs-lookup"><span data-stu-id="c58f3-211">Resolution</span></span>
<span data-ttu-id="c58f3-212">메모리 사용량의 정상 유지를 위해 몇 가지 가능한 변경은 다음과 같습니다.</span><span class="sxs-lookup"><span data-stu-id="c58f3-212">There are several possible changes that you can make to help keep memory usage healthy:</span></span>

1. <span data-ttu-id="c58f3-213">[메모리 정책을 구성](cache-configure.md#maxmemory-policy-and-maxmemory-reserved) 하고 키에 만료 시간을 설정합니다.</span><span class="sxs-lookup"><span data-stu-id="c58f3-213">[Configure a memory policy](cache-configure.md#maxmemory-policy-and-maxmemory-reserved) and set expiration times on your keys.</span></span> <span data-ttu-id="c58f3-214">조각화가 있을 경우 이것으로는 부족할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="c58f3-214">Note that this may not be sufficient if you have fragmentation.</span></span>
2. <span data-ttu-id="c58f3-215">[maxmemory-reserved 값을 구성합니다](cache-configure.md#maxmemory-policy-and-maxmemory-reserved) .</span><span class="sxs-lookup"><span data-stu-id="c58f3-215">[Configure a maxmemory-reserved value](cache-configure.md#maxmemory-policy-and-maxmemory-reserved) that is large enough to compensate for memory fragmentation.</span></span>
3. <span data-ttu-id="c58f3-216">크게 캐시된 개체를 더 작은 관련 개체로 분할합니다.</span><span class="sxs-lookup"><span data-stu-id="c58f3-216">Break up your large cached objects into smaller related objects.</span></span>
4. <span data-ttu-id="c58f3-217">[확장합니다](cache-how-to-scale.md) .</span><span class="sxs-lookup"><span data-stu-id="c58f3-217">[Scale](cache-how-to-scale.md) to a larger cache size.</span></span>
5. <span data-ttu-id="c58f3-218">[Redis 클러스터를 사용할 수 있는 프리미엄 캐시](cache-how-to-premium-clustering.md)를 사용하고 있다면, [분할된 데이터베이스 수를 늘릴](cache-how-to-premium-clustering.md#change-the-cluster-size-on-a-running-premium-cache) 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="c58f3-218">If you are using a [premium cache with Redis cluster enabled](cache-how-to-premium-clustering.md) you can [increase the number of shards](cache-how-to-premium-clustering.md#change-the-cluster-size-on-a-running-premium-cache).</span></span>

### <a name="high-cpu-usage--server-load"></a><span data-ttu-id="c58f3-219">높은 CPU 사용량 / 서버 부하</span><span class="sxs-lookup"><span data-stu-id="c58f3-219">High CPU usage / Server Load</span></span>
#### <a name="problem"></a><span data-ttu-id="c58f3-220">문제</span><span class="sxs-lookup"><span data-stu-id="c58f3-220">Problem</span></span>
<span data-ttu-id="c58f3-221">높은 CPU 사용량은 Redis가 응답을 매우 신속하게 전송하더라도 클라이언트 쪽이 Redis의 응답을 적시에 처리하지 못할 수도 있음을 의미할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="c58f3-221">High CPU usage can mean that the client side can fail to process a response from Redis in a timely fashion even though Redis sent the response very quickly.</span></span>

#### <a name="measurement"></a><span data-ttu-id="c58f3-222">측정</span><span class="sxs-lookup"><span data-stu-id="c58f3-222">Measurement</span></span>
<span data-ttu-id="c58f3-223">Azure 포털을 통해 또는 연결된 성능 카운터를 통해 시스템 전반 CPU 사용량을 모니터링합니다.</span><span class="sxs-lookup"><span data-stu-id="c58f3-223">Monitor the System Wide CPU usage through the Azure Portal or through the associated performance counter.</span></span> <span data-ttu-id="c58f3-224">단일 프로세스는 CUP 사용량이 낮은 동시에 전체 시스템 CPU 사룡량을 높을 수 있기 때문에 *프로세스* CPU를 모니터링 하지 않도록 주의합니다.</span><span class="sxs-lookup"><span data-stu-id="c58f3-224">Be careful not to monitor *process* CPU because a single process can have low CPU usage at the same time that overall system CPU can be high.</span></span> <span data-ttu-id="c58f3-225">CPU 사용량에서 제한 시간에 해당 하는 급증을 확인합니다.</span><span class="sxs-lookup"><span data-stu-id="c58f3-225">Watch for spikes in CPU usage that correspond with timeouts.</span></span>

#### <a name="resolution"></a><span data-ttu-id="c58f3-226">해결 방법</span><span class="sxs-lookup"><span data-stu-id="c58f3-226">Resolution</span></span>
<span data-ttu-id="c58f3-227">[확장합니다](cache-how-to-scale.md) 하거나 CPU 스파이크의 원인이 무엇인지 확인합니다.</span><span class="sxs-lookup"><span data-stu-id="c58f3-227">[Scale](cache-how-to-scale.md) to a larger cache tier with more CPU capacity or investigate what is causing CPU spikes.</span></span> 

### <a name="server-side-bandwidth-exceeded"></a><span data-ttu-id="c58f3-228">서버 쪽 대역폭 초과</span><span class="sxs-lookup"><span data-stu-id="c58f3-228">Server Side Bandwidth Exceeded</span></span>
#### <a name="problem"></a><span data-ttu-id="c58f3-229">문제</span><span class="sxs-lookup"><span data-stu-id="c58f3-229">Problem</span></span>
<span data-ttu-id="c58f3-230">크기가 다른 캐시 인스턴스는 어느 정도의 네트워크 대역폭을 사용할 수 있는지에 제한이 있습니다.</span><span class="sxs-lookup"><span data-stu-id="c58f3-230">Different sized cache instances have limitations on how much network bandwidth they have available.</span></span> <span data-ttu-id="c58f3-231">서버가 사용 가능한 대역폭을 초과하면 데이터가 클라이언트에게 신속하게 전송되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="c58f3-231">If the server exceeds the available bandwidth, then data will not be sent to the client as quickly.</span></span> <span data-ttu-id="c58f3-232">이 때문에 시간 제한에 걸릴 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="c58f3-232">This can lead to timeouts.</span></span>

#### <a name="measurement"></a><span data-ttu-id="c58f3-233">측정</span><span class="sxs-lookup"><span data-stu-id="c58f3-233">Measurement</span></span>
<span data-ttu-id="c58f3-234">지정한 보고 간격 동안 캐시에서 읽은 초당 메가바이트(MB/s) 단위의 데이터 양인 `Cache Read` 메트릭을 모니터링할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="c58f3-234">You can monitor the `Cache Read` metric, which is the amount of data read from the cache in Megabytes per second (MB/s) during the specified reporting interval.</span></span> <span data-ttu-id="c58f3-235">이 값은 캐시에서 사용되는 네트워크 대역폭에 해당합니다.</span><span class="sxs-lookup"><span data-stu-id="c58f3-235">This value corresponds to the network bandwidth used by this cache.</span></span> <span data-ttu-id="c58f3-236">서버 쪽 네트워크 대역폭 제한에 대한 경고를 설정하려면, `Cache Read` 카운터를 사용하여 경고를 생성합니다.</span><span class="sxs-lookup"><span data-stu-id="c58f3-236">If you want to set up alerts for server side network bandwidth limits, you can create them using this `Cache Read` counter.</span></span> <span data-ttu-id="c58f3-237">여러분의 판독값을 다양한 캐시 가격 책정 계층 및 크기에 대해 관찰된 대역폭 제한은 [이 테이블](cache-faq.md#cache-performance) 의 값과 비교합니다.</span><span class="sxs-lookup"><span data-stu-id="c58f3-237">Compare your readings with the values in [this table](cache-faq.md#cache-performance) for the observed bandwidth limits for various cache pricing tiers and sizes.</span></span>

#### <a name="resolution"></a><span data-ttu-id="c58f3-238">해결 방법</span><span class="sxs-lookup"><span data-stu-id="c58f3-238">Resolution</span></span>
<span data-ttu-id="c58f3-239">가격 책정 계층과 캐시 크기에 대해 관찰된 최대 대역폭에 지속적으로 접근한다면 [이 테이블](cache-faq.md#cache-performance)의 값을 가이드로 사용하여 더 큰 네트워크 대역폭을 가진 가격 책정 계층 또는 크기로 [확장](cache-how-to-scale.md)하는 것을 고려합니다.</span><span class="sxs-lookup"><span data-stu-id="c58f3-239">If you are consistently near the observed maximum bandwidth for your pricing tier and cache size, consider [scaling](cache-how-to-scale.md) to a pricing tier or size that has greater network bandwidth, using the values in [this table](cache-faq.md#cache-performance) as a guide.</span></span>

## <a name="stackexchangeredis-timeout-exceptions"></a><span data-ttu-id="c58f3-240">StackExchange.Redis 시간 제한 예외 조사</span><span class="sxs-lookup"><span data-stu-id="c58f3-240">StackExchange.Redis timeout exceptions</span></span>
<span data-ttu-id="c58f3-241">StackExchange.Redis는 기본값이 1000ms인 동기 작업에 대해 `synctimeout`이라는 이름의 구성 설정을 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="c58f3-241">StackExchange.Redis uses a configuration setting named `synctimeout` for synchronous operations which has a default value  of 1000 ms.</span></span> <span data-ttu-id="c58f3-242">동기 호출이 규정된 시간 내에 완료되지 않으면, StackExchange.Redis 클라이언트는 다음 예제와 유사하게 시간 초과 오류 메시지를 냅니다.</span><span class="sxs-lookup"><span data-stu-id="c58f3-242">If a synchronous call doesn’t complete in the stipulated time, the StackExchange.Redis client throws a timeout error similar to the following example.</span></span>

    System.TimeoutException: Timeout performing MGET 2728cc84-58ae-406b-8ec8-3f962419f641, inst: 1,mgr: Inactive, queue: 73, qu=6, qs=67, qc=0, wr=1/1, in=0/0 IOCP: (Busy=6, Free=999, Min=2,Max=1000), WORKER (Busy=7,Free=8184,Min=2,Max=8191)


<span data-ttu-id="c58f3-243">이 오류 메시지에는 문제의 원인과 가능한 해결로 이끌 메트릭이 들어 있습니다.</span><span class="sxs-lookup"><span data-stu-id="c58f3-243">This error message contains metrics that can help point you to the cause and possible resolution of the issue.</span></span> <span data-ttu-id="c58f3-244">다음 테이블에는 오류 메시지 메트릭에 대한 세부 정보가 있습니다.</span><span class="sxs-lookup"><span data-stu-id="c58f3-244">The following table contains details about the error message metrics.</span></span>

| <span data-ttu-id="c58f3-245">오류 메시지 메트릭</span><span class="sxs-lookup"><span data-stu-id="c58f3-245">Error message metric</span></span> | <span data-ttu-id="c58f3-246">세부 정보</span><span class="sxs-lookup"><span data-stu-id="c58f3-246">Details</span></span> |
| --- | --- |
| <span data-ttu-id="c58f3-247">inst</span><span class="sxs-lookup"><span data-stu-id="c58f3-247">inst</span></span> |<span data-ttu-id="c58f3-248">마지막 시간 조각에서: 0 명령이 발급되었습니다</span><span class="sxs-lookup"><span data-stu-id="c58f3-248">In the last time slice: 0 commands have been issued</span></span> |
| <span data-ttu-id="c58f3-249">mgr</span><span class="sxs-lookup"><span data-stu-id="c58f3-249">mgr</span></span> |<span data-ttu-id="c58f3-250">소켓 관리자가 OS에게 해야 할 일이 있는 소켓을 나타내게 하고자 `socket.select`을 수행합니다. 기본적으로: 판독기는 해야 할 일이 없다고 생각하기 때문에 네트워크에서 적극적으로 읽지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="c58f3-250">The socket manager is performing `socket.select` which means it is asking the OS to indicate a socket that has something to do; basically: the reader is not actively reading from the network because it doesn't think there is anything to do</span></span> |
| <span data-ttu-id="c58f3-251">큐</span><span class="sxs-lookup"><span data-stu-id="c58f3-251">queue</span></span> |<span data-ttu-id="c58f3-252">진행 중인 작업이 총 73건 있습니다.</span><span class="sxs-lookup"><span data-stu-id="c58f3-252">There are 73 total in-progress operations</span></span> |
| <span data-ttu-id="c58f3-253">qu</span><span class="sxs-lookup"><span data-stu-id="c58f3-253">qu</span></span> |<span data-ttu-id="c58f3-254">진행 중인 작업의 6건이 보내지 않은 큐에 있고 아직 아웃바운드 네트워크에 작성되지 않았습니다.</span><span class="sxs-lookup"><span data-stu-id="c58f3-254">6 of the in-progress operations are in the unsent queue and have not yet been written to the outbound network</span></span> |
| <span data-ttu-id="c58f3-255">qs</span><span class="sxs-lookup"><span data-stu-id="c58f3-255">qs</span></span> |<span data-ttu-id="c58f3-256">진행 중인 작업의 67건은 서버로 보내졌지만 아직 응답이 없습니다.</span><span class="sxs-lookup"><span data-stu-id="c58f3-256">67 of he in-progress operations have been sent to the server but a response is not yet available.</span></span> <span data-ttu-id="c58f3-257">응답은 `Not yet sent by the server` 또는 `sent by the server but not yet processed by the client.`일 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="c58f3-257">The response could be `Not yet sent by the server` or `sent by the server but not yet processed by the client.`</span></span> |
| <span data-ttu-id="c58f3-258">qc</span><span class="sxs-lookup"><span data-stu-id="c58f3-258">qc</span></span> |<span data-ttu-id="c58f3-259">진행 중인 작업의 0건이 응답을 보았으나 완료 루프에서 대기하는 까닭에 아직 완료로 표시되지 않았습니다.</span><span class="sxs-lookup"><span data-stu-id="c58f3-259">0 of the in-progress operations have seen replies but have not yet been marked as complete due to waiting on the completion loop</span></span> |
| <span data-ttu-id="c58f3-260">wr</span><span class="sxs-lookup"><span data-stu-id="c58f3-260">wr</span></span> |<span data-ttu-id="c58f3-261">활성 기록기가 있습니다(보내지 않은 요청 6건이 무시되지 않았음을 의미합니다)바이트/activewriters</span><span class="sxs-lookup"><span data-stu-id="c58f3-261">There is an active writer (meaning the 6 unsent requests are not being ignored) bytes/activewriters</span></span> |
| <span data-ttu-id="c58f3-262">in</span><span class="sxs-lookup"><span data-stu-id="c58f3-262">in</span></span> |<span data-ttu-id="c58f3-263">활성 판독기가 없으며 NIC 바이트/activereaders에서 판독하는 데 사용 가능한 바이트는 0입니다.</span><span class="sxs-lookup"><span data-stu-id="c58f3-263">There are no active readers and zero bytes are available to be read on the NIC bytes/activereaders</span></span> |

### <a name="steps-to-investigate"></a><span data-ttu-id="c58f3-264">조사 단계</span><span class="sxs-lookup"><span data-stu-id="c58f3-264">Steps to investigate</span></span>
1. <span data-ttu-id="c58f3-265">모범 사례로 StackExchange.Redis 클리이언트를 사용할 때 연결하기 위해 다음 패턴을 사용하는지 확인합니다.</span><span class="sxs-lookup"><span data-stu-id="c58f3-265">As a best practice make sure you are using the following pattern to connect when using the StackExchange.Redis client.</span></span>

    ```c#
    private static Lazy<ConnectionMultiplexer> lazyConnection = new Lazy<ConnectionMultiplexer>(() =>
    {
        return ConnectionMultiplexer.Connect("cachename.redis.cache.windows.net,abortConnect=false,ssl=true,password=...");
    
    });
    
    public static ConnectionMultiplexer Connection
    {
        get
        {
            return lazyConnection.Value;
        }
    }
    ````

    <span data-ttu-id="c58f3-266">자세한 내용은 [StackExchange.Redis를 사용하여 캐시에 연결](cache-dotnet-how-to-use-azure-redis-cache.md#connect-to-the-cache)을 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="c58f3-266">For more information, see [Connect to the cache using StackExchange.Redis](cache-dotnet-how-to-use-azure-redis-cache.md#connect-to-the-cache).</span></span>

1. <span data-ttu-id="c58f3-267">Azure Redis Cache와 클라이언트 응용 프로그램이 Azure에서 동일한 지역에 있는지 확인합니다.</span><span class="sxs-lookup"><span data-stu-id="c58f3-267">Ensure that your Azure Redis Cache and the client application are in the same region in Azure.</span></span> <span data-ttu-id="c58f3-268">예를 들어 캐시는 미국 동부에 있는 반면에 클라이언트는 미국 서부에 있고 요청이 `synctimeout` 간격 내에 완료되지 않을 때 시간 초과가 일어날 수 있거나 또는 로컬 개발 컴퓨터에서 디버깅을 할 때 시관 초과가 일어날 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="c58f3-268">For example, you might be getting timeouts when your cache is in East US but the client is in West US and the request doesn't complete within the `synctimeout` interval or you might be getting timeouts when you are debugging from your local development machine.</span></span> 
   
    <span data-ttu-id="c58f3-269">동일한 Azure 지역에 캐시와 클라이언트를 두도록 하는 것이 좋습니다.</span><span class="sxs-lookup"><span data-stu-id="c58f3-269">It’s highly recommended to have the cache and in the client in the same Azure region.</span></span> <span data-ttu-id="c58f3-270">지역 간 호출을 포함하는 시나리오가 있다면, `synctimeout` 속성을 연결 문자열에 포함함으로써 `synctimeout` 간격을 기본값인 1000ms 간격보다 높은 값에 설정해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="c58f3-270">If you have a scenario that includes cross region calls, you should set the `synctimeout` interval to a value higher than the default 1000 ms interval by including a `synctimeout` property in the connection string.</span></span> <span data-ttu-id="c58f3-271">다음 예제는 StackExchange.Redis 캐시 연결 문자열을 2000ms의 `synctimeout` 과 연결하는 코드 조각을 보여줍니다.</span><span class="sxs-lookup"><span data-stu-id="c58f3-271">The following example shows a StackExchange.Redis cache connection string snippet with a `synctimeout` of 2000 ms.</span></span>
   
        synctimeout=2000,cachename.redis.cache.windows.net,abortConnect=false,ssl=true,password=...
2. <span data-ttu-id="c58f3-272">[StackExchange.Redis NuGet 패키지](https://www.nuget.org/packages/StackExchange.Redis/)최신 버전을 사용 중인지 확인합니다.</span><span class="sxs-lookup"><span data-stu-id="c58f3-272">Ensure you using the latest version of the [StackExchange.Redis NuGet package](https://www.nuget.org/packages/StackExchange.Redis/).</span></span> <span data-ttu-id="c58f3-273">제한 시간에 더욱 견고하도록 만들기 위해 코드 속의 버그를 지속적으로 수정하고 있으므로 최신 버전을 갖는 것이 중요합니다.</span><span class="sxs-lookup"><span data-stu-id="c58f3-273">There are bugs constantly being fixed in the code to make it more robust to timeouts so having the latest version is important.</span></span>
3. <span data-ttu-id="c58f3-274">서버나 클라이언트에 걸린 대역폭 제한에 묶인 요청이 있다면, 완료하는 데 더 많은 시간이 걸려 시간 초과의 원인이 됩니다.</span><span class="sxs-lookup"><span data-stu-id="c58f3-274">If there are requests that are getting bound by bandwidth limitations on the server or client, it will take longer for them to complete and thereby cause timeouts.</span></span> <span data-ttu-id="c58f3-275">시간 초과가 서버의 네트워크 대역폭 때문인지 보려면 [서버 쪽 대역폭 초과](#server-side-bandwidth-exceeded)를 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="c58f3-275">To see if your timeout is due to network bandwidth on the server, see [Server side bandwidth exceeded](#server-side-bandwidth-exceeded).</span></span> <span data-ttu-id="c58f3-276">시간 초과가 클라이언트 네트워크 대역폭 때문인지 보려면 [클라이언트 쪽 대역폭 초과](#client-side-bandwidth-exceeded)를 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="c58f3-276">To see if your timeout is due to client network bandwidth, see [Client side bandwidth exceeded](#client-side-bandwidth-exceeded).</span></span>
4. <span data-ttu-id="c58f3-277">CPU가 서버 또는 클라이언트에 바인딩됩니까?</span><span class="sxs-lookup"><span data-stu-id="c58f3-277">Are you getting CPU bound on the server or on the client?</span></span>
   
   * <span data-ttu-id="c58f3-278">CPU가 클라이언트에 바인딩되어 요청이 `synctimeout` 간격 내에 처리될 수가 없게 되어 시간 초과가 일어나는지 확인합니다.</span><span class="sxs-lookup"><span data-stu-id="c58f3-278">Check if you are getting bound by CPU on your client which could cause the request to not be processed within the `synctimeout` interval, thus causing a timeout.</span></span> <span data-ttu-id="c58f3-279">더 큰 클라이언트 크기로 이동하거나 부하를 분산한다면 이것을 제어하는데 도움이 됩니다.</span><span class="sxs-lookup"><span data-stu-id="c58f3-279">Moving to a larger client size or distributing the load can help to control this.</span></span> 
   * <span data-ttu-id="c58f3-280">서버에서 CPU가 서버에 바인딩되는지 `CPU` [캐시 성능 메트릭](cache-how-to-monitor.md#available-metrics-and-reporting-intervals)을 모니터링하여 확인합니다.</span><span class="sxs-lookup"><span data-stu-id="c58f3-280">Check if you are getting CPU bound on the server by monitoring the `CPU` [cache performance metric](cache-how-to-monitor.md#available-metrics-and-reporting-intervals).</span></span> <span data-ttu-id="c58f3-281">Redis가 CPU에 바인딩된 동안 들어오는 요청은 시간 초과를 초래할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="c58f3-281">Requests coming in while Redis is CPU bound can cause those requests to timeout.</span></span> <span data-ttu-id="c58f3-282">이 문제를 해결하기 위해 부하를 프리미엄 캐시에서 여러 분할된 데이터베이스로 분산하거나 더 큰 크기나 가격 책정 계층으로 업그레이드할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="c58f3-282">To address this you can distribute the load across multiple shards in a premium cache, or upgrade to a larger size or pricing tier.</span></span> <span data-ttu-id="c58f3-283">자세한 내용은 [서버 쪽 대역폭 초과](#server-side-bandwidth-exceeded)를 참조합니다.</span><span class="sxs-lookup"><span data-stu-id="c58f3-283">For more information, see [Server Side Bandwidth Exceeded](#server-side-bandwidth-exceeded).</span></span>
5. <span data-ttu-id="c58f3-284">서버에서 처리하는데 시간이 오래 걸리는 명령이 있습니까?</span><span class="sxs-lookup"><span data-stu-id="c58f3-284">Are there commands taking long time to process on the server?</span></span> <span data-ttu-id="c58f3-285">Redis 서버에서 처리하는 데 시간이 오래 걸리는 장기 실행 명령은 시간 초과의 원인이 될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="c58f3-285">Long running commands that are taking long time to process on the redis-server can cause timeouts.</span></span> <span data-ttu-id="c58f3-286">장기 실행 명령의 몇 가지 예로 다수의 키 작동을 요하는 `mget`, `keys *` 또는 형편없게 짜여진 lua 스크립트 등이 있습니다.</span><span class="sxs-lookup"><span data-stu-id="c58f3-286">Some examples of long running commands are `mget` with large numbers of keys, `keys *` or poorly written lua scripts.</span></span> <span data-ttu-id="c58f3-287">예상보다 오래 걸리는 요청이 있는지 확인하기 위해 Redis cli 클라이언트를 사용하여 Azure Redis Cache 인스턴스에 연결하거나 [Redis 콘솔](cache-configure.md#redis-console)을 사용하여 [SlowLog](http://redis.io/commands/slowlog) 명령을 실행할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="c58f3-287">You can connect to your Azure Redis Cache instance using the redis-cli client or use the [Redis Console](cache-configure.md#redis-console) and run the [SlowLog](http://redis.io/commands/slowlog) command to see if there are requests taking longer than expected.</span></span> <span data-ttu-id="c58f3-288">Redis 서버와 StackExchange.Redis는 작은 수의 큰 요청보다 많은 수의 작은 요청을 위해 최적화되어 있습니다.</span><span class="sxs-lookup"><span data-stu-id="c58f3-288">Redis Server and StackExchange.Redis are optimized for many small requests rather than fewer large requests.</span></span> <span data-ttu-id="c58f3-289">데이터를 더 작은 청크로 분할한다면 다음을 향상시킵니다.</span><span class="sxs-lookup"><span data-stu-id="c58f3-289">Splitting your data into smaller chunks may improve things here.</span></span> 
   
    <span data-ttu-id="c58f3-290">Redis cli 및 stunnel를 사용하여 Azure Redis 캐시 SSL 끝점에 연결 하는 방법에 대한 자세한 내용은 [Redis용 ASP.NET 세션 상태 공급자 미리 보기 릴리스 발표](http://blogs.msdn.com/b/webdev/archive/2014/05/12/announcing-asp-net-session-state-provider-for-redis-preview-release.aspx) 블로그 게시물을 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="c58f3-290">For information on connecting to the Azure Redis Cache SSL endpoint using redis-cli and stunnel, see the [Announcing ASP.NET Session State Provider for Redis Preview Release](http://blogs.msdn.com/b/webdev/archive/2014/05/12/announcing-asp-net-session-state-provider-for-redis-preview-release.aspx) blog post.</span></span> <span data-ttu-id="c58f3-291">자세한 내용은 [SlowLog](http://redis.io/commands/slowlog)를 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="c58f3-291">For more information, see [SlowLog](http://redis.io/commands/slowlog).</span></span>
6. <span data-ttu-id="c58f3-292">높은 Redis 서버 부하로 시간 초과가 발생할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="c58f3-292">High Redis server load can cause timeouts.</span></span> <span data-ttu-id="c58f3-293">`Redis Server Load` [캐시 성능 메트릭](cache-how-to-monitor.md#available-metrics-and-reporting-intervals)을 모니터링함으로써 서버 부하를 모니터링할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="c58f3-293">You can monitor the server load by monitoring the `Redis Server Load` [cache performance metric](cache-how-to-monitor.md#available-metrics-and-reporting-intervals).</span></span> <span data-ttu-id="c58f3-294">100(최대 값)이란 서버 부하는 redis 서버가 요청을 처리하느라 유휴 시간이 전혀 없이 사용 중이었음을 나타냅니다.</span><span class="sxs-lookup"><span data-stu-id="c58f3-294">A server load of 100 (maximum value) signifies that the redis server has been busy, with no idle time, processing requests.</span></span> <span data-ttu-id="c58f3-295">특정 요청이 서버 기능의 전부를 차지하는지 확인하려면 이전 단락에서 설명한 대로 SlowLog 명령을 실행합니다.</span><span class="sxs-lookup"><span data-stu-id="c58f3-295">To see if certain requests are taking up all of the server capability, run the SlowLog command, as described in the previous paragraph.</span></span> <span data-ttu-id="c58f3-296">자세한 내용은 [높은 CPU 사용량/서버 로드](#high-cpu-usage-server-load)를 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="c58f3-296">For more information, see [High CPU usage / Server Load](#high-cpu-usage-server-load).</span></span>
7. <span data-ttu-id="c58f3-297">클라이언트 쪽에서 네트워크 문제를 일으킬 만한 이벤트가 있었습니까?</span><span class="sxs-lookup"><span data-stu-id="c58f3-297">Was there any other event on the client side that could have caused a network blip?</span></span> <span data-ttu-id="c58f3-298">클라이언트 인스턴스 수를 위아래로 조정하거나, 클라이언트 새 버전을 배포하거나, 자동 크기 조정을 사용하도록 설정되었는지 클라이언트(웹, 작업자 역할 또는 Iaas VM)를 확인합니다.우리 테스트에서 자동 크기 조정이나 위/아래 크기 조정을 하면 아웃바운드 네트워크 연결이 몇초간 끊어진다는 점이 밝혀졌습니다.</span><span class="sxs-lookup"><span data-stu-id="c58f3-298">Check on the client (web, worker role or an Iaas VM) if there was an event like scaling the number of client instances up or down, or deploying a new version of the client or auto-scale is enabled?In our testing we have found that autoscale or scaling up/down can cause outbound network connectivity can be lost for several seconds.</span></span> <span data-ttu-id="c58f3-299">StackExchange.Redis 코드는 이러한 이벤트에 복원력이 있어 다시 연결합니다.</span><span class="sxs-lookup"><span data-stu-id="c58f3-299">StackExchange.Redis code is resilient to such events and will reconnect.</span></span> <span data-ttu-id="c58f3-300">다시 연결되는 이 시간 동안 큐에 있는 모든 요청은 시간 초과될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="c58f3-300">During this time of re-connection any requests in the queue can time out.</span></span>
8. <span data-ttu-id="c58f3-301">시간 초과한 Redis 캐시에 여러 작은 요청에 앞서 큰 요청이 있었습니까?</span><span class="sxs-lookup"><span data-stu-id="c58f3-301">Was there a big request preceding several small requests to the Redis Cache that timed out?</span></span> <span data-ttu-id="c58f3-302">오류 메시지에 있는 매개 변수 `qs`는 클라이언트에서 서버로 요청은 보내졌으나 아직 응답 처리가 되지 않은 경우가 얼마나 많은지 알려줍니다.</span><span class="sxs-lookup"><span data-stu-id="c58f3-302">The parameter `qs` in the error message tells you how many requests were sent from the client to the server, but have not yet processed a response.</span></span> <span data-ttu-id="c58f3-303">StackExchange.Redis는 하나의 TCP 연결을 사용하고 한 번에 하나의 응답만 읽을 수 있기 때문에 이 값은 계속 증가할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="c58f3-303">This value can keep growing because StackExchange.Redis uses a single TCP connection and can only read one response at a time.</span></span> <span data-ttu-id="c58f3-304">첫 번째 작업이 시간 초과하더라도, 서버와 데이터를 주고 받는 일이 중단되지 않으며, 다른 요청은 이 일이 끝날 때까지 차단되기 때문에 시간 초과가 일어납니다.</span><span class="sxs-lookup"><span data-stu-id="c58f3-304">Even though the first operation timed out, it does not stop the data being sent to/from the server, and other requests are blocked until this is finished, causing time outs.</span></span> <span data-ttu-id="c58f3-305">하나의 솔루션은 워크로드를 감당할 수 있게 캐시를 충분히 크게 하고 큰 값을 작은 청크로 분할하여 시간 초과의 가능성을 최소화하는 것입니다.</span><span class="sxs-lookup"><span data-stu-id="c58f3-305">One solution is to minimize the chance of timeouts by ensuring that your cache is large enough for your workload and splitting large values into smaller chunks.</span></span> <span data-ttu-id="c58f3-306">또 다른 가능한 솔루션은 클라이언트에서 `ConnectionMultiplexer` 개체 풀을 사용하고, 새 요청을 보낼 때 부하가 최소인 `ConnectionMultiplexer`을 선택합니다,</span><span class="sxs-lookup"><span data-stu-id="c58f3-306">Another possible solution is to use a pool of `ConnectionMultiplexer` objects in your client, and choose the least loaded `ConnectionMultiplexer` when sending a new request.</span></span> <span data-ttu-id="c58f3-307">이렇게 하면 단일 시간 초과가 다른 요청들도 또한 시간 초과되게 하는 것을 막습니다.</span><span class="sxs-lookup"><span data-stu-id="c58f3-307">This should prevent a single timeout from causing other requests to also timeout.</span></span>
9. <span data-ttu-id="c58f3-308">`RedisSessionStateprovider`보다 높아야 합니다.</span><span class="sxs-lookup"><span data-stu-id="c58f3-308">If you are using `RedisSessionStateprovider`, ensure you have set the retry timeout correctly.</span></span> <span data-ttu-id="c58f3-309">`retrytimeoutInMilliseconds`는 `operationTimeoutinMilliseonds`보다 높아야 합니다. 그렇지 않으면 재시도가 발생하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="c58f3-309">`retrytimeoutInMilliseconds` should be higher than `operationTimeoutinMilliseonds`, otherwise no retries will occur.</span></span> <span data-ttu-id="c58f3-310">다음 예제에서 `retrytimeoutInMilliseconds` 가 3000으로 설정됩니다.</span><span class="sxs-lookup"><span data-stu-id="c58f3-310">In the following example `retrytimeoutInMilliseconds` is set to 3000.</span></span> <span data-ttu-id="c58f3-311">자세한 내용은 [Azure Redis Cache용 ASP.NET 세션 상태 제공자](cache-aspnet-session-state-provider.md) 및 [세션 상태 제공자와 출력 캐시 공급자의 구성 매개 변수를 사용하는 방법](https://github.com/Azure/aspnet-redis-providers/wiki/Configuration)을 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="c58f3-311">For more information, see [ASP.NET Session State Provider for Azure Redis Cache](cache-aspnet-session-state-provider.md) and [How to use the configuration parameters of Session State Provider and Output Cache Provider](https://github.com/Azure/aspnet-redis-providers/wiki/Configuration).</span></span>

    <add
      name="AFRedisCacheSessionStateProvider"
      type="Microsoft.Web.Redis.RedisSessionStateProvider"
      host="enbwcache.redis.cache.windows.net"
      port="6380"
      accessKey="…"
      ssl="true"
      databaseId="0"
      applicationName="AFRedisCacheSessionState"
      connectionTimeoutInMilliseconds = "5000"
      operationTimeoutInMilliseconds = "1000"
      retryTimeoutInMilliseconds="3000" />


1. <span data-ttu-id="c58f3-312">`Used Memory RSS`와 `Used Memory`를 [모니터링](cache-how-to-monitor.md#available-metrics-and-reporting-intervals)하여Azure Redis Cache 서버의 메모리 사용량을 확인합니다.</span><span class="sxs-lookup"><span data-stu-id="c58f3-312">Check memory usage on the Azure Redis Cache server by [monitoring](cache-how-to-monitor.md#available-metrics-and-reporting-intervals) `Used Memory RSS` and `Used Memory`.</span></span> <span data-ttu-id="c58f3-313">제거 정책이 구현되었다면, `Used_Memory` 가 캐시 크기에 도달할 때 Redis는 제거 키를 작동합니다.</span><span class="sxs-lookup"><span data-stu-id="c58f3-313">If an eviction policy is in place, Redis starts evicting keys when `Used_Memory` reaches the cache size.</span></span> <span data-ttu-id="c58f3-314">이상적으로 `Used Memory RSS`는 `Used memory`보다 약간만 높아야 합니다.</span><span class="sxs-lookup"><span data-stu-id="c58f3-314">Ideally, `Used Memory RSS` should be only slightly higher than `Used memory`.</span></span> <span data-ttu-id="c58f3-315">큰 차이는 메모리 조각화 (내부 또는 외부)가 심함을 의미합니다.</span><span class="sxs-lookup"><span data-stu-id="c58f3-315">A large difference means there is memory fragmentation (internal or external.</span></span> <span data-ttu-id="c58f3-316">`Used Memory RSS`가 `Used Memory`보다 작다면 운영 체제가 캐시 메모리의 일부를 스왑했음을 의미합니다.</span><span class="sxs-lookup"><span data-stu-id="c58f3-316">When `Used Memory RSS` is less than `Used Memory`, it means part of the cache memory has been swapped  by the operating system.</span></span> <span data-ttu-id="c58f3-317">이 경우 일부 상당한 대기 시간을 예상할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="c58f3-317">If this occurs you can expect some significant latencies.</span></span> <span data-ttu-id="c58f3-318">Redis는 할당이 메모리 페이지에 매핑되는 방법을 제어하지 않기 때문에 높은 `Used Memory RSS` 은 흔히 메모리 사용량에서 스파이크의 결과로 나타납니다.</span><span class="sxs-lookup"><span data-stu-id="c58f3-318">Because Redis does not have control over how its allocations are mapped to memory pages, high `Used Memory RSS` is often the result of a spike in memory usage.</span></span> <span data-ttu-id="c58f3-319">Redis가 메모리를 놓아주면, 메모리는 할당자에게 돌아가고, 할당자는 메모리를 시스템에 돌려주거나 그러지 않을 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="c58f3-319">When Redis frees memory, the memory is given back to the allocator, and the allocator may or may not give the memory back to the system.</span></span> <span data-ttu-id="c58f3-320">운영 체제가 보고하는 `Used Memory` 값과 메모리 소비량 사이에 차이가 있을 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="c58f3-320">There may be a discrepancy between the `Used Memory` value and memory consumption as reported by the operating system.</span></span> <span data-ttu-id="c58f3-321">Redis가 메모리를 사용되고 사용하고 놓아줬지만 시스템으로 돌려지지 않았습니다.</span><span class="sxs-lookup"><span data-stu-id="c58f3-321">It may be due to the fact memory has been used and released by Redis, but not given back to the system.</span></span> <span data-ttu-id="c58f3-322">메모리 문제를 완화하려면 다음 방법들을 수행할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="c58f3-322">To help mitigate memory issues you can perform the following steps.</span></span>
   
   * <span data-ttu-id="c58f3-323">캐시를 더 큰 크기로 업그레이드하여 시스템에서 메모리 제한을 겪지 않도록 합니다.</span><span class="sxs-lookup"><span data-stu-id="c58f3-323">Upgrade the cache to a larger size so that you are not running up against memory limitations on the system.</span></span>
   * <span data-ttu-id="c58f3-324">키에 만료 시간을 설정하여 이전 값이 사전에 제거되게 합니다.</span><span class="sxs-lookup"><span data-stu-id="c58f3-324">Set expiration times on the keys so that older values are evicted proactively.</span></span>
   * <span data-ttu-id="c58f3-325">`used_memory_rss` 캐시 메트릭을 모니터링합니다.</span><span class="sxs-lookup"><span data-stu-id="c58f3-325">Monitor the the `used_memory_rss` cache metric.</span></span> <span data-ttu-id="c58f3-326">이 값이 해당 캐시의 크기에 가까워질 때 성능 문제가 나타나는 것을 보기 시작할 가능성이 있습니다.</span><span class="sxs-lookup"><span data-stu-id="c58f3-326">When this value approaches the size of their cache, you are likely to start seeing performance issues.</span></span> <span data-ttu-id="c58f3-327">프리미엄 캐시를 사용하거나 더 큰 캐시 크기로 업그레이드 하는 경우, 데이터를 여러 분할된 데이터베이스에 배포합니다.</span><span class="sxs-lookup"><span data-stu-id="c58f3-327">Distribute the data across multiple shards if you are using a premium cache, or upgrade to a larger cache size.</span></span>
   
   <span data-ttu-id="c58f3-328">자세한 내용은 [서버 쪽의 메모리 부족](#memory-pressure-on-the-server)을 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="c58f3-328">For more information, see [Memory Pressure on the server](#memory-pressure-on-the-server).</span></span>

## <a name="additional-information"></a><span data-ttu-id="c58f3-329">추가 정보</span><span class="sxs-lookup"><span data-stu-id="c58f3-329">Additional information</span></span>
* [<span data-ttu-id="c58f3-330">어떤 Redis Cache 제품 및 크기를 사용해야 하나요?</span><span class="sxs-lookup"><span data-stu-id="c58f3-330">What Redis Cache offering and size should I use?</span></span>](cache-faq.md#what-redis-cache-offering-and-size-should-i-use)
* [<span data-ttu-id="c58f3-331">내 캐시의 성능을 어떻게 벤치마크 및 테스트할 수 있나요?</span><span class="sxs-lookup"><span data-stu-id="c58f3-331">How can I benchmark and test the performance of my cache?</span></span>](cache-faq.md#how-can-i-benchmark-and-test-the-performance-of-my-cache)
* [<span data-ttu-id="c58f3-332">어떻게 Redis 명령을 실행할 수 있나요?</span><span class="sxs-lookup"><span data-stu-id="c58f3-332">How can I run Redis commands?</span></span>](cache-faq.md#how-can-i-run-redis-commands)
* [<span data-ttu-id="c58f3-333">Azure Redis Cache를 모니터링하는 방법</span><span class="sxs-lookup"><span data-stu-id="c58f3-333">How to monitor Azure Redis Cache</span></span>](cache-how-to-monitor.md)

