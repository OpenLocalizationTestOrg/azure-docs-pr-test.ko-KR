---
title: "Vm 및 역할 인스턴스에 대 한 aaaResolution"
description: "Azure IaaS, 하이브리드 솔루션, 서로 다른 클라우드 서비스, Active Directory, 자체 DNS 서버 사용 시의 이름 확인 시나리오  "
services: virtual-network
documentationcenter: na
author: GarethBradshawMSFT
manager: carmonm
editor: tysonn
ms.assetid: 5d73edde-979a-470a-b28c-e103fcf07e3e
ms.service: virtual-network
ms.devlang: na
ms.topic: article
ms.tgt_pltfrm: na
ms.workload: infrastructure-services
ms.date: 12/06/2016
ms.author: telmos
ms.openlocfilehash: 0ec7903cf200c1d04d75601a5b0cefe4268f3dcf
ms.sourcegitcommit: 523283cc1b3c37c428e77850964dc1c33742c5f0
ms.translationtype: MT
ms.contentlocale: ko-KR
ms.lasthandoff: 10/06/2017
---
# <a name="name-resolution-for-vms-and-role-instances"></a><span data-ttu-id="27f86-103">VM 및 역할 인스턴스에 대한 이름 확인</span><span class="sxs-lookup"><span data-stu-id="27f86-103">Name Resolution for VMs and Role Instances</span></span>
<span data-ttu-id="27f86-104">사용 방법에 따라 사용자 Azure toohost IaaS, PaaS 및 하이브리드 솔루션을 tooallow hello Vm 및 역할 인스턴스를 서로 toocommunicate 만들어야 할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="27f86-104">Depending on how you use Azure toohost IaaS, PaaS, and hybrid solutions, you may need tooallow hello VMs and role instances that you create toocommunicate with each other.</span></span> <span data-ttu-id="27f86-105">IP 주소를 사용 하 여이 통신을 수행할 수 있습니다, 이지만 보다 간단 하 게 toouse 이름의 기억 하기 쉬운 변경 되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="27f86-105">Although this communication can be done by using IP addresses, it is much simpler toouse names that can be easily remembered and do not change.</span></span> 

<span data-ttu-id="27f86-106">역할 인스턴스 및 Azure에서 호스팅되는 Vm tooresolve 도메인 이름을 toointernal IP 주소를 할 때 두 가지 방법 중 하나를 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="27f86-106">When role instances and VMs hosted in Azure need tooresolve domain names toointernal IP addresses, they can use one of two methods:</span></span>

* [<span data-ttu-id="27f86-107">Azure에서 제공하는 이름 확인</span><span class="sxs-lookup"><span data-stu-id="27f86-107">Azure-provided name resolution</span></span>](#azure-provided-name-resolution)
* <span data-ttu-id="27f86-108">[자체 DNS 서버를 사용 하 여 이름 확인](#name-resolution-using-your-own-dns-server) (있는 전달 될 수 있습니다 쿼리 toohello Azure 제공 DNS 서버)</span><span class="sxs-lookup"><span data-stu-id="27f86-108">[Name resolution using your own DNS server](#name-resolution-using-your-own-dns-server) (which may forward queries toohello Azure-provided DNS servers)</span></span> 

<span data-ttu-id="27f86-109">hello 종류의 이름 확인 사용 어떻게 Vm 및 역할 인스턴스는 서로 toocommunicate 필요에 따라 달라 집니다.</span><span class="sxs-lookup"><span data-stu-id="27f86-109">hello type of name resolution you use depends on how your VMs and role instances need toocommunicate with each other.</span></span>

<span data-ttu-id="27f86-110">**hello 다음 표에 나와 시나리오와 해당 이름 확인 솔루션이 있습니다.**</span><span class="sxs-lookup"><span data-stu-id="27f86-110">**hello following table illustrates scenarios and corresponding name resolution solutions:**</span></span>

| <span data-ttu-id="27f86-111">**시나리오**</span><span class="sxs-lookup"><span data-stu-id="27f86-111">**Scenario**</span></span> | <span data-ttu-id="27f86-112">**솔루션**</span><span class="sxs-lookup"><span data-stu-id="27f86-112">**Solution**</span></span> | <span data-ttu-id="27f86-113">**접미사**</span><span class="sxs-lookup"><span data-stu-id="27f86-113">**Suffix**</span></span> |
| --- | --- | --- |
| <span data-ttu-id="27f86-114">역할 인스턴스 또는 Vm 간의 이름 확인에 hello 동일한 클라우드 서비스 또는 가상 네트워크</span><span class="sxs-lookup"><span data-stu-id="27f86-114">Name resolution between role instances or VMs located in hello same cloud service or virtual network</span></span> |[<span data-ttu-id="27f86-115">Azure에서 제공하는 이름 확인</span><span class="sxs-lookup"><span data-stu-id="27f86-115">Azure-provided name resolution</span></span>](#azure-provided-name-resolution) |<span data-ttu-id="27f86-116">호스트 이름 또는 FQDN</span><span class="sxs-lookup"><span data-stu-id="27f86-116">hostname or FQDN</span></span> |
| <span data-ttu-id="27f86-117">서로 다른 네트워크에 위치한 역할 인스턴스 또는 VM 간 이름 확인</span><span class="sxs-lookup"><span data-stu-id="27f86-117">Name resolution between role instances or VMs located in different virtual networks</span></span> |<span data-ttu-id="27f86-118">고객이 관리하는 DNS 서버가 Azure(DNS 프록시)에서 확인을 위해 vnet 간의 쿼리를 전달합니다.</span><span class="sxs-lookup"><span data-stu-id="27f86-118">Customer-managed DNS servers forwarding queries between vnets for resolution by Azure (DNS proxy).</span></span>  <span data-ttu-id="27f86-119">[자체 DNS 서버를 이용한 이름 확인](#name-resolution-using-your-own-dns-server)</span><span class="sxs-lookup"><span data-stu-id="27f86-119">see [Name resolution using your own DNS server](#name-resolution-using-your-own-dns-server)</span></span> |<span data-ttu-id="27f86-120">FQDN만</span><span class="sxs-lookup"><span data-stu-id="27f86-120">FQDN only</span></span> |
| <span data-ttu-id="27f86-121">Azure의 VM 또는 역할 인스턴스에서 온-프레미스 컴퓨터와 서비스 이름 확인</span><span class="sxs-lookup"><span data-stu-id="27f86-121">Resolution of on-premises computer and service names from role instances or VMs in Azure</span></span> |<span data-ttu-id="27f86-122">고객이 관리하는 DNS 서버(예: 온-프레미스 도메인 컨트롤러, 로컬 읽기 전용 도메인 컨트롤러 또는 영역 전송을 사용하여 동기화된 DNS 보조)입니다.</span><span class="sxs-lookup"><span data-stu-id="27f86-122">Customer-managed DNS servers (e.g. on-premises domain controller, local read-only domain controller or a DNS secondary synced using zone transfers).</span></span>  <span data-ttu-id="27f86-123">See [자체 DNS 서버를 이용한 이름 확인](#name-resolution-using-your-own-dns-server)</span><span class="sxs-lookup"><span data-stu-id="27f86-123">See [Name resolution using your own DNS server](#name-resolution-using-your-own-dns-server)</span></span> |<span data-ttu-id="27f86-124">FQDN만</span><span class="sxs-lookup"><span data-stu-id="27f86-124">FQDN only</span></span> |
| <span data-ttu-id="27f86-125">온-프레미스 컴퓨터에서 Azure 호스트 이름 확인</span><span class="sxs-lookup"><span data-stu-id="27f86-125">Resolution of Azure hostnames from on-premises computers</span></span> |<span data-ttu-id="27f86-126">쿼리 전달 tooa 고객이 관리 하는 DNS에서에서 프록시 서버 hello 해당 vnet hello 프록시 서버는 확인을 위해 쿼리 tooAzure 전달합니다.</span><span class="sxs-lookup"><span data-stu-id="27f86-126">Forward queries tooa customer-managed DNS proxy server in hello corresponding vnet, hello proxy server forwards queries tooAzure for resolution.</span></span> <span data-ttu-id="27f86-127">See [자체 DNS 서버를 사용한 이름 확인](#name-resolution-using-your-own-dns-server)</span><span class="sxs-lookup"><span data-stu-id="27f86-127">See [Name resolution using your own DNS server](#name-resolution-using-your-own-dns-server)</span></span> |<span data-ttu-id="27f86-128">FQDN만</span><span class="sxs-lookup"><span data-stu-id="27f86-128">FQDN only</span></span> |
| <span data-ttu-id="27f86-129">내부 IP에 대한 역방향 DNS</span><span class="sxs-lookup"><span data-stu-id="27f86-129">Reverse DNS for internal IPs</span></span> |[<span data-ttu-id="27f86-130">자체 DNS 서버를 사용한 이름 확인</span><span class="sxs-lookup"><span data-stu-id="27f86-130">Name resolution using your own DNS server</span></span>](#name-resolution-using-your-own-dns-server) |<span data-ttu-id="27f86-131">해당 없음</span><span class="sxs-lookup"><span data-stu-id="27f86-131">n/a</span></span> |
| <span data-ttu-id="27f86-132">서로 다른 클라우드 서비스에 위치하며 가상 네트워크에 존재하지 않는 VM 또는 역할 인스턴스 간 이름 확인</span><span class="sxs-lookup"><span data-stu-id="27f86-132">Name resolution between VMs or role instances located in different cloud services, not in a virtual network</span></span> |<span data-ttu-id="27f86-133">사용할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="27f86-133">Not applicable.</span></span> <span data-ttu-id="27f86-134">가상 네트워크 외부에 있는 VM과 역할 인스턴스가 서로 다른 클라우드 서비스에 위치한 경우에는 연결을 지원하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="27f86-134">Connectivity between VMs and role instances in different cloud services is not supported outside a virtual network.</span></span> |<span data-ttu-id="27f86-135">해당 없음</span><span class="sxs-lookup"><span data-stu-id="27f86-135">n/a</span></span> |

## <a name="azure-provided-name-resolution"></a><span data-ttu-id="27f86-136">Azure에서 제공하는 이름 확인</span><span class="sxs-lookup"><span data-stu-id="27f86-136">Azure-provided name resolution</span></span>
<span data-ttu-id="27f86-137">공용 DNS 이름 확인와 Azure Vm에 대 한 내부 이름 확인을 제공 하 고, 역할 인스턴스 내에 있는 동일한 가상 네트워크 또는 클라우드 서비스 hello 합니다.</span><span class="sxs-lookup"><span data-stu-id="27f86-137">Along with resolution of public DNS names, Azure provides internal name resolution for VMs and role instances that reside within hello same virtual network or cloud service.</span></span>  <span data-ttu-id="27f86-138">Vm/클라우드 서비스의 인스턴스는 동일한 DNS 접미사 (충분 한 hello 호스트 이름 만으로는 이므로) 그러나 클래식 가상 네트워크 서로 다른 클라우드 서비스는 서로 다른 DNS 접미사 hello FQDN은 서로 다른 클라우드 서비스 간에 필요한 tooresolve 이름을 hello를 공유 합니다.</span><span class="sxs-lookup"><span data-stu-id="27f86-138">VMs/instances in a cloud service share hello same DNS suffix (so hello hostname alone is sufficient) but in classic virtual networks different cloud services have different DNS suffixes so hello FQDN is needed tooresolve names between different cloud services.</span></span>  <span data-ttu-id="27f86-139">Hello 리소스 관리자 배포 모델의 가상 네트워크에 DNS 접미사 hello 일관적 hello 가상 네트워크를 통해 (있으므로 hello FQDN 필요 하지 않습니다) 이며 tooboth Nic 및 Vm에는 DNS 이름을 지정할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="27f86-139">In virtual networks in hello Resource Manager deployment model, hello DNS suffix is consistent across hello virtual network (so hello FQDN is not needed) and DNS names can be assigned tooboth NICs and VMs.</span></span> <span data-ttu-id="27f86-140">하지만 Azure 제공 이름 확인에는 구성이 필요 하지 않지만 하지 hello 적절 한 선택은 모든 배포 시나리오에 대 한 위의 hello 테이블에 표시 된 것과 같이 합니다.</span><span class="sxs-lookup"><span data-stu-id="27f86-140">Although Azure-provided name resolution does not require any configuration, it is not hello appropriate choice for all deployment scenarios, as seen on hello table above.</span></span>

> [!NOTE]
> <span data-ttu-id="27f86-141">웹 및 작업자 역할의 경우 hello hello hello 역할 이름 및 인스턴스 번호 hello Azure 서비스 관리 REST API를 사용 하 여를 기반으로 역할 인스턴스의 내부 IP 주소를 액세스할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="27f86-141">In hello case of web and worker roles, you can also access hello internal IP addresses of role instances based on hello role name and instance number using hello Azure Service Management REST API.</span></span> <span data-ttu-id="27f86-142">자세한 내용은 [서비스 관리 REST API 참조](https://msdn.microsoft.com/library/azure/ee460799.aspx)를 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="27f86-142">For more information, see [Service Management REST API Reference](https://msdn.microsoft.com/library/azure/ee460799.aspx).</span></span>
> 
> 

### <a name="features-and-considerations"></a><span data-ttu-id="27f86-143">기능 및 고려 사항</span><span class="sxs-lookup"><span data-stu-id="27f86-143">Features and Considerations</span></span>
<span data-ttu-id="27f86-144">**기능:**</span><span class="sxs-lookup"><span data-stu-id="27f86-144">**Features:**</span></span>

* <span data-ttu-id="27f86-145">사용 편의성: 순서 toouse Azure 제공 이름 확인에에서 필요한 구성이 없습니다.</span><span class="sxs-lookup"><span data-stu-id="27f86-145">Ease of use: No configuration is required in order toouse Azure-provided name resolution.</span></span>
* <span data-ttu-id="27f86-146">hello Azure 제공 이름 확인 서비스는 항상 사용 가능을 저장 하면 hello toocreate 필요한 사용자 고유의 DNS 서버 클러스터를 관리 합니다.</span><span class="sxs-lookup"><span data-stu-id="27f86-146">hello Azure-provided name resolution service is highly available, saving you hello need toocreate and manage clusters of your own DNS servers.</span></span>
* <span data-ttu-id="27f86-147">사용자 고유의 DNS 서버 tooresolve와 함께에서 사용할 수 있습니다 온-프레미스와 Azure 호스트 이름입니다.</span><span class="sxs-lookup"><span data-stu-id="27f86-147">Can be used in conjunction with your own DNS servers tooresolve both on-premises and Azure hostnames.</span></span>
* <span data-ttu-id="27f86-148">이름 확인에는 동일한 클라우드 서비스 FQDN에 대 한 필요 없이 역할 인스턴스/hello Vm 간에 제공 됩니다.</span><span class="sxs-lookup"><span data-stu-id="27f86-148">Name resolution is provided between role instances/VMs within hello same cloud service without need for a FQDN.</span></span>
* <span data-ttu-id="27f86-149">이름 확인은 hello FQDN에 대 한 필요 없이 hello 리소스 관리자 배포 모델을 사용 하는 가상 네트워크의 Vm 간에 제공 됩니다.</span><span class="sxs-lookup"><span data-stu-id="27f86-149">Name resolution is provided between VMs in virtual networks that use hello Resource Manager deployment model, without need for hello FQDN.</span></span> <span data-ttu-id="27f86-150">Hello 클래식 배포 모델에서 가상 네트워크는 서로 다른 클라우드 서비스의 이름을 확인할 때 hello FQDN 필요 합니다.</span><span class="sxs-lookup"><span data-stu-id="27f86-150">Virtual networks in hello classic deployment model require hello FQDN when resolving names in different cloud services.</span></span> 
* <span data-ttu-id="27f86-151">자동 생성되는 이름 대신에 배포를 가장 잘 설명해주는 호스트 이름을 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="27f86-151">You can use hostnames that best describe your deployments, rather than working with auto-generated names.</span></span>

<span data-ttu-id="27f86-152">**고려 사항:**</span><span class="sxs-lookup"><span data-stu-id="27f86-152">**Considerations:**</span></span>

* <span data-ttu-id="27f86-153">hello Azure에서 만든 DNS 접미사를 수정할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="27f86-153">hello Azure-created DNS suffix cannot be modified.</span></span>
* <span data-ttu-id="27f86-154">사용자 고유의 레코드를 수동으로 등록할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="27f86-154">You cannot manually register your own records.</span></span>
* <span data-ttu-id="27f86-155">WINS 및 NetBIOS는 지원되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="27f86-155">WINS and NetBIOS are not supported.</span></span> <span data-ttu-id="27f86-156">(Windows 탐색기에 VM은 표시되지 않습니다.)</span><span class="sxs-lookup"><span data-stu-id="27f86-156">(You cannot see your VMs in Windows Explorer.)</span></span>
* <span data-ttu-id="27f86-157">호스트 이름이 DNS와 호환될 수 있어야 합니다. (0-9, a-z 및 '-'만 사용이 가능하며, '-'로 시작하거나 끝날 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="27f86-157">Hostnames must be DNS-compatible (They must use only 0-9, a-z and '-', and cannot start or end with a '-'.</span></span> <span data-ttu-id="27f86-158">RFC 3696 섹션을 2를 참조하세요.)</span><span class="sxs-lookup"><span data-stu-id="27f86-158">See RFC 3696 section 2.)</span></span>
* <span data-ttu-id="27f86-159">DNS 쿼리 트래픽은 각 VM에 대해 제한됩니다.</span><span class="sxs-lookup"><span data-stu-id="27f86-159">DNS query traffic is throttled for each VM.</span></span> <span data-ttu-id="27f86-160">이 대부분의 응용 프로그램에 영향을 주지 않아야 합니다.</span><span class="sxs-lookup"><span data-stu-id="27f86-160">This shouldn't impact most applications.</span></span>  <span data-ttu-id="27f86-161">요청 제한이 확인되는 경우 클라이언트쪽 캐싱이 사용하도록 설정되었는지 확인합니다.</span><span class="sxs-lookup"><span data-stu-id="27f86-161">If request throttling is observed, ensure that client-side caching is enabled.</span></span>  <span data-ttu-id="27f86-162">자세한 내용은 참조 하십시오. [hello Azure 제공 이름 확인 대부분 가져오는](#Getting-the-most-from-Azure-provided-name-resolution)합니다.</span><span class="sxs-lookup"><span data-stu-id="27f86-162">For more details, see [Getting hello most from Azure-provided name resolution](#Getting-the-most-from-Azure-provided-name-resolution).</span></span>
* <span data-ttu-id="27f86-163">클래식 배포 모델에서 각 가상 네트워크에 대 한 hello 처음 180 개의 클라우드 서비스 내의 Vm만 등록 됩니다.</span><span class="sxs-lookup"><span data-stu-id="27f86-163">Only VMs in hello first 180 cloud services are registered for each virtual network in a classic deployment model.</span></span> <span data-ttu-id="27f86-164">Toovirtual 네트워크 리소스 관리자 배포 모델에는 적용 되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="27f86-164">This does not apply toovirtual networks in Resource Manager deployment models.</span></span>

### <a name="getting-hello-most-from-azure-provided-name-resolution"></a><span data-ttu-id="27f86-165">Hello Azure 제공 이름 확인 대부분 가져오기</span><span class="sxs-lookup"><span data-stu-id="27f86-165">Getting hello most from Azure-provided name resolution</span></span>
<span data-ttu-id="27f86-166">**클라이언트쪽 캐싱:**</span><span class="sxs-lookup"><span data-stu-id="27f86-166">**Client-side Caching:**</span></span>

<span data-ttu-id="27f86-167">모든 DNS 쿼리 toobe hello 네트워크를 통해 전송 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="27f86-167">Not every DNS query needs toobe sent across hello network.</span></span>  <span data-ttu-id="27f86-168">클라이언트 쪽 캐싱 대기 시간을 줄이고 로컬 캐시에서 되풀이 DNS 쿼리를 확인 하 여 복원 력을 toonetwork 탐사를 향상 시킬 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="27f86-168">Client-side caching helps reduce latency and improve resilience toonetwork blips by resolving recurring DNS queries from a local cache.</span></span>  <span data-ttu-id="27f86-169">DNS 레코드는 활성 시간 (TTL) 하므로 대부분의 경우에 적합 한 클라이언트 쪽 캐싱 레코드 freshness, 영향을 주지 않고 가능한 한 오랫동안에 대 한 hello 캐시 toostore hello 레코드 수를 포함 합니다.</span><span class="sxs-lookup"><span data-stu-id="27f86-169">DNS records contain a Time-To-Live (TTL) which allows hello cache toostore hello record for as long as possible without impacting record freshness, so client-side caching is suitable for most situations.</span></span>

<span data-ttu-id="27f86-170">hello 기본 Windows DNS 클라이언트는 기본 제공 되는 DNS 캐시를 있습니다.</span><span class="sxs-lookup"><span data-stu-id="27f86-170">hello default Windows DNS Client has a DNS cache built-in.</span></span>  <span data-ttu-id="27f86-171">일부 Linux 배포판에 기본적으로 캐싱을 포함 되지 않습니다 (아님을 로컬 캐시 이미 확인) 한 후 tooeach Linux VM을 추가할 수 하나 것이 좋습니다.</span><span class="sxs-lookup"><span data-stu-id="27f86-171">Some Linux distros do not include caching by default, it is recommended that one be added tooeach Linux VM (after checking that there isn't a local cache already).</span></span>

<span data-ttu-id="27f86-172">제공 되는 다른 DNS 캐싱 패키지, 예: dnsmasq 여러 가지, hello 가장 일반적인 배포판에 hello 단계 tooinstall dnsmasq 다음과 같습니다.</span><span class="sxs-lookup"><span data-stu-id="27f86-172">There are a number of different DNS caching packages available, e.g. dnsmasq, here are hello steps tooinstall dnsmasq on hello most common distros:</span></span>

* <span data-ttu-id="27f86-173">**Ubuntu(resolvconf 사용)**:</span><span class="sxs-lookup"><span data-stu-id="27f86-173">**Ubuntu (uses resolvconf)**:</span></span>
  * <span data-ttu-id="27f86-174">방금 hello dnsmasq 패키지 ("sudo apt get 설치 dnsmasq")를 설치 합니다.</span><span class="sxs-lookup"><span data-stu-id="27f86-174">just install hello dnsmasq package (“sudo apt-get install dnsmasq”).</span></span>
* <span data-ttu-id="27f86-175">**SUSE(netconf 사용)**:</span><span class="sxs-lookup"><span data-stu-id="27f86-175">**SUSE (uses netconf)**:</span></span>
  * <span data-ttu-id="27f86-176">hello dnsmasq 패키지 ("sudo zypper 설치 dnsmasq")를 설치 합니다.</span><span class="sxs-lookup"><span data-stu-id="27f86-176">install hello dnsmasq package (“sudo zypper install dnsmasq”)</span></span> 
  * <span data-ttu-id="27f86-177">hello dnsmasq 서비스 ("systemctl enable dnsmasq.service")를 사용 하도록 설정</span><span class="sxs-lookup"><span data-stu-id="27f86-177">enable hello dnsmasq service (“systemctl enable dnsmasq.service”)</span></span> 
  * <span data-ttu-id="27f86-178">hello dnsmasq 서비스 ("systemctl 시작 dnsmasq.service")를 시작 합니다.</span><span class="sxs-lookup"><span data-stu-id="27f86-178">start hello dnsmasq service (“systemctl start dnsmasq.service”)</span></span> 
  * <span data-ttu-id="27f86-179">편집 "/ 등/sysconfig/네트워크/config" NETCONFIG_DNS_FORWARDER 변경 = "" 너무 "dnsmasq"</span><span class="sxs-lookup"><span data-stu-id="27f86-179">edit “/etc/sysconfig/network/config” and change NETCONFIG_DNS_FORWARDER="" too”dnsmasq”</span></span>
  * <span data-ttu-id="27f86-180">로컬 DNS 확인자 hello 대로 resolv.conf ("다음과 같은 netconfig 업데이트") tooset hello 캐시 업데이트</span><span class="sxs-lookup"><span data-stu-id="27f86-180">update resolv.conf ("netconfig update") tooset hello cache as hello local DNS resolver</span></span>
* <span data-ttu-id="27f86-181">**OpenLogic(NetworkManager 사용)**:</span><span class="sxs-lookup"><span data-stu-id="27f86-181">**OpenLogic (uses NetworkManager)**:</span></span>
  * <span data-ttu-id="27f86-182">hello dnsmasq 패키지 ("sudo yum 설치 dnsmasq")를 설치 합니다.</span><span class="sxs-lookup"><span data-stu-id="27f86-182">install hello dnsmasq package (“sudo yum install dnsmasq”)</span></span>
  * <span data-ttu-id="27f86-183">hello dnsmasq 서비스 ("systemctl enable dnsmasq.service")를 사용 하도록 설정</span><span class="sxs-lookup"><span data-stu-id="27f86-183">enable hello dnsmasq service (“systemctl enable dnsmasq.service”)</span></span>
  * <span data-ttu-id="27f86-184">hello dnsmasq 서비스 ("systemctl 시작 dnsmasq.service")를 시작 합니다.</span><span class="sxs-lookup"><span data-stu-id="27f86-184">start hello dnsmasq service (“systemctl start dnsmasq.service”)</span></span>
  * <span data-ttu-id="27f86-185">"도메인 이름 서버 127.0.0.1; 앞에 추가" 추가 too"/etc/dhclient-eth0.conf"</span><span class="sxs-lookup"><span data-stu-id="27f86-185">add “prepend domain-name-servers 127.0.0.1;” too“/etc/dhclient-eth0.conf”</span></span>
  * <span data-ttu-id="27f86-186">로컬 DNS 확인자 hello 대로 hello 네트워크 서비스 ("서비스 네트워크를 다시 시작") tooset hello 캐시를 다시 시작</span><span class="sxs-lookup"><span data-stu-id="27f86-186">restart hello network service (“service network restart”) tooset hello cache as hello local DNS resolver</span></span>

> [!NOTE]
> <span data-ttu-id="27f86-187">hello 'dnsmasq' 패키지 많은 DNS 캐시를 사용할 수 있는 Linux 용는 hello 중 하나입니다.</span><span class="sxs-lookup"><span data-stu-id="27f86-187">hello 'dnsmasq' package is only one of hello many DNS caches available for Linux.</span></span>  <span data-ttu-id="27f86-188">사용하기 전에 특정 요구 사항에 대한 적합성을 확인하고 다른 캐시가 설치되어 있지 않은지 확인합니다.</span><span class="sxs-lookup"><span data-stu-id="27f86-188">Before using it, please check its suitability for your particular needs and that no other cache is installed.</span></span>
> 
> 

<span data-ttu-id="27f86-189">**클라이언트쪽 재시도:**</span><span class="sxs-lookup"><span data-stu-id="27f86-189">**Client-side Retries:**</span></span>

<span data-ttu-id="27f86-190">DNS는 주로 UDP 프로토콜입니다.</span><span class="sxs-lookup"><span data-stu-id="27f86-190">DNS is primarily a UDP protocol.</span></span>  <span data-ttu-id="27f86-191">UDP 프로토콜 hello 메시지 배달을 보장 하지 않습니다, 처럼 재시도 논리 hello DNS 프로토콜 자체에서 처리 됩니다.</span><span class="sxs-lookup"><span data-stu-id="27f86-191">As hello UDP protocol doesn't guarantee message delivery, retry logic is handled in hello DNS protocol itself.</span></span>  <span data-ttu-id="27f86-192">각 DNS 클라이언트 (운영 체제) hello 작성자가 기본 설정에 따라 다시 시도 논리를 나타낼 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="27f86-192">Each DNS client (operating system) can exhibit different retry logic depending on hello creators preference:</span></span>

* <span data-ttu-id="27f86-193">Windows 운영 체제는 1초 후 재시도한 후 2초, 4초 후 다시 재시도하고 또 다시 4초 후 재시도합니다.</span><span class="sxs-lookup"><span data-stu-id="27f86-193">Windows operating systems retry after 1 second and then again after another 2, 4 and another 4 seconds.</span></span> 
* <span data-ttu-id="27f86-194">hello 기본 Linux 설치 후에 다시 시도 5 초입니다.</span><span class="sxs-lookup"><span data-stu-id="27f86-194">hello default Linux setup retries after 5 seconds.</span></span>  <span data-ttu-id="27f86-195">5 번 1 초 간격이 tooretry toochange을 것이 좋습니다.</span><span class="sxs-lookup"><span data-stu-id="27f86-195">It is recommended toochange this tooretry 5 times at 1 second intervals.</span></span>  

<span data-ttu-id="27f86-196">toocheck hello 'cat /etc/resolv.conf' Linux VM의 현재 설정 하 고 예를 들어 hello '옵션' 줄 확인:</span><span class="sxs-lookup"><span data-stu-id="27f86-196">toocheck hello current settings on a Linux VM, 'cat /etc/resolv.conf' and look at hello 'options' line, e.g.:</span></span>

    options timeout:1 attempts:5

<span data-ttu-id="27f86-197">hello resolv.conf 파일은 일반적으로 자동 생성 및 편집할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="27f86-197">hello resolv.conf file is usually auto-generated and should not be edited.</span></span>  <span data-ttu-id="27f86-198">옵션' hello' 줄을 추가 하기 위한 구체적인 단계 hello distro로 다릅니다.</span><span class="sxs-lookup"><span data-stu-id="27f86-198">hello specific steps for adding hello 'options' line vary by distro:</span></span>

* <span data-ttu-id="27f86-199">**Ubuntu** (resolvconf 사용):</span><span class="sxs-lookup"><span data-stu-id="27f86-199">**Ubuntu** (uses resolvconf):</span></span>
  * <span data-ttu-id="27f86-200">hello 옵션 선 too'/etc/resolveconf/resolv.conf.d/head 추가 '</span><span class="sxs-lookup"><span data-stu-id="27f86-200">add hello options line too'/etc/resolveconf/resolv.conf.d/head'</span></span> 
  * <span data-ttu-id="27f86-201">' resolvconf u' tooupdate 실행</span><span class="sxs-lookup"><span data-stu-id="27f86-201">run 'resolvconf -u' tooupdate</span></span>
* <span data-ttu-id="27f86-202">**SUSE** (netconf 사용):</span><span class="sxs-lookup"><span data-stu-id="27f86-202">**SUSE** (uses netconf):</span></span>
  * <span data-ttu-id="27f86-203">' timeout:1 시도 횟수: 5' toohello NETCONFIG_DNS_RESOLVER_OPTIONS 추가 = ""에 '/ 등/sysconfig/네트워크/config' 매개 변수</span><span class="sxs-lookup"><span data-stu-id="27f86-203">add 'timeout:1 attempts:5' toohello NETCONFIG_DNS_RESOLVER_OPTIONS="" parameter in '/etc/sysconfig/network/config'</span></span> 
  * <span data-ttu-id="27f86-204">'다음과 같은 netconfig 업데이트' tooupdate 실행</span><span class="sxs-lookup"><span data-stu-id="27f86-204">run 'netconfig update' tooupdate</span></span>
* <span data-ttu-id="27f86-205">**OpenLogic** (NetworkManager 사용):</span><span class="sxs-lookup"><span data-stu-id="27f86-205">**OpenLogic** (uses NetworkManager):</span></span>
  * <span data-ttu-id="27f86-206">추가 too'/etc/NetworkManager/dispatcher.d/11-dhclient '에코 "옵션 timeout:1 시도 횟수: 5" ' '</span><span class="sxs-lookup"><span data-stu-id="27f86-206">add 'echo "options timeout:1 attempts:5"' too'/etc/NetworkManager/dispatcher.d/11-dhclient'</span></span> 
  * <span data-ttu-id="27f86-207">서비스가 네트워크 다시 시작' tooupdate 실행</span><span class="sxs-lookup"><span data-stu-id="27f86-207">run 'service network restart' tooupdate</span></span>

## <a name="name-resolution-using-your-own-dns-server"></a><span data-ttu-id="27f86-208">자체 DNS 서버를 이용한 이름 확인</span><span class="sxs-lookup"><span data-stu-id="27f86-208">Name resolution using your own DNS server</span></span>
<span data-ttu-id="27f86-209">이름 확인 요구 될 수 있습니다 이동 hello 기능 Azure에서 제공 예를 들어 경우 초과 사용 하 여 Active Directory 도메인 또는 가상 네트워크 (vnet) 간의 DNS 확인을 요구 하는 경우 다양 한 상황이 있습니다.</span><span class="sxs-lookup"><span data-stu-id="27f86-209">There are a number of situations where your name resolution needs may go beyond hello features provided by Azure, for example when using Active Directory domains or when you require DNS resolution between virtual networks (vnets).</span></span>  <span data-ttu-id="27f86-210">toocover 이러한 시나리오에서는 Azure 기능을 제공 hello toouse 있습니다에 대 한 사용자 고유 DNS 서버입니다.</span><span class="sxs-lookup"><span data-stu-id="27f86-210">toocover these scenarios, Azure provides hello ability for you toouse your own DNS servers.</span></span>  

<span data-ttu-id="27f86-211">가상 네트워크 내에서 DNS 서버는 해당 가상 네트워크 내에서 tooresolve 호스트 이름이 DNS 쿼리 tooAzure 재귀 확인자 전달할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="27f86-211">DNS servers within a virtual network can forward DNS queries tooAzure's recursive resolvers tooresolve hostnames within that virtual network.</span></span>  <span data-ttu-id="27f86-212">예를 들어 도메인 컨트롤러 (DC) Azure에서 실행 중인 tooDNS 쿼리 해당 도메인에 대 한 응답을 다른 모든 쿼리 tooAzure 전달 됩니다.</span><span class="sxs-lookup"><span data-stu-id="27f86-212">For example, a Domain Controller (DC) running in Azure can respond tooDNS queries for its domains and forward all other queries tooAzure.</span></span>  <span data-ttu-id="27f86-213">이렇게 하면 Vm toosee (DC hello)를 통해 온-프레미스 리소스와 (hello 전달자)를 통해 Azure에서 제공 호스트 이름입니다.</span><span class="sxs-lookup"><span data-stu-id="27f86-213">This allows VMs toosee both your on-premises resources (via hello DC) and Azure-provided hostnames (via hello forwarder).</span></span>  <span data-ttu-id="27f86-214">액세스 tooAzure 재귀 확인자 hello 가상 IP 168.63.129.16 통해 제공 됩니다.</span><span class="sxs-lookup"><span data-stu-id="27f86-214">Access tooAzure's recursive resolvers is provided via hello virtual IP 168.63.129.16.</span></span>

<span data-ttu-id="27f86-215">또한 DNS 전달 간 vnet DNS 확인 있으며 온-프레미스 컴퓨터 tooresolve Azure에서 제공 되는 호스트 이름이 있습니다.</span><span class="sxs-lookup"><span data-stu-id="27f86-215">DNS forwarding also enables inter-vnet DNS resolution and allows your on-premises machines tooresolve Azure-provided hostnames.</span></span>  <span data-ttu-id="27f86-216">주문 tooresolve VM의 호스트 이름, VM hello DNS 서버에에서 있어야 hello 동일한 가상 네트워크 및 구성 된 tooforward hostname 쿼리 tooAzure 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="27f86-216">In order tooresolve a VM's hostname, hello DNS server VM must reside in hello same virtual network and be configured tooforward hostname queries tooAzure.</span></span>  <span data-ttu-id="27f86-217">조건부 전달 hello DNS 접미사 각 vnet에 다른 그대로 사용할 수 있습니다 toosend DNS 쿼리 toohello 규칙 확인용 vnet을 해결 합니다.</span><span class="sxs-lookup"><span data-stu-id="27f86-217">As hello DNS suffix is different in each vnet, you can use conditional forwarding rules toosend DNS queries toohello correct vnet for resolution.</span></span>  <span data-ttu-id="27f86-218">다음 이미지는 hello 두 vnet 및이 메서드를 사용 하 여 vnet 간 DNS 확인을 수행 하는 온-프레미스 네트워크를 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="27f86-218">hello following image shows two vnets and an on-premises network doing inter-vnet DNS resolution using this method.</span></span>  <span data-ttu-id="27f86-219">예제 DNS 전달자는 hello 영어로 [Azure 빠른 시작 템플릿 갤러리](https://azure.microsoft.com/documentation/templates/301-dns-forwarder/) 및 [GitHub](https://github.com/Azure/azure-quickstart-templates/tree/master/301-dns-forwarder)합니다.</span><span class="sxs-lookup"><span data-stu-id="27f86-219">An example DNS forwarder is available in hello [Azure Quickstart Templates gallery](https://azure.microsoft.com/documentation/templates/301-dns-forwarder/) and [GitHub](https://github.com/Azure/azure-quickstart-templates/tree/master/301-dns-forwarder).</span></span>

![Vnet 간 DNS](./media/virtual-networks-name-resolution-for-vms-and-role-instances/inter-vnet-dns.png)

<span data-ttu-id="27f86-221">Azure 제공 이름 확인이 내부 DNS 접미사를 사용 하는 경우 (*. internal.cloudapp.net) DHCP를 사용 하 여 제공 된 tooeach VM 됩니다.</span><span class="sxs-lookup"><span data-stu-id="27f86-221">When using Azure-provided name resolution, an Internal DNS suffix (*.internal.cloudapp.net) is provided tooeach VM using DHCP.</span></span>  <span data-ttu-id="27f86-222">이 통해 레코드 hello internal.cloudapp.net 영역에는 hello 호스트 이름으로 호스트 이름 확인 합니다.</span><span class="sxs-lookup"><span data-stu-id="27f86-222">This enables hostname resolution as hello hostname records are in hello internal.cloudapp.net zone.</span></span>  <span data-ttu-id="27f86-223">사용자 고유의 이름 확인 솔루션을 사용 하는 경우 다른 DNS 아키텍처 (예: 도메인에 가입 된 시나리오) 충돌 하므로 IDN 접미사가 않습니다 hello tooVMs를 제공 합니다.</span><span class="sxs-lookup"><span data-stu-id="27f86-223">When using your own name resolution solution, hello IDNS suffix is not supplied tooVMs because it interferes with other DNS architectures (like domain-joined scenarios).</span></span>  <span data-ttu-id="27f86-224">대신 작동하지 않는 자리 표시자(reddog.microsoft.com)가 제공됩니다.</span><span class="sxs-lookup"><span data-stu-id="27f86-224">Instead we provide a non-functioning placeholder (reddog.microsoft.com).</span></span>  

<span data-ttu-id="27f86-225">필요한 경우 PowerShell 또는 hello API를 사용 하 여 hello 내부 DNS 접미사를 확인할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="27f86-225">If needed, hello Internal DNS suffix can be determined using PowerShell or hello API:</span></span>

* <span data-ttu-id="27f86-226">리소스 관리자 배포 모델에서 가상 네트워크에 대 한 hello 접미사는 hello를 통해 사용할 수 있는 [네트워크 인터페이스 카드](https://msdn.microsoft.com/library/azure/mt163668.aspx) 리소스 또는 hello를 통해 [Get AzureRmNetworkInterface](https://msdn.microsoft.com/library/mt619434.aspx) cmdlet.</span><span class="sxs-lookup"><span data-stu-id="27f86-226">For virtual networks in Resource Manager deployment models, hello suffix is available via hello [network interface card](https://msdn.microsoft.com/library/azure/mt163668.aspx) resource or via hello [Get-AzureRmNetworkInterface](https://msdn.microsoft.com/library/mt619434.aspx) cmdlet.</span></span>    
* <span data-ttu-id="27f86-227">클래식 배포 모델에서 hello 접미사는 hello를 통해 사용할 수 있는 [배포 API 가져오기](https://msdn.microsoft.com/library/azure/ee460804.aspx) 호출 또는 hello를 통해 [Get-azurevm-디버그](https://msdn.microsoft.com/library/azure/dn495236.aspx) cmdlet.</span><span class="sxs-lookup"><span data-stu-id="27f86-227">In classic deployment models, hello suffix is available via hello [Get Deployment API](https://msdn.microsoft.com/library/azure/ee460804.aspx) call or via hello [Get-AzureVM -Debug](https://msdn.microsoft.com/library/azure/dn495236.aspx) cmdlet.</span></span>

<span data-ttu-id="27f86-228">TooAzure 요구 사항에 적합 하지 않습니다는 쿼리를 전달 하는 경우 자체 DNS 솔루션 tooprovide 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="27f86-228">If forwarding queries tooAzure doesn't suit your needs, you will need tooprovide your own DNS solution.</span></span>  <span data-ttu-id="27f86-229">DNS 솔루션은 다음을 수행해야 합니다:</span><span class="sxs-lookup"><span data-stu-id="27f86-229">Your DNS solution will need to:</span></span>

* <span data-ttu-id="27f86-230">예를 들어 [DDNS](virtual-networks-name-resolution-ddns.md)를 통해 적절한 호스트 이름 확인을 제공해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="27f86-230">Provide appropriate hostname resolution, e.g. via [DDNS](virtual-networks-name-resolution-ddns.md).</span></span>  <span data-ttu-id="27f86-231">Note. DDNS toodisable DNS 레코드 청소 Azure의 DHCP 임대 매우 긴 하 여 청소 DNS 제거 될 수 있습니다를 할 수 있습니다를 사용 하 여 중간 기록 하는 경우.</span><span class="sxs-lookup"><span data-stu-id="27f86-231">Note, if using DDNS you may need toodisable DNS record scavenging as Azure's DHCP leases are very long and scavenging may remove DNS records prematurely.</span></span> 
* <span data-ttu-id="27f86-232">외부 도메인 이름의 적절 한 재귀 해상도 tooallow 확인을 제공 합니다.</span><span class="sxs-lookup"><span data-stu-id="27f86-232">Provide appropriate recursive resolution tooallow resolution of external domain names.</span></span>
* <span data-ttu-id="27f86-233">액세스할 수 있는 (TCP 및 UDP 포트 53) 사용 되 고 수 tooaccess 수 hello 클라이언트에서 인터넷 hello 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="27f86-233">Be accessible (TCP and UDP on port 53) from hello clients it serves and be able tooaccess hello internet.</span></span>
* <span data-ttu-id="27f86-234">Hello에서 액세스 로부터 보호 인터넷, 외부 에이전트에서 발생할 수 있는 toomitigate 위험 합니다.</span><span class="sxs-lookup"><span data-stu-id="27f86-234">Be secured against access from hello internet, toomitigate threats posed by external agents.</span></span>

> [!NOTE]
> <span data-ttu-id="27f86-235">최상의 성능을 위해 DNS 서버와 Azure Vm을 사용 하는 경우, i p v 6을 비활성화 해야 및 [인스턴스 수준 공용 IP](virtual-networks-instance-level-public-ip.md) tooeach DNS 서버 VM을 할당 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="27f86-235">For best performance, when using Azure VMs as DNS servers, IPv6 should be disabled and an [Instance-Level Public IP](virtual-networks-instance-level-public-ip.md) should be assigned tooeach DNS server VM.</span></span>  <span data-ttu-id="27f86-236">DNS 서버로 toouse Windows 서버를 선택 하면 [이 여기서](http://blogs.technet.com/b/networking/archive/2015/08/19/name-resolution-performance-of-a-recursive-windows-dns-server-2012-r2.aspx) 추가적인 성능 분석과 최적화를 제공 합니다.</span><span class="sxs-lookup"><span data-stu-id="27f86-236">If you choose toouse Windows Server as your DNS server, [this article](http://blogs.technet.com/b/networking/archive/2015/08/19/name-resolution-performance-of-a-recursive-windows-dns-server-2012-r2.aspx) provides additional performance analysis and optimizations.</span></span>
> 
> 

### <a name="specifying-dns-servers"></a><span data-ttu-id="27f86-237">DNS 서버 지정</span><span class="sxs-lookup"><span data-stu-id="27f86-237">Specifying DNS servers</span></span>
<span data-ttu-id="27f86-238">사용자 고유의 DNS 서버를 사용할 때 Azure 가상 네트워크 당 여러 DNS 서버 hello 기능 toospecify 제공 하나의 네트워크 인터페이스 (리소스 관리자) / 또는 클라우드 서비스 (클래식).</span><span class="sxs-lookup"><span data-stu-id="27f86-238">When using your own DNS servers, Azure provides hello ability toospecify multiple DNS servers per virtual network or per network interface (Resource Manager) / cloud service (classic).</span></span>  <span data-ttu-id="27f86-239">클라우드 서비스/네트워크 인터페이스에 대 한 지정 된 DNS 서버 hello 가상 네트워크에 대해 지정 된 조치 우선 순위를 가져옵니다.</span><span class="sxs-lookup"><span data-stu-id="27f86-239">DNS servers specified for a cloud service/network interface get precedence over those specified for hello virtual network.</span></span>

> [!NOTE]
> <span data-ttu-id="27f86-240">네트워크 연결 속성, 서비스 하는 동안 지워질 가져올 있습니다 대로 DNS 서버 Ip을 Windows Vm 내에서 직접 편집할 수와 같은 치료 hello 가상 네트워크 어댑터 바꾸면 가져옵니다.</span><span class="sxs-lookup"><span data-stu-id="27f86-240">Network connection properties, such as DNS server IPs, should not be edited directly within Windows VMs as they may get erased during service heal when hello virtual network adaptor gets replaced.</span></span> 
> 
> 

<span data-ttu-id="27f86-241">Hello 리소스 관리자 배포 모델을 사용할 때는 hello 포털, API/템플릿에에서 DNS 서버를 지정할 수 있습니다 ([vnet](https://msdn.microsoft.com/library/azure/mt163661.aspx), [nic](https://msdn.microsoft.com/library/azure/mt163668.aspx)) 또는 PowerShell ([vnet](https://msdn.microsoft.com/library/mt603657.aspx), [nic](https://msdn.microsoft.com/library/mt619370.aspx)).</span><span class="sxs-lookup"><span data-stu-id="27f86-241">When using hello Resource Manager deployment model, DNS servers can be specified in hello Portal, API/Templates ([vnet](https://msdn.microsoft.com/library/azure/mt163661.aspx), [nic](https://msdn.microsoft.com/library/azure/mt163668.aspx)) or PowerShell ([vnet](https://msdn.microsoft.com/library/mt603657.aspx), [nic](https://msdn.microsoft.com/library/mt619370.aspx)).</span></span>

<span data-ttu-id="27f86-242">Hello 클래식 배포 모델을 사용할 때는 DNS 서버 hello 가상 네트워크에 지정할 수 있습니다에 대 한 hello 포털 또는 [hello *네트워크 구성* 파일](https://msdn.microsoft.com/library/azure/jj157100)합니다.</span><span class="sxs-lookup"><span data-stu-id="27f86-242">When using hello classic deployment model, DNS servers for hello virtual network can be specified in hello Portal or [hello *Network Configuration* file](https://msdn.microsoft.com/library/azure/jj157100).</span></span>  <span data-ttu-id="27f86-243">클라우드 서비스에 대 한 hello DNS 서버를 통해 지정 [hello *서비스 구성* 파일](https://msdn.microsoft.com/library/azure/ee758710) 또는 PowerShell ([New-azurevm](https://msdn.microsoft.com/library/azure/dn495254.aspx)).</span><span class="sxs-lookup"><span data-stu-id="27f86-243">For cloud services, hello DNS servers are specified via [hello *Service Configuration* file](https://msdn.microsoft.com/library/azure/ee758710) or in PowerShell ([New-AzureVM](https://msdn.microsoft.com/library/azure/dn495254.aspx)).</span></span>

> [!NOTE]
> <span data-ttu-id="27f86-244">이미 배포 된 가상 네트워크/가상 컴퓨터에 대 한 hello DNS 설정을 변경 하면 toorestart 영향을 받는 각 VM에 필요한 hello 변경 tootake 효과입니다.</span><span class="sxs-lookup"><span data-stu-id="27f86-244">If you change hello DNS settings for a virtual network/virtual machine that is already deployed, you need toorestart each affected VM for hello changes tootake effect.</span></span>
> 
> 

## <a name="next-steps"></a><span data-ttu-id="27f86-245">다음 단계</span><span class="sxs-lookup"><span data-stu-id="27f86-245">Next steps</span></span>
<span data-ttu-id="27f86-246">리소스 관리자 배포 모델:</span><span class="sxs-lookup"><span data-stu-id="27f86-246">Resource Manager deployment model:</span></span>

* [<span data-ttu-id="27f86-247">가상 네트워크 만들기 또는 업데이트</span><span class="sxs-lookup"><span data-stu-id="27f86-247">Create or update a virtual network</span></span>](https://msdn.microsoft.com/library/azure/mt163661.aspx)
* [<span data-ttu-id="27f86-248">네트워크 인터페이스 카드 만들기 또는 업데이트</span><span class="sxs-lookup"><span data-stu-id="27f86-248">Create or update a network interface card</span></span>](https://msdn.microsoft.com/library/azure/mt163668.aspx)
* [<span data-ttu-id="27f86-249">새-AzureRmVirtualNetwork</span><span class="sxs-lookup"><span data-stu-id="27f86-249">New-AzureRmVirtualNetwork</span></span>](https://msdn.microsoft.com/library/mt603657.aspx)
* [<span data-ttu-id="27f86-250">새-AzureRmNetworkInterface</span><span class="sxs-lookup"><span data-stu-id="27f86-250">New-AzureRmNetworkInterface</span></span>](https://msdn.microsoft.com/library/mt619370.aspx)

<span data-ttu-id="27f86-251">클래식 배포 모델:</span><span class="sxs-lookup"><span data-stu-id="27f86-251">Classic deployment model:</span></span>

* [<span data-ttu-id="27f86-252">Azure 서비스 구성 스키마</span><span class="sxs-lookup"><span data-stu-id="27f86-252">Azure Service Configuration Schema</span></span>](https://msdn.microsoft.com/library/azure/ee758710)
* [<span data-ttu-id="27f86-253">가상 네트워크 구성 스키마</span><span class="sxs-lookup"><span data-stu-id="27f86-253">Virtual Network Configuration Schema</span></span>](https://msdn.microsoft.com/library/azure/jj157100)
* [<span data-ttu-id="27f86-254">네트워크 구성 파일을 사용하여 가상 네트워크 구성</span><span class="sxs-lookup"><span data-stu-id="27f86-254">Configure a Virtual Network by Using a Network Configuration File</span></span>](virtual-networks-using-network-configuration-file.md) 

