---
title: "VM 및 역할 인스턴스 이름 확인"
description: "Azure IaaS, 하이브리드 솔루션, 서로 다른 클라우드 서비스, Active Directory, 자체 DNS 서버 사용 시의 이름 확인 시나리오  "
services: virtual-network
documentationcenter: na
author: GarethBradshawMSFT
manager: carmonm
editor: tysonn
ms.assetid: 5d73edde-979a-470a-b28c-e103fcf07e3e
ms.service: virtual-network
ms.devlang: na
ms.topic: article
ms.tgt_pltfrm: na
ms.workload: infrastructure-services
ms.date: 12/06/2016
ms.author: telmos
ms.openlocfilehash: 479cf8cf358d0b242d8ce030d8639b493e4767d8
ms.sourcegitcommit: f537befafb079256fba0529ee554c034d73f36b0
ms.translationtype: MT
ms.contentlocale: ko-KR
ms.lasthandoff: 07/11/2017
---
# <a name="name-resolution-for-vms-and-role-instances"></a><span data-ttu-id="ef9f2-103">VM 및 역할 인스턴스에 대한 이름 확인</span><span class="sxs-lookup"><span data-stu-id="ef9f2-103">Name Resolution for VMs and Role Instances</span></span>
<span data-ttu-id="ef9f2-104">IaaS, PaaS, 하이브리드 솔루션 호스팅에 Azure를 어떻게 사용할지에 따라 귀하가 만든 VM 및 역할 인스턴스가 서로 통신하도록 설정해야 할 수도 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ef9f2-104">Depending on how you use Azure to host IaaS, PaaS, and hybrid solutions, you may need to allow the VMs and role instances that you create to communicate with each other.</span></span> <span data-ttu-id="ef9f2-105">IP 주소를 이용해 통신할 수도 있지만, 기억하기 쉽고 변경되지 않는 이름을 사용하면 보다 간편합니다.</span><span class="sxs-lookup"><span data-stu-id="ef9f2-105">Although this communication can be done by using IP addresses, it is much simpler to use names that can be easily remembered and do not change.</span></span> 

<span data-ttu-id="ef9f2-106">역할 인스턴스와 VM을 Azure에 호스트할 때 도메인 이름으로 내부 IP 주소를 확인하는 방법은 다음의 두 가지가 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ef9f2-106">When role instances and VMs hosted in Azure need to resolve domain names to internal IP addresses, they can use one of two methods:</span></span>

* [<span data-ttu-id="ef9f2-107">Azure에서 제공하는 이름 확인</span><span class="sxs-lookup"><span data-stu-id="ef9f2-107">Azure-provided name resolution</span></span>](#azure-provided-name-resolution)
* <span data-ttu-id="ef9f2-108">[자체 DNS 서버를 이용한 이름 확인](#name-resolution-using-your-own-dns-server) (Azure에서 제공하는 DNS 서버에 쿼리를 전달할 수 있음)</span><span class="sxs-lookup"><span data-stu-id="ef9f2-108">[Name resolution using your own DNS server](#name-resolution-using-your-own-dns-server) (which may forward queries to the Azure-provided DNS servers)</span></span> 

<span data-ttu-id="ef9f2-109">어떤 방법으로 이름을 확인할지는 사용하는 VM 및 역할 인스턴스가 서로 어떻게 통신해야 하는지에 따라 다릅니다.</span><span class="sxs-lookup"><span data-stu-id="ef9f2-109">The type of name resolution you use depends on how your VMs and role instances need to communicate with each other.</span></span>

<span data-ttu-id="ef9f2-110">**다음 표에 각 시나리오 별로 해당하는 이름 확인 방법이 나와 있습니다.**</span><span class="sxs-lookup"><span data-stu-id="ef9f2-110">**The following table illustrates scenarios and corresponding name resolution solutions:**</span></span>

| <span data-ttu-id="ef9f2-111">**시나리오**</span><span class="sxs-lookup"><span data-stu-id="ef9f2-111">**Scenario**</span></span> | <span data-ttu-id="ef9f2-112">**솔루션**</span><span class="sxs-lookup"><span data-stu-id="ef9f2-112">**Solution**</span></span> | <span data-ttu-id="ef9f2-113">**접미사**</span><span class="sxs-lookup"><span data-stu-id="ef9f2-113">**Suffix**</span></span> |
| --- | --- | --- |
| <span data-ttu-id="ef9f2-114">동일한 클라우드 서비스 또는 가상 네트워크에 위치한 역할 인스턴스 또는 VM 간 이름 확인</span><span class="sxs-lookup"><span data-stu-id="ef9f2-114">Name resolution between role instances or VMs located in the same cloud service or virtual network</span></span> |[<span data-ttu-id="ef9f2-115">Azure에서 제공하는 이름 확인</span><span class="sxs-lookup"><span data-stu-id="ef9f2-115">Azure-provided name resolution</span></span>](#azure-provided-name-resolution) |<span data-ttu-id="ef9f2-116">호스트 이름 또는 FQDN</span><span class="sxs-lookup"><span data-stu-id="ef9f2-116">hostname or FQDN</span></span> |
| <span data-ttu-id="ef9f2-117">서로 다른 네트워크에 위치한 역할 인스턴스 또는 VM 간 이름 확인</span><span class="sxs-lookup"><span data-stu-id="ef9f2-117">Name resolution between role instances or VMs located in different virtual networks</span></span> |<span data-ttu-id="ef9f2-118">고객이 관리하는 DNS 서버가 Azure(DNS 프록시)에서 확인을 위해 vnet 간의 쿼리를 전달합니다.</span><span class="sxs-lookup"><span data-stu-id="ef9f2-118">Customer-managed DNS servers forwarding queries between vnets for resolution by Azure (DNS proxy).</span></span>  <span data-ttu-id="ef9f2-119">[자체 DNS 서버를 이용한 이름 확인](#name-resolution-using-your-own-dns-server)</span><span class="sxs-lookup"><span data-stu-id="ef9f2-119">see [Name resolution using your own DNS server](#name-resolution-using-your-own-dns-server)</span></span> |<span data-ttu-id="ef9f2-120">FQDN만</span><span class="sxs-lookup"><span data-stu-id="ef9f2-120">FQDN only</span></span> |
| <span data-ttu-id="ef9f2-121">Azure의 VM 또는 역할 인스턴스에서 온-프레미스 컴퓨터와 서비스 이름 확인</span><span class="sxs-lookup"><span data-stu-id="ef9f2-121">Resolution of on-premises computer and service names from role instances or VMs in Azure</span></span> |<span data-ttu-id="ef9f2-122">고객이 관리하는 DNS 서버(예: 온-프레미스 도메인 컨트롤러, 로컬 읽기 전용 도메인 컨트롤러 또는 영역 전송을 사용하여 동기화된 DNS 보조)입니다.</span><span class="sxs-lookup"><span data-stu-id="ef9f2-122">Customer-managed DNS servers (e.g. on-premises domain controller, local read-only domain controller or a DNS secondary synced using zone transfers).</span></span>  <span data-ttu-id="ef9f2-123">See [자체 DNS 서버를 이용한 이름 확인](#name-resolution-using-your-own-dns-server)</span><span class="sxs-lookup"><span data-stu-id="ef9f2-123">See [Name resolution using your own DNS server](#name-resolution-using-your-own-dns-server)</span></span> |<span data-ttu-id="ef9f2-124">FQDN만</span><span class="sxs-lookup"><span data-stu-id="ef9f2-124">FQDN only</span></span> |
| <span data-ttu-id="ef9f2-125">온-프레미스 컴퓨터에서 Azure 호스트 이름 확인</span><span class="sxs-lookup"><span data-stu-id="ef9f2-125">Resolution of Azure hostnames from on-premises computers</span></span> |<span data-ttu-id="ef9f2-126">해당 vnet에서 고객이 관리하는 DNS 프록시 서버에 쿼리를 전달하면 프록시 서버는 이름 확인을 위해 Azure에 쿼리를 전달합니다.</span><span class="sxs-lookup"><span data-stu-id="ef9f2-126">Forward queries to a customer-managed DNS proxy server in the corresponding vnet, the proxy server forwards queries to Azure for resolution.</span></span> <span data-ttu-id="ef9f2-127">See [자체 DNS 서버를 이용한 이름 확인](#name-resolution-using-your-own-dns-server)</span><span class="sxs-lookup"><span data-stu-id="ef9f2-127">See [Name resolution using your own DNS server](#name-resolution-using-your-own-dns-server)</span></span> |<span data-ttu-id="ef9f2-128">FQDN만</span><span class="sxs-lookup"><span data-stu-id="ef9f2-128">FQDN only</span></span> |
| <span data-ttu-id="ef9f2-129">내부 IP에 대한 역방향 DNS</span><span class="sxs-lookup"><span data-stu-id="ef9f2-129">Reverse DNS for internal IPs</span></span> |[<span data-ttu-id="ef9f2-130">자체 DNS 서버를 사용한 이름 확인</span><span class="sxs-lookup"><span data-stu-id="ef9f2-130">Name resolution using your own DNS server</span></span>](#name-resolution-using-your-own-dns-server) |<span data-ttu-id="ef9f2-131">해당 없음</span><span class="sxs-lookup"><span data-stu-id="ef9f2-131">n/a</span></span> |
| <span data-ttu-id="ef9f2-132">서로 다른 클라우드 서비스에 위치하며 가상 네트워크에 존재하지 않는 VM 또는 역할 인스턴스 간 이름 확인</span><span class="sxs-lookup"><span data-stu-id="ef9f2-132">Name resolution between VMs or role instances located in different cloud services, not in a virtual network</span></span> |<span data-ttu-id="ef9f2-133">사용할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="ef9f2-133">Not applicable.</span></span> <span data-ttu-id="ef9f2-134">가상 네트워크 외부에 있는 VM과 역할 인스턴스가 서로 다른 클라우드 서비스에 위치한 경우에는 연결을 지원하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="ef9f2-134">Connectivity between VMs and role instances in different cloud services is not supported outside a virtual network.</span></span> |<span data-ttu-id="ef9f2-135">해당 없음</span><span class="sxs-lookup"><span data-stu-id="ef9f2-135">n/a</span></span> |

## <a name="azure-provided-name-resolution"></a><span data-ttu-id="ef9f2-136">Azure에서 제공하는 이름 확인</span><span class="sxs-lookup"><span data-stu-id="ef9f2-136">Azure-provided name resolution</span></span>
<span data-ttu-id="ef9f2-137">Azure에서는 공용 DNS 이름 확인과 함께, 동일한 가상 네트워크 또는 클라우드 서비스 내에 있는 VM 및 역할 인스턴스에 대한 내부 이름 확인을 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="ef9f2-137">Along with resolution of public DNS names, Azure provides internal name resolution for VMs and role instances that reside within the same virtual network or cloud service.</span></span>  <span data-ttu-id="ef9f2-138">클라우드 서비스의 VM/인스턴스는 동일한 DNS 접미사를 공유하므로 호스트 이름만으로도 충분하지만 클래식 가상 네트워크에서는 여러 클라우드 서비스에 여러 DNS 접미사가 있으므로 여러 클라우드 서비스에서 이름을 확인하려면 FQDN이 필요합니다.</span><span class="sxs-lookup"><span data-stu-id="ef9f2-138">VMs/instances in a cloud service share the same DNS suffix (so the hostname alone is sufficient) but in classic virtual networks different cloud services have different DNS suffixes so the FQDN is needed to resolve names between different cloud services.</span></span>  <span data-ttu-id="ef9f2-139">리소스 관리자 배포 모델 내의 가상 네트워크에 DNS 접미사가 가상 네트워크에 걸쳐 일관적이므로(따라서 FQDN이 필요 없음) NIC 및 VM 모두에 DNS 이름을 지정할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ef9f2-139">In virtual networks in the Resource Manager deployment model, the DNS suffix is consistent across the virtual network (so the FQDN is not needed) and DNS names can be assigned to both NICs and VMs.</span></span> <span data-ttu-id="ef9f2-140">Azure에서 제공한 이름 확인은 별도로 구성할 필요가 없으나, 위의 표에 나온 바와 같이 모든 배포 서비스에서 선택할 수 있는 것은 아닙니다.</span><span class="sxs-lookup"><span data-stu-id="ef9f2-140">Although Azure-provided name resolution does not require any configuration, it is not the appropriate choice for all deployment scenarios, as seen on the table above.</span></span>

> [!NOTE]
> <span data-ttu-id="ef9f2-141">웹 역할 및 작업자 역할의 경우, Azure 서비스 관리 REST API를 사용하면 역할 이름과 인스턴스 번호를 통해 역할 인스턴스의 내부 IP 주소를 접속할 수도 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ef9f2-141">In the case of web and worker roles, you can also access the internal IP addresses of role instances based on the role name and instance number using the Azure Service Management REST API.</span></span> <span data-ttu-id="ef9f2-142">자세한 내용은 [서비스 관리 REST API 참조](https://msdn.microsoft.com/library/azure/ee460799.aspx)를 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="ef9f2-142">For more information, see [Service Management REST API Reference](https://msdn.microsoft.com/library/azure/ee460799.aspx).</span></span>
> 
> 

### <a name="features-and-considerations"></a><span data-ttu-id="ef9f2-143">기능 및 고려 사항</span><span class="sxs-lookup"><span data-stu-id="ef9f2-143">Features and Considerations</span></span>
<span data-ttu-id="ef9f2-144">**기능:**</span><span class="sxs-lookup"><span data-stu-id="ef9f2-144">**Features:**</span></span>

* <span data-ttu-id="ef9f2-145">사용 편의성: Azure에서 제공하는 이름 확인을 사용하면 별도로 구성할 필요가 없습니다.</span><span class="sxs-lookup"><span data-stu-id="ef9f2-145">Ease of use: No configuration is required in order to use Azure-provided name resolution.</span></span>
* <span data-ttu-id="ef9f2-146">Azure에서 제공하는 이름 확인 서비스는 항상 사용 가능하며 사용자 고유 DNS 서버의 클러스터를 만들고 관리해야 하는 필요성을 줄여줍니다.</span><span class="sxs-lookup"><span data-stu-id="ef9f2-146">The Azure-provided name resolution service is highly available, saving you the need to create and manage clusters of your own DNS servers.</span></span>
* <span data-ttu-id="ef9f2-147">온-프레미스와 Azure 호스트 이름을 모두 확인하기 위해 자체 DNS 서버와 함께 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ef9f2-147">Can be used in conjunction with your own DNS servers to resolve both on-premises and Azure hostnames.</span></span>
* <span data-ttu-id="ef9f2-148">역할 인스턴스/VM이 동일한 클라우드 서비스에 위치할 경우에 이름 확인이 제공되며 FQDN이 필요하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="ef9f2-148">Name resolution is provided between role instances/VMs within the same cloud service without need for a FQDN.</span></span>
* <span data-ttu-id="ef9f2-149">리소스 관리자 배포 모델을 사용하는 가상 네트워크에서 VM 사이에 이름 확인이 제공됩니다. FQDN은 필요 없습니다.</span><span class="sxs-lookup"><span data-stu-id="ef9f2-149">Name resolution is provided between VMs in virtual networks that use the Resource Manager deployment model, without need for the FQDN.</span></span> <span data-ttu-id="ef9f2-150">다른 클라우드 서비스에서 이름을 확인할 때 클래식 배포 모델에서 가상 네트워크는 FQDN을 필요로 합니다.</span><span class="sxs-lookup"><span data-stu-id="ef9f2-150">Virtual networks in the classic deployment model require the FQDN when resolving names in different cloud services.</span></span> 
* <span data-ttu-id="ef9f2-151">자동 생성되는 이름 대신에 배포를 가장 잘 설명해주는 호스트 이름을 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ef9f2-151">You can use hostnames that best describe your deployments, rather than working with auto-generated names.</span></span>

<span data-ttu-id="ef9f2-152">**고려 사항:**</span><span class="sxs-lookup"><span data-stu-id="ef9f2-152">**Considerations:**</span></span>

* <span data-ttu-id="ef9f2-153">Azure에서 만든 DNS 접미사는 수정할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="ef9f2-153">The Azure-created DNS suffix cannot be modified.</span></span>
* <span data-ttu-id="ef9f2-154">사용자 고유의 레코드를 수동으로 등록할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="ef9f2-154">You cannot manually register your own records.</span></span>
* <span data-ttu-id="ef9f2-155">WINS 및 NetBIOS는 지원되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="ef9f2-155">WINS and NetBIOS are not supported.</span></span> <span data-ttu-id="ef9f2-156">(Windows 탐색기에 VM은 표시되지 않습니다.)</span><span class="sxs-lookup"><span data-stu-id="ef9f2-156">(You cannot see your VMs in Windows Explorer.)</span></span>
* <span data-ttu-id="ef9f2-157">호스트 이름이 DNS와 호환될 수 있어야 합니다. (0-9, a-z 및 '-'만 사용이 가능하며, '-'로 시작하거나 끝날 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="ef9f2-157">Hostnames must be DNS-compatible (They must use only 0-9, a-z and '-', and cannot start or end with a '-'.</span></span> <span data-ttu-id="ef9f2-158">RFC 3696 섹션을 2를 참조하세요.)</span><span class="sxs-lookup"><span data-stu-id="ef9f2-158">See RFC 3696 section 2.)</span></span>
* <span data-ttu-id="ef9f2-159">DNS 쿼리 트래픽은 각 VM에 대해 제한됩니다.</span><span class="sxs-lookup"><span data-stu-id="ef9f2-159">DNS query traffic is throttled for each VM.</span></span> <span data-ttu-id="ef9f2-160">이 대부분의 응용 프로그램에 영향을 주지 않아야 합니다.</span><span class="sxs-lookup"><span data-stu-id="ef9f2-160">This shouldn't impact most applications.</span></span>  <span data-ttu-id="ef9f2-161">요청 제한이 확인되는 경우 클라이언트쪽 캐싱이 사용하도록 설정되었는지 확인합니다.</span><span class="sxs-lookup"><span data-stu-id="ef9f2-161">If request throttling is observed, ensure that client-side caching is enabled.</span></span>  <span data-ttu-id="ef9f2-162">자세한 내용은 참조 [Azure에서 제공하는 이름 확인 활용](#Getting-the-most-from-Azure-provided-name-resolution)을 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="ef9f2-162">For more details, see [Getting the most from Azure-provided name resolution](#Getting-the-most-from-Azure-provided-name-resolution).</span></span>
* <span data-ttu-id="ef9f2-163">처음 180개의 클라우드 서비스 내에서 VM만 클래식 배포 모델 내의 가상 네트워크에 대해 등록됩니다.</span><span class="sxs-lookup"><span data-stu-id="ef9f2-163">Only VMs in the first 180 cloud services are registered for each virtual network in a classic deployment model.</span></span> <span data-ttu-id="ef9f2-164">이것은 리소스 관리자 배포 모델에서 가상 네트워크에는 적용되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="ef9f2-164">This does not apply to virtual networks in Resource Manager deployment models.</span></span>

### <a name="getting-the-most-from-azure-provided-name-resolution"></a><span data-ttu-id="ef9f2-165">Azure에서 제공하는 이름 확인 활용</span><span class="sxs-lookup"><span data-stu-id="ef9f2-165">Getting the most from Azure-provided name resolution</span></span>
<span data-ttu-id="ef9f2-166">**클라이언트쪽 캐싱:**</span><span class="sxs-lookup"><span data-stu-id="ef9f2-166">**Client-side Caching:**</span></span>

<span data-ttu-id="ef9f2-167">모든 DNS 쿼리를 네트워크를 통해 전송해야 하는 것은 아닙니다.</span><span class="sxs-lookup"><span data-stu-id="ef9f2-167">Not every DNS query needs to be sent across the network.</span></span>  <span data-ttu-id="ef9f2-168">클라이언트쪽 캐싱을 사용하면 대기 시간을 줄이고 로컬 캐시에서 되풀이되는 DNS 쿼리를 확인하여 네트워크 블립에 대한 복원력을 개선하는 데 도움이 됩니다.</span><span class="sxs-lookup"><span data-stu-id="ef9f2-168">Client-side caching helps reduce latency and improve resilience to network blips by resolving recurring DNS queries from a local cache.</span></span>  <span data-ttu-id="ef9f2-169">DNS 레코드는 레코드 새로 고침에 영향을 주지 않으면서 캐시가 가능한 오랫동안 레코드를 저장할 수 있도록 하는 TTL(Time-To-Live)을 포함하므로 클라이언트쪽 캐싱은 대부분의 상황에 적합합니다.</span><span class="sxs-lookup"><span data-stu-id="ef9f2-169">DNS records contain a Time-To-Live (TTL) which allows the cache to store the record for as long as possible without impacting record freshness, so client-side caching is suitable for most situations.</span></span>

<span data-ttu-id="ef9f2-170">기본 Windows DNS 클라이언트에는 기본 제공되는 DNS 캐시가 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ef9f2-170">The default Windows DNS Client has a DNS cache built-in.</span></span>  <span data-ttu-id="ef9f2-171">일부 Linux 배포판은 기본적으로 캐싱을 포함하지 않으므로 각 Linux VM에 캐싱을 추가하는 것이 좋습니다(로컬 캐시가 아직 없다는 것을 확인한 후).</span><span class="sxs-lookup"><span data-stu-id="ef9f2-171">Some Linux distros do not include caching by default, it is recommended that one be added to each Linux VM (after checking that there isn't a local cache already).</span></span>

<span data-ttu-id="ef9f2-172">dnsmasq와 같은 다양한 여러 DNS 캐싱이 제공되며 여기서는 가장 일반적인 배포판에 dnsmasq를 설치하는 단계를 설명합니다.</span><span class="sxs-lookup"><span data-stu-id="ef9f2-172">There are a number of different DNS caching packages available, e.g. dnsmasq, here are the steps to install dnsmasq on the most common distros:</span></span>

* <span data-ttu-id="ef9f2-173">**Ubuntu(resolvconf 사용)**:</span><span class="sxs-lookup"><span data-stu-id="ef9f2-173">**Ubuntu (uses resolvconf)**:</span></span>
  * <span data-ttu-id="ef9f2-174">dnsmasq 패키지를 설치합니다("sudo apt-get install dnsmasq").</span><span class="sxs-lookup"><span data-stu-id="ef9f2-174">just install the dnsmasq package (“sudo apt-get install dnsmasq”).</span></span>
* <span data-ttu-id="ef9f2-175">**SUSE(netconf 사용)**:</span><span class="sxs-lookup"><span data-stu-id="ef9f2-175">**SUSE (uses netconf)**:</span></span>
  * <span data-ttu-id="ef9f2-176">dnsmasq 패키지를 설치합니다("sudo zypper install dnsmasq").</span><span class="sxs-lookup"><span data-stu-id="ef9f2-176">install the dnsmasq package (“sudo zypper install dnsmasq”)</span></span> 
  * <span data-ttu-id="ef9f2-177">dnsmasq 서비스를 사용하도록 설정합니다("systemctl enable dnsmasq.service").</span><span class="sxs-lookup"><span data-stu-id="ef9f2-177">enable the dnsmasq service (“systemctl enable dnsmasq.service”)</span></span> 
  * <span data-ttu-id="ef9f2-178">dnsmasq 서비스를 시작합니다("systemctl start dnsmasq.service").</span><span class="sxs-lookup"><span data-stu-id="ef9f2-178">start the dnsmasq service (“systemctl start dnsmasq.service”)</span></span> 
  * <span data-ttu-id="ef9f2-179">"/etc/sysconfig/network/config"를 편집하고 NETCONFIG_DNS_FORWARDER=""를 "dnsmasq"로 변경합니다.</span><span class="sxs-lookup"><span data-stu-id="ef9f2-179">edit “/etc/sysconfig/network/config” and change NETCONFIG_DNS_FORWARDER="" to ”dnsmasq”</span></span>
  * <span data-ttu-id="ef9f2-180">캐시를 로컬 DNS 확인자로 설정하기 위해 resolv.conf("netconfig update")를 업데이트합니다.</span><span class="sxs-lookup"><span data-stu-id="ef9f2-180">update resolv.conf ("netconfig update") to set the cache as the local DNS resolver</span></span>
* <span data-ttu-id="ef9f2-181">**OpenLogic(NetworkManager 사용)**:</span><span class="sxs-lookup"><span data-stu-id="ef9f2-181">**OpenLogic (uses NetworkManager)**:</span></span>
  * <span data-ttu-id="ef9f2-182">dnsmasq 패키지를 설치합니다("sudo yum install dnsmasq").</span><span class="sxs-lookup"><span data-stu-id="ef9f2-182">install the dnsmasq package (“sudo yum install dnsmasq”)</span></span>
  * <span data-ttu-id="ef9f2-183">dnsmasq 서비스를 사용하도록 설정합니다("systemctl enable dnsmasq.service").</span><span class="sxs-lookup"><span data-stu-id="ef9f2-183">enable the dnsmasq service (“systemctl enable dnsmasq.service”)</span></span>
  * <span data-ttu-id="ef9f2-184">dnsmasq 서비스를 시작합니다("systemctl start dnsmasq.service").</span><span class="sxs-lookup"><span data-stu-id="ef9f2-184">start the dnsmasq service (“systemctl start dnsmasq.service”)</span></span>
  * <span data-ttu-id="ef9f2-185">"prepend domain-name-servers 127.0.0.1;"을 "/etc/dhclient-eth0.conf"에 추가합니다.</span><span class="sxs-lookup"><span data-stu-id="ef9f2-185">add “prepend domain-name-servers 127.0.0.1;” to “/etc/dhclient-eth0.conf”</span></span>
  * <span data-ttu-id="ef9f2-186">캐시를 로컬 DNS 확인자로 설정하기 위해 네트워크 서비스("service network restart")를 다시 시작합니다.</span><span class="sxs-lookup"><span data-stu-id="ef9f2-186">restart the network service (“service network restart”) to set the cache as the local DNS resolver</span></span>

> [!NOTE]
> <span data-ttu-id="ef9f2-187">'dnsmasq' 패키지는 여러 DNS 캐시 중에 Linux에 사용할 수 있는 유일한 캐시입니다.</span><span class="sxs-lookup"><span data-stu-id="ef9f2-187">The 'dnsmasq' package is only one of the many DNS caches available for Linux.</span></span>  <span data-ttu-id="ef9f2-188">사용하기 전에 특정 요구 사항에 대한 적합성을 확인하고 다른 캐시가 설치되어 있지 않은지 확인합니다.</span><span class="sxs-lookup"><span data-stu-id="ef9f2-188">Before using it, please check its suitability for your particular needs and that no other cache is installed.</span></span>
> 
> 

<span data-ttu-id="ef9f2-189">**클라이언트쪽 재시도:**</span><span class="sxs-lookup"><span data-stu-id="ef9f2-189">**Client-side Retries:**</span></span>

<span data-ttu-id="ef9f2-190">DNS는 주로 UDP 프로토콜입니다.</span><span class="sxs-lookup"><span data-stu-id="ef9f2-190">DNS is primarily a UDP protocol.</span></span>  <span data-ttu-id="ef9f2-191">UDP 프로토콜은 메시지 배달을 보장하지 않으므로 DNS 프로토콜 자체에서 재시도 논리가 처리됩니다.</span><span class="sxs-lookup"><span data-stu-id="ef9f2-191">As the UDP protocol doesn't guarantee message delivery, retry logic is handled in the DNS protocol itself.</span></span>  <span data-ttu-id="ef9f2-192">각 DNS 클라이언트(운영 체제)는 작성자의 기본 설정에 따라 서로 다른 재시도 논리를 나타낼 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ef9f2-192">Each DNS client (operating system) can exhibit different retry logic depending on the creators preference:</span></span>

* <span data-ttu-id="ef9f2-193">Windows 운영 체제는 1초 후 재시도한 후 2초, 4초 후 다시 재시도하고 또 다시 4초 후 재시도합니다.</span><span class="sxs-lookup"><span data-stu-id="ef9f2-193">Windows operating systems retry after 1 second and then again after another 2, 4 and another 4 seconds.</span></span> 
* <span data-ttu-id="ef9f2-194">기본 Linux 설정에서는 5초 후 재시도합니다.</span><span class="sxs-lookup"><span data-stu-id="ef9f2-194">The default Linux setup retries after 5 seconds.</span></span>  <span data-ttu-id="ef9f2-195">1초 간격으로 5번 재시도하도록 설정을 변경하는 것이 좋습니다.</span><span class="sxs-lookup"><span data-stu-id="ef9f2-195">It is recommended to change this to retry 5 times at 1 second intervals.</span></span>  

<span data-ttu-id="ef9f2-196">Linux VM에서 현재 설정을 확인하려면 'cat /etc/resolv.conf'에서 'options' 줄을 확인합니다. 예를 들면 다음과 같습니다.</span><span class="sxs-lookup"><span data-stu-id="ef9f2-196">To check the current settings on a Linux VM, 'cat /etc/resolv.conf' and look at the 'options' line, e.g.:</span></span>

    options timeout:1 attempts:5

<span data-ttu-id="ef9f2-197">resolv.conf 파일은 일반적으로 자동으로 생성되며 편집할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="ef9f2-197">The resolv.conf file is usually auto-generated and should not be edited.</span></span>  <span data-ttu-id="ef9f2-198">'options' 줄을 추가하는 구체적인 단계는 배포판마다 다릅니다.</span><span class="sxs-lookup"><span data-stu-id="ef9f2-198">The specific steps for adding the 'options' line vary by distro:</span></span>

* <span data-ttu-id="ef9f2-199">**Ubuntu** (resolvconf 사용):</span><span class="sxs-lookup"><span data-stu-id="ef9f2-199">**Ubuntu** (uses resolvconf):</span></span>
  * <span data-ttu-id="ef9f2-200">options 줄을 '/etc/resolveconf/resolv.conf.d/head'에 추가합니다.</span><span class="sxs-lookup"><span data-stu-id="ef9f2-200">add the options line to '/etc/resolveconf/resolv.conf.d/head'</span></span> 
  * <span data-ttu-id="ef9f2-201">'resolvconf -u'를 실행하여 업데이트합니다.</span><span class="sxs-lookup"><span data-stu-id="ef9f2-201">run 'resolvconf -u' to update</span></span>
* <span data-ttu-id="ef9f2-202">**SUSE** (netconf 사용):</span><span class="sxs-lookup"><span data-stu-id="ef9f2-202">**SUSE** (uses netconf):</span></span>
  * <span data-ttu-id="ef9f2-203">'timeout:1 attempts:5'를 '/etc/sysconfig/network/config'의 NETCONFIG_DNS_RESOLVER_OPTIONS="" 매개 변수에 추가합니다.</span><span class="sxs-lookup"><span data-stu-id="ef9f2-203">add 'timeout:1 attempts:5' to the NETCONFIG_DNS_RESOLVER_OPTIONS="" parameter in '/etc/sysconfig/network/config'</span></span> 
  * <span data-ttu-id="ef9f2-204">'netconfig update'를 실행하여 업데이트합니다.</span><span class="sxs-lookup"><span data-stu-id="ef9f2-204">run 'netconfig update' to update</span></span>
* <span data-ttu-id="ef9f2-205">**OpenLogic** (NetworkManager 사용):</span><span class="sxs-lookup"><span data-stu-id="ef9f2-205">**OpenLogic** (uses NetworkManager):</span></span>
  * <span data-ttu-id="ef9f2-206">'echo "options timeout:1 attempts:5"'를 '/etc/NetworkManager/dispatcher.d/11-dhclient'에 추가합니다.</span><span class="sxs-lookup"><span data-stu-id="ef9f2-206">add 'echo "options timeout:1 attempts:5"' to '/etc/NetworkManager/dispatcher.d/11-dhclient'</span></span> 
  * <span data-ttu-id="ef9f2-207">'service network restart'를 실행하여 업데이트합니다.</span><span class="sxs-lookup"><span data-stu-id="ef9f2-207">run 'service network restart' to update</span></span>

## <a name="name-resolution-using-your-own-dns-server"></a><span data-ttu-id="ef9f2-208">자체 DNS 서버를 이용한 이름 확인</span><span class="sxs-lookup"><span data-stu-id="ef9f2-208">Name resolution using your own DNS server</span></span>
<span data-ttu-id="ef9f2-209">이름 확인 요구 사항이 Azure에서 제공하는 기능을 벗어날 수 있는 여러 상황이 있습니다. 예를 들어 Active Directory 도메인을 사용할 때나 vnet(가상 네트워크) 간의 DNS 확인이 요구될 때와 같은 상황입니다.</span><span class="sxs-lookup"><span data-stu-id="ef9f2-209">There are a number of situations where your name resolution needs may go beyond the features provided by Azure, for example when using Active Directory domains or when you require DNS resolution between virtual networks (vnets).</span></span>  <span data-ttu-id="ef9f2-210">이러한 시나리오를 해결하기 위해 Azure는 자체 DNS 서버를 사용할 수 있는 기능을 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="ef9f2-210">To cover these scenarios, Azure provides the ability for you to use your own DNS servers.</span></span>  

<span data-ttu-id="ef9f2-211">가상 네트워크 내에서 DNS 서버는 해당 가상 네트워크 내에서 호스트 이름을 확인하기 위해 Azure의 재귀 확인자에게 DNS 쿼리를 전달할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ef9f2-211">DNS servers within a virtual network can forward DNS queries to Azure's recursive resolvers to resolve hostnames within that virtual network.</span></span>  <span data-ttu-id="ef9f2-212">예를 들어 Azure에서 실행 중인 DC(도메인 컨트롤러)는 해당 도메인에 대한 DNS 쿼리에 응답하고 Azure에 다른 모든 쿼리를 전달할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ef9f2-212">For example, a Domain Controller (DC) running in Azure can respond to DNS queries for its domains and forward all other queries to Azure.</span></span>  <span data-ttu-id="ef9f2-213">이렇게 하면 VM은 온-프레미스 리소스(DC를 통해)와 Azure에서 제공하는 호스트 이름(전달자를 통해)을 확인할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ef9f2-213">This allows VMs to see both your on-premises resources (via the DC) and Azure-provided hostnames (via the forwarder).</span></span>  <span data-ttu-id="ef9f2-214">Azure의 재귀 확인자에 대한 액세스는 가상 IP 168.63.129.16을 통해 제공됩니다.</span><span class="sxs-lookup"><span data-stu-id="ef9f2-214">Access to Azure's recursive resolvers is provided via the virtual IP 168.63.129.16.</span></span>

<span data-ttu-id="ef9f2-215">또한 DNS 전달로 vnet 간 DNS 확인이 가능하며 온-프레미스 컴퓨터는 Azure에서 제공하는 호스트 이름을 확인할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ef9f2-215">DNS forwarding also enables inter-vnet DNS resolution and allows your on-premises machines to resolve Azure-provided hostnames.</span></span>  <span data-ttu-id="ef9f2-216">VM의 호스트 이름을 확인하려면 DNS 서버 VM이 동일한 가상 네트워크에 있어야 하며 Azure에 호스트 이름 쿼리를 전달하도록 구성되어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="ef9f2-216">In order to resolve a VM's hostname, the DNS server VM must reside in the same virtual network and be configured to forward hostname queries to Azure.</span></span>  <span data-ttu-id="ef9f2-217">DNS 접미사는 각 vnet마다 다르기 때문에 확인을 위해 올바른 vnet에 DNS 쿼리를 보내도록 조건부 전달 규칙을 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ef9f2-217">As the DNS suffix is different in each vnet, you can use conditional forwarding rules to send DNS queries to the correct vnet for resolution.</span></span>  <span data-ttu-id="ef9f2-218">다음 이미지에서는 두 vnet과 온-프레미스 네트워크가 이 메서드를 사용하여 vnet 간 DNS 확인을 수행하는 것을 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="ef9f2-218">The following image shows two vnets and an on-premises network doing inter-vnet DNS resolution using this method.</span></span>  <span data-ttu-id="ef9f2-219">예제 DNS 전달자는 [Azure 빠른 시작 템플릿 갤러리](https://azure.microsoft.com/documentation/templates/301-dns-forwarder/) 및 [GitHub](https://github.com/Azure/azure-quickstart-templates/tree/master/301-dns-forwarder)에서 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ef9f2-219">An example DNS forwarder is available in the [Azure Quickstart Templates gallery](https://azure.microsoft.com/documentation/templates/301-dns-forwarder/) and [GitHub](https://github.com/Azure/azure-quickstart-templates/tree/master/301-dns-forwarder).</span></span>

![Vnet 간 DNS](./media/virtual-networks-name-resolution-for-vms-and-role-instances/inter-vnet-dns.png)

<span data-ttu-id="ef9f2-221">Azure에서 제공하는 이름 확인을 사용하는 경우 DHCP를 사용하여 각 VM에 내부 DNS 접미사(*.internal.cloudapp.net)를 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="ef9f2-221">When using Azure-provided name resolution, an Internal DNS suffix (*.internal.cloudapp.net) is provided to each VM using DHCP.</span></span>  <span data-ttu-id="ef9f2-222">그러면 호스트 이름 레코드가 internal.cloudapp.net 영역에 있으므로 호스트 이름 확인을 수행할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ef9f2-222">This enables hostname resolution as the hostname records are in the internal.cloudapp.net zone.</span></span>  <span data-ttu-id="ef9f2-223">자체 이름 확인 솔루션을 사용하는 경우 이 IDNS 접미사는 다른 DNS 아키텍처에 방해가 되기 때문에 VM에 제공되지 않습니다(예: 도메인 가입 시나리오).</span><span class="sxs-lookup"><span data-stu-id="ef9f2-223">When using your own name resolution solution, the IDNS suffix is not supplied to VMs because it interferes with other DNS architectures (like domain-joined scenarios).</span></span>  <span data-ttu-id="ef9f2-224">대신 작동하지 않는 자리 표시자(reddog.microsoft.com)가 제공됩니다.</span><span class="sxs-lookup"><span data-stu-id="ef9f2-224">Instead we provide a non-functioning placeholder (reddog.microsoft.com).</span></span>  

<span data-ttu-id="ef9f2-225">필요한 경우 PowerShell 또는 API를 사용하여 내부 DNS 접미사를 확인할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ef9f2-225">If needed, the Internal DNS suffix can be determined using PowerShell or the API:</span></span>

* <span data-ttu-id="ef9f2-226">리소스 관리자 배포 모델에서 가상 네트워크의 경우, [네트워크 인터페이스 카드](https://msdn.microsoft.com/library/azure/mt163668.aspx) 리소스 또는 [Get AzureRmNetworkInterface](https://msdn.microsoft.com/library/mt619434.aspx) cmdlet을 통해 접미사를 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ef9f2-226">For virtual networks in Resource Manager deployment models, the suffix is available via the [network interface card](https://msdn.microsoft.com/library/azure/mt163668.aspx) resource or via the [Get-AzureRmNetworkInterface](https://msdn.microsoft.com/library/mt619434.aspx) cmdlet.</span></span>    
* <span data-ttu-id="ef9f2-227">클래식 배포 모델에서 접미사는 [배포 API 가져오기](https://msdn.microsoft.com/library/azure/ee460804.aspx) 호출 또는 [Get-AzureVM -Debug](https://msdn.microsoft.com/library/azure/dn495236.aspx) cmdlet을 통해 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ef9f2-227">In classic deployment models, the suffix is available via the [Get Deployment API](https://msdn.microsoft.com/library/azure/ee460804.aspx) call or via the [Get-AzureVM -Debug](https://msdn.microsoft.com/library/azure/dn495236.aspx) cmdlet.</span></span>

<span data-ttu-id="ef9f2-228">Azure에 전달하는 쿼리가 사용자 요구에 적합하지 않은 경우 자체 DNS 솔루션을 제공해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="ef9f2-228">If forwarding queries to Azure doesn't suit your needs, you will need to provide your own DNS solution.</span></span>  <span data-ttu-id="ef9f2-229">DNS 솔루션은 다음을 수행해야 합니다:</span><span class="sxs-lookup"><span data-stu-id="ef9f2-229">Your DNS solution will need to:</span></span>

* <span data-ttu-id="ef9f2-230">예를 들어 [DDNS](virtual-networks-name-resolution-ddns.md)를 통해 적절한 호스트 이름 확인을 제공해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="ef9f2-230">Provide appropriate hostname resolution, e.g. via [DDNS](virtual-networks-name-resolution-ddns.md).</span></span>  <span data-ttu-id="ef9f2-231">DDNS를 사용하는 경우 Azure의 DHCP 임대는 매우 길고 청소는 DNS 레코드를 중간에 제거할 수 있기 때문에 DNS 레코드 청소를 사용하지 않도록 설정해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="ef9f2-231">Note, if using DDNS you may need to disable DNS record scavenging as Azure's DHCP leases are very long and scavenging may remove DNS records prematurely.</span></span> 
* <span data-ttu-id="ef9f2-232">외부 도메인 이름을 확인할 수 있도록 적절한 재귀 확인을 제공해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="ef9f2-232">Provide appropriate recursive resolution to allow resolution of external domain names.</span></span>
* <span data-ttu-id="ef9f2-233">제공하는 클라이언트에서 액세스 가능해야 하고(포트 53에서 TCP 및 UDP) 인터넷에 액세스할 수 있어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="ef9f2-233">Be accessible (TCP and UDP on port 53) from the clients it serves and be able to access the internet.</span></span>
* <span data-ttu-id="ef9f2-234">외부 에이전트로 인해 나타나는 위험을 완화하기 위해 인터넷의 액세스로부터 보호되어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="ef9f2-234">Be secured against access from the internet, to mitigate threats posed by external agents.</span></span>

> [!NOTE]
> <span data-ttu-id="ef9f2-235">최상의 성능을 위해 DNS 서버로 Azure VM을 사용할 때는 IPv6을 사용하지 않도록 설정하고 [인스턴스 수준 공용 IP](virtual-networks-instance-level-public-ip.md) 를 각 DNS 서버 VM에 할당해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="ef9f2-235">For best performance, when using Azure VMs as DNS servers, IPv6 should be disabled and an [Instance-Level Public IP](virtual-networks-instance-level-public-ip.md) should be assigned to each DNS server VM.</span></span>  <span data-ttu-id="ef9f2-236">Windows Server를 DNS 서버로 사용하려고 선택한 경우 [이 문서](http://blogs.technet.com/b/networking/archive/2015/08/19/name-resolution-performance-of-a-recursive-windows-dns-server-2012-r2.aspx) 에서 추가로 성능을 분석하고 최적화하는 방법을 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="ef9f2-236">If you choose to use Windows Server as your DNS server, [this article](http://blogs.technet.com/b/networking/archive/2015/08/19/name-resolution-performance-of-a-recursive-windows-dns-server-2012-r2.aspx) provides additional performance analysis and optimizations.</span></span>
> 
> 

### <a name="specifying-dns-servers"></a><span data-ttu-id="ef9f2-237">DNS 서버 지정</span><span class="sxs-lookup"><span data-stu-id="ef9f2-237">Specifying DNS servers</span></span>
<span data-ttu-id="ef9f2-238">사용자 고유의 DNS 서버를 사용할 때 Azure는 가상 네트워크당 또는 네트워크 인터페이스(리소스 관리자)/클라우드 서비스(클래식)당 여러 DNS 서버를 지정할 수 있는 기능을 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="ef9f2-238">When using your own DNS servers, Azure provides the ability to specify multiple DNS servers per virtual network or per network interface (Resource Manager) / cloud service (classic).</span></span>  <span data-ttu-id="ef9f2-239">클라우드 서비스/네트워크 인터페이스에 대해 지정된 DNS 서버가 가상 네트워크에 대해 지정된 서버보다 우선적으로 사용됩니다.</span><span class="sxs-lookup"><span data-stu-id="ef9f2-239">DNS servers specified for a cloud service/network interface get precedence over those specified for the virtual network.</span></span>

> [!NOTE]
> <span data-ttu-id="ef9f2-240">DNS 서버 IP와 같은 네트워크 연결 속성은 Windows VM 내에서 직접 편집할 수 없습니다. 이들은 가상 네트워크 어댑터가 교체될 때 서비스 치료 중에 지워질 수도 있기 때문입니다.</span><span class="sxs-lookup"><span data-stu-id="ef9f2-240">Network connection properties, such as DNS server IPs, should not be edited directly within Windows VMs as they may get erased during service heal when the virtual network adaptor gets replaced.</span></span> 
> 
> 

<span data-ttu-id="ef9f2-241">리소스 관리자 배포 모델을 사용할 때는 DNS 서버를 포털, API/템플릿([vnet](https://msdn.microsoft.com/library/azure/mt163661.aspx), [nic](https://msdn.microsoft.com/library/azure/mt163668.aspx)) 또는 PowerShell ([vnet](https://msdn.microsoft.com/library/mt603657.aspx), [nic](https://msdn.microsoft.com/library/mt619370.aspx))에서 지정할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ef9f2-241">When using the Resource Manager deployment model, DNS servers can be specified in the Portal, API/Templates ([vnet](https://msdn.microsoft.com/library/azure/mt163661.aspx), [nic](https://msdn.microsoft.com/library/azure/mt163668.aspx)) or PowerShell ([vnet](https://msdn.microsoft.com/library/mt603657.aspx), [nic](https://msdn.microsoft.com/library/mt619370.aspx)).</span></span>

<span data-ttu-id="ef9f2-242">클래식 배포 모델을 사용할 때 가상 네트워크에 대한 DNS 서버를 포털 또는 [*네트워크 구성* 파일](https://msdn.microsoft.com/library/azure/jj157100)에서 지정할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="ef9f2-242">When using the classic deployment model, DNS servers for the virtual network can be specified in the Portal or [the *Network Configuration* file](https://msdn.microsoft.com/library/azure/jj157100).</span></span>  <span data-ttu-id="ef9f2-243">클라우드 서비스의 경우 DNS 서버는 [ *서비스 구성* 파일](https://msdn.microsoft.com/library/azure/ee758710)을 통해 또는 Powershell ([New-AzureVM](https://msdn.microsoft.com/library/azure/dn495254.aspx)) 내에서 지정됩니다.</span><span class="sxs-lookup"><span data-stu-id="ef9f2-243">For cloud services, the DNS servers are specified via [the *Service Configuration* file](https://msdn.microsoft.com/library/azure/ee758710) or in PowerShell ([New-AzureVM](https://msdn.microsoft.com/library/azure/dn495254.aspx)).</span></span>

> [!NOTE]
> <span data-ttu-id="ef9f2-244">이미 배포된 가상 네트워크/가상 컴퓨터에 대한 DNS 설정을 변경하면 영향을 받는 각 VM을 다시 시작해야 변경사항이 적용됩니다.</span><span class="sxs-lookup"><span data-stu-id="ef9f2-244">If you change the DNS settings for a virtual network/virtual machine that is already deployed, you need to restart each affected VM for the changes to take effect.</span></span>
> 
> 

## <a name="next-steps"></a><span data-ttu-id="ef9f2-245">다음 단계</span><span class="sxs-lookup"><span data-stu-id="ef9f2-245">Next steps</span></span>
<span data-ttu-id="ef9f2-246">리소스 관리자 배포 모델:</span><span class="sxs-lookup"><span data-stu-id="ef9f2-246">Resource Manager deployment model:</span></span>

* [<span data-ttu-id="ef9f2-247">가상 네트워크 만들기 또는 업데이트</span><span class="sxs-lookup"><span data-stu-id="ef9f2-247">Create or update a virtual network</span></span>](https://msdn.microsoft.com/library/azure/mt163661.aspx)
* [<span data-ttu-id="ef9f2-248">네트워크 인터페이스 카드 만들기 또는 업데이트</span><span class="sxs-lookup"><span data-stu-id="ef9f2-248">Create or update a network interface card</span></span>](https://msdn.microsoft.com/library/azure/mt163668.aspx)
* [<span data-ttu-id="ef9f2-249">새-AzureRmVirtualNetwork</span><span class="sxs-lookup"><span data-stu-id="ef9f2-249">New-AzureRmVirtualNetwork</span></span>](https://msdn.microsoft.com/library/mt603657.aspx)
* [<span data-ttu-id="ef9f2-250">새-AzureRmNetworkInterface</span><span class="sxs-lookup"><span data-stu-id="ef9f2-250">New-AzureRmNetworkInterface</span></span>](https://msdn.microsoft.com/library/mt619370.aspx)

<span data-ttu-id="ef9f2-251">클래식 배포 모델:</span><span class="sxs-lookup"><span data-stu-id="ef9f2-251">Classic deployment model:</span></span>

* [<span data-ttu-id="ef9f2-252">Azure 서비스 구성 스키마</span><span class="sxs-lookup"><span data-stu-id="ef9f2-252">Azure Service Configuration Schema</span></span>](https://msdn.microsoft.com/library/azure/ee758710)
* [<span data-ttu-id="ef9f2-253">가상 네트워크 구성 스키마</span><span class="sxs-lookup"><span data-stu-id="ef9f2-253">Virtual Network Configuration Schema</span></span>](https://msdn.microsoft.com/library/azure/jj157100)
* [<span data-ttu-id="ef9f2-254">네트워크 구성 파일을 사용하여 가상 네트워크 구성</span><span class="sxs-lookup"><span data-stu-id="ef9f2-254">Configure a Virtual Network by Using a Network Configuration File</span></span>](virtual-networks-using-network-configuration-file.md) 

