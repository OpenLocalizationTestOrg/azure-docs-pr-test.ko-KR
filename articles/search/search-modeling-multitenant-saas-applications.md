---
title: "Azure Search의 다중 테넌트 모델링 | Microsoft Docs"
description: "Azure 검색을 사용할 때의 다중 테넌트 SaaS 응용 프로그램에 대한 일반적인 디자인 패턴에 대해 알아봅니다."
services: search
manager: jhubbard
author: ashmaka
documentationcenter: 
ms.assetid: 72e9696a-553b-47dc-9e05-a82db0ebf094
ms.service: search
ms.devlang: NA
ms.workload: search
ms.topic: article
ms.tgt_pltfrm: na
ms.date: 10/26/2016
ms.author: ashmaka
ms.openlocfilehash: fd1b0c7cc8210d27fdc500bf4e5641bedfe93cff
ms.sourcegitcommit: f537befafb079256fba0529ee554c034d73f36b0
ms.translationtype: MT
ms.contentlocale: ko-KR
ms.lasthandoff: 07/11/2017
---
# <a name="design-patterns-for-multitenant-saas-applications-and-azure-search"></a><span data-ttu-id="7dd94-103">다중 테넌트 SaaS 응용 프로그램 및 Azure 검색에 대한 디자인 패턴</span><span class="sxs-lookup"><span data-stu-id="7dd94-103">Design patterns for multitenant SaaS applications and Azure Search</span></span>
<span data-ttu-id="7dd94-104">다중 테넌트 응용 프로그램은 다른 테넌트의 데이터를 보거나 공유할 수 없는 임의 개수의 테넌트에 동일한 서비스와 기능을 제공하는 응용 프로그램입니다.</span><span class="sxs-lookup"><span data-stu-id="7dd94-104">A multitenant application is one that provides the same services and capabilities to any number of tenants who cannot see or share the data of any other tenant.</span></span> <span data-ttu-id="7dd94-105">이 문서에서는 Azure 검색을 사용하여 작성된 다중 테넌트 응용 프로그램에 대한 테넌트 격리 전략에 대해 설명합니다.</span><span class="sxs-lookup"><span data-stu-id="7dd94-105">This document discusses tenant isolation strategies for multitenant applications built with Azure Search.</span></span>

## <a name="azure-search-concepts"></a><span data-ttu-id="7dd94-106">Azure 검색 개념</span><span class="sxs-lookup"><span data-stu-id="7dd94-106">Azure Search concepts</span></span>
<span data-ttu-id="7dd94-107">Search-as-a-Service 솔루션인 Azure 검색은 개발자가 인프라를 관리하거나 검색 전문가가 아니더라도 응용 프로그램에 다양한 검색 환경을 추가할 수 있도록 합니다.</span><span class="sxs-lookup"><span data-stu-id="7dd94-107">As a search-as-a-service solution, Azure Search allows developers to add rich search experiences to applications without managing any infrastructure or becoming an expert in search.</span></span> <span data-ttu-id="7dd94-108">데이터는 서비스에 업로드된 후 클라우드에 저장됩니다.</span><span class="sxs-lookup"><span data-stu-id="7dd94-108">Data is uploaded to the service and then stored in the cloud.</span></span> <span data-ttu-id="7dd94-109">Azure 검색 API에 대한 간단한 요청을 사용하여 데이터를 수정 및 검색할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="7dd94-109">Using simple requests to the Azure Search API, the data can then be modified and searched.</span></span> <span data-ttu-id="7dd94-110">서비스의 개요는 [이 문서](http://aka.ms/whatisazsearch)에서 확인할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="7dd94-110">An overview of the service can be found in [this article](http://aka.ms/whatisazsearch).</span></span> <span data-ttu-id="7dd94-111">디자인 패턴에 대해 논의하기 전에 Azure 검색의 일부 개념을 이해해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="7dd94-111">Before discussing design patterns, it is important to understand some concepts in Azure Search.</span></span>

### <a name="search-services-indexes-fields-and-documents"></a><span data-ttu-id="7dd94-112">검색 서비스, 인덱스, 필드 및 문서</span><span class="sxs-lookup"><span data-stu-id="7dd94-112">Search services, indexes, fields, and documents</span></span>
<span data-ttu-id="7dd94-113">Azure 검색을 사용하는 경우 *검색 서비스*를 구독하게 됩니다.</span><span class="sxs-lookup"><span data-stu-id="7dd94-113">When using Azure Search, one subscribes to a *search service*.</span></span> <span data-ttu-id="7dd94-114">데이터가 Azure 검색에 업로드되면 검색 서비스 내의 *인덱스* 에 저장됩니다.</span><span class="sxs-lookup"><span data-stu-id="7dd94-114">As data is uploaded to Azure Search, it is stored in an *index* within the search service.</span></span> <span data-ttu-id="7dd94-115">하나의 서비스 내에 많은 수의 인덱스가 있을 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="7dd94-115">There can be a number of indexes within a single service.</span></span> <span data-ttu-id="7dd94-116">데이터베이스의 익숙한 개념을 사용하기 위해 검색 서비스를 데이터베이스에, 서비스 내의 인덱스를 데이터베이스 내의 테이블에 비유할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="7dd94-116">To use the familiar concepts of databases, the search service can be likened to a database while the indexes within a service can be likened to tables within a database.</span></span>

<span data-ttu-id="7dd94-117">검색 서비스 내의 각 인덱스는 많은 수의 사용자 지정 가능 *필드*로 정의되는 고유 스키마를 갖습니다.</span><span class="sxs-lookup"><span data-stu-id="7dd94-117">Each index within a search service has its own schema, which is defined by a number of customizable *fields*.</span></span> <span data-ttu-id="7dd94-118">데이터는 개별 *문서*형식으로 Azure 검색 인덱스에 추가됩니다.</span><span class="sxs-lookup"><span data-stu-id="7dd94-118">Data is added to an Azure Search index in the form of individual *documents*.</span></span> <span data-ttu-id="7dd94-119">각 문서는 특정 인덱스에 업로드되어야 하고 해당 인덱스의 스키마를 결정해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="7dd94-119">Each document must be uploaded to a particular index and must fit that index's schema.</span></span> <span data-ttu-id="7dd94-120">Azure 검색을 사용하여 데이터를 검색할 때 특정 인덱스에 대해 전체 텍스트 검색 쿼리가 실행됩니다.</span><span class="sxs-lookup"><span data-stu-id="7dd94-120">When searching data using Azure Search, the full-text search queries are issued against a particular index.</span></span>  <span data-ttu-id="7dd94-121">이러한 개념을 데이터베이스의 개념과 비교하려면 필드를 테이블의 열에, 문서를 행에 비유할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="7dd94-121">To compare these concepts to those of a database, fields can be likened to columns in a table and documents can be likened to rows.</span></span>

### <a name="scalability"></a><span data-ttu-id="7dd94-122">확장성</span><span class="sxs-lookup"><span data-stu-id="7dd94-122">Scalability</span></span>
<span data-ttu-id="7dd94-123">표준 [가격 책정 계층](https://azure.microsoft.com/pricing/details/search/) 의 모든 Azure 검색 서비스는 저장소 및 가용성의 2가지 차원으로 확장할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="7dd94-123">Any Azure Search service in the Standard [pricing tier](https://azure.microsoft.com/pricing/details/search/) can scale in two dimensions: storage and availability.</span></span>

* <span data-ttu-id="7dd94-124">*파티션* 을 추가하여 검색 서비스 저장소를 늘릴 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="7dd94-124">*Partitions* can be added to increase the storage of a search service.</span></span>
* <span data-ttu-id="7dd94-125">*복제본* 을 서비스에 추가하여 검색 서비스가 처리할 수 있는 요청 처리량을 늘릴 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="7dd94-125">*Replicas* can be added to a service to increase the throughput of requests that a search service can handle.</span></span>

<span data-ttu-id="7dd94-126">파티션 및 복제본을 추가 또는 제거하여 응용 프로그램이 요구하는 데이터 및 트래픽 양으로 검색 서비스의 용량을 늘릴 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="7dd94-126">Adding and removing partitions and replicas at will allow the capacity of the search service to grow with the amount of data and traffic the application demands.</span></span> <span data-ttu-id="7dd94-127">검색 서비스가 읽기 [SLA](https://azure.microsoft.com/support/legal/sla/search/v1_0/)를 달성하려면 2개의 복제본이 필요합니다.</span><span class="sxs-lookup"><span data-stu-id="7dd94-127">In order for a search service to achieve a read [SLA](https://azure.microsoft.com/support/legal/sla/search/v1_0/), it requires two replicas.</span></span> <span data-ttu-id="7dd94-128">검색 서비스가 읽기/쓰기 [SLA](https://azure.microsoft.com/support/legal/sla/search/v1_0/)를 달성하려면 3개의 복제본이 필요합니다.</span><span class="sxs-lookup"><span data-stu-id="7dd94-128">In order for a service to achieve a read-write [SLA](https://azure.microsoft.com/support/legal/sla/search/v1_0/), it requires three replicas.</span></span>

### <a name="service-and-index-limits-in-azure-search"></a><span data-ttu-id="7dd94-129">Azure 검색의 서비스 및 인덱스 제한 사항</span><span class="sxs-lookup"><span data-stu-id="7dd94-129">Service and index limits in Azure Search</span></span>
<span data-ttu-id="7dd94-130">Azure Search에는 각 계층이 각기 다른 [제한 및 할당량](search-limits-quotas-capacity.md)을 갖는 다른 몇 가지 [가격 책정 계층](https://azure.microsoft.com/pricing/details/search/)이 있습니다.</span><span class="sxs-lookup"><span data-stu-id="7dd94-130">There are a few different [pricing tiers](https://azure.microsoft.com/pricing/details/search/) in Azure Search, each of the tiers has different [limits and quotas](search-limits-quotas-capacity.md).</span></span> <span data-ttu-id="7dd94-131">서비스 수준에서 적용되는 제한도 있고, 인덱스 수준에서 적용되는 제한도 있고, 파티션 수준에서 적용되는 제한도 있습니다.</span><span class="sxs-lookup"><span data-stu-id="7dd94-131">Some of these limits are at the service-level, some are at the index-level, and some are at the partition-level.</span></span>

|  | <span data-ttu-id="7dd94-132">Basic</span><span class="sxs-lookup"><span data-stu-id="7dd94-132">Basic</span></span> | <span data-ttu-id="7dd94-133">Standard1</span><span class="sxs-lookup"><span data-stu-id="7dd94-133">Standard1</span></span> | <span data-ttu-id="7dd94-134">Standard2</span><span class="sxs-lookup"><span data-stu-id="7dd94-134">Standard2</span></span> | <span data-ttu-id="7dd94-135">Standard3</span><span class="sxs-lookup"><span data-stu-id="7dd94-135">Standard3</span></span> | <span data-ttu-id="7dd94-136">Standard3 HD</span><span class="sxs-lookup"><span data-stu-id="7dd94-136">Standard3 HD</span></span> |
| --- | --- | --- | --- | --- | --- |
| <span data-ttu-id="7dd94-137">서비스당 최대 복제본</span><span class="sxs-lookup"><span data-stu-id="7dd94-137">Maximum Replicas per Service</span></span> |<span data-ttu-id="7dd94-138">3</span><span class="sxs-lookup"><span data-stu-id="7dd94-138">3</span></span> |<span data-ttu-id="7dd94-139">12</span><span class="sxs-lookup"><span data-stu-id="7dd94-139">12</span></span> |<span data-ttu-id="7dd94-140">12</span><span class="sxs-lookup"><span data-stu-id="7dd94-140">12</span></span> |<span data-ttu-id="7dd94-141">12</span><span class="sxs-lookup"><span data-stu-id="7dd94-141">12</span></span> |<span data-ttu-id="7dd94-142">12</span><span class="sxs-lookup"><span data-stu-id="7dd94-142">12</span></span> |
| <span data-ttu-id="7dd94-143">서비스당 최대 파티션</span><span class="sxs-lookup"><span data-stu-id="7dd94-143">Maximum Partitions per Service</span></span> |<span data-ttu-id="7dd94-144">1</span><span class="sxs-lookup"><span data-stu-id="7dd94-144">1</span></span> |<span data-ttu-id="7dd94-145">12</span><span class="sxs-lookup"><span data-stu-id="7dd94-145">12</span></span> |<span data-ttu-id="7dd94-146">12</span><span class="sxs-lookup"><span data-stu-id="7dd94-146">12</span></span> |<span data-ttu-id="7dd94-147">12</span><span class="sxs-lookup"><span data-stu-id="7dd94-147">12</span></span> |<span data-ttu-id="7dd94-148">1</span><span class="sxs-lookup"><span data-stu-id="7dd94-148">1</span></span> |
| <span data-ttu-id="7dd94-149">서비스당 최대 검색 단위(복제본*파티션)</span><span class="sxs-lookup"><span data-stu-id="7dd94-149">Maximum Search Units (Replicas*Partitions) per Service</span></span> |<span data-ttu-id="7dd94-150">3</span><span class="sxs-lookup"><span data-stu-id="7dd94-150">3</span></span> |<span data-ttu-id="7dd94-151">36</span><span class="sxs-lookup"><span data-stu-id="7dd94-151">36</span></span> |<span data-ttu-id="7dd94-152">36</span><span class="sxs-lookup"><span data-stu-id="7dd94-152">36</span></span> |<span data-ttu-id="7dd94-153">36</span><span class="sxs-lookup"><span data-stu-id="7dd94-153">36</span></span> |<span data-ttu-id="7dd94-154">36(파티션 최대 3개)</span><span class="sxs-lookup"><span data-stu-id="7dd94-154">36 (max 3 partitions)</span></span> |
| <span data-ttu-id="7dd94-155">서비스당 최대 문서</span><span class="sxs-lookup"><span data-stu-id="7dd94-155">Maximum Documents per Service</span></span> |<span data-ttu-id="7dd94-156">1백만</span><span class="sxs-lookup"><span data-stu-id="7dd94-156">1 million</span></span> |<span data-ttu-id="7dd94-157">1억 8천만</span><span class="sxs-lookup"><span data-stu-id="7dd94-157">180 million</span></span> |<span data-ttu-id="7dd94-158">7억 2천만</span><span class="sxs-lookup"><span data-stu-id="7dd94-158">720 million</span></span> |<span data-ttu-id="7dd94-159">14억</span><span class="sxs-lookup"><span data-stu-id="7dd94-159">1.4 billion</span></span> |<span data-ttu-id="7dd94-160">6억</span><span class="sxs-lookup"><span data-stu-id="7dd94-160">600 million</span></span> |
| <span data-ttu-id="7dd94-161">서비스당 최대 저장소</span><span class="sxs-lookup"><span data-stu-id="7dd94-161">Maximum Storage per Service</span></span> |<span data-ttu-id="7dd94-162">2 GB</span><span class="sxs-lookup"><span data-stu-id="7dd94-162">2 GB</span></span> |<span data-ttu-id="7dd94-163">300GB</span><span class="sxs-lookup"><span data-stu-id="7dd94-163">300 GB</span></span> |<span data-ttu-id="7dd94-164">1.2TB</span><span class="sxs-lookup"><span data-stu-id="7dd94-164">1.2 TB</span></span> |<span data-ttu-id="7dd94-165">2.4TB</span><span class="sxs-lookup"><span data-stu-id="7dd94-165">2.4 TB</span></span> |<span data-ttu-id="7dd94-166">600GB</span><span class="sxs-lookup"><span data-stu-id="7dd94-166">600 GB</span></span> |
| <span data-ttu-id="7dd94-167">파티션당 최대 문서</span><span class="sxs-lookup"><span data-stu-id="7dd94-167">Maximum Documents per Partition</span></span> |<span data-ttu-id="7dd94-168">1백만</span><span class="sxs-lookup"><span data-stu-id="7dd94-168">1 million</span></span> |<span data-ttu-id="7dd94-169">1천 5백만</span><span class="sxs-lookup"><span data-stu-id="7dd94-169">15 million</span></span> |<span data-ttu-id="7dd94-170">6천만</span><span class="sxs-lookup"><span data-stu-id="7dd94-170">60 million</span></span> |<span data-ttu-id="7dd94-171">1억 2천만</span><span class="sxs-lookup"><span data-stu-id="7dd94-171">120 million</span></span> |<span data-ttu-id="7dd94-172">2억</span><span class="sxs-lookup"><span data-stu-id="7dd94-172">200 million</span></span> |
| <span data-ttu-id="7dd94-173">파티션당 최대 저장소</span><span class="sxs-lookup"><span data-stu-id="7dd94-173">Maximum Storage per Partition</span></span> |<span data-ttu-id="7dd94-174">2 GB</span><span class="sxs-lookup"><span data-stu-id="7dd94-174">2 GB</span></span> |<span data-ttu-id="7dd94-175">25GB</span><span class="sxs-lookup"><span data-stu-id="7dd94-175">25 GB</span></span> |<span data-ttu-id="7dd94-176">100GB</span><span class="sxs-lookup"><span data-stu-id="7dd94-176">100 GB</span></span> |<span data-ttu-id="7dd94-177">200GB</span><span class="sxs-lookup"><span data-stu-id="7dd94-177">200 GB</span></span> |<span data-ttu-id="7dd94-178">200GB</span><span class="sxs-lookup"><span data-stu-id="7dd94-178">200 GB</span></span> |
| <span data-ttu-id="7dd94-179">서비스당 최대 인덱스</span><span class="sxs-lookup"><span data-stu-id="7dd94-179">Maximum Indexes per Service</span></span> |<span data-ttu-id="7dd94-180">5</span><span class="sxs-lookup"><span data-stu-id="7dd94-180">5</span></span> |<span data-ttu-id="7dd94-181">50</span><span class="sxs-lookup"><span data-stu-id="7dd94-181">50</span></span> |<span data-ttu-id="7dd94-182">200</span><span class="sxs-lookup"><span data-stu-id="7dd94-182">200</span></span> |<span data-ttu-id="7dd94-183">200</span><span class="sxs-lookup"><span data-stu-id="7dd94-183">200</span></span> |<span data-ttu-id="7dd94-184">3000(인덱서/파티션 최대 1000)</span><span class="sxs-lookup"><span data-stu-id="7dd94-184">3000 (max 1000 indexes/partition)</span></span> |

#### <a name="s3-high-density"></a><span data-ttu-id="7dd94-185">S3 고밀도</span><span class="sxs-lookup"><span data-stu-id="7dd94-185">S3 High Density'</span></span>
<span data-ttu-id="7dd94-186">Azure 검색의 S3 가격 책정 계층에는 다중 테넌트 시나리오를 위해 특별히 디자인된 HD(고밀도) 모드에 대한 옵션이 있습니다.</span><span class="sxs-lookup"><span data-stu-id="7dd94-186">In Azure Search’s S3 pricing tier, there is an option for the High Density (HD) mode designed specifically for multitenant scenarios.</span></span> <span data-ttu-id="7dd94-187">대부분의 경우 간소성 및 비용 효율성을 달성하기 위해 단일 서비스에서 여러 소규모 테넌트를 지원해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="7dd94-187">In many cases, it is necessary to support a large number of smaller tenants under a single service to achieve the benefits of simplicity and cost efficiency.</span></span>

<span data-ttu-id="7dd94-188">S3 HD는 파티션을 사용하여 인덱스를 확장할 수 있는 기능을 단일 서비스에서 더 많은 인덱스를 호스트할 수 있는 기능과 교환하여 단일 검색 서비스에서 관리되는 여러 작은 인덱스의 압축을 허용합니다.</span><span class="sxs-lookup"><span data-stu-id="7dd94-188">S3 HD allows for the many small indexes to be packed under the management of a single search service by trading the ability to scale out indexes using partitions for the ability to host more indexes in a single service.</span></span>

<span data-ttu-id="7dd94-189">구체적으로, S3 서비스는 1~200개의 인덱스를 함께 사용하여 최대 14억 개의 문서를 호스트할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="7dd94-189">Concretely, an S3 service could have between 1 and 200 indexes that together could host up to 1.4 billion documents.</span></span> <span data-ttu-id="7dd94-190">반면, S3 HD는 개별 인덱스에 대해 최대 100만 개의 문서만 허용하지만 파티션당 최대 1000개(서비스당 최대 3000개)의 인덱스를 처리할 수 있으며, 파티션당 총 문서 수는 2억 개(서비스당 최대 6억 개)입니다.</span><span class="sxs-lookup"><span data-stu-id="7dd94-190">An S3 HD on the other hand would allow individual indexes to only go up to 1 million documents, but it can handle up to 1000 indexes per partition (up to 3000 per service) with a total document count of 200 million per partition (up to 600 million per service).</span></span>

## <a name="considerations-for-multitenant-applications"></a><span data-ttu-id="7dd94-191">다중 테넌트 응용 프로그램에 대한 고려 사항</span><span class="sxs-lookup"><span data-stu-id="7dd94-191">Considerations for multitenant applications</span></span>
<span data-ttu-id="7dd94-192">다중 테넌트 응용 프로그램은 다양한 테넌트 간에 일정 수준의 개인 정보를 유지하면서 테넌트 간에 리소스를 효과적으로 배포해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="7dd94-192">Multitenant applications must effectively distribute resources among the tenants while preserving some level of privacy between the various tenants.</span></span> <span data-ttu-id="7dd94-193">이러한 응용 프로그램에 대한 아키텍처를 디자인할 때 다음과 같은 사항을 고려해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="7dd94-193">There are a few considerations when designing the architecture for such an application:</span></span>

* <span data-ttu-id="7dd94-194">*테넌트 격리:* 응용 프로그램 개발자는 다른 테넌트의 데이터에 무단으로 또는 동의 없이 액세스하는 테넌트가 없도록 하기 위해 적절한 조치를 수행해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="7dd94-194">*Tenant isolation:* Application developers need to take appropriate measures to ensure that no tenants have unauthorized or unwanted access to the data of other tenants.</span></span> <span data-ttu-id="7dd94-195">테넌트 격리 전략은 데이터 개인 정보 보호 측면 외에도, 공유 리소스를 효과적으로 관리하고 노이즈 환경으로부터 보호할 수 있어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="7dd94-195">Beyond the perspective of data privacy, tenant isolation strategies require effective management of shared resources and protection from noisy neighbors.</span></span>
* <span data-ttu-id="7dd94-196">*클라우드 리소스 비용:* 다른 응용 프로그램과 마찬가지로, 소프트웨어 솔루션은 다중 테넌트 응용 프로그램의 구성 요소로서 비용 경쟁력을 유지해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="7dd94-196">*Cloud resource cost:* As with any other application, software solutions must remain cost competitive as a component of a multitenant application.</span></span>
* <span data-ttu-id="7dd94-197">*작업의 용이성:* 다중 테넌트 아키텍처를 개발할 때 응용 프로그램의 작업 및 복잡성에 미치는 영향도 중요한 고려 사항입니다.</span><span class="sxs-lookup"><span data-stu-id="7dd94-197">*Ease of Operations:* When developing a multitenant architecture, the impact on the application's operations and complexity is an important consideration.</span></span> <span data-ttu-id="7dd94-198">Azure Search는 [99.9% SLA](https://azure.microsoft.com/support/legal/sla/search/v1_0/)를 보장합니다.</span><span class="sxs-lookup"><span data-stu-id="7dd94-198">Azure Search has a [99.9% SLA](https://azure.microsoft.com/support/legal/sla/search/v1_0/).</span></span>
* <span data-ttu-id="7dd94-199">*전역 공간:* 다중 테넌트 응용 프로그램은 전 세계에 분산되어 있는 테넌트를 효과적으로 서비스할 수 있어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="7dd94-199">*Global footprint:* Multitenant applications may need to effectively serve tenants which are distributed across the globe.</span></span>
* <span data-ttu-id="7dd94-200">*확장성:* 응용 프로그램 개발자는 충분히 낮은 수준의 응용 프로그램 복잡성을 유지하면서 테넌트의 데이터 및 워크로드의 수와 규모에 맞게 조정되도록 응용 프로그램을 설계하는 방안을 고려해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="7dd94-200">*Scalability:* Application developers need to consider how they reconcile between maintaining a sufficiently low level of application complexity and designing the application to scale with number of tenants and the size of tenants' data and workload.</span></span>

<span data-ttu-id="7dd94-201">Azure 검색에서는 테넌트의 데이터 및 작업 부하를 격리하는 데 사용할 수 있는 몇 가지 경계를 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="7dd94-201">Azure Search offers a few boundaries that can be used to isolate tenants’ data and workload.</span></span>

## <a name="modeling-multitenancy-with-azure-search"></a><span data-ttu-id="7dd94-202">Azure 검색을 사용한 다중 테넌트 모델링</span><span class="sxs-lookup"><span data-stu-id="7dd94-202">Modeling multitenancy with Azure Search</span></span>
<span data-ttu-id="7dd94-203">다중 테넌트 시나리오에서 응용 프로그램 개발자는 하나 이상의 검색 서비스를 사용하고 서비스, 인덱스 또는 둘 다에서 해당 테넌트를 나눕니다.</span><span class="sxs-lookup"><span data-stu-id="7dd94-203">In the case of a multitenant scenario, the application developer consumes one or more search services and divide their tenants among services, indexes, or both.</span></span> <span data-ttu-id="7dd94-204">Azure 검색에서는 다중 테넌트 시나리오를 모델링할 때 몇 가지 일반적인 패턴을 따릅니다.</span><span class="sxs-lookup"><span data-stu-id="7dd94-204">Azure Search has a few common patterns when modeling a multitenant scenario:</span></span>

1. <span data-ttu-id="7dd94-205">*테넌트당 인덱스:* 각 테넌트는 다른 테넌트와 공유되는 검색 서비스 내의 자체 인덱스를 갖습니다.</span><span class="sxs-lookup"><span data-stu-id="7dd94-205">*Index per tenant:* Each tenant has its own index within a search service that is shared with other tenants.</span></span>
2. <span data-ttu-id="7dd94-206">*테넌트당 서비스:* 각 테넌트는 자체 전용 Azure Search 서비스를 갖습니다. 이 검색 서비스는 가장 높은 수준의 데이터 및 워크로드 분리를 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="7dd94-206">*Service per tenant:* Each tenant has its own dedicated Azure Search service, offering highest level of data and workload separation.</span></span>
3. <span data-ttu-id="7dd94-207">*두 가지 조합:* 좀 더 작은 테넌트에는 공유 서비스 내에서 개별 인덱스가 할당되지만, 좀 더 큰 활성 테넌트에는 전용 서비스가 할당됩니다.</span><span class="sxs-lookup"><span data-stu-id="7dd94-207">*Mix of both:* Larger, more-active tenants are assigned dedicated services while smaller tenants are assigned individual indexes within shared services.</span></span>

## <a name="1-index-per-tenant"></a><span data-ttu-id="7dd94-208">1. 테넌트당 인덱스</span><span class="sxs-lookup"><span data-stu-id="7dd94-208">1. Index per tenant</span></span>
![테넌트당 인덱스 모델](./media/search-modeling-multitenant-saas-applications/azure-search-index-per-tenant.png)

<span data-ttu-id="7dd94-210">테넌트당 인덱스 모델에서 여러 테넌트가 단일 Azure 검색 서비스에 포함되며, 각 테넌트는 고유 인덱스를 갖습니다.</span><span class="sxs-lookup"><span data-stu-id="7dd94-210">In an index-per-tenant model, multiple tenants occupy a single Azure Search service where each tenant has their own index.</span></span>

<span data-ttu-id="7dd94-211">모든 검색 요청 및 문서 작업은 Azure 검색의 인덱스 수준에서 실행되므로 테넌트의 데이터 격리가 구현됩니다.</span><span class="sxs-lookup"><span data-stu-id="7dd94-211">Tenants achieve data isolation because all search requests and document operations are issued at an index level in Azure Search.</span></span> <span data-ttu-id="7dd94-212">응용 프로그램 계층에서는 모든 테넌트의 서비스 수준에서 리소스를 관리하면서 다양한 테넌트의 트래픽을 적절한 인덱스로 전달해야 한다는 것을 인식해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="7dd94-212">In the application layer, there is the need awareness to direct the various tenants’ traffic to the proper indexes while also managing resources at the service level across all tenants.</span></span>

<span data-ttu-id="7dd94-213">테넌트당 인덱스 모델의 주요 특성은 응용 프로그램 개발자가 응용 프로그램의 테넌트 간에 검색 서비스의 용량을 초과 구독할 수 있다는 것입니다.</span><span class="sxs-lookup"><span data-stu-id="7dd94-213">A key attribute of the index-per-tenant model is the ability for the application developer to oversubscribe the capacity of a search service among the application’s tenants.</span></span> <span data-ttu-id="7dd94-214">테넌트의 워크로드가 균일하지 않게 분산되는 경우 사용 빈도가 낮은 테넌트의 긴 꼬리를 동시에 처리하면서 사용 빈도가 높은 많은 수의 리소스 집약적 테넌트를 수용하도록 하는 최적의 테넌트 조합을 검색 서비스의 인덱스에서 분산할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="7dd94-214">If the tenants have an uneven distribution of workload, the optimal combination of tenants can be distributed across a search service’s indexes to accommodate a number of highly active, resource-intensive tenants while simultaneously serving a long tail of less active tenants.</span></span> <span data-ttu-id="7dd94-215">단점은 이 모델의 경우 각 테넌트의 사용 빈도가 동시에 높아지는 상황을 처리하지 못한다는 것입니다.</span><span class="sxs-lookup"><span data-stu-id="7dd94-215">The trade-off is the inability of the model to handle situations where each tenant is concurrently highly active.</span></span>

<span data-ttu-id="7dd94-216">테넌트당 인덱스 모델은 가변 비용 모델의 토대를 제공합니다. 이러한 모델에서는 전체 Azure 검색 서비스가 사전 구매된 후 이후에 테넌트로 채워집니다.</span><span class="sxs-lookup"><span data-stu-id="7dd94-216">The index-per-tenant model provides the basis for a variable cost model, where an entire Azure Search service is bought up-front and then subsequently filled with tenants.</span></span> <span data-ttu-id="7dd94-217">따라서 평가판 및 무료 계정을 위해 미사용 용량을 디자인할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="7dd94-217">This allows for unused capacity to be designated for trials and free accounts.</span></span>

<span data-ttu-id="7dd94-218">전역 공간이 있는 응용 프로그램의 경우 테넌트당 인덱스 모델이 가장 효율적이 아닐 수도 있습니다.</span><span class="sxs-lookup"><span data-stu-id="7dd94-218">For applications with a global footprint, the index-per-tenant model may not be the most efficient.</span></span> <span data-ttu-id="7dd94-219">응용 프로그램의 테넌트가 전 세계에 걸쳐 분산되어 있으면 각 지역에 대해 별도 서비스가 필요할 수 있으므로 각각에 대해 비용이 중복될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="7dd94-219">If an application's tenants are distributed across the globe, a separate service may be necessary for each region which may duplicate costs across each of them.</span></span>

<span data-ttu-id="7dd94-220">Azure 검색을 사용하면 개별 인덱스와 총 인덱스 수가 모두 커져도 됩니다.</span><span class="sxs-lookup"><span data-stu-id="7dd94-220">Azure Search allows for the scale of both the individual indexes and the total number of indexes to grow.</span></span> <span data-ttu-id="7dd94-221">적절한 가격 계층을 선택한 경우 서비스 내의 개별 인덱스가 저장소 또는 트래픽 측면에서 너무 커질 때 전체 검색 서비스에 파티션 및 복제본을 추가할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="7dd94-221">If an appropriate pricing tier is chosen, partitions and replicas can be added to the entire search service when an individual index within the service grows too large in terms of storage or traffic.</span></span>

<span data-ttu-id="7dd94-222">인덱스의 총 수가 단일 서비스에 대해 너무 커지면 새 테넌트를 수용하도록 다른 서비스를 프로비전해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="7dd94-222">If the total number of indexes grows too large for a single service, another service has to be provisioned to accommodate the new tenants.</span></span> <span data-ttu-id="7dd94-223">새 서비스를 추가할 때 인덱스를 검색 서비스 간에 이동해야 할 경우, Azure 검색 서비스는 인덱스 이동을 허용하지 않으므로 인덱스의 데이터를 수동으로 한 인덱스에서 다른 인덱스로 복사해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="7dd94-223">If indexes have to be moved between search services as new services are added, the data from the index has to be manually copied from one index to the other as Azure Search does not allow for an index to be moved.</span></span>

## <a name="2-service-per-tenant"></a><span data-ttu-id="7dd94-224">2. 테넌트당 서비스</span><span class="sxs-lookup"><span data-stu-id="7dd94-224">2. Service per tenant</span></span>
![테넌트당 서비스 모델](./media/search-modeling-multitenant-saas-applications/azure-search-service-per-tenant.png)

<span data-ttu-id="7dd94-226">테넌트당 서비스 아키텍처에서 각 테넌트에는 자체 검색 서비스가 있습니다.</span><span class="sxs-lookup"><span data-stu-id="7dd94-226">In a service-per-tenant architecture, each tenant has its own search service.</span></span>

<span data-ttu-id="7dd94-227">이 모델에서 응용 프로그램에는 해당 테넌트에 대해 최대 수준의 격리가 구현됩니다.</span><span class="sxs-lookup"><span data-stu-id="7dd94-227">In this model, the application achieves the maximum level of isolation for its tenants.</span></span> <span data-ttu-id="7dd94-228">각 서비스에는 별도의 API 키 외에도, 검색 요청을 처리하기 위한 전용 저장소 및 처리량을 갖습니다.</span><span class="sxs-lookup"><span data-stu-id="7dd94-228">Each service has dedicated storage and throughput for handling search request as well as separate API keys.</span></span>

<span data-ttu-id="7dd94-229">각 테넌트가 많은 공간을 차지하거나 워크로드가 테넌트 간에 거의 변동되지 않는 응용 프로그램의 경우 테넌트당 서비스 모델은 다양한 테넌트의 워크로드에서 리소스를 공유되지 않으므로 효과적입니다.</span><span class="sxs-lookup"><span data-stu-id="7dd94-229">For applications where each tenant has a large footprint or the workload has little variability from tenant to tenant, the service-per-tenant model is an effective choice as resources are not shared across various tenants’ workloads.</span></span>

<span data-ttu-id="7dd94-230">테넌트당 서비스 모델 또한 예측 가능한 고정 비용 모델의 이점을 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="7dd94-230">A service per tenant model also offers the benefit of a predictable, fixed cost model.</span></span> <span data-ttu-id="7dd94-231">채울 테넌트가 있을 때까지 전체 검색 서비스에서 선행 투자가 없으므로 테넌트당 비용이 테넌트당 인덱스 모델보다 더 높습니다.</span><span class="sxs-lookup"><span data-stu-id="7dd94-231">There is no up-front investment in an entire search service until there is a tenant to fill it, however the cost-per-tenant is higher than an index-per-tenant model.</span></span>

<span data-ttu-id="7dd94-232">테넌트당 서비스 모델은 전역 공간을 차지하는 응용 프로그램에 효율적인 선택입니다.</span><span class="sxs-lookup"><span data-stu-id="7dd94-232">The service-per-tenant model is an efficient choice for applications with a global footprint.</span></span> <span data-ttu-id="7dd94-233">지리적으로 분산 테넌트를 사용할 경우 각 테넌트 서비스를 적절한 지역에 두기 쉽습니다.</span><span class="sxs-lookup"><span data-stu-id="7dd94-233">With geographically-distributed tenants, it is easy to have each tenant's service in the appropriate region.</span></span>

<span data-ttu-id="7dd94-234">개별 테넌트가 서비스보다 커지면 이 패턴의 규모를 조정하기 어렵습니다.</span><span class="sxs-lookup"><span data-stu-id="7dd94-234">The challenges in scaling this pattern arise when individual tenants outgrow their service.</span></span> <span data-ttu-id="7dd94-235">Azure 검색에서는 현재 검색 서비스의 가격 책정 계층에 대한 업그레이드를 지원하지 않으므로 모든 데이터를 새 서비스에 수동으로 복사해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="7dd94-235">Azure Search does not currently support upgrading the pricing tier of a search service, so all data would have to be manually copied to a new service.</span></span>

## <a name="3-mixing-both-models"></a><span data-ttu-id="7dd94-236">3. 두 모델 조합</span><span class="sxs-lookup"><span data-stu-id="7dd94-236">3. Mixing both models</span></span>
<span data-ttu-id="7dd94-237">다중 테넌트를 모델링하기 위한 또 다른 패턴은 테넌트당 인덱스 및 테넌트당 서비스 전략을 조합하는 것입니다.</span><span class="sxs-lookup"><span data-stu-id="7dd94-237">Another pattern for modeling multitenancy is mixing both index-per-tenant and service-per-tenant strategies.</span></span>

<span data-ttu-id="7dd94-238">두 가지 패턴을 조합하면 응용 프로그램의 가장 큰 테넌트가 전용 서비스를 차지할 수 있지만, 사용 빈도가 낮으면서 좀 더 작은 테넌트의 긴 꼬리가 공유 서비스의 인덱스를 차지할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="7dd94-238">By mixing the two patterns, an application's largest tenants can occupy dedicated services while the long tail of less active, smaller tenants can occupy indexes in a shared service.</span></span> <span data-ttu-id="7dd94-239">이 모델에서는 노이즈 이웃의 좀 더 작은 테넌트를 보호하면서 가장 큰 테넌트가 서비스에서 일관된 고성능을 보장합니다.</span><span class="sxs-lookup"><span data-stu-id="7dd94-239">This model ensures that the largest tenants have consistently high performance from the service while helping to protect the smaller tenants from any noisy neighbors.</span></span>

<span data-ttu-id="7dd94-240">그러나 이 전략을 구현하려면 공유 서비스의 인덱스 대비, 전용 서비스를 요구하는 테넌트를 예측해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="7dd94-240">However, implementing this strategy relies foresight in predicting which tenants will require a dedicated service versus an index in a shared service.</span></span> <span data-ttu-id="7dd94-241">이러한 다중 테넌트 모델을 둘 다 관리하기 위해 응용 프로그램 복잡성이 증가합니다.</span><span class="sxs-lookup"><span data-stu-id="7dd94-241">Application complexity increases with the need to manage both of these multitenancy models.</span></span>

## <a name="achieving-even-finer-granularity"></a><span data-ttu-id="7dd94-242">훨씬 더 미세한 세밀성 달성</span><span class="sxs-lookup"><span data-stu-id="7dd94-242">Achieving even finer granularity</span></span>
<span data-ttu-id="7dd94-243">Azure 검색에서 다중 테넌트 시나리오를 모델링하기 위한 위의 디자인 패턴은 각 테넌트가 응용 프로그램의 전체 인스턴스에 해당하는 균일한 범위를 가정합니다.</span><span class="sxs-lookup"><span data-stu-id="7dd94-243">The above design patterns to model multitenant scenarios in Azure Search assume a uniform scope where each tenant is a whole instance of an application.</span></span> <span data-ttu-id="7dd94-244">그러나 응용 프로그램은 경우에 따라 좀 더 작은 여러 범위를 처리할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="7dd94-244">However, applications can sometimes handle many smaller scopes.</span></span>

<span data-ttu-id="7dd94-245">테넌트당 서비스 및 테넌트당 인덱스 모델은 충분히 작은 범위가 아니므로 훨씬 더 미세한 세밀성을 얻기 위헤 인덱스를 모델링할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="7dd94-245">If service-per-tenant and index-per-tenant models are not sufficiently small scopes, it is possible to model an index to achieve an even finer degree of granularity.</span></span>

<span data-ttu-id="7dd94-246">단일 인덱스가 다양한 클라이언트 끝점에 대해 다르게 동작하도록 하기 위해 가능한 각 클라이언트에 대한 특정 값을 지정하는 필드를 인덱스에 추가할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="7dd94-246">To have a single index behave differently for different client endpoints, a field can be added to an index which designates a certain value for each possible client.</span></span> <span data-ttu-id="7dd94-247">클라이언트가 Azure 검색을 호출하여 인덱스를 쿼리 또는 수정할 때마다 클라이언트 응용 프로그램의 코드는 쿼리 시에 Azure 검색의 [필터](https://msdn.microsoft.com/library/azure/dn798921.aspx) 기능을 사용하여 해당 필드에 대해 적절한 값을 지정합니다.</span><span class="sxs-lookup"><span data-stu-id="7dd94-247">Each time a client calls Azure Search to query or modify an index, the code from the client application specifies the appropriate value for that field using Azure Search's [filter](https://msdn.microsoft.com/library/azure/dn798921.aspx) capability at query time.</span></span>

<span data-ttu-id="7dd94-248">이 방법을 사용하면 별도의 사용자 계정, 별도의 사용 권한 수준 및 완전 별도의 응용 프로그램 기능을 얻을 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="7dd94-248">This method can be used to achieve functionality of separate user accounts, separate permission levels, and even completely separate applications.</span></span>

> [!NOTE]
> <span data-ttu-id="7dd94-249">위에서 설명한 방법을 사용하여 여러 테넌트를 제공하는 단일 인덱스를 구성하면 검색 결과의 관련성에 영향을 미칩니다.</span><span class="sxs-lookup"><span data-stu-id="7dd94-249">Using the approach described above to configure a single index to serve multiple tenants affects the relevance of search results.</span></span> <span data-ttu-id="7dd94-250">검색 관련성 점수는 테넌트 수준 범위가 아닌 인덱스 수준 범위에서 계산되므로, 모든 테넌트의 데이터는 용어 빈도 등의 관련성 점수의 기본 통계에 포함됩니다.</span><span class="sxs-lookup"><span data-stu-id="7dd94-250">Search relevance scores are computed at an index-level scope, not a tenant-level scope, so all tenants' data is incorporated in the relevance scores' underlying statistics such as term frequency.</span></span>
> 
> 

## <a name="next-steps"></a><span data-ttu-id="7dd94-251">다음 단계</span><span class="sxs-lookup"><span data-stu-id="7dd94-251">Next steps</span></span>
<span data-ttu-id="7dd94-252">Azure Search는 대부분의 응용 프로그램에 적합한 방법입니다. [이 서비스의 강력한 기능을 자세히 읽어 보세요](http://aka.ms/whatisazsearch).</span><span class="sxs-lookup"><span data-stu-id="7dd94-252">Azure Search is a compelling choice for many applications, [read more about the service's robust capabilities](http://aka.ms/whatisazsearch).</span></span> <span data-ttu-id="7dd94-253">다중 테넌트 응용 프로그램에 대한 다양한 디자인 패턴을 평가할 때 [다양한 가격 책정 계층](https://azure.microsoft.com/pricing/details/search/) 및 해당 [서비스 제한](search-limits-quotas-capacity.md)을 고려하여 모든 규모의 응용 프로그램 워크로드 및 아키텍처에 가장 잘 맞게 Azure Search를 조정할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="7dd94-253">When evaluating the various design patterns for multitenant applications, consider the [various pricing tiers](https://azure.microsoft.com/pricing/details/search/) and the respective [service limits](search-limits-quotas-capacity.md) to best tailor Azure Search to fit application workloads and architectures of all sizes.</span></span>

<span data-ttu-id="7dd94-254">Azure Search 및 다중 테넌트 시나리오에 대한 질문은 azuresearch_contact@microsoft.com으로 보내 주세요.</span><span class="sxs-lookup"><span data-stu-id="7dd94-254">Any questions about Azure Search and multitenant scenarios can be directed to azuresearch_contact@microsoft.com.</span></span>

