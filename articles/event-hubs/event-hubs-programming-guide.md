---
title: "Azure Event Hubs에 대한 프로그래밍 가이드 | Microsoft Docs"
description: "Azure.NET SDK를 사용하여 Azure Event Hubs에 대한 코드를 작성합니다."
services: event-hubs
documentationcenter: na
author: sethmanheim
manager: timlt
editor: 
ms.assetid: 64cbfd3d-4a0e-4455-a90a-7f3d4f080323
ms.service: event-hubs
ms.devlang: na
ms.topic: article
ms.tgt_pltfrm: na
ms.workload: tbd
ms.date: 08/17/2017
ms.author: sethm
ms.openlocfilehash: 405ec2b27b488b570c4a5c86e4950ff98233360e
ms.sourcegitcommit: 50e23e8d3b1148ae2d36dad3167936b4e52c8a23
ms.translationtype: MT
ms.contentlocale: ko-KR
ms.lasthandoff: 08/18/2017
---
# <a name="event-hubs-programming-guide"></a><span data-ttu-id="70846-103">이벤트 허브 프로그래밍 가이드</span><span class="sxs-lookup"><span data-stu-id="70846-103">Event Hubs programming guide</span></span>

<span data-ttu-id="70846-104">이 문서에서는 Azure Event Hub 및 Azure .NET SDK를 사용하여 코드를 작성하는 몇 가지 일반적인 시나리오에 대해 논의합니다.</span><span class="sxs-lookup"><span data-stu-id="70846-104">This article discusses some common scenarios in writing code using Azure Event Hubs and the Azure .NET SDK.</span></span> <span data-ttu-id="70846-105">이벤트 허브에 대한 예비 이해가 있다고 가정합니다.</span><span class="sxs-lookup"><span data-stu-id="70846-105">It assumes a preliminary understanding of Event Hubs.</span></span> <span data-ttu-id="70846-106">이벤트 허브의 개요에 대한 개념은 [이벤트 허브 개요](event-hubs-what-is-event-hubs.md)를 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="70846-106">For a conceptual overview of Event Hubs, see the [Event Hubs overview](event-hubs-what-is-event-hubs.md).</span></span>

## <a name="event-publishers"></a><span data-ttu-id="70846-107">이벤트 게시자</span><span class="sxs-lookup"><span data-stu-id="70846-107">Event publishers</span></span>

<span data-ttu-id="70846-108">HTTP POST를 사용하거나 AMQP 1.0 연결을 통해 이벤트 허브에 이벤트를 보냅니다.</span><span class="sxs-lookup"><span data-stu-id="70846-108">You send events to an event hub either using HTTP POST or via an AMQP 1.0 connection.</span></span> <span data-ttu-id="70846-109">해결할 구체적인 시나리오에 따라 무엇을 언제 사용할지 선택합니다.</span><span class="sxs-lookup"><span data-stu-id="70846-109">The choice of which to use and when depends on the specific scenario being addressed.</span></span> <span data-ttu-id="70846-110">AMQP 1.0 연결은 영구 메시징 채널을 제공하기 때문에 서비스 버스에서 조정된 연결로 계량되며 시나리오에서 자주 높은 메시지 볼륨 및 낮은 대기 시간 요구 사항에 적절합니다.</span><span class="sxs-lookup"><span data-stu-id="70846-110">AMQP 1.0 connections are metered as brokered connections in Service Bus and are more appropriate in scenarios with frequent higher message volumes and lower latency requirements, as they provide a persistent messaging channel.</span></span>

<span data-ttu-id="70846-111">[NamespaceManager][] 클래스를 사용하여 이벤트 허브를 만들고 관리합니다.</span><span class="sxs-lookup"><span data-stu-id="70846-111">You create and manage Event Hubs using the [NamespaceManager][] class.</span></span> <span data-ttu-id="70846-112">.NET 관리 API를 사용하는 경우 Event Hubs에 데이터를 게시하기 위한 기본 구조는 [EventHubClient](/dotnet/api/microsoft.servicebus.messaging.eventhubclient) 및 [EventData][] 클래스입니다.</span><span class="sxs-lookup"><span data-stu-id="70846-112">When using the .NET managed APIs, the primary constructs for publishing data to Event Hubs are the [EventHubClient](/dotnet/api/microsoft.servicebus.messaging.eventhubclient) and [EventData][] classes.</span></span> <span data-ttu-id="70846-113">[EventHubClient][]는 이벤트가 이벤트 허브로 전송되는 AMQP 통신 채널을 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="70846-113">[EventHubClient][] provides the AMQP communication channel over which events are sent to the event hub.</span></span> <span data-ttu-id="70846-114">[EventData][] 클래스는 이벤트를 나타내며 이벤트 허브에 메시지를 게시하는데 사용됩니다.</span><span class="sxs-lookup"><span data-stu-id="70846-114">The [EventData][] class represents an event, and is used to publish messages to an event hub.</span></span> <span data-ttu-id="70846-115">이 클래스는 이벤트에 대한 본문, 일부 메타데이터 및 헤더 정보를 포함합니다.</span><span class="sxs-lookup"><span data-stu-id="70846-115">This class includes the body, some metadata, and header information about the event.</span></span> <span data-ttu-id="70846-116">[EventData][] 개체가 이벤트 허브를 통과할 때 여기에 다른 속성이 추가됩니다.</span><span class="sxs-lookup"><span data-stu-id="70846-116">Other properties are added to the [EventData][] object as it passes through an event hub.</span></span>

## <a name="get-started"></a><span data-ttu-id="70846-117">시작</span><span class="sxs-lookup"><span data-stu-id="70846-117">Get started</span></span>

<span data-ttu-id="70846-118">이벤트 허브를 지원하는 .NET 클래스는 Microsoft.ServiceBus.dll 어셈블리에 제공됩니다.</span><span class="sxs-lookup"><span data-stu-id="70846-118">The .NET classes that support Event Hubs are provided in the Microsoft.ServiceBus.dll assembly.</span></span> <span data-ttu-id="70846-119">서비스 버스 API를 가져오고 모든 서비스 버스 종속성으로 응용 프로그램을 구성하는 가장 쉬운 방법은 [서비스 버스 NuGet 패키지](https://www.nuget.org/packages/WindowsAzure.ServiceBus)를 다운로드하는 것입니다.</span><span class="sxs-lookup"><span data-stu-id="70846-119">The easiest way to reference the Service Bus API and to configure your application with all of the Service Bus dependencies is to download the [Service Bus NuGet package](https://www.nuget.org/packages/WindowsAzure.ServiceBus).</span></span> <span data-ttu-id="70846-120">또는 Visual Studio에서 [패키지 관리자 콘솔](http://docs.nuget.org/docs/start-here/using-the-package-manager-console) 을 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="70846-120">Alternatively, you can use the [Package Manager Console](http://docs.nuget.org/docs/start-here/using-the-package-manager-console) in Visual Studio.</span></span> <span data-ttu-id="70846-121">이렇게 하려면 [패키지 관리자 콘솔](http://docs.nuget.org/docs/start-here/using-the-package-manager-console) 창에서 다음 명령을 발급합니다.</span><span class="sxs-lookup"><span data-stu-id="70846-121">To do so, issue the following command in the [Package Manager Console](http://docs.nuget.org/docs/start-here/using-the-package-manager-console) window:</span></span>

```
Install-Package WindowsAzure.ServiceBus
```

## <a name="create-an-event-hub"></a><span data-ttu-id="70846-122">이벤트 허브 만들기</span><span class="sxs-lookup"><span data-stu-id="70846-122">Create an event hub</span></span>
<span data-ttu-id="70846-123">이벤트 허브 만들기에 [NamespaceManager][] 클래스를 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="70846-123">You can use the [NamespaceManager][] class to create Event Hubs.</span></span> <span data-ttu-id="70846-124">예:</span><span class="sxs-lookup"><span data-stu-id="70846-124">For example:</span></span>

```csharp
var manager = new Microsoft.ServiceBus.NamespaceManager("mynamespace.servicebus.windows.net");
var description = manager.CreateEventHub("MyEventHub");
```

<span data-ttu-id="70846-125">대부분의 경우에서 [CreateEventHubIfNotExists][] 메서드를 사용하여 서비스를 다시 시작하는 경우 예외를 생성하지 않도록 하는 것이 좋습니다.</span><span class="sxs-lookup"><span data-stu-id="70846-125">In most cases, it is recommended that you use the [CreateEventHubIfNotExists][] methods to avoid generating exceptions if the service restarts.</span></span> <span data-ttu-id="70846-126">예:</span><span class="sxs-lookup"><span data-stu-id="70846-126">For example:</span></span>

```csharp
var description = manager.CreateEventHubIfNotExists("MyEventHub");
```

<span data-ttu-id="70846-127">[CreateEventHubIfNotExists][]를 포함하여 모든 이벤트 허브 만들기 작업은 해당 네임스페이스에 대한 **관리** 권한이 필요합니다.</span><span class="sxs-lookup"><span data-stu-id="70846-127">All Event Hubs creation operations, including [CreateEventHubIfNotExists][], require **Manage** permissions on the namespace in question.</span></span> <span data-ttu-id="70846-128">게시자 또는 소비자 응용 프로그램의 사용 권한을 제한하려면 제한된 권한으로 자격 증명을 사용하는 경우 프로덕션 코드에서 작업 호출을 만들기를 방지할 수 있습니다</span><span class="sxs-lookup"><span data-stu-id="70846-128">If you want to limit the permissions of your publisher or consumer applications, you can avoid these create operation calls in production code when you use credentials with limited permissions.</span></span>

<span data-ttu-id="70846-129">[EventHubDescription](/dotnet/api/microsoft.servicebus.messaging.eventhubdescription) 클래스에는 권한 부여 규칙, 메시지 보존 간격, 파티션 ID, 상태 및 경로를 포함하는 이벤트 허브에 대한 세부 정보가 포함됩니다.</span><span class="sxs-lookup"><span data-stu-id="70846-129">The [EventHubDescription](/dotnet/api/microsoft.servicebus.messaging.eventhubdescription) class contains details about an event hub, including the authorization rules, the message retention interval, partition IDs, status, and path.</span></span> <span data-ttu-id="70846-130">이 클래스를 사용하여 이벤트 허브에서 메타데이터를 업데이트할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="70846-130">You can use this class to update the metadata on an event hub.</span></span>

## <a name="create-an-event-hubs-client"></a><span data-ttu-id="70846-131">이벤트 허브 클라이언트 만들기</span><span class="sxs-lookup"><span data-stu-id="70846-131">Create an Event Hubs client</span></span>
<span data-ttu-id="70846-132">Event Hubs와 상호 작용하기 위한 기본 클래스는 [Microsoft.ServiceBus.Messaging.EventHubClient][EventHubClient]입니다.</span><span class="sxs-lookup"><span data-stu-id="70846-132">The primary class for interacting with Event Hubs is [Microsoft.ServiceBus.Messaging.EventHubClient][EventHubClient].</span></span> <span data-ttu-id="70846-133">이 클래스는 발신자와 수신자 기능을 모두 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="70846-133">This class provides both sender and receiver capabilities.</span></span> <span data-ttu-id="70846-134">다음 예와 같이 [만들기](/dotnet/api/microsoft.servicebus.messaging.eventhubclient.create) 메서드를 사용하여 이 클래스를 인스턴스화할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="70846-134">You can instantiate this class using the [Create](/dotnet/api/microsoft.servicebus.messaging.eventhubclient.create) method, as shown in the following example.</span></span>

```csharp
var client = EventHubClient.Create(description.Path);
```

<span data-ttu-id="70846-135">이 메서드는 `appSettings` 섹션의 App.config 파일에서 서비스 버스 연결 정보를 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="70846-135">This method uses the Service Bus connection information in the App.config file, in the `appSettings` section.</span></span> <span data-ttu-id="70846-136">서비스 버스 연결 정보를 저장하는 데 사용되는 `appSettings` XML의 예제는 [Microsoft.ServiceBus.Messaging.EventHubClient.Create(System.String)](/dotnet/api/microsoft.servicebus.messaging.eventhubclient#Microsoft_ServiceBus_Messaging_EventHubClient_Create_System_String_) 메서드에 대한 문서를 참고하십시오.</span><span class="sxs-lookup"><span data-stu-id="70846-136">For an example of the `appSettings` XML used to store the Service Bus connection information, see the documentation for the [Microsoft.ServiceBus.Messaging.EventHubClient.Create(System.String)](/dotnet/api/microsoft.servicebus.messaging.eventhubclient#Microsoft_ServiceBus_Messaging_EventHubClient_Create_System_String_) method.</span></span>

<span data-ttu-id="70846-137">다른 옵션은 연결 문자열에 클라이언트를 만드는 것입니다.</span><span class="sxs-lookup"><span data-stu-id="70846-137">Another option is to create the client from a connection string.</span></span> <span data-ttu-id="70846-138">작업자에 대한 구성 속성에 문자열을 저장할 수 있으므로 이 옵션은 Azure 작업자 역할을 사용하는 경우에 잘 작동합니다.</span><span class="sxs-lookup"><span data-stu-id="70846-138">This option works well when using Azure worker roles, because you can store the string in the configuration properties for the worker.</span></span> <span data-ttu-id="70846-139">예:</span><span class="sxs-lookup"><span data-stu-id="70846-139">For example:</span></span>

```csharp
EventHubClient.CreateFromConnectionString("your_connection_string");
```

<span data-ttu-id="70846-140">이전 방법에 대한 App.config 파일에서 표시된 대로 연결 문자열은 동일한 형식에 있습니다.</span><span class="sxs-lookup"><span data-stu-id="70846-140">The connection string will be in the same format as it appears in the App.config file for the previous methods:</span></span>

```
Endpoint=sb://[namespace].servicebus.windows.net/;SharedAccessKeyName=RootManageSharedAccessKey;SharedAccessKey=[key]
```

<span data-ttu-id="70846-141">또한 마지막으로 다음 예와 같이 [MessagingFactory](/dotnet/api/microsoft.servicebus.messaging.messagingfactory) 인스턴스에서 [EventHubClient][] 개체를 만들 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="70846-141">Finally, it is also possible to create an [EventHubClient][] object from a [MessagingFactory](/dotnet/api/microsoft.servicebus.messaging.messagingfactory) instance, as shown in the following example.</span></span>

```csharp
var factory = MessagingFactory.CreateFromConnectionString("your_connection_string");
var client = factory.CreateEventHubClient("MyEventHub");
```

<span data-ttu-id="70846-142">메시징 팩터리 인스턴스에서 만들어진 추가 [EventHubClient][] 개체가 동일한 기본 TCP 연결을 재사용하는 것이 중요합니다.</span><span class="sxs-lookup"><span data-stu-id="70846-142">It is important to note that additional [EventHubClient][] objects created from a messaging factory instance will reuse the same underlying TCP connection.</span></span> <span data-ttu-id="70846-143">따라서 이러한 개체는 처리량에 클라이언트쪽 한계를 갖습니다.</span><span class="sxs-lookup"><span data-stu-id="70846-143">Therefore, these objects have a client-side limit on throughput.</span></span> <span data-ttu-id="70846-144">[만들기](/dotnet/api/microsoft.servicebus.messaging.eventhubclient#Microsoft_ServiceBus_Messaging_EventHubClient_Create_System_String_) 메서드는 단일 메시징 팩터리를 재사용합니다.</span><span class="sxs-lookup"><span data-stu-id="70846-144">The [Create](/dotnet/api/microsoft.servicebus.messaging.eventhubclient#Microsoft_ServiceBus_Messaging_EventHubClient_Create_System_String_) method reuses a single messaging factory.</span></span> <span data-ttu-id="70846-145">단일 발신자에서 매우 높은 처리량이 필요한 경우 각 메시징 팩터리에서 다양한 메시지 팩터리 및 하나의 [EventHubClient][] 개체를 만들 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="70846-145">If you need very high throughput from a single sender, then you can create multiple message factories and one [EventHubClient][] object from each messaging factory.</span></span>

## <a name="send-events-to-an-event-hub"></a><span data-ttu-id="70846-146">이벤트 허브로 이벤트 보내기</span><span class="sxs-lookup"><span data-stu-id="70846-146">Send events to an event hub</span></span>
<span data-ttu-id="70846-147">[EventData][] 인스턴스를 만들고 [보내기](/dotnet/api/microsoft.servicebus.messaging.eventhubclient#Microsoft_ServiceBus_Messaging_EventHubClient_Send_Microsoft_ServiceBus_Messaging_EventData_) 메서드를 통해 보내 이벤트를 이벤트 허브로 보냅니다.</span><span class="sxs-lookup"><span data-stu-id="70846-147">You send events to an event hub by creating an [EventData][] instance and sending it via the [Send](/dotnet/api/microsoft.servicebus.messaging.eventhubclient#Microsoft_ServiceBus_Messaging_EventHubClient_Send_Microsoft_ServiceBus_Messaging_EventData_) method.</span></span> <span data-ttu-id="70846-148">이 메서드는 단일 [EventData][] 인스턴스 매개 변수를 가져오는 동시에 이벤트 허브로 보냅니다.</span><span class="sxs-lookup"><span data-stu-id="70846-148">This method takes a single [EventData][] instance parameter and synchronously sends it to an event hub.</span></span>

## <a name="event-serialization"></a><span data-ttu-id="70846-149">이벤트 직렬화</span><span class="sxs-lookup"><span data-stu-id="70846-149">Event serialization</span></span>
<span data-ttu-id="70846-150">[EventData][] 클래스에는 개체 및 직렬 변환기, 바이트 배열 또는 스트림과 같은 다양한 매개 변수를 가진 [4개의 오버로드된 생성자](/dotnet/api/microsoft.servicebus.messaging.eventdata#constructors_)가 있습니다.</span><span class="sxs-lookup"><span data-stu-id="70846-150">The [EventData][] class has [four overloaded constructors](/dotnet/api/microsoft.servicebus.messaging.eventdata#constructors_) that take a variety of parameters, such as an object and serializer, a byte array, or a stream.</span></span> <span data-ttu-id="70846-151">[EventData][] 클래스를 인스턴스화하고 나중에 본문 스트림을 설정할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="70846-151">It is also possible to instantiate the [EventData][] class and set the body stream afterwards.</span></span> <span data-ttu-id="70846-152">[EventData][]와 함께 JSON을 사용하는 경우 **Encoding.UTF8.GetBytes()** 를 사용하여 JSON으로 인코딩된 문자열에 대한 바이트 배열을 검색할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="70846-152">When using JSON with [EventData][], you can use **Encoding.UTF8.GetBytes()** to retrieve the byte array for a JSON-encoded string.</span></span>

## <a name="partition-key"></a><span data-ttu-id="70846-153">파티션 키</span><span class="sxs-lookup"><span data-stu-id="70846-153">Partition key</span></span>
<span data-ttu-id="70846-154">[EventData][] 클래스에는 보낸 사람이 파티션 할당을 생성하도록 해시하는 값을 지정할 수 있도록 하는 [PartitionKey][] 속성이 있습니다.</span><span class="sxs-lookup"><span data-stu-id="70846-154">The [EventData][] class has a [PartitionKey][] property that enables the sender to specify a value that is hashed to produce a partition assignment.</span></span> <span data-ttu-id="70846-155">파티션 키를 사용하여 동일한 키를 가진 모든 이벤트가 이벤트 허브의 동일한 파티션에 전송되었는지 확인합니다.</span><span class="sxs-lookup"><span data-stu-id="70846-155">Using a partition key ensures that all the events with the same key are sent to the same partition in the event hub.</span></span> <span data-ttu-id="70846-156">공통 파티션 키에는 사용자 세션 ID 및 고유한 보낸 사람 ID가 있습니다.</span><span class="sxs-lookup"><span data-stu-id="70846-156">Common partition keys include user session IDs and unique sender IDs.</span></span> <span data-ttu-id="70846-157">[PartitionKey][] 속성은 선택적이며 [Microsoft.ServiceBus.Messaging.EventHubClient.Send(Microsoft.ServiceBus.Messaging.EventData)](/dotnet/api/microsoft.servicebus.messaging.eventhubclient#Microsoft_ServiceBus_Messaging_EventHubClient_Send_Microsoft_ServiceBus_Messaging_EventData_) 또는 [Microsoft.ServiceBus.Messaging.EventHubClient.SendAsync(Microsoft.ServiceBus.Messaging.EventData)](/dotnet/api/microsoft.servicebus.messaging.eventhubclient#Microsoft_ServiceBus_Messaging_EventHubClient_SendAsync_Microsoft_ServiceBus_Messaging_EventData_) 메서드를 사용하는 경우 제공될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="70846-157">The [PartitionKey][] property is optional and can be provided when using the [Microsoft.ServiceBus.Messaging.EventHubClient.Send(Microsoft.ServiceBus.Messaging.EventData)](/dotnet/api/microsoft.servicebus.messaging.eventhubclient#Microsoft_ServiceBus_Messaging_EventHubClient_Send_Microsoft_ServiceBus_Messaging_EventData_) or [Microsoft.ServiceBus.Messaging.EventHubClient.SendAsync(Microsoft.ServiceBus.Messaging.EventData)](/dotnet/api/microsoft.servicebus.messaging.eventhubclient#Microsoft_ServiceBus_Messaging_EventHubClient_SendAsync_Microsoft_ServiceBus_Messaging_EventData_) methods.</span></span> <span data-ttu-id="70846-158">[PartitionKey][]에 대한 값을 제공하지 않는 경우 보내진 이벤트는 라운드 로빈 모델을 사용하여 파티션에 배포됩니다.</span><span class="sxs-lookup"><span data-stu-id="70846-158">If you do not provide a value for [PartitionKey][], sent events are distributed to partitions using a round-robin model.</span></span>

### <a name="availability-considerations"></a><span data-ttu-id="70846-159">가용성 고려 사항</span><span class="sxs-lookup"><span data-stu-id="70846-159">Availability considerations</span></span>

<span data-ttu-id="70846-160">파티션 키 사용은 선택 사항이며 사용 여부를 신중하게 고려해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="70846-160">Using a partition key is optional, and you should consider carefully whether or not to use one.</span></span> <span data-ttu-id="70846-161">대부분의 경우에서 이벤트 순서 지정이 중요한 경우 파티션 키를 사용 하는 것이 좋습니다.</span><span class="sxs-lookup"><span data-stu-id="70846-161">In many cases, using a partition key is a good choice if event ordering is important.</span></span> <span data-ttu-id="70846-162">파티션 키를 사용할 경우 이러한 파티션은 단일 노드에서 가용성이 필요하며 시간이 지나면 중단이 발생할 수 있습니다(예: 연산 노드를 재부팅하고 패치할 경우).</span><span class="sxs-lookup"><span data-stu-id="70846-162">When you use a partition key, these partitions require availability on a single node, and outages can occur over time; for example, when compute nodes reboot and patch.</span></span> <span data-ttu-id="70846-163">따라서 파티션 ID를 설정하고 해당 파티션을 어떠한 이유로 사용할 수 없게 되면 해당 파티션의 데이터에 액세스하지 못하게 됩니다.</span><span class="sxs-lookup"><span data-stu-id="70846-163">As such, if you set a partition ID and that partition becomes unavailable for some reason, an attempt to access the data in that partition will fail.</span></span> <span data-ttu-id="70846-164">고가용성이 가장 중요한 경우에는 파티션 키를 지정하지 마십시오. 이러한 경우 이벤트는 이전에 설명한 라운드 로빈 모델을 사용하는 파티션으로 보내집니다.</span><span class="sxs-lookup"><span data-stu-id="70846-164">If high availability is most important, do not specify a partition key; in that case events will be sent to partitions using the round-robin model described previously.</span></span> <span data-ttu-id="70846-165">이 시나리오에서는 가용성(파티션 ID 없음)과 일관성(파티션 ID에 이벤트 고정) 간에 명시적인 선택을 합니다.</span><span class="sxs-lookup"><span data-stu-id="70846-165">In this scenario, you are making an explicit choice between availability (no partition ID) and consistency (pinning events to a partition ID).</span></span>

<span data-ttu-id="70846-166">이벤트 처리에서 지연을 처리하는 것도 고려해야 할 사항입니다.</span><span class="sxs-lookup"><span data-stu-id="70846-166">Another consideration is handling delays in processing events.</span></span> <span data-ttu-id="70846-167">경우에 따라, 잠재적으로 추가 다운스트림 처리 지연을 일으킬 수 있으므로 처리를 시도하여 계속 진행하는 것보다 데이터를 삭제한 다음 다시 시도하는 것 나을 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="70846-167">In some cases it might be better to drop data and retry than to try and keep up with processing, which can potentially cause further downstream processing delays.</span></span> <span data-ttu-id="70846-168">예를 들어 주식 시세 표시기 사용 시 완벽한 최신 데이터를 기다리는 것이 좋지만, 실시간 채팅 또는 VOIP 시나리오에서는 완벽하지는 않아도 데이터를 빨리 보유하는 것이 낫습니다.</span><span class="sxs-lookup"><span data-stu-id="70846-168">For example, with a stock ticker it's better to wait for complete up-to-date data, but in a live chat or VOIP scenario you'd rather have the data quickly, even if it isn't complete.</span></span>

<span data-ttu-id="70846-169">이러한 가용성을 고려해 볼 때 이러한 시나리오에서는 다음 오류 처리 전략 중 하나를 선택할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="70846-169">Given these availability considerations, in these scenarios you might choose one of the following error handling strategies:</span></span>

- <span data-ttu-id="70846-170">중지(문제가 해결될 때까지 Event Hubs에서 읽기 중지)</span><span class="sxs-lookup"><span data-stu-id="70846-170">Stop (stop reading from Event Hubs until things are fixed)</span></span>
- <span data-ttu-id="70846-171">삭제(메시지가 중요하지 않을 경우에는 삭제)</span><span class="sxs-lookup"><span data-stu-id="70846-171">Drop (messages aren’t important, drop them)</span></span>
- <span data-ttu-id="70846-172">다시 시도(적합하게 보이도록 메시지를 다시 시도)</span><span class="sxs-lookup"><span data-stu-id="70846-172">Retry (retry the messages as you see fit)</span></span>
- <span data-ttu-id="70846-173">[배달 못 한 편지](../service-bus-messaging/service-bus-dead-letter-queues.md)(처리할 수 없는 메시지만 배달 못 한 편지에 큐 또는 다른 이벤트 허브 사용)</span><span class="sxs-lookup"><span data-stu-id="70846-173">[Dead letter](../service-bus-messaging/service-bus-dead-letter-queues.md) (use a queue or another event hub to dead letter only the messages you couldn’t process)</span></span>

<span data-ttu-id="70846-174">가용성과 일관성 간의 절충에 대한 자세한 내용은 [Event Hubs의 가용성 및 일관성](event-hubs-availability-and-consistency.md)을 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="70846-174">For more information and a discussion about the trade-offs between availability and consistency, see [Availability and consistency in Event Hubs](event-hubs-availability-and-consistency.md).</span></span> 

## <a name="batch-event-send-operations"></a><span data-ttu-id="70846-175">배치 이벤트가 작업을 보냅니다</span><span class="sxs-lookup"><span data-stu-id="70846-175">Batch event send operations</span></span>
<span data-ttu-id="70846-176">배치에서 이벤트를 보내면 처리량을 크게 향상시킬 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="70846-176">Sending events in batches can dramatically increase throughput.</span></span> <span data-ttu-id="70846-177">[SendBatch](/dotnet/api/microsoft.servicebus.messaging.eventhubclient#Microsoft_ServiceBus_Messaging_EventHubClient_SendBatch_System_Collections_Generic_IEnumerable_Microsoft_ServiceBus_Messaging_EventData__) 메서드는 [EventData][] 형식의 **IEnumerable** 매개 변수를 사용하고 이벤트 허브에 원자성 작업으로 전체 배치를 보냅니다.</span><span class="sxs-lookup"><span data-stu-id="70846-177">The [SendBatch](/dotnet/api/microsoft.servicebus.messaging.eventhubclient#Microsoft_ServiceBus_Messaging_EventHubClient_SendBatch_System_Collections_Generic_IEnumerable_Microsoft_ServiceBus_Messaging_EventData__) method takes an **IEnumerable** parameter of type [EventData][] and sends the entire batch as an atomic operation to the event hub.</span></span>

```csharp
public void SendBatch(IEnumerable<EventData> eventDataList);
```

<span data-ttu-id="70846-178">단일 배치가 이벤트의 256KB 제한을 넘지 않아야 한다는 것에 유의해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="70846-178">Note that a single batch must not exceed the 256 KB limit of an event.</span></span> <span data-ttu-id="70846-179">또한 배치의 각 메시지는 동일한 게시자 id를 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="70846-179">Additionally, each message in the batch uses the same publisher identity.</span></span> <span data-ttu-id="70846-180">배치가 최대 이벤트 크기를 초과하지 않도록 확인하는 것은 보낸 사람의 책임입니다.</span><span class="sxs-lookup"><span data-stu-id="70846-180">It is the responsibility of the sender to ensure that the batch does not exceed the maximum event size.</span></span> <span data-ttu-id="70846-181">그런 경우 클라이언트 **보내기** 오류가 생성됩니다.</span><span class="sxs-lookup"><span data-stu-id="70846-181">If it does, a client **Send** error is generated.</span></span>

## <a name="send-asynchronously-and-send-at-scale"></a><span data-ttu-id="70846-182">비동기적으로 보내고 규모로 보내기</span><span class="sxs-lookup"><span data-stu-id="70846-182">Send asynchronously and send at scale</span></span>
<span data-ttu-id="70846-183">또한 비동기적으로 이벤트를 이벤트 허브로 보낼 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="70846-183">You can also send events to an event hub asynchronously.</span></span> <span data-ttu-id="70846-184">비동기적으로 보내기는 클라이언트가 이벤트를 보낼 수 있는 속도를 증가시킬 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="70846-184">Sending asynchronously can increase the rate at which a client is able to send events.</span></span> <span data-ttu-id="70846-185">[보내기](/dotnet/api/microsoft.servicebus.messaging.eventhubclient#Microsoft_ServiceBus_Messaging_EventHubClient_Send_Microsoft_ServiceBus_Messaging_EventData_) 및 [SendBatch](/dotnet/api/microsoft.servicebus.messaging.eventhubclient#Microsoft_ServiceBus_Messaging_EventHubClient_SendBatch_System_Collections_Generic_IEnumerable_Microsoft_ServiceBus_Messaging_EventData__) 메서드는 모두 [태스크](https://msdn.microsoft.com/library/system.threading.tasks.task.aspx) 개체를 반환하는 비동기 버전에서 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="70846-185">Both the [Send](/dotnet/api/microsoft.servicebus.messaging.eventhubclient#Microsoft_ServiceBus_Messaging_EventHubClient_Send_Microsoft_ServiceBus_Messaging_EventData_) and [SendBatch](/dotnet/api/microsoft.servicebus.messaging.eventhubclient#Microsoft_ServiceBus_Messaging_EventHubClient_SendBatch_System_Collections_Generic_IEnumerable_Microsoft_ServiceBus_Messaging_EventData__) methods are available in asynchronous versions that return a [Task](https://msdn.microsoft.com/library/system.threading.tasks.task.aspx) object.</span></span> <span data-ttu-id="70846-186">이 기술은 처리량을 늘릴 수 있는 반면 이벤트 허브 서비스에 의해 제한되는 동안 이벤트를 보내기 위해 클라이언트를 계속 발생시킬 수 있고 제대로 구현되지 않은 경우 클라이언트에 오류 또는 손실 메시지가 발생할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="70846-186">While this technique can increase throughput, it can also cause the client to continue to send events even while it is being throttled by the Event Hubs service and can result in the client experiencing failures or lost messages if not properly implemented.</span></span> <span data-ttu-id="70846-187">또한 클라이언트에서 [RetryPolicy](/dotnet/api/microsoft.servicebus.messaging.cliententity#Microsoft_ServiceBus_Messaging_ClientEntity_RetryPolicy) 속성을 사용하여 클라이언트 다시 시도 옵션을 제어할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="70846-187">In addition, you can use the [RetryPolicy](/dotnet/api/microsoft.servicebus.messaging.cliententity#Microsoft_ServiceBus_Messaging_ClientEntity_RetryPolicy) property on the client to control client retry options.</span></span>

## <a name="create-a-partition-sender"></a><span data-ttu-id="70846-188">파티션 발신자 만들기</span><span class="sxs-lookup"><span data-stu-id="70846-188">Create a partition sender</span></span>
<span data-ttu-id="70846-189">파티션 키 없이 이벤트 허브에 이벤트를 보내는 방법이 가장 일반적이지만 지정된 파티션에 직접 이벤트를 보낼 수 있는 경우도 있습니다.</span><span class="sxs-lookup"><span data-stu-id="70846-189">Although it is most common to send events to an event hub without a partition key, in some cases you might want to send events directly to a given partition.</span></span> <span data-ttu-id="70846-190">예:</span><span class="sxs-lookup"><span data-stu-id="70846-190">For example:</span></span>

```csharp
var partitionedSender = client.CreatePartitionedSender(description.PartitionIds[0]);
```

<span data-ttu-id="70846-191">[CreatePartitionedSender](/dotnet/api/microsoft.servicebus.messaging.eventhubclient#Microsoft_ServiceBus_Messaging_EventHubClient_CreatePartitionedSender_System_String_)는 특정 Event Hub 파티션에 이벤트를 게시하는데 사용할 수 있는 [EventHubSender](/dotnet/api/microsoft.servicebus.messaging.eventhubsender) 개체를 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="70846-191">[CreatePartitionedSender](/dotnet/api/microsoft.servicebus.messaging.eventhubclient#Microsoft_ServiceBus_Messaging_EventHubClient_CreatePartitionedSender_System_String_) returns an [EventHubSender](/dotnet/api/microsoft.servicebus.messaging.eventhubsender) object that you can use to publish events to a specific event hub partition.</span></span>

## <a name="event-consumers"></a><span data-ttu-id="70846-192">이벤트 소비자</span><span class="sxs-lookup"><span data-stu-id="70846-192">Event consumers</span></span>
<span data-ttu-id="70846-193">Event Hubs에는 이벤트 사용에 대한 두 기본 모델인 직접 수신기 및 [EventProcessorHost][]와 같은 상위 수준의 추상화가 있습니다.</span><span class="sxs-lookup"><span data-stu-id="70846-193">Event Hubs has two primary models for event consumption: direct receivers and higher-level abstractions, such as [EventProcessorHost][].</span></span> <span data-ttu-id="70846-194">직접 수신기는 소비자 그룹 내의 파티션에 액세스를 자체 조정을 담당합니다.</span><span class="sxs-lookup"><span data-stu-id="70846-194">Direct receivers are responsible for their own coordination of access to partitions within a consumer group.</span></span>

### <a name="direct-consumer"></a><span data-ttu-id="70846-195">직접 소비자</span><span class="sxs-lookup"><span data-stu-id="70846-195">Direct consumer</span></span>
<span data-ttu-id="70846-196">소비자 그룹 내의 파티션에서 읽을 수 있는 가장 직접적인 방법은 [EventHubReceiver](/dotnet/apie/microsoft.servicebus.messaging.eventhubreceiver) 클래스를 사용하는 것입니다.</span><span class="sxs-lookup"><span data-stu-id="70846-196">The most direct way to read from a partition within a consumer group is to use the [EventHubReceiver](/dotnet/apie/microsoft.servicebus.messaging.eventhubreceiver) class.</span></span> <span data-ttu-id="70846-197">이 클래스의 인스턴스를 만들려면 [EventHubConsumerGroup](/dotnet/api/microsoft.servicebus.messaging.eventhubconsumergroup) 클래스의 인스턴스를 사용해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="70846-197">To create an instance of this class, you must use an instance of the [EventHubConsumerGroup](/dotnet/api/microsoft.servicebus.messaging.eventhubconsumergroup) class.</span></span> <span data-ttu-id="70846-198">다음 예제에서 소비자 그룹에 대한 수신기를 만들 때 파티션 ID를 지정해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="70846-198">In the following example, the partition ID must be specified when creating the receiver for the consumer group.</span></span>

```csharp
EventHubConsumerGroup group = client.GetDefaultConsumerGroup();
var receiver = group.CreateReceiver(client.GetRuntimeInformation().PartitionIds[0]);
```

<span data-ttu-id="70846-199">[CreateReceiver](/dotnet/api/microsoft.servicebus.messaging.eventhubconsumergroup#methods_summary) 메서드에는 생성되는 판독기에 대한 제어를 용이하게 하는 몇가지 오버로드가 있습니다.</span><span class="sxs-lookup"><span data-stu-id="70846-199">The [CreateReceiver](/dotnet/api/microsoft.servicebus.messaging.eventhubconsumergroup#methods_summary) method has several overloads that facilitate control over the reader being created.</span></span> <span data-ttu-id="70846-200">이러한 메서드는 오프셋을 문자열 또는 타임 스탬프로 지정하는 것을 포함하거나 반환된 스트림에서 지정된 오프셋을 포함할지 아니면 이후 시작할지를 지정하는 기능을 포함합니다.</span><span class="sxs-lookup"><span data-stu-id="70846-200">These methods include specifying an offset as either a string or timestamp, and the ability to specify whether to include this specified offset in the returned stream, or start after it.</span></span> <span data-ttu-id="70846-201">수신기를 만든 후 반환된 개체에 대한 이벤트 수신을 시작할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="70846-201">After you create the receiver, you can start receiving events on the returned object.</span></span> <span data-ttu-id="70846-202">[수신](/dotnet/api/microsoft.servicebus.messaging.eventhubreceiver#methods_summary) 메서드는 배치 크기 및 대기 시간과 같은 수신 작업 매개 변수를 제어하는 4개의 오버로드가 있습니다.</span><span class="sxs-lookup"><span data-stu-id="70846-202">The [Receive](/dotnet/api/microsoft.servicebus.messaging.eventhubreceiver#methods_summary) method has four overloads that control the receive operation parameters, such as batch size and wait time.</span></span> <span data-ttu-id="70846-203">이러한 메서드의 비동기 버전을 사용하여 소비자의 처리량을 증가시킬 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="70846-203">You can use the asynchronous versions of these methods to increase the throughput of a consumer.</span></span> <span data-ttu-id="70846-204">예:</span><span class="sxs-lookup"><span data-stu-id="70846-204">For example:</span></span>

```csharp
bool receive = true;
string myOffset;
while(receive)
{
    var message = receiver.Receive();
    myOffset = message.Offset;
    string body = Encoding.UTF8.GetString(message.GetBytes());
    Console.WriteLine(String.Format("Received message offset: {0} \nbody: {1}", myOffset, body));
}
```

<span data-ttu-id="70846-205">특정 파티션과 관련하여 메시지가 이벤트 허브로 전송된 순서로 메시지를 수신합니다.</span><span class="sxs-lookup"><span data-stu-id="70846-205">With respect to a specific partition, the messages are received in the order in which they were sent to the event hub.</span></span> <span data-ttu-id="70846-206">오프셋은 파티션에서 메시지를 식별하는 데 사용되는 문자열 토큰입니다.</span><span class="sxs-lookup"><span data-stu-id="70846-206">The offset is a string token used to identify a message in a partition.</span></span>

<span data-ttu-id="70846-207">소비자 그룹 내에서 단일 파티션은 언제든지 연결되는 5개의 동시 판독기를 가질 수 없다는 점에 유의해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="70846-207">Note that a single partition within a consumer group cannot have more than 5 concurrent readers connected at any time.</span></span> <span data-ttu-id="70846-208">판독기를 연결하거나 연결이 끊기면 서비스 연결이 끊어져 있는지 인식하기 전에 몇 분간 해당 세션이 활성 상태로 유지될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="70846-208">As readers connect or become disconnected, their sessions might stay active for several minutes before the service recognizes that they have disconnected.</span></span> <span data-ttu-id="70846-209">이 시간 동안 파티션에 다시 연결이 실패할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="70846-209">During this time, reconnecting to a partition may fail.</span></span> <span data-ttu-id="70846-210">Event Hubs용 직접 수신기 작성의 전체 예제는 [Event Hubs 직접 수신기](https://code.msdn.microsoft.com/Event-Hub-Direct-Receivers-13fa95c6) 샘플을 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="70846-210">For a complete example of writing a direct receiver for Event Hubs, see the [Event Hubs Direct Receivers](https://code.msdn.microsoft.com/Event-Hub-Direct-Receivers-13fa95c6) sample.</span></span>

### <a name="event-processor-host"></a><span data-ttu-id="70846-211">이벤트 프로세서 호스트</span><span class="sxs-lookup"><span data-stu-id="70846-211">Event processor host</span></span>
<span data-ttu-id="70846-212">[EventProcessorHost][] 클래스는 이벤트 허브에서 데이터를 처리합니다.</span><span class="sxs-lookup"><span data-stu-id="70846-212">The [EventProcessorHost][] class processes data from Event Hubs.</span></span> <span data-ttu-id="70846-213">.NET 플랫폼에서 이벤트 판독기를 작성할 때 이 구현을 사용해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="70846-213">You should use this implementation when building event readers on the .NET platform.</span></span> <span data-ttu-id="70846-214">[EventProcessorHost][] 는 검사점 및 파티션 임대 관리를 제공하는 이벤트 처리기 구현에 대한 스레드 안전, 다중 프로세스, 안전한 런타임 환경을 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="70846-214">[EventProcessorHost][] provides a thread-safe, multi-process, safe runtime environment for event processor implementations that also provides checkpointing and partition lease management.</span></span>

<span data-ttu-id="70846-215">[EventProcessorHost][] 클래스를 사용하려면 [IEventProcessor](/dotnet/api/microsoft.servicebus.messaging.ieventprocessor)를 구현할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="70846-215">To use the [EventProcessorHost][] class, you can implement [IEventProcessor](/dotnet/api/microsoft.servicebus.messaging.ieventprocessor).</span></span> <span data-ttu-id="70846-216">이 인터페이스는 세 가지 메서드가 포함합니다.</span><span class="sxs-lookup"><span data-stu-id="70846-216">This interface contains three methods:</span></span>

* [<span data-ttu-id="70846-217">OpenAsync</span><span class="sxs-lookup"><span data-stu-id="70846-217">OpenAsync</span></span>](/dotnet/api/microsoft.servicebus.messaging.ieventprocessor#Microsoft_ServiceBus_Messaging_IEventProcessor_OpenAsync_Microsoft_ServiceBus_Messaging_PartitionContext_)
* [<span data-ttu-id="70846-218">CloseAsync</span><span class="sxs-lookup"><span data-stu-id="70846-218">CloseAsync</span></span>](/dotnet/api/microsoft.servicebus.messaging.ieventprocessor#Microsoft_ServiceBus_Messaging_IEventProcessor_CloseAsync_Microsoft_ServiceBus_Messaging_PartitionContext_Microsoft_ServiceBus_Messaging_CloseReason_)
* [<span data-ttu-id="70846-219">ProcessEventsAsync</span><span class="sxs-lookup"><span data-stu-id="70846-219">ProcessEventsAsync</span></span>](/dotnet/api/microsoft.servicebus.messaging.ieventprocessor#Microsoft_ServiceBus_Messaging_IEventProcessor_ProcessEventsAsync_Microsoft_ServiceBus_Messaging_PartitionContext_System_Collections_Generic_IEnumerable_Microsoft_ServiceBus_Messaging_EventData__)

<span data-ttu-id="70846-220">이벤트 처리를 시작하려면 이벤트 허브에 대한 적절한 매개 변수를 제공하여 [EventProcessorHost][]를 인스턴스화합니다.</span><span class="sxs-lookup"><span data-stu-id="70846-220">To start event processing, instantiate [EventProcessorHost][], providing the appropriate parameters for your event hub.</span></span> <span data-ttu-id="70846-221">그런 다음 [RegisterEventProcessorAsync](/dotnet/api/microsoft.servicebus.messaging.eventprocessorhost#Microsoft_ServiceBus_Messaging_EventProcessorHost_RegisterEventProcessorAsync__1)을 호출하여 런타임에 [IEventProcessor](/dotnet/api/microsoft.servicebus.messaging.ieventprocessor) 구현을 등록합니다.</span><span class="sxs-lookup"><span data-stu-id="70846-221">Then, call [RegisterEventProcessorAsync](/dotnet/api/microsoft.servicebus.messaging.eventprocessorhost#Microsoft_ServiceBus_Messaging_EventProcessorHost_RegisterEventProcessorAsync__1) to register your [IEventProcessor](/dotnet/api/microsoft.servicebus.messaging.ieventprocessor) implementation with the runtime.</span></span> <span data-ttu-id="70846-222">이 시점에서 호스트는 "greedy" 알고리즘을 사용하여 허브 이벤트의 모든 파티션에서 임대를 획득하려 합니다.</span><span class="sxs-lookup"><span data-stu-id="70846-222">At this point, the host will attempt to acquire a lease on every partition in the event hub using a "greedy" algorithm.</span></span> <span data-ttu-id="70846-223">이러한 임대는 지정된 시간 프레임 동안 지속되며 갱신되어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="70846-223">These leases will last for a given timeframe and must then be renewed.</span></span> <span data-ttu-id="70846-224">새 노드(이 경우 작업자 인스턴스)가 온라인 상태가 되면 임대 예약을 놓고 더 많은 임대를 획득하기 위해 시간이 지남에 따라 노드 간에 부하가 이동합니다.</span><span class="sxs-lookup"><span data-stu-id="70846-224">As new nodes, worker instances in this case, come online, they place lease reservations and over time the load shifts between nodes as each attempts to acquire more leases.</span></span>

![이벤트 프로세서 호스트](./media/event-hubs-programming-guide/IC759863.png)

<span data-ttu-id="70846-226">시간이 지남에 따라 평형이 설정됩니다.</span><span class="sxs-lookup"><span data-stu-id="70846-226">Over time, an equilibrium is established.</span></span> <span data-ttu-id="70846-227">이 동적 기능을 사용하면 확장 및 축소 모두에 대해 소비자에게 적용할 CPU 기반 자동 크기 조정을 할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="70846-227">This dynamic capability enables CPU-based autoscaling to be applied to consumers for both scale-up and scale-down.</span></span> <span data-ttu-id="70846-228">이벤트 허브에 메시지 개수의 직접 개념이 없기 때문에 평균 CPU 사용률은 백 엔드 또는 소비자 규모를 측정하는 최적의 메커니즘인 경우가 많습니다.</span><span class="sxs-lookup"><span data-stu-id="70846-228">Because Event Hubs do not have a direct concept of message counts, average CPU utilization is often the best mechanism to measure back end or consumer scale.</span></span> <span data-ttu-id="70846-229">소비자가 처리할 수 있는 것 보다 더 많은 이벤트를 게시자가 게시하기 시작하는 경우 소비자에게 CPU 증가를 사용하여 작업자 인스턴스 수의 크기를 자동으로 조정할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="70846-229">If publishers begin to publish more events than consumers can process, the CPU increase on consumers can be used to cause an auto-scale on worker instance count.</span></span>

<span data-ttu-id="70846-230">또한 [EventProcessorHost][] 클래스는 Azure 저장소 기반 검사점 메커니즘을 구현합니다.</span><span class="sxs-lookup"><span data-stu-id="70846-230">The [EventProcessorHost][] class also implements an Azure storage-based checkpointing mechanism.</span></span> <span data-ttu-id="70846-231">이 메커니즘은 파티션 당 오프셋을 저장하므로 각 소비자가 이전 소비자의 마지막 검사점 무엇인지를 결정할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="70846-231">This mechanism stores the offset on a per partition basis, so that each consumer can determine what the last checkpoint from the previous consumer was.</span></span> <span data-ttu-id="70846-232">임대를 통해 노드 간에 파티션이 전환되면 이동하는 부하를 용이하게 하는 동기화 메커니즘입니다.</span><span class="sxs-lookup"><span data-stu-id="70846-232">As partitions transition between nodes via leases, this is the synchronization mechanism that facilitates load shifting.</span></span>

## <a name="publisher-revocation"></a><span data-ttu-id="70846-233">게시자 해지</span><span class="sxs-lookup"><span data-stu-id="70846-233">Publisher revocation</span></span>
<span data-ttu-id="70846-234">[EventProcessorHost][]의 고급 런타임 기능 외에도 이벤트 허브는 이벤트 허브로 이벤트를 보내는 특정 게시자를 차단하기 위해 게시자를 해지할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="70846-234">In addition to the advanced run-time features of [EventProcessorHost][], Event Hubs enables publisher revocation in order to block specific publishers from sending event to an event hub.</span></span> <span data-ttu-id="70846-235">이러한 기능은 게시자의 토큰이 손상되거나 소프트웨어 업데이트가 부적절하게 동작을 일으킨 경우 특히 유용합니다.</span><span class="sxs-lookup"><span data-stu-id="70846-235">These features are particularly useful if a publisher token has been compromised, or a software update is causing them to behave inappropriately.</span></span> <span data-ttu-id="70846-236">이러한 상황에서 해당 SAS 토큰의 일부인 게시자의 id가 이벤트 게시에서 차단될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="70846-236">In these situations, the publisher's identity, which is part of their SAS token, can be blocked from publishing events.</span></span>

<span data-ttu-id="70846-237">게시자 해지 및 게시자로 Event Hubs에 보내는 방법에 대한 자세한 내용은 [Event Hubs 대규모 보안 게시](https://code.msdn.microsoft.com/Service-Bus-Event-Hub-99ce67ab) 샘플을 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="70846-237">For more information about publisher revocation and how to send to Event Hubs as a publisher, see the [Event Hubs Large Scale Secure Publishing](https://code.msdn.microsoft.com/Service-Bus-Event-Hub-99ce67ab) sample.</span></span>

## <a name="next-steps"></a><span data-ttu-id="70846-238">다음 단계</span><span class="sxs-lookup"><span data-stu-id="70846-238">Next steps</span></span>
<span data-ttu-id="70846-239">이벤트 허브 시나리오에 대한 자세한 내용은 다음 링크를 방문하십시오.</span><span class="sxs-lookup"><span data-stu-id="70846-239">To learn more about Event Hubs scenarios, visit these links:</span></span>

* [<span data-ttu-id="70846-240">이벤트 허브 API 개요</span><span class="sxs-lookup"><span data-stu-id="70846-240">Event Hubs API overview</span></span>](event-hubs-api-overview.md)
* [<span data-ttu-id="70846-241">Event Hubs의 정의</span><span class="sxs-lookup"><span data-stu-id="70846-241">What is Event Hubs</span></span>](event-hubs-what-is-event-hubs.md)
* [<span data-ttu-id="70846-242">Event Hubs의 가용성 및 일관성</span><span class="sxs-lookup"><span data-stu-id="70846-242">Availability and consistency in Event Hubs</span></span>](event-hubs-availability-and-consistency.md)
* [<span data-ttu-id="70846-243">이벤트 프로세서 호스트 API 참조</span><span class="sxs-lookup"><span data-stu-id="70846-243">Event processor host API reference</span></span>](/dotnet/api/microsoft.servicebus.messaging.eventprocessorhost)

<span data-ttu-id="70846-244">[NamespaceManager]: /dotnet/api/microsoft.servicebus.namespacemanager</span><span class="sxs-lookup"><span data-stu-id="70846-244">[NamespaceManager]: /dotnet/api/microsoft.servicebus.namespacemanager</span></span>
<span data-ttu-id="70846-245">[EventHubClient]: /dotnet/api/microsoft.servicebus.messaging.eventhubclient</span><span class="sxs-lookup"><span data-stu-id="70846-245">[EventHubClient]: /dotnet/api/microsoft.servicebus.messaging.eventhubclient</span></span>
<span data-ttu-id="70846-246">[EventData]: /dotnet/api/microsoft.servicebus.messaging.eventdata</span><span class="sxs-lookup"><span data-stu-id="70846-246">[EventData]: /dotnet/api/microsoft.servicebus.messaging.eventdata</span></span>
<span data-ttu-id="70846-247">[CreateEventHubIfNotExists]: /dotnet/api/microsoft.servicebus.namespacemanager.createeventhubifnotexists</span><span class="sxs-lookup"><span data-stu-id="70846-247">[CreateEventHubIfNotExists]: /dotnet/api/microsoft.servicebus.namespacemanager.createeventhubifnotexists</span></span>
<span data-ttu-id="70846-248">[PartitionKey]: /dotnet/api/microsoft.servicebus.messaging.eventdata#Microsoft_ServiceBus_Messaging_EventData_PartitionKey</span><span class="sxs-lookup"><span data-stu-id="70846-248">[PartitionKey]: /dotnet/api/microsoft.servicebus.messaging.eventdata#Microsoft_ServiceBus_Messaging_EventData_PartitionKey</span></span>
<span data-ttu-id="70846-249">[EventProcessorHost]: /dotnet/api/microsoft.servicebus.messaging.eventprocessorhost</span><span class="sxs-lookup"><span data-stu-id="70846-249">[EventProcessorHost]: /dotnet/api/microsoft.servicebus.messaging.eventprocessorhost</span></span>
