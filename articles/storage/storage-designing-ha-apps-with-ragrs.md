---
title: "Azure RA-GRS(읽기 액세스 지역 중복 저장소)를 사용하여 항상 사용 가능한 응용 프로그램 설계 | Microsoft Docs"
description: "Azure RA-GRS 저장소를 사용하여 가동 중단을 처리할 만큼 유연하면서 항상 사용 가능한 응용 프로그램을 설계하는 방법입니다."
services: storage
documentationcenter: .net
author: robinsh
manager: timlt
editor: tysonn
ms.assetid: 8f040b0f-8926-4831-ac07-79f646f31926
ms.service: storage
ms.workload: storage
ms.tgt_pltfrm: na
ms.devlang: dotnet
ms.topic: article
ms.date: 1/19/2017
ms.author: robinsh
ms.openlocfilehash: adc7e23d8c9f869f2951490020e3d0f1a2b2e81c
ms.sourcegitcommit: 02e69c4a9d17645633357fe3d46677c2ff22c85a
ms.translationtype: MT
ms.contentlocale: ko-KR
ms.lasthandoff: 08/03/2017
---
# <a name="designing-highly-available-applications-using-ra-grs"></a><span data-ttu-id="62bb4-103">RA-GRS를 사용하여 항상 사용 가능한 응용 프로그램 설계</span><span class="sxs-lookup"><span data-stu-id="62bb4-103">Designing Highly Available Applications using RA-GRS</span></span>

<span data-ttu-id="62bb4-104">클라우드 기반 인프라의 일반적인 기능은 응용 프로그램 호스팅을 위해 항상 사용할 수 있는 플랫폼을 제공하는 것입니다.</span><span class="sxs-lookup"><span data-stu-id="62bb4-104">A common feature of cloud-based infrastructures is that they provide a highly available platform for hosting applications.</span></span> <span data-ttu-id="62bb4-105">클라우드 기반 응용 프로그램 개발자는 사용자에게 항상 사용 가능한 응용 프로그램을 제공하기 위해 이러한 플랫폼을 활용할 방법을 신중하게 고려해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="62bb4-105">Developers of cloud-based applications must consider carefully how to leverage this platform to deliver highly available applications to their users.</span></span> <span data-ttu-id="62bb4-106">이 문서는 개발자가 Azure Storage RA-GRS(읽기 액세스 지역 중복 저장소)를 사용하여 응용 프로그램의 사용 가능성을 높이는 방법에 특히 중점을 두고 있습니다.</span><span class="sxs-lookup"><span data-stu-id="62bb4-106">This article focuses specifically on how developers can use the Azure Storage Read Access Geo Redundant Storage (RA-GRS) to make their applications more available.</span></span>

<span data-ttu-id="62bb4-107">중복 옵션에는 LRS(로컬 중복 저장소), ZRS(영역 중복 저장소), GRS(지역 중복 저장소) 및 RA-GRS(읽기 액세스 지역 중복 저장소)라는 네 가지 옵션이 있습니다.</span><span class="sxs-lookup"><span data-stu-id="62bb4-107">There are four choices for redundancy – LRS (Locally Redundant Storage), ZRS (Zone Redundant Storage), GRS (Geo-Redundant Storage), and RA-GRS (Read Access Geo-Redundant Storage).</span></span> <span data-ttu-id="62bb4-108">이 문서에서는 GRS와 RA-GRS를 설명하겠습니다.</span><span class="sxs-lookup"><span data-stu-id="62bb4-108">We are going to discuss GRS and RA-GRS in this article.</span></span> <span data-ttu-id="62bb4-109">GRS를 사용하면 세 개의 데이터 복사본이 저장소 계정을 설정할 때 선택된 주 지역에 유지됩니다.</span><span class="sxs-lookup"><span data-stu-id="62bb4-109">With GRS, three copies of your data are kept in the primary region you selected when setting up the storage account.</span></span> <span data-ttu-id="62bb4-110">세 개의 추가 복사본은 Azure에서 지정된 보조 지역에 비동기적으로 유지됩니다.</span><span class="sxs-lookup"><span data-stu-id="62bb4-110">Three additional copies are maintained asynchronously in a secondary region specified by Azure.</span></span> <span data-ttu-id="62bb4-111">RA-GRS는 보조 복사본에 대해 읽기 액세스를 갖는다는 점을 제외하면 GRS와 동일합니다.</span><span class="sxs-lookup"><span data-stu-id="62bb4-111">RA-GRS is the same thing as GRS except that you have read access to the secondary copy.</span></span> <span data-ttu-id="62bb4-112">다양한 Azure Storage 중복 옵션에 대한 자세한 내용은 [Azure Storage 복제](https://docs.microsoft.com/en-us/azure/storage/storage-redundancy)를 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="62bb4-112">For more information about the different Azure Storage redundancy options, see [Azure Storage replication](https://docs.microsoft.com/en-us/azure/storage/storage-redundancy).</span></span> <span data-ttu-id="62bb4-113">복제 문서는 주 지역과 보조 지역의 페어링도 보여줍니다.</span><span class="sxs-lookup"><span data-stu-id="62bb4-113">The replication article also shows the pairings of the primary and secondary regions.</span></span>

<span data-ttu-id="62bb4-114">이 문서에는 코드 조각이 포함되어 있고 끝 부분에는 다운로드하여 실행할 수 있는 전체 샘플에 대한 링크가 있습니다.</span><span class="sxs-lookup"><span data-stu-id="62bb4-114">There are code snippets included in this article, and a link to a complete sample at the end that you can download and run.</span></span>

## <a name="key-features-of-ra-grs"></a><span data-ttu-id="62bb4-115">RA-GRS의 주요 기능</span><span class="sxs-lookup"><span data-stu-id="62bb4-115">Key features of RA-GRS</span></span>

<span data-ttu-id="62bb4-116">RA-GRS 저장소 사용법에 대해 언급하기 전에 속성과 동작에 대해 살펴보겠습니다.</span><span class="sxs-lookup"><span data-stu-id="62bb4-116">Before we talk about how to use RA-GRS storage, let's talk about its properties and behavior.</span></span>

* <span data-ttu-id="62bb4-117">Azure Storage는 보조 지역, 주 지역에 저장된 데이터의 읽기 전용 복사본을 유지하며 위에 언급했듯이 저장소 서비스는 보조 지역의 위치를 결정합니다.</span><span class="sxs-lookup"><span data-stu-id="62bb4-117">Azure Storage maintains a read-only copy of the data you store in your primary region in a secondary region; as noted above, the storage service determines the location of the secondary region.</span></span>

* <span data-ttu-id="62bb4-118">읽기 전용 복사본은 주 지역의 데이터와 [결과적으로 일치](https://en.wikipedia.org/wiki/Eventual_consistency)합니다.</span><span class="sxs-lookup"><span data-stu-id="62bb4-118">The read-only copy is [eventually consistent](https://en.wikipedia.org/wiki/Eventual_consistency) with the data in the primary region.</span></span>

* <span data-ttu-id="62bb4-119">Blob, 테이블 및 큐에 대해 주 지역에서 보조 지역으로 마지막 복제가 발생한 시간을 알려주는 *Last Sync Time* 값을 보조 지역에 쿼리할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="62bb4-119">For blobs, tables, and queues, you can query the secondary region for a *Last Sync Time* value that tells you when the last replication from the primary to the secondary region occurred.</span></span> <span data-ttu-id="62bb4-120">(현재 RA-GRS 중복 옵션이 없는 Azure File Storage에 대해서는 지원되지 않습니다.)</span><span class="sxs-lookup"><span data-stu-id="62bb4-120">(This is not supported for Azure File storage, which doesn't have RA-GRS redundancy at this time.)</span></span>

* <span data-ttu-id="62bb4-121">저장소 클라이언트 라이브러리를 사용하여 주 지역 또는 보조 지역의 데이터와 상호 작용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="62bb4-121">You can use the Storage Client Library to interact with the data in either the primary or secondary region.</span></span> <span data-ttu-id="62bb4-122">주 지역에 대한 읽기 요청의 시간이 초과되면 읽기 요청을 보조 지역에 자동으로 리디렉션할 수도 있습니다.</span><span class="sxs-lookup"><span data-stu-id="62bb4-122">You can also redirect read requests automatically to the secondary region if a read request to the primary region times out.</span></span>

* <span data-ttu-id="62bb4-123">주 지역의 데이터에 대한 접근성에 영향을 미치는 주요한 문제가 있으면 Azure 팀에서 지역 장애 조치(failover)를 트리거할 수 있고, 그러면 주 지역을 가리키는 DNS 항목이 보조 지역을 가리키도록 변경됩니다.</span><span class="sxs-lookup"><span data-stu-id="62bb4-123">If there is a major issue affecting the accessibility of the data in the primary region, the Azure team may trigger a geo-failover, at which point the DNS entries pointing to the primary region will be changed to point to the secondary region.</span></span>

* <span data-ttu-id="62bb4-124">지역 장애 조치(failover)가 발생하면 Azure는 새로운 보조 지역을 선택하고 그 위치에 데이터를 복제한 다음 보조 DNS 항목으로 그 위치를 가리킵니다.</span><span class="sxs-lookup"><span data-stu-id="62bb4-124">If a geo-failover occurs, Azure will select a new secondary location and replicate the data to that location, then point the secondary DNS entries to it.</span></span> <span data-ttu-id="62bb4-125">저장소 계정이 복제를 마칠 때까지 보조 끝점을 사용할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="62bb4-125">The secondary endpoint will be unavailable until the storage account has finished replicating.</span></span> <span data-ttu-id="62bb4-126">자세한 내용은 [Azure Storage 중단이 발생할 경우 수행할 작업](https://docs.microsoft.com/en-us/azure/storage/storage-disaster-recovery-guidance)을 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="62bb4-126">For more information, please see [What to do if an Azure Storage outage occurs](https://docs.microsoft.com/en-us/azure/storage/storage-disaster-recovery-guidance).</span></span>

## <a name="application-design-considerations-when-using-ra-grs"></a><span data-ttu-id="62bb4-127">RA-GRS를 사용하는 경우 응용 프로그램 설계 고려 사항</span><span class="sxs-lookup"><span data-stu-id="62bb4-127">Application design considerations when using RA-GRS</span></span>

<span data-ttu-id="62bb4-128">이 문서의 주된 목적은 기본 데이터 센터에 대규모 재난이 발생하더라도 작동을 계속할 수 있는(제한된 용량이라도) 응용 프로그램을 설계하는 방법을 보여주는 것입니다.</span><span class="sxs-lookup"><span data-stu-id="62bb4-128">The main purpose of this article is to show you how to design an application that will continue to function (albeit in a limited capacity) even in the event of a major disaster at the primary data center.</span></span> <span data-ttu-id="62bb4-129">이러한 작업은 문제가 있는 동안은 응용 프로그램이 보조 지역에서 읽기로 전환하여 일시적인 또는 장기적인 문제를 처리하고 주 지역을 다시 사용할 수 있게 되면 원래대로 다시 전환하는 방식으로 수행합니다.</span><span class="sxs-lookup"><span data-stu-id="62bb4-129">You do this by having your application to handle transient or long-running issues by switching to read from the secondary region while there is a problem, and switching back when the primary region is available again.</span></span>

### <a name="using-eventually-consistent-data"></a><span data-ttu-id="62bb4-130">결과적으로 일치하는 데이터 사용</span><span class="sxs-lookup"><span data-stu-id="62bb4-130">Using eventually consistent data</span></span>

<span data-ttu-id="62bb4-131">이 제안 솔루션에서는 부실할 가능성이 있는 데이터를 호출하는 응용 프로그램에 반환하는 것이 괜찮다고 가정합니다.</span><span class="sxs-lookup"><span data-stu-id="62bb4-131">This proposed solution assumes that it is okay to return what could be stale data to the calling application.</span></span> <span data-ttu-id="62bb4-132">보조 데이터는 결과적으로 일치하기 때문에 데이터가 주 지역에 기록되었더라도 주 지역에 액세스할 수 없게 되면 보조 지역에 대한 업데이트가 복제를 마치지 못할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="62bb4-132">Because the secondary data is eventually consistent, it is possible that the data was written to the primary but the update to the secondary had not finished replicating when the primary region became inaccessible.</span></span>

<span data-ttu-id="62bb4-133">예를 들어 고객이 업데이트를 제출하여 완료된 후 보조 데이터에 업데이트가 전파되기 전에 주 데이터가 다운될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="62bb4-133">For example, your customer could submit an update that is successful, and then the primary could go down before the update is propagated to the secondary.</span></span> <span data-ttu-id="62bb4-134">이런 경우 고객이 데이터를 다시 읽어오도록 요청하면 업데이트된 데이터 대신 부실 데이터를 수신합니다.</span><span class="sxs-lookup"><span data-stu-id="62bb4-134">In this case, if the customer then asks to read the data back, he receives the stale data instead of the updated data.</span></span> <span data-ttu-id="62bb4-135">이런 경우를 허용할지 결정하고, 허용한다면 고객에게 어떤 메시지를 표시할지 결정해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="62bb4-135">You must decide if this is acceptable, and if so, how you will message the customer.</span></span> <span data-ttu-id="62bb4-136">보조 데이터가 최신인지 확인하기 위해 이 문서의 뒷부분에서 보조 데이터의 마지막 동기화 시간을 확인하는 방법을 볼 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="62bb4-136">You'll see how to check the Last Sync Time on the secondary data later in this article to see if the secondary is up-to-date.</span></span>

### <a name="handling-services-separately-or-all-together"></a><span data-ttu-id="62bb4-137">서비스를 개별적으로 또는 모두 함께 처리</span><span class="sxs-lookup"><span data-stu-id="62bb4-137">Handling services separately or all together</span></span>

<span data-ttu-id="62bb4-138">흔하지는 않지만 한 가지 서비스를 사용할 수 없게 되더라도 다른 서비스는 완벽하게 작동하는 경우가 있을 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="62bb4-138">While not likely, it is possible for one service to become unavailable while the other services are still fully functional.</span></span> <span data-ttu-id="62bb4-139">각 서비스의 다시 시도 및 읽기 전용 모드를 개별적으로 처리하거나(Blob, 큐, 테이블) 모든 저장소 서비스의 다시 시도를 포괄적으로 함께 처리할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="62bb4-139">You can handle the retries and read-only mode for each service separately (blobs, queues, tables), or you can handle retries generically for all the storage services together.</span></span>

<span data-ttu-id="62bb4-140">예를 들어 응용 프로그램에 큐와 Blob을 사용하는 경우 각각에 대해 다시 시도 가능한 오류를 처리하기 위해 별도의 코드를 배치하도록 결정할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="62bb4-140">For example, if you use queues and blobs in your application, you may decide to put in separate code to handle retryable errors for each of these.</span></span> <span data-ttu-id="62bb4-141">그런 다음 Blob service에서 다시 시도를 가져올 경우 큐 서비스가 여전히 작동하면 Blob을 처리하는 응용 프로그램의 일부만 영향을 받습니다.</span><span class="sxs-lookup"><span data-stu-id="62bb4-141">Then if you get a retry from the blob service, but the queue service is still working, only the part of your application that handles blobs will be impacted.</span></span> <span data-ttu-id="62bb4-142">모든 저장소 서비스 다시 시도를 포괄적으로 처리하기로 결정하고 Blob service에 대한 호출이 다시 시도 가능한 오류를 반환하면 Blob service와 큐 서비스에 대한 요청이 모두 영향을 받습니다.</span><span class="sxs-lookup"><span data-stu-id="62bb4-142">If you decide to handle all storage service retries generically and a call to the blob service returns a retryable error, then requests to both the blob service and the queue service will be impacted.</span></span>

<span data-ttu-id="62bb4-143">궁극적으로 이것은 응용 프로그램의 복잡성에 달려 있습니다.</span><span class="sxs-lookup"><span data-stu-id="62bb4-143">Ultimately, this depends on the complexity of your application.</span></span> <span data-ttu-id="62bb4-144">주 지역의 저장소 서비스에서 문제를 감지하면 실패를 서비스별로 처리하는 대신 모든 저장소 서비스에 대한 읽기 요청을 보조 지역으로 리디렉션하고 읽기 전용 모드에서 응용 프로그램을 실행하도록 결정할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="62bb4-144">You may decide not to handle the failures by service, but instead to redirect read requests for all storage services to the secondary region and run the application in read-only mode when you detect a problem with any storage service in the primary region.</span></span>

### <a name="other-considerations"></a><span data-ttu-id="62bb4-145">기타 고려 사항</span><span class="sxs-lookup"><span data-stu-id="62bb4-145">Other considerations</span></span>

<span data-ttu-id="62bb4-146">다음은 이 문서의 나머지 부분에서 논의할 기타 고려 사항입니다.</span><span class="sxs-lookup"><span data-stu-id="62bb4-146">These are the other considerations we will discuss in the rest of this article.</span></span>

*   <span data-ttu-id="62bb4-147">회로 차단기 패턴을 사용한 읽기 요청의 다시 시도 처리</span><span class="sxs-lookup"><span data-stu-id="62bb4-147">Handling retries of read requests using the Circuit Breaker pattern</span></span>

*   <span data-ttu-id="62bb4-148">결과적으로 일치하는 데이터 및 마지막 동기화 시간</span><span class="sxs-lookup"><span data-stu-id="62bb4-148">Eventually-consistent data and the Last Sync Time</span></span>

*   <span data-ttu-id="62bb4-149">테스트</span><span class="sxs-lookup"><span data-stu-id="62bb4-149">Testing</span></span>

## <a name="running-your-application-in-read-only-mode"></a><span data-ttu-id="62bb4-150">읽기 전용 모드에서 응용 프로그램 실행</span><span class="sxs-lookup"><span data-stu-id="62bb4-150">Running your application in read-only mode</span></span>

<span data-ttu-id="62bb4-151">RA-GRS 저장소를 사용하려면 실패한 읽기 요청 및 실패한 업데이트 요청(이 경우 업데이트는 삽입, 업데이트 및 삭제를 의미함)을 모두 처리할 수 있어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="62bb4-151">To use RA-GRS storage, you must be able to handle both failed read requests and failed update requests (with update in this case meaning inserts, updates, and deletions).</span></span> <span data-ttu-id="62bb4-152">기본 데이터 센터에 장애가 발생하면 읽기 요청은 보조 데이터 센터로 리디렉션될 수 있지만 업데이트 요청은 보조 데이터 센터가 읽기 전용이기 때문에 리디렉션될 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="62bb4-152">If the primary data center fails, read requests can be redirected to the secondary data center, but update requests cannot because the secondary is read only.</span></span> <span data-ttu-id="62bb4-153">이런 이유 때문에 읽기 전용 모드에서 응용 프로그램을 실행할 수 있는 방법이 필요합니다.</span><span class="sxs-lookup"><span data-stu-id="62bb4-153">For this reason, you need some way to run your application in read-only mode.</span></span>

<span data-ttu-id="62bb4-154">예를 들어 저장소 서비스에 업데이트 요청을 제출하기 전에 확인되는 플래그를 설정할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="62bb4-154">For example, you can set a flag that will be checked before submitting any update requests to the storage service.</span></span> <span data-ttu-id="62bb4-155">업데이트 요청 중 하나가 도착하면 이것을 건너뛰고 고객에게 적절한 응답을 반환할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="62bb4-155">When one of the update requests comes through, you can skip it and return an appropriate response to the customer.</span></span> <span data-ttu-id="62bb4-156">문제가 해결될 때까지 특정 기능을 모두 비활성화하고 사용자에게 해당 기능을 일시적으로 사용할 수 없다고 알릴 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="62bb4-156">You may even want to disable certain features altogether until the problem is resolved and notify users that those features are temporarily unavailable.</span></span>

<span data-ttu-id="62bb4-157">각 서비스의 오류를 개별적으로 처리하기로 결정하면 읽기 전용 모드에서 응용 프로그램을 실행하는 기능도 서비스별로 처리해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="62bb4-157">If you decide to handle errors for each service separately, you will also need to handle the ability to run your application in read-only mode by service.</span></span> <span data-ttu-id="62bb4-158">각 서비스에 대해 사용하거나 사용하지 않도록 설정할 수 있는 읽기 전용 플래그를 두고 코드의 적절한 위치에서 적절한 플래그를 처리할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="62bb4-158">You could have read-only flags for each service that can be enabled and disabled and handle the appropriate flag in the appropriate places in your code.</span></span>

<span data-ttu-id="62bb4-159">읽기 전용 모드에서 응용 프로그램을 실행할 수 있다는 점은 또 다른 이점입니다. 주요 응용 프로그램 업그레이드를 진행하는 동안 제한된 기능만 실행되도록 할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="62bb4-159">Being able to run your application in read-only mode has another side benefit – it gives you the ability to ensure limited functionality during a major application upgrade.</span></span> <span data-ttu-id="62bb4-160">응용 프로그램을 트리거하여 읽기 전용 모드에서 실행하고 보조 데이터 센터를 가리켜서, 업그레이드를 진행하는 동안 주 지역의 데이터에 아무도 액세스하지 않도록 할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="62bb4-160">You can trigger your application to run in read-only mode and point to the secondary data center, ensuring nobody is accessing the data in the primary region while you're making upgrades.</span></span>

## <a name="handling-updates-when-running-in-read-only-mode"></a><span data-ttu-id="62bb4-161">읽기 전용 모드에서 실행하는 경우 업데이트 처리</span><span class="sxs-lookup"><span data-stu-id="62bb4-161">Handling updates when running in read-only mode</span></span>

<span data-ttu-id="62bb4-162">읽기 전용 모드에서 실행하는 경우 업데이트 요청을 처리하는 방법이 많이 있습니다.</span><span class="sxs-lookup"><span data-stu-id="62bb4-162">There are many ways to handle update requests when running in read-only mode.</span></span> <span data-ttu-id="62bb4-163">이 내용에 대해서는 포괄적인 경우 대신 일반적인 경우와 몇 가지 고려해야 할 패턴을 언급하겠습니다.</span><span class="sxs-lookup"><span data-stu-id="62bb4-163">We won't cover this comprehensively, but generally, there are a couple of patterns that you consider.</span></span>

1.  <span data-ttu-id="62bb4-164">사용자에게 응답하고 현재 업데이트를 수락하지 않는다고 알릴 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="62bb4-164">You can respond to your user and tell them you are not currently accepting updates.</span></span> <span data-ttu-id="62bb4-165">예를 들어 연락처 관리 시스템에서 고객이 연락처 정보에 액세스할 수 있지만 업데이트는 할 수 없도록 할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="62bb4-165">For example, a contact management system could enable customers to access contact information but not make updates.</span></span>

2.  <span data-ttu-id="62bb4-166">업데이트를 다른 지역의 큐에 넣을 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="62bb4-166">You can enqueue your updates in another region.</span></span> <span data-ttu-id="62bb4-167">이 경우 보류 중인 업데이트 요청을 다른 지역에 있는 큐에 써 놓은 다음 기본 데이터 센터가 다시 온라인이 되면 요청을 처리하는 방법이 있습니다.</span><span class="sxs-lookup"><span data-stu-id="62bb4-167">In this case, you would write your pending update requests to a queue in a different region, and then have a way to process those requests after the primary data center comes online again.</span></span> <span data-ttu-id="62bb4-168">이 시나리오에서는 나중에 처리하기 위해 업데이트 요청이 큐에 대기 중이라는 점을 고객에게 알려야 합니다.</span><span class="sxs-lookup"><span data-stu-id="62bb4-168">In this scenario, you should let the customer know that the update requested is queued for later processing.</span></span>

3.  <span data-ttu-id="62bb4-169">다른 지역의 저장소 계정에 업데이트를 작성할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="62bb4-169">You can write your updates to a storage account in another region.</span></span> <span data-ttu-id="62bb4-170">그런 다음 기본 데이터 센터가 다시 온라인이 되면 데이터의 구조에 따라 업데이트를 기본 데이터에 병합하는 방법이 있습니다.</span><span class="sxs-lookup"><span data-stu-id="62bb4-170">Then when the primary data center comes back online, you can have a way to merge those updates into the primary data, depending on the structure of the data.</span></span> <span data-ttu-id="62bb4-171">예를 들어 이름에 날짜/시간 스탬프가 있는 별도의 파일을 만드는 경우 파일을 주 지역에 다시 복사할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="62bb4-171">For example, if you are creating separate files with a date/time stamp in the name, you can copy those files back to the primary region.</span></span> <span data-ttu-id="62bb4-172">이러한 방식은 로깅 및 iOT 데이터와 같은 워크로드에 적합합니다.</span><span class="sxs-lookup"><span data-stu-id="62bb4-172">This works for some workloads such as logging and iOT data.</span></span>

## <a name="handling-retries"></a><span data-ttu-id="62bb4-173">다시 시도 처리</span><span class="sxs-lookup"><span data-stu-id="62bb4-173">Handling retries</span></span>

<span data-ttu-id="62bb4-174">어떤 오류를 다시 시도할 수 있는지 어떻게 할 수 있을까요?</span><span class="sxs-lookup"><span data-stu-id="62bb4-174">How do you know which errors are retryable?</span></span> <span data-ttu-id="62bb4-175">이것은 저장소 클라이언트 라이브러리에 의해 결정됩니다.</span><span class="sxs-lookup"><span data-stu-id="62bb4-175">This is determined by the storage client library.</span></span> <span data-ttu-id="62bb4-176">예를 들어 404 오류(리소스를 찾을 수 없음)는 재시도가 성공할 가능성이 없기 때문에 다시 시도할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="62bb4-176">For example, a 404 error (resource not found) is not retryable because retrying it is not likely to result in success.</span></span> <span data-ttu-id="62bb4-177">반면에 500 오류는 서버 오류이고 단순히 일시적인 문제일 수 있기 때문에 다시 시도할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="62bb4-177">On the other hand, a 500 error is retryable because it is a server error, and it may simply be a transient issue.</span></span> <span data-ttu-id="62bb4-178">자세한 내용은 .NET 저장소 클라이언트 라이브러리에서 [ExponentialRetry 클래스에 대한 오픈 소스 코드](https://github.com/Azure/azure-storage-net/blob/87b84b3d5ee884c7adc10e494e2c7060956515d0/Lib/Common/RetryPolicies/ExponentialRetry.cs)를 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="62bb4-178">For more details, check out the [open source code for the ExponentialRetry class](https://github.com/Azure/azure-storage-net/blob/87b84b3d5ee884c7adc10e494e2c7060956515d0/Lib/Common/RetryPolicies/ExponentialRetry.cs) in the .NET storage client library.</span></span> <span data-ttu-id="62bb4-179">(ShouldRetry 메서드를 찾아보세요.)</span><span class="sxs-lookup"><span data-stu-id="62bb4-179">(Look for the ShouldRetry method.)</span></span>

### <a name="read-requests"></a><span data-ttu-id="62bb4-180">읽기 요청</span><span class="sxs-lookup"><span data-stu-id="62bb4-180">Read requests</span></span>

<span data-ttu-id="62bb4-181">읽기 요청은 기본 저장소에 문제가 있으면 보조 저장소로 리디렉션될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="62bb4-181">Read requests can be redirected to secondary storage if there is a problem with primary storage.</span></span> <span data-ttu-id="62bb4-182">[결과적으로 일치하는 데이터 사용](#using-eventually-consistent-data)에 언급된 바와 같이 응용 프로그램에서 잠재적으로 부실 데이터를 읽는 것이 허용됩니다.</span><span class="sxs-lookup"><span data-stu-id="62bb4-182">As noted above in [Using Eventually Consistent Data](#using-eventually-consistent-data), it must be acceptable for your application to potentially read stale data.</span></span> <span data-ttu-id="62bb4-183">저장소 클라이언트 라이브러리를 사용하여 RA-GRS 데이터에 액세스하는 경우 **LocationMode** 속성에 대한 값을 다음 중 하나로 설정하여 읽기 요청의 다시 시도 동작을 지정할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="62bb4-183">If you are using the storage client library to access RA-GRS data, you can specify the retry behavior of a read request by setting a value for the **LocationMode** property to one of the following:</span></span>

*   <span data-ttu-id="62bb4-184">**PrimaryOnly**(기본값)</span><span class="sxs-lookup"><span data-stu-id="62bb4-184">**PrimaryOnly** (the default)</span></span>

*   <span data-ttu-id="62bb4-185">**PrimaryThenSecondary**</span><span class="sxs-lookup"><span data-stu-id="62bb4-185">**PrimaryThenSecondary**</span></span>

*   <span data-ttu-id="62bb4-186">**SecondaryOnly**</span><span class="sxs-lookup"><span data-stu-id="62bb4-186">**SecondaryOnly**</span></span>

*   <span data-ttu-id="62bb4-187">**SecondaryThenPrimary**</span><span class="sxs-lookup"><span data-stu-id="62bb4-187">**SecondaryThenPrimary**</span></span>

<span data-ttu-id="62bb4-188">**LocationMode**를 **PrimaryThenSecondary**로 설정한 경우 기본 끝점에 대한 초기 읽기 요청이 다시 시도 가능한 오류로 인해 실패하면 클라이언트는 보조 끝점에 대해 또 다른 읽기 요청을 자동으로 수행합니다.</span><span class="sxs-lookup"><span data-stu-id="62bb4-188">When you set the **LocationMode** to **PrimaryThenSecondary**, if the initial read request to the primary endpoint fails with a retryable error, the client automatically makes another read request to the secondary endpoint.</span></span> <span data-ttu-id="62bb4-189">오류가 서버 시간 초과 오류이면 클라이언트는 서버로부터 재시도 가능한 오류를 수신하기 전에 시간 제한이 만료될 때까지 대기해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="62bb4-189">If the error is a server timeout, then the client will have to wait for the timeout to expire before it receives a retryable error from the service.</span></span>

<span data-ttu-id="62bb4-190">재시도 가능한 오류에 대응하는 방법을 결정하는 시나리오는 기본적으로 두 가지입니다.</span><span class="sxs-lookup"><span data-stu-id="62bb4-190">There are basically two scenarios to consider when you are deciding how to respond to a retryable error:</span></span>

*   <span data-ttu-id="62bb4-191">격리된 문제이고 기본 끝점에 대한 후속 요청이 재시도 가능한 오류를 반환하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="62bb4-191">This is an isolated problem and subsequent requests to the primary endpoint will not return a retryable error.</span></span> <span data-ttu-id="62bb4-192">이런 경우가 발생할 수 있는 예는 일시적인 네트워크 오류가 있는 경우입니다.</span><span class="sxs-lookup"><span data-stu-id="62bb4-192">An example of where this might happen is when there is a transient network error.</span></span>

    <span data-ttu-id="62bb4-193">이 시나리오에서는 **LocationMode**를 **PrimaryThenSecondary**로 설정하더라도 이런 경우가 드물게 발생하기 때문에 현저한 성능 저하가 없습니다.</span><span class="sxs-lookup"><span data-stu-id="62bb4-193">In this scenario, there is no significant performance penalty in having **LocationMode** set to **PrimaryThenSecondary** as this only happens infrequently.</span></span>

*   <span data-ttu-id="62bb4-194">주 지역에 있는 하나 이상의 저장소 서비스에 문제가 있고 주 지역에서 해당 서비스에 대한 모든 후속 요청이 일정 기간 동안 재시도 가능한 오류를 반환할 가능성이 높습니다.</span><span class="sxs-lookup"><span data-stu-id="62bb4-194">This is a problem with at least one of the storage services in the primary region and all subsequent requests to that service in the primary region are likely to return retryable errors for a period of time.</span></span> <span data-ttu-id="62bb4-195">이러한 예는 주 지역에 완전히 액세스할 수 없는 경우입니다.</span><span class="sxs-lookup"><span data-stu-id="62bb4-195">An example of this is if the primary region is completely inaccessible.</span></span>

    <span data-ttu-id="62bb4-196">이 시나리오에서는 모든 읽기 요청이 기본 끝점을 먼저 시도하고, 시간 제한이 만료되기를 기다린 다음, 보조 끝점으로 전환하기 때문에 성능 저하가 있습니다.</span><span class="sxs-lookup"><span data-stu-id="62bb4-196">In this scenario, there is a performance penalty because all your read requests will try the primary endpoint first, wait for the timeout to expire, then switch to the secondary endpoint.</span></span>

<span data-ttu-id="62bb4-197">이 시나리오에서는 기본 끝점에 계속되는 문제가 있는지 식별하고 **LocationMode** 속성을 **SecondaryOnly**로 설정하여 모든 읽기 요청을 보조 끝점으로 바로 보내야 합니다.</span><span class="sxs-lookup"><span data-stu-id="62bb4-197">For these scenarios, you should identify that there is an ongoing issue with the primary endpoint and send all read requests directly to the secondary endpoint by setting the **LocationMode** property to **SecondaryOnly**.</span></span> <span data-ttu-id="62bb4-198">이 때 응용 프로그램을 읽기 전용 모드에서 실행하도록 변경해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="62bb4-198">At this time, you should also change the application to run in read-only mode.</span></span> <span data-ttu-id="62bb4-199">이 방법은 [회로 차단기 패턴](https://msdn.microsoft.com/library/dn589784.aspx)이라고 합니다.</span><span class="sxs-lookup"><span data-stu-id="62bb4-199">This approach is known as the [Circuit Breaker Pattern](https://msdn.microsoft.com/library/dn589784.aspx).</span></span>

### <a name="update-requests"></a><span data-ttu-id="62bb4-200">업데이트 요청</span><span class="sxs-lookup"><span data-stu-id="62bb4-200">Update requests</span></span>

<span data-ttu-id="62bb4-201">회로 차단기 패턴은 업데이트 요청에도 적용될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="62bb4-201">The Circuit Breaker pattern can also be applied to update requests.</span></span> <span data-ttu-id="62bb4-202">하지만 업데이트 요청은 읽기 전용 상태인 보조 저장소로 리디렉션될 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="62bb4-202">However, update requests cannot be redirected to secondary storage, which is read-only.</span></span> <span data-ttu-id="62bb4-203">이러한 요청에 대해서는 **LocationMode** 속성을 **PrimaryOnly**(기본값)로 설정해 두어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="62bb4-203">For these requests, you should leave the **LocationMode** property set to **PrimaryOnly** (the default).</span></span> <span data-ttu-id="62bb4-204">이러한 오류를 처리하려면 메트릭(예: 연속 실패 10번)을 요청에 적용하고 임계값에 도달하면 응용 프로그램을 읽기 전용 모드로 전환합니다.</span><span class="sxs-lookup"><span data-stu-id="62bb4-204">To handle these errors, you can apply a metric to these requests – such as 10 failures in a row – and when your threshold is met, switch the application into read-only mode.</span></span> <span data-ttu-id="62bb4-205">업데이트 모드로 돌아가려면 아래에 있는 다음 섹션의 회로 차단 패턴에 설명된 것과 같은 방법을 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="62bb4-205">You can use the same methods for returning to update mode as those described below in the next section about the Circuit Breaker pattern.</span></span>

## <a name="circuit-breaker-pattern"></a><span data-ttu-id="62bb4-206">회로 차단기 패턴</span><span class="sxs-lookup"><span data-stu-id="62bb4-206">Circuit Breaker pattern</span></span>

<span data-ttu-id="62bb4-207">회로 차단기 패턴을 응용 프로그램에 사용하면 반복해서 실패할 가능성이 있는 작업을 다시 시도하지 않도록 할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="62bb4-207">Using the Circuit Breaker pattern in your application can prevent it from retrying an operation that is likely to fail repeatedly.</span></span> <span data-ttu-id="62bb4-208">작업이 기하급수적으로 다시 시도되는 동안 시간을 뺏기지 않고 응용 프로그램을 계속 실행할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="62bb4-208">It allows the application to continue to run rather than taking up time while the operation is retried exponentially.</span></span> <span data-ttu-id="62bb4-209">또한 장애가 해결되어 응용 프로그램이 작업을 다시 시도할 수 있는 때를 감지합니다.</span><span class="sxs-lookup"><span data-stu-id="62bb4-209">It also detects when the fault has been fixed, at which time the application can try the operation again.</span></span>

### <a name="how-to-implement-the-circuit-breaker-pattern"></a><span data-ttu-id="62bb4-210">회로 차단기 패턴을 구현하는 방법</span><span class="sxs-lookup"><span data-stu-id="62bb4-210">How to implement the circuit breaker pattern</span></span>

<span data-ttu-id="62bb4-211">기본 끝점에 계속되는 문제가 있는지 식별하려면 클라이언트에 재시도 가능한 오류가 발생하는 빈도를 모니터링합니다.</span><span class="sxs-lookup"><span data-stu-id="62bb4-211">To identify that there is an ongoing problem with a primary endpoint, you can monitor how frequently the client encounters retryable errors.</span></span> <span data-ttu-id="62bb4-212">각각의 경우가 다르기 때문에 보조 끝점으로 전환하고 응용 프로그램을 읽기 전용 모드에서 실행하기로 결정하는 데 사용할 임계값을 결정해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="62bb4-212">Because each case is different, you have to decide on the threshold you want to use for the decision to switch to the secondary endpoint and run the application in read-only mode.</span></span> <span data-ttu-id="62bb4-213">예를 들어 성공하지 못하고 연속해서 10번 실패하면 전환을 수행하도록 결정할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="62bb4-213">For example, you could decide to perform the switch if there are 10 failures in a row with no successes.</span></span> <span data-ttu-id="62bb4-214">또 다른 예는 2분 동안 요청의 90%가 실패하면 전환하도록 하는 것입니다.</span><span class="sxs-lookup"><span data-stu-id="62bb4-214">Another example is to switch if 90% of the requests in a 2-minute period fail.</span></span>

<span data-ttu-id="62bb4-215">첫 번째 시나리오에서는 실패 개수만 유지했다가 최대값에 도달하기 전에 성공하면 개수를 다시 0으로 설정합니다.</span><span class="sxs-lookup"><span data-stu-id="62bb4-215">For the first scenario, you can simply keep a count of the failures, and if there is a success before reaching the maximum, set the count back to zero.</span></span> <span data-ttu-id="62bb4-216">두 번째 시나리오의 경우 이를 구현하는 한 가지 방법은 MemoryCache 개체(.NET용)를 사용하는 것입니다.</span><span class="sxs-lookup"><span data-stu-id="62bb4-216">For the second scenario, one way to implement it is to use the MemoryCache object (in .NET).</span></span> <span data-ttu-id="62bb4-217">각 요청에 대해 캐시에 CacheItem을 추가하고, 성공(1) 또는 실패(0)에 값을 설정하고, 만료 시간을 지금(또는 원하는 시간 제약 조건)부터 2분으로 설정합니다.</span><span class="sxs-lookup"><span data-stu-id="62bb4-217">For each request, add a CacheItem to the cache, set the value to success (1) or fail (0), and set the expiration time to 2 minutes from now (or whatever your time constraint is).</span></span> <span data-ttu-id="62bb4-218">항목의 만료 시간에 도달하면 항목이 자동으로 제거됩니다.</span><span class="sxs-lookup"><span data-stu-id="62bb4-218">When an entry's expiration time is reached, the entry is automatically removed.</span></span> <span data-ttu-id="62bb4-219">이렇게 하면 2분 기간으로 롤링하게 됩니다.</span><span class="sxs-lookup"><span data-stu-id="62bb4-219">This will give you a rolling 2-minute window.</span></span> <span data-ttu-id="62bb4-220">저장소 서비스에 요청할 때마다 먼저 MemoryCache 개체 전반에 Linq 쿼리를 사용하여 값의 합계를 구하고 개수로 나눠서 성공 비율을 계산합니다.</span><span class="sxs-lookup"><span data-stu-id="62bb4-220">Each time you make a request to the storage service, you first use a Linq query across the MemoryCache object to calculate the percent success by summing the values and dividing by the count.</span></span> <span data-ttu-id="62bb4-221">성공 비율이 일정한 임계값(예: 10%) 아래로 떨어지면 계속하기 전에 읽기 요청에 대한 **LocationMode** 속성을 **SecondaryOnly**로 설정하고 응용 프로그램을 읽기 전용 모드로 전환합니다.</span><span class="sxs-lookup"><span data-stu-id="62bb4-221">When the percent success drops below some threshold (such as 10%), set the **LocationMode** property for read requests to **SecondaryOnly** and switch the application into read-only mode before continuing.</span></span>

<span data-ttu-id="62bb4-222">전환할 때를 결정하는 데 사용되는 오류 임계값은 응용 프로그램의 서비스마다 다를 수 있으므로 구성할 수 있는 매개 변수로 설정하는 것이 좋습니다.</span><span class="sxs-lookup"><span data-stu-id="62bb4-222">The threshold of errors used to determine when to make the switch may vary from service to service in your application, so you should consider making them configurable parameters.</span></span> <span data-ttu-id="62bb4-223">앞에서 언급했듯이 재시도 가능한 오류를 서비스마다 별도로 처리할지 또는 하나로 처리할지도 여기서 결정합니다.</span><span class="sxs-lookup"><span data-stu-id="62bb4-223">This is also where you decide to handle retryable errors from each service separately or as one, as discussed previously.</span></span>

<span data-ttu-id="62bb4-224">또 다른 고려 사항은 응용 프로그램의 여러 인스턴스를 처리하는 방법과 각 인스턴스에서 재시도 가능한 오류를 감지하는 경우 어떻게 할지 입니다.</span><span class="sxs-lookup"><span data-stu-id="62bb4-224">Another consideration is how to handle multiple instances of an application, and what to do when you detect retryable errors in each instance.</span></span> <span data-ttu-id="62bb4-225">예를 들어 동일한 응용 프로그램이 로드된 VM을 20개 실행하는 경우가 있습니다.</span><span class="sxs-lookup"><span data-stu-id="62bb4-225">For example, you may have 20 VMs running with the same application loaded.</span></span> <span data-ttu-id="62bb4-226">각 인스턴스를 별도로 처리할까요?</span><span class="sxs-lookup"><span data-stu-id="62bb4-226">Do you handle each instance separately?</span></span> <span data-ttu-id="62bb4-227">하나의 인스턴스에 문제가 발생하기 시작하면 하나의 인스턴스만으로 응답을 제한할까요 아니면 하나의 인스턴스에 문제가 발생하면 모든 인스턴스가 같은 방식으로 응답하도록 할까요?</span><span class="sxs-lookup"><span data-stu-id="62bb4-227">If one instance starts having problems, do you want to limit the response to just that one instance, or do you want to try to have all instances respond in the same way when one instance has a problem?</span></span> <span data-ttu-id="62bb4-228">인스턴스를 개별적으로 처리하는 것이 모든 인스턴스의 응답을 조정하는 것보다 훨씬 더 간단하지만 이를 구현하는 방법은 응용 프로그램의 아키텍처에 달려 있습니다.</span><span class="sxs-lookup"><span data-stu-id="62bb4-228">Handling the instances separately is much simpler than trying to coordinate the response across them, but how you do this depends on your application's architecture.</span></span>

### <a name="options-for-monitoring-the-error-frequency"></a><span data-ttu-id="62bb4-229">오류 빈도를 모니터링하는 옵션</span><span class="sxs-lookup"><span data-stu-id="62bb4-229">Options for monitoring the error frequency</span></span>

<span data-ttu-id="62bb4-230">보조 지역으로 전환하고 응용 프로그램을 읽기 전용 모드에서 실행하도록 변경할 때를 결정하기 위해 주 지역에서 재시도 빈도를 모니터링하는 주요 옵션은 세 가지입니다.</span><span class="sxs-lookup"><span data-stu-id="62bb4-230">You have three main options for monitoring the frequency of retries in the primary region in order to determine when to switch over to the secondary region and change the application to run in read-only mode.</span></span>

*   <span data-ttu-id="62bb4-231">저장소 요청에 전달하는 [**OperationContext**](http://msdn.microsoft.com/en-us/library/microsoft.windowsazure.storage.operationcontext.aspx) 개체의 [**Retrying**](http://msdn.microsoft.com/en-us/library/microsoft.windowsazure.storage.operationcontext.retrying.aspx) 이벤트에 대해 처리기를 추가합니다. 이 방법은 이 문서에 표시되어 있고 함께 제공되는 샘플에 사용되어 있습니다.</span><span class="sxs-lookup"><span data-stu-id="62bb4-231">Add a handler for the [**Retrying**](http://msdn.microsoft.com/en-us/library/microsoft.windowsazure.storage.operationcontext.retrying.aspx) event on the [**OperationContext**](http://msdn.microsoft.com/en-us/library/microsoft.windowsazure.storage.operationcontext.aspx) object you pass to your storage requests – this is the method displayed in this article and used in the accompanying sample.</span></span> <span data-ttu-id="62bb4-232">이러한 이벤트는 클라이언트가 요청을 재시도할 때마다 발생하기 때문에 기본 끝점에서 재시도 가능한 오류가 클라이언트에 발생하는 빈도를 추적할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="62bb4-232">These events fire whenever the client retries a request, enabling you to track how often the client encounters retryable errors on a primary endpoint.</span></span>

    ```csharp 
    operationContext.Retrying += (sender, arguments) =>
    {
        // Retrying in the primary region
        if (arguments.Request.Host == primaryhostname)
            ...
    };
    ```

*   <span data-ttu-id="62bb4-233">사용자 지정 다시 시도 정책의 [**Evaluate**](http://msdn.microsoft.com/en-us/library/microsoft.windowsazure.storage.retrypolicies.iextendedretrypolicy.evaluate.aspx) 메서드에서 다시 시도가 발생할 때마다 사용자 지정 코드를 실행할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="62bb4-233">In the [**Evaluate**](http://msdn.microsoft.com/en-us/library/microsoft.windowsazure.storage.retrypolicies.iextendedretrypolicy.evaluate.aspx) method in a custom retry policy, you can run custom code whenever a retry takes place.</span></span> <span data-ttu-id="62bb4-234">이렇게 하면 다시 시도가 발생하는 때를 기록하는 것 외에 다시 시도 동작을 수정할 수 있는 기회도 갖게 됩니다.</span><span class="sxs-lookup"><span data-stu-id="62bb4-234">In addition to recording when a retry happens, this also gives you the opportunity to modify your retry behavior.</span></span>

    ```csharp 
    public RetryInfo Evaluate(RetryContext retryContext,
    OperationContext operationContext)
    {
        var statusCode = retryContext.LastRequestResult.HttpStatusCode;
        if (retryContext.CurrentRetryCount >= this.maximumAttempts
        || ((statusCode &gt;= 300 && statusCode &lt; 500 && statusCode != 408)
        || statusCode == 501 // Not Implemented
        || statusCode == 505 // Version Not Supported
            ))
        {
        // Do not retry
            return null;
        }

        // Monitor retries in the primary location
        ...

        // Determine RetryInterval and TargetLocation
        RetryInfo info =
            CreateRetryInfo(retryContext.CurrentRetryCount);

        return info;
    }
    ```

*   <span data-ttu-id="62bb4-235">세 번째 방법은 기본 저장소 끝점의 상태를 파악하기 위해 더미 읽기 요청(예: 소규모 Blob 읽기)을 사용하여 기본 저장소 끝점에 계속해서 ping을 실행하는 사용자 지정 모니터링 구성 요소를 응용 프로그램에 구현하는 것입니다.</span><span class="sxs-lookup"><span data-stu-id="62bb4-235">The third approach is to implement a custom monitoring component in your application that continually pings your primary storage endpoint with dummy read requests (such as reading a small blob) to determine its health.</span></span> <span data-ttu-id="62bb4-236">이렇게 하려면 리소스가 소비되지만 그 양은 많지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="62bb4-236">This would take up some resources, but not a significant amount.</span></span> <span data-ttu-id="62bb4-237">임계값에 도달하는 문제가 발견되면 **SecondaryOnly** 및 읽기 전용 모드로 전환을 수행합니다.</span><span class="sxs-lookup"><span data-stu-id="62bb4-237">When a problem is discovered that reaches your threshold, you would then perform the switch to **SecondaryOnly** and read-only mode.</span></span>

<span data-ttu-id="62bb4-238">일정 시점에 기본 끝점을 사용하도록 다시 전환하고 업데이트를 허용하는 것이 좋습니다.</span><span class="sxs-lookup"><span data-stu-id="62bb4-238">At some point, you will want to switch back to using the primary endpoint and allowing updates.</span></span> <span data-ttu-id="62bb4-239">위의 앞쪽에 나열된 두 가지 방법 중 하나를 사용하면 임의의 선택된 시간이 지나거나 선택된 횟수만큼 작업이 수행된 후 기본 끝점으로 다시 전환하고 업데이트 모드를 사용하도록 설정할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="62bb4-239">If using one of the first two methods listed above, you could simply switch back to the primary endpoint and enable update mode after an arbitrarily selected amount of time or number of operations has been performed.</span></span> <span data-ttu-id="62bb4-240">그런 다음 다시 시도 논리를 다시 적용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="62bb4-240">You can then let it go through the retry logic again.</span></span> <span data-ttu-id="62bb4-241">문제가 수정되면 기본 끝점을 계속 사용하고 업데이트를 허용하게 됩니다.</span><span class="sxs-lookup"><span data-stu-id="62bb4-241">If the problem has been fixed, it will continue to use the primary endpoint and allow updates.</span></span> <span data-ttu-id="62bb4-242">문제가 지속되면 설정해 놓은 조건에 실패한 후 다시 한 번 보조 끝점 및 읽기 전용 모드로 전환됩니다.</span><span class="sxs-lookup"><span data-stu-id="62bb4-242">If there is still a problem, it will once more switch back to the secondary endpoint and read-only mode after failing the criteria you've set.</span></span>

<span data-ttu-id="62bb4-243">세 번째 시나리오의 경우 기본 저장소 끝점에 대한 ping이 다시 성공하게 되면 스위치를 **PrimaryOnly**로 다시 트리거하고 업데이트를 계속 허용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="62bb4-243">For the third scenario, when pinging the primary storage endpoint becomes successful again, you can trigger the switch back to **PrimaryOnly** and continue allowing updates.</span></span>

## <a name="handling-eventually-consistent-data"></a><span data-ttu-id="62bb4-244">결과적으로 일치하는 데이터 처리</span><span class="sxs-lookup"><span data-stu-id="62bb4-244">Handling eventually consistent data</span></span>

<span data-ttu-id="62bb4-245">RA-GRS는 주 지역에서 보조 지역으로 트랜잭션을 복제하는 방식으로 작동합니다.</span><span class="sxs-lookup"><span data-stu-id="62bb4-245">RA-GRS works by replicating transactions from the primary to the secondary region.</span></span> <span data-ttu-id="62bb4-246">복제 프로세스는 보조 지역의 데이터가 *결과적으로 일치*하도록 보장합니다.</span><span class="sxs-lookup"><span data-stu-id="62bb4-246">This replication process guarantees that the data in the secondary region is *eventually consistent*.</span></span> <span data-ttu-id="62bb4-247">즉, 주 지역의 모든 트랜잭션이 보조 지역에 언젠가는 표시되지만 트랜잭션이 표시되기 전에 지연이 있을 수 있고 트랜잭션이 보조 지역에 도착하는 순서가 주 지역에 원래 적용된 순서와 같다는 보장이 없습니다.</span><span class="sxs-lookup"><span data-stu-id="62bb4-247">This means that all the transactions in the primary region will eventually appear in the secondary region, but that there may be a lag before they appear, and that there is no guarantee the transactions arrive in the secondary region in the same order as that in which they were originally applied in the primary region.</span></span> <span data-ttu-id="62bb4-248">트랜잭션이 보조 지역에 순서가 바뀌어 도착하면 서비스가 이를 처리할 때까지 보조 지역의 데이터가 불일치 상태인 것으로 생각할 수 *있습니다*.</span><span class="sxs-lookup"><span data-stu-id="62bb4-248">If your transactions arrive in the secondary region out of order, you *may* consider your data in the secondary region to be in an inconsistent state until the service catches up.</span></span>

<span data-ttu-id="62bb4-249">다음 테이블은 직원을 *관리자* 역할의 구성원으로 만들기 위해 해당 직원의 세부 정보를 업데이트하는 경우 발생할 수 있는 사례를 보여줍니다.</span><span class="sxs-lookup"><span data-stu-id="62bb4-249">The following table shows an example of what might happen when you update the details of an employee to make her a member of the *administrators* role.</span></span> <span data-ttu-id="62bb4-250">이 예제의 경우 **직원** 엔터티를 업데이트하고 총 관리자 수로 **관리자 역할** 엔터티를 업데이트해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="62bb4-250">For the sake of this example, this requires you update the **employee** entity and update an **administrator role** entity with a count of the total number of administrators.</span></span> <span data-ttu-id="62bb4-251">업데이트가 보조 지역에서 어떻게 다른 순서로 적용되는지 살펴보겠습니다.</span><span class="sxs-lookup"><span data-stu-id="62bb4-251">Notice how the updates are applied out of order in the secondary region.</span></span>

| <span data-ttu-id="62bb4-252">**Time**</span><span class="sxs-lookup"><span data-stu-id="62bb4-252">**Time**</span></span> | <span data-ttu-id="62bb4-253">**트랜잭션**</span><span class="sxs-lookup"><span data-stu-id="62bb4-253">**Transaction**</span></span>                                            | <span data-ttu-id="62bb4-254">**복제**</span><span class="sxs-lookup"><span data-stu-id="62bb4-254">**Replication**</span></span>                       | <span data-ttu-id="62bb4-255">**마지막 동기화 시간**</span><span class="sxs-lookup"><span data-stu-id="62bb4-255">**Last Sync Time**</span></span> | <span data-ttu-id="62bb4-256">**결과**</span><span class="sxs-lookup"><span data-stu-id="62bb4-256">**Result**</span></span> |
|----------|------------------------------------------------------------|---------------------------------------|--------------------|------------| 
| <span data-ttu-id="62bb4-257">T0</span><span class="sxs-lookup"><span data-stu-id="62bb4-257">T0</span></span>       | <span data-ttu-id="62bb4-258">트랜잭션 A:</span><span class="sxs-lookup"><span data-stu-id="62bb4-258">Transaction A:</span></span> <br> <span data-ttu-id="62bb4-259">주 지역에</span><span class="sxs-lookup"><span data-stu-id="62bb4-259">Insert employee</span></span> <br> <span data-ttu-id="62bb4-260">직원 엔터티 삽입</span><span class="sxs-lookup"><span data-stu-id="62bb4-260">entity in primary</span></span> |                                   |                    | <span data-ttu-id="62bb4-261">트랜잭션 A가 주 지역에 삽입됐지만</span><span class="sxs-lookup"><span data-stu-id="62bb4-261">Transaction A inserted to primary,</span></span><br> <span data-ttu-id="62bb4-262">아직 복제되지 않음</span><span class="sxs-lookup"><span data-stu-id="62bb4-262">not replicated yet.</span></span> |
| <span data-ttu-id="62bb4-263">T1</span><span class="sxs-lookup"><span data-stu-id="62bb4-263">T1</span></span>       |                                                            | <span data-ttu-id="62bb4-264">트랜잭션 A가</span><span class="sxs-lookup"><span data-stu-id="62bb4-264">Transaction A</span></span> <br> <span data-ttu-id="62bb4-265">보조 지역에</span><span class="sxs-lookup"><span data-stu-id="62bb4-265">replicated to</span></span><br> <span data-ttu-id="62bb4-266">복제됨</span><span class="sxs-lookup"><span data-stu-id="62bb4-266">secondary</span></span> | <span data-ttu-id="62bb4-267">T1</span><span class="sxs-lookup"><span data-stu-id="62bb4-267">T1</span></span> | <span data-ttu-id="62bb4-268">트랜잭션 A가 보조 지역에 복제됨.</span><span class="sxs-lookup"><span data-stu-id="62bb4-268">Transaction A replicated to secondary.</span></span> <br><span data-ttu-id="62bb4-269">마지막 동기화 시간이 업데이트됨.</span><span class="sxs-lookup"><span data-stu-id="62bb4-269">Last Sync Time updated.</span></span>    |
| <span data-ttu-id="62bb4-270">T2</span><span class="sxs-lookup"><span data-stu-id="62bb4-270">T2</span></span>       | <span data-ttu-id="62bb4-271">트랜잭션 B:</span><span class="sxs-lookup"><span data-stu-id="62bb4-271">Transaction B:</span></span><br><span data-ttu-id="62bb4-272">주 지역에서</span><span class="sxs-lookup"><span data-stu-id="62bb4-272">Update</span></span><br> <span data-ttu-id="62bb4-273">직원 엔터티</span><span class="sxs-lookup"><span data-stu-id="62bb4-273">employee entity</span></span><br> <span data-ttu-id="62bb4-274">업데이트</span><span class="sxs-lookup"><span data-stu-id="62bb4-274">in primary</span></span>  |                                | <span data-ttu-id="62bb4-275">T1</span><span class="sxs-lookup"><span data-stu-id="62bb4-275">T1</span></span>                 | <span data-ttu-id="62bb4-276">트랜잭션 B가 주 지역에 기록됐지만</span><span class="sxs-lookup"><span data-stu-id="62bb4-276">Transaction B written to primary,</span></span><br> <span data-ttu-id="62bb4-277">아직 복제되지 않음</span><span class="sxs-lookup"><span data-stu-id="62bb4-277">not replicated yet.</span></span>  |
| <span data-ttu-id="62bb4-278">T3</span><span class="sxs-lookup"><span data-stu-id="62bb4-278">T3</span></span>       | <span data-ttu-id="62bb4-279">트랜잭션 C:</span><span class="sxs-lookup"><span data-stu-id="62bb4-279">Transaction C:</span></span><br> <span data-ttu-id="62bb4-280">주 지역에서</span><span class="sxs-lookup"><span data-stu-id="62bb4-280">Update</span></span> <br><span data-ttu-id="62bb4-281">관리자 역할</span><span class="sxs-lookup"><span data-stu-id="62bb4-281">administrator</span></span><br><span data-ttu-id="62bb4-282">엔터티</span><span class="sxs-lookup"><span data-stu-id="62bb4-282">role entity in</span></span><br><span data-ttu-id="62bb4-283">업데이트</span><span class="sxs-lookup"><span data-stu-id="62bb4-283">primary</span></span> |                    | <span data-ttu-id="62bb4-284">T1</span><span class="sxs-lookup"><span data-stu-id="62bb4-284">T1</span></span>                 | <span data-ttu-id="62bb4-285">트랜잭션 C가 주 지역에 기록됐지만</span><span class="sxs-lookup"><span data-stu-id="62bb4-285">Transaction C written to primary,</span></span><br> <span data-ttu-id="62bb4-286">아직 복제되지 않음</span><span class="sxs-lookup"><span data-stu-id="62bb4-286">not replicated yet.</span></span>  |
| <span data-ttu-id="62bb4-287">*T4*</span><span class="sxs-lookup"><span data-stu-id="62bb4-287">*T4*</span></span>     |                                                       | <span data-ttu-id="62bb4-288">트랜잭션 C가</span><span class="sxs-lookup"><span data-stu-id="62bb4-288">Transaction C</span></span> <br><span data-ttu-id="62bb4-289">보조 지역에</span><span class="sxs-lookup"><span data-stu-id="62bb4-289">replicated to</span></span><br> <span data-ttu-id="62bb4-290">복제됨</span><span class="sxs-lookup"><span data-stu-id="62bb4-290">secondary</span></span> | <span data-ttu-id="62bb4-291">T1</span><span class="sxs-lookup"><span data-stu-id="62bb4-291">T1</span></span>         | <span data-ttu-id="62bb4-292">트랜잭션 C가 보조 지역에 복제됨.</span><span class="sxs-lookup"><span data-stu-id="62bb4-292">Transaction C replicated to secondary.</span></span><br><span data-ttu-id="62bb4-293">트랜잭션 B가 아직 복제되지 않아서</span><span class="sxs-lookup"><span data-stu-id="62bb4-293">LastSyncTime not updated because</span></span> <br><span data-ttu-id="62bb4-294">LastSyncTime이 업데이트되지 않음</span><span class="sxs-lookup"><span data-stu-id="62bb4-294">transaction B has not been replicated yet.</span></span>|
| <span data-ttu-id="62bb4-295">*T5*</span><span class="sxs-lookup"><span data-stu-id="62bb4-295">*T5*</span></span>     | <span data-ttu-id="62bb4-296">보조 지역의</span><span class="sxs-lookup"><span data-stu-id="62bb4-296">Read entities</span></span> <br><span data-ttu-id="62bb4-297">엔터티 읽기</span><span class="sxs-lookup"><span data-stu-id="62bb4-297">from secondary</span></span>                           |                                  | <span data-ttu-id="62bb4-298">T1</span><span class="sxs-lookup"><span data-stu-id="62bb4-298">T1</span></span>                 | <span data-ttu-id="62bb4-299">트랜잭션 B가 아직 복제되지</span><span class="sxs-lookup"><span data-stu-id="62bb4-299">You get the stale value for employee</span></span> <br> <span data-ttu-id="62bb4-300">않아서 직원 엔터티에 대해</span><span class="sxs-lookup"><span data-stu-id="62bb4-300">entity because transaction B hasn't</span></span> <br> <span data-ttu-id="62bb4-301">부실한 값을 얻음</span><span class="sxs-lookup"><span data-stu-id="62bb4-301">replicated yet.</span></span> <span data-ttu-id="62bb4-302">C가 복제되었기 때문에</span><span class="sxs-lookup"><span data-stu-id="62bb4-302">You get the new value for</span></span><br> <span data-ttu-id="62bb4-303">관리자 역할 엔터티에 대해</span><span class="sxs-lookup"><span data-stu-id="62bb4-303">administrator role entity because C has</span></span><br> <span data-ttu-id="62bb4-304">새 값을 얻음</span><span class="sxs-lookup"><span data-stu-id="62bb4-304">replicated.</span></span> <span data-ttu-id="62bb4-305">트랜잭션 B가 복제되지 않았기</span><span class="sxs-lookup"><span data-stu-id="62bb4-305">Last Sync Time still hasn't</span></span><br> <span data-ttu-id="62bb4-306">때문에 마지막 동기화 시간이</span><span class="sxs-lookup"><span data-stu-id="62bb4-306">been updated because transaction B</span></span><br> <span data-ttu-id="62bb4-307">아직 업데이트되지 않음.</span><span class="sxs-lookup"><span data-stu-id="62bb4-307">hasn't replicated.</span></span> <span data-ttu-id="62bb4-308">엔터티 날짜/시간이 마지막</span><span class="sxs-lookup"><span data-stu-id="62bb4-308">You can tell the</span></span><br><span data-ttu-id="62bb4-309">동기화 시간보다 나중이기 때문에</span><span class="sxs-lookup"><span data-stu-id="62bb4-309">administrator role entity is inconsistent</span></span> <br><span data-ttu-id="62bb4-310">관리자 역할 엔터티가 불일치</span><span class="sxs-lookup"><span data-stu-id="62bb4-310">because the entity date/time is after</span></span> <br><span data-ttu-id="62bb4-311">상태라고 볼 수 있음</span><span class="sxs-lookup"><span data-stu-id="62bb4-311">the Last Sync Time.</span></span> |
| <span data-ttu-id="62bb4-312">*T6*</span><span class="sxs-lookup"><span data-stu-id="62bb4-312">*T6*</span></span>     |                                                      | <span data-ttu-id="62bb4-313">트랜잭션 B가</span><span class="sxs-lookup"><span data-stu-id="62bb4-313">Transaction B</span></span><br> <span data-ttu-id="62bb4-314">보조 지역에</span><span class="sxs-lookup"><span data-stu-id="62bb4-314">replicated to</span></span><br> <span data-ttu-id="62bb4-315">복제됨</span><span class="sxs-lookup"><span data-stu-id="62bb4-315">secondary</span></span> | <span data-ttu-id="62bb4-316">T6</span><span class="sxs-lookup"><span data-stu-id="62bb4-316">T6</span></span>                 | <span data-ttu-id="62bb4-317">*T6* – C까지 모든 트랜잭션이</span><span class="sxs-lookup"><span data-stu-id="62bb4-317">*T6* – All transactions through C have</span></span> <br><span data-ttu-id="62bb4-318">복제됨. 마지막 동기화</span><span class="sxs-lookup"><span data-stu-id="62bb4-318">been replicated, Last Sync Time</span></span><br> <span data-ttu-id="62bb4-319">시간이 업데이트됨</span><span class="sxs-lookup"><span data-stu-id="62bb4-319">is updated.</span></span> |

<span data-ttu-id="62bb4-320">이 예제에서는 T5 지점에서 클라이언트가 보조 지역을 읽는 것으로 전환한다고 가정합니다.</span><span class="sxs-lookup"><span data-stu-id="62bb4-320">In this example, assume the client switches to reading from the secondary region at T5.</span></span> <span data-ttu-id="62bb4-321">지금은 **관리자 역할** 엔터티를 성공적으로 읽을 수 있지만 이 엔터티에는 관리자 수에 대한 값이 포함되어 있고 이 값은 현재 보조 지역에 관리자로 표시되어 있는 **직원** 엔터티의 수와 일치하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="62bb4-321">It can successfully read the **administrator role** entity at this time, but the entity contains a value for the count of administrators that is not consistent with the number of **employee** entities that are marked as administrators in the secondary region at this time.</span></span> <span data-ttu-id="62bb4-322">클라이언트는 이 값을 표시할 수 있지만 정보가 불일치할 위험이 있을 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="62bb4-322">Your client could simply display this value, with the risk that it is inconsistent information.</span></span> <span data-ttu-id="62bb4-323">아니면 클라이언트에서 업데이트 순서가 바뀌어 진행되었으므로 **관리자 역할**이 잠재적으로 불일치 상태인지를 파악하려고 시도한 다음 사용자에게 이 사실을 알릴 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="62bb4-323">Alternatively, the client could attempt to determine that the **administrator role** is in a potentially inconsistent state because the updates have happened out of order, and then inform the user of this fact.</span></span>

<span data-ttu-id="62bb4-324">잠재적으로 일치하지 않는 데이터가 포함되었는지 파악하기 위해 클라이언트는 저장소 서비스에 쿼리를 실행하면 언제든 얻을 수 있는 *마지막 동기화 시간* 값을 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="62bb4-324">To recognize that it has potentially inconsistent data, the client can use the value of the *Last Sync Time* that you can get at any time by querying a storage service.</span></span> <span data-ttu-id="62bb4-325">이렇게 하면 보조 지역의 데이터가 마지막으로 일치했던 시간과 이 시간 전에 서비스가 모든 트랜잭션을 적용한 시간을 알 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="62bb4-325">This tells you the time when the data in the secondary region was last consistent and when the service had applied all the transactions prior to that point in time.</span></span> <span data-ttu-id="62bb4-326">위의 예제에는 서비스가 보조 지역에 **직원** 엔터티를 삽입한 후 마지막 동기화 시간이 *T1*로 설정되어 있습니다.</span><span class="sxs-lookup"><span data-stu-id="62bb4-326">In the example shown above, after the service inserts the **employee** entity in the secondary region, the last sync time is set to *T1*.</span></span> <span data-ttu-id="62bb4-327">이 시간은 서비스가 보조 지역에서 **직원** 엔터티를 업데이트할 때까지 *T1*에 유지되었다가 *T6*로 설정됩니다.</span><span class="sxs-lookup"><span data-stu-id="62bb4-327">It remains at *T1* until the service updates the **employee** entity in the secondary region when it is set to *T6*.</span></span> <span data-ttu-id="62bb4-328">클라이언트가 *T5*에서 엔터티를 읽을 때 마지막 동기화 시간을 검색하는 경우 엔터티의 타임스탬프와 비교할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="62bb4-328">If the client retrieves the last sync time when it reads the entity at *T5*, it can compare it with the timestamp on the entity.</span></span> <span data-ttu-id="62bb4-329">엔터티의 타임스탬프가 마지막 동기화 시간보다 나중이면 엔터티는 잠재적으로 불일치 상태이며 응용 프로그램에 적절한 조치를 무엇이든 취할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="62bb4-329">If the timestamp on the entity is later than the last sync time, then the entity is in a potentially inconsistent state, and you can take whatever is the appropriate action for your application.</span></span> <span data-ttu-id="62bb4-330">이 필드를 사용하려면 주 지역에 대한 마지막 업데이트가 완료된 시간을 알아야 합니다.</span><span class="sxs-lookup"><span data-stu-id="62bb4-330">Using this field requires that you know when the last update to the primary was completed.</span></span>

## <a name="testing"></a><span data-ttu-id="62bb4-331">테스트</span><span class="sxs-lookup"><span data-stu-id="62bb4-331">Testing</span></span>

<span data-ttu-id="62bb4-332">응용 프로그램에 재시도 가능한 오류가 발생하는 경우 예상대로 작동하는지를 테스트하는 것이 중요합니다.</span><span class="sxs-lookup"><span data-stu-id="62bb4-332">It's important to test that your application behaves as expected when it encounters retryable errors.</span></span> <span data-ttu-id="62bb4-333">예를 들어 응용 프로그램이 문제를 감지하면 보조 지역 및 읽기 전용 모드로 전환했다가 주 지역을 다시 사용할 수 있게 되면 다시 전환하는지 테스트해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="62bb4-333">For example, you need to test that the application switches to the secondary and into read-only mode when it detects a problem, and switches back when the primary region becomes available again.</span></span> <span data-ttu-id="62bb4-334">이렇게 하려면 재시도 가능한 오류를 시뮬레이션하고 이것이 발생하는 빈도를 제어할 수 있는 방법이 필요합니다.</span><span class="sxs-lookup"><span data-stu-id="62bb4-334">To do this, you need a way to simulate retryable errors and control how often they occur.</span></span>

<span data-ttu-id="62bb4-335">[Fiddler](http://www.telerik.com/fiddler)를 사용하면 스크립트에서 HTTP 요청을 가로채서 수정할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="62bb4-335">You can use [Fiddler](http://www.telerik.com/fiddler) to intercept and modify HTTP responses in a script.</span></span> <span data-ttu-id="62bb4-336">이 스크립트는 기본 끝점에서 오는 응답을 식별하고 HTTP 상태 코드를 저장소 클라이언트 라이브러리에서 재시도 가능한 오류로 인식하는 코드로 변경할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="62bb4-336">This script can identify responses that come from your primary endpoint and change the HTTP status code to one that the Storage Client Library recognizes as a retryable error.</span></span> <span data-ttu-id="62bb4-337">이 코드 조각은 **employeedata** 테이블에 대한 읽기 요청에 대한 응답을 가로채서 502 상태를 반환하는 Fiddler 스크립트의 간단한 예를 보여줍니다.</span><span class="sxs-lookup"><span data-stu-id="62bb4-337">This code snippet shows a simple example of a Fiddler script that intercepts responses to read requests against the **employeedata** table to return a 502 status:</span></span>

```java
static function OnBeforeResponse(oSession: Session) {
    ...
    if ((oSession.hostname == "\[yourstorageaccount\].table.core.windows.net")
      && (oSession.PathAndQuery.StartsWith("/employeedata?$filter"))) {
        oSession.responseCode = 502;
    }
}
```

<span data-ttu-id="62bb4-338">시나리오를 더 실감나게 시뮬레이션하려면 보다 광범위한 요청을 가로채서 그 중 일부에 대한 **responseCode**만 변경하도록 이 예제를 확장할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="62bb4-338">You could extend this example to intercept a wider range of requests and only change the **responseCode** on some of them to better simulate a real-world scenario.</span></span> <span data-ttu-id="62bb4-339">Fiddler 스크립트 사용자 지정에 대한 자세한 내용은 Fiddler 설명서에서 [Modifying a Request or Response](http://docs.telerik.com/fiddler/KnowledgeBase/FiddlerScript/ModifyRequestOrResponse)(요청 또는 응답 수정)를 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="62bb4-339">For more information about customizing Fiddler scripts, see [Modifying a Request or Response](http://docs.telerik.com/fiddler/KnowledgeBase/FiddlerScript/ModifyRequestOrResponse) in the Fiddler documentation.</span></span>

<span data-ttu-id="62bb4-340">응용 프로그램을 읽기 전용 모드로 전환하기 위한 임계값을 구성할 수 있으면 프로덕션이 아닌 트랜잭션 볼륨을 사용하여 보다 간편하게 동작을 테스트할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="62bb4-340">If you have made the thresholds for switching your application to read-only mode configurable, it will be easier to test the behavior with non-production transaction volumes.</span></span>

## <a name="next-steps"></a><span data-ttu-id="62bb4-341">다음 단계</span><span class="sxs-lookup"><span data-stu-id="62bb4-341">Next Steps</span></span>

* <span data-ttu-id="62bb4-342">LastSyncTime 설정 방법에 대한 다른 예제를 비롯한 읽기 액세스 지역 중복에 대한 자세한 내용은 [Windows Azure Storage 중복 작업 및 읽기 액세스 지역 중복 저장소](https://blogs.msdn.microsoft.com/windowsazurestorage/2013/12/11/windows-azure-storage-redundancy-options-and-read-access-geo-redundant-storage/)를 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="62bb4-342">For more information about Read Access Geo-Redundancy, including another example of how the LastSyncTime is set, please see [Windows Azure Storage Redundancy Options and Read Access Geo Redundant Storage](https://blogs.msdn.microsoft.com/windowsazurestorage/2013/12/11/windows-azure-storage-redundancy-options-and-read-access-geo-redundant-storage/).</span></span>

* <span data-ttu-id="62bb4-343">기본 끝점과 보조 끝점 간에 전환을 수행하는 방법을 보여주는 전체 샘플은 [Azure 샘플 – RA-GRS 저장소에서 회로 차단 패턴 사용](https://github.com/Azure-Samples/storage-dotnet-circuit-breaker-pattern-ha-apps-using-ra-grs)을 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="62bb4-343">For a complete sample showing how to make the switch back and forth between the Primary and Secondary endpoints, please see [Azure Samples – Using the Circuit Breaker Pattern with RA-GRS storage](https://github.com/Azure-Samples/storage-dotnet-circuit-breaker-pattern-ha-apps-using-ra-grs).</span></span>
