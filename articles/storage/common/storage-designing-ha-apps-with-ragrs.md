---
title: "aaaDesigning Azure 읽기 액세스 지리적 중복 저장소 (RA-GRS)를 사용 하는 항상 사용 가능한 응용 프로그램입니다. | Microsoft Docs"
description: "어떻게 toouse Azure RA-GRS 저장소 tooarchitect 유연한 항상 사용 가능한 응용 프로그램을 충분 한 toohandle 중단 합니다."
services: storage
documentationcenter: .net
author: robinsh
manager: timlt
editor: tysonn
ms.assetid: 8f040b0f-8926-4831-ac07-79f646f31926
ms.service: storage
ms.workload: storage
ms.tgt_pltfrm: na
ms.devlang: dotnet
ms.topic: article
ms.date: 1/19/2017
ms.author: robinsh
ms.openlocfilehash: e4a9fe7ef33eecd894408b3c1ef59920a248d1bd
ms.sourcegitcommit: 523283cc1b3c37c428e77850964dc1c33742c5f0
ms.translationtype: MT
ms.contentlocale: ko-KR
ms.lasthandoff: 10/06/2017
---
# <a name="designing-highly-available-applications-using-ra-grs"></a><span data-ttu-id="10ed1-103">RA-GRS를 사용하여 항상 사용 가능한 응용 프로그램 설계</span><span class="sxs-lookup"><span data-stu-id="10ed1-103">Designing Highly Available Applications using RA-GRS</span></span>

<span data-ttu-id="10ed1-104">클라우드 기반 인프라의 일반적인 기능은 응용 프로그램 호스팅을 위해 항상 사용할 수 있는 플랫폼을 제공하는 것입니다.</span><span class="sxs-lookup"><span data-stu-id="10ed1-104">A common feature of cloud-based infrastructures is that they provide a highly available platform for hosting applications.</span></span> <span data-ttu-id="10ed1-105">클라우드 기반 응용 프로그램 개발자가 고려해 야 방법을 신중 하 게 tooleverage이 플랫폼 toodeliver 항상 사용 가능한 응용 프로그램 tootheir 사용자입니다.</span><span class="sxs-lookup"><span data-stu-id="10ed1-105">Developers of cloud-based applications must consider carefully how tooleverage this platform toodeliver highly available applications tootheir users.</span></span> <span data-ttu-id="10ed1-106">본이 문서에서는 사용할 수 있는 응용 프로그램 개발자가 Azure 저장소 읽기 액세스 지역 중복 저장소 (RA-GRS) toomake hello 사용 방법에 대해서만 설명 합니다.</span><span class="sxs-lookup"><span data-stu-id="10ed1-106">This article focuses specifically on how developers can use hello Azure Storage Read Access Geo Redundant Storage (RA-GRS) toomake their applications more available.</span></span>

<span data-ttu-id="10ed1-107">중복 옵션에는 LRS(로컬 중복 저장소), ZRS(영역 중복 저장소), GRS(지역 중복 저장소) 및 RA-GRS(읽기 액세스 지역 중복 저장소)라는 네 가지 옵션이 있습니다.</span><span class="sxs-lookup"><span data-stu-id="10ed1-107">There are four choices for redundancy – LRS (Locally Redundant Storage), ZRS (Zone Redundant Storage), GRS (Geo-Redundant Storage), and RA-GRS (Read Access Geo-Redundant Storage).</span></span> <span data-ttu-id="10ed1-108">이 문서의 toodiscuss GRS 및 RA-GRS 하겠습니다.</span><span class="sxs-lookup"><span data-stu-id="10ed1-108">We are going toodiscuss GRS and RA-GRS in this article.</span></span> <span data-ttu-id="10ed1-109">Grs를 사용할 경우 3 개의 데이터 복사본이 hello 저장소 계정을 설정할 때 선택한 hello 기본 지역에 유지 됩니다.</span><span class="sxs-lookup"><span data-stu-id="10ed1-109">With GRS, three copies of your data are kept in hello primary region you selected when setting up hello storage account.</span></span> <span data-ttu-id="10ed1-110">세 개의 추가 복사본은 Azure에서 지정된 보조 지역에 비동기적으로 유지됩니다.</span><span class="sxs-lookup"><span data-stu-id="10ed1-110">Three additional copies are maintained asynchronously in a secondary region specified by Azure.</span></span> <span data-ttu-id="10ed1-111">RA-GRS는 점을 제외 하 고 있는 경우 읽기 권한 toohello 보조 복사본 GRS와 같은 작업을 hello 합니다.</span><span class="sxs-lookup"><span data-stu-id="10ed1-111">RA-GRS is hello same thing as GRS except that you have read access toohello secondary copy.</span></span> <span data-ttu-id="10ed1-112">Hello 다른 Azure 저장소 중복 옵션에 대 한 자세한 내용은 참조 [Azure 저장소 복제](https://docs.microsoft.com/en-us/azure/storage/storage-redundancy)합니다.</span><span class="sxs-lookup"><span data-stu-id="10ed1-112">For more information about hello different Azure Storage redundancy options, see [Azure Storage replication](https://docs.microsoft.com/en-us/azure/storage/storage-redundancy).</span></span> <span data-ttu-id="10ed1-113">또한 hello 복제 아티클을 hello hello 기본 지역과 보조 지역 쌍을 표시합니다.</span><span class="sxs-lookup"><span data-stu-id="10ed1-113">hello replication article also shows hello pairings of hello primary and secondary regions.</span></span>

<span data-ttu-id="10ed1-114">이 문서 및 다운로드 하 고 실행할 수 있는 hello 끝에서 링크 tooa 전체 샘플에 포함 된 코드 조각이 있습니다.</span><span class="sxs-lookup"><span data-stu-id="10ed1-114">There are code snippets included in this article, and a link tooa complete sample at hello end that you can download and run.</span></span>

## <a name="key-features-of-ra-grs"></a><span data-ttu-id="10ed1-115">RA-GRS의 주요 기능</span><span class="sxs-lookup"><span data-stu-id="10ed1-115">Key features of RA-GRS</span></span>

<span data-ttu-id="10ed1-116">방법에 대 한 하기 전에 toouse RA-GRS 저장소 속성 및 동작에 대해 살펴보겠습니다.</span><span class="sxs-lookup"><span data-stu-id="10ed1-116">Before we talk about how toouse RA-GRS storage, let's talk about its properties and behavior.</span></span>

* <span data-ttu-id="10ed1-117">보조 지역; 하면 기본 지역의에 저장 된 hello 데이터의 읽기 전용 복사본을 유지 하는 azure 저장소 위에서 언급 한 대로 hello 저장소 서비스는 hello 보조 지역의 hello 위치를 결정 합니다.</span><span class="sxs-lookup"><span data-stu-id="10ed1-117">Azure Storage maintains a read-only copy of hello data you store in your primary region in a secondary region; as noted above, hello storage service determines hello location of hello secondary region.</span></span>

* <span data-ttu-id="10ed1-118">hello 읽기 전용 복사본은 [결국 일관 된](https://en.wikipedia.org/wiki/Eventual_consistency) hello 기본 지역의 hello 데이터를 사용 합니다.</span><span class="sxs-lookup"><span data-stu-id="10ed1-118">hello read-only copy is [eventually consistent](https://en.wikipedia.org/wiki/Eventual_consistency) with hello data in hello primary region.</span></span>

* <span data-ttu-id="10ed1-119">Blob, 테이블 및 큐에 대 한 hello에 대 한 보조 영역을 쿼리할 수 있습니다는 *마지막 동기화 시간* hello 기본 toohello 보조 지역에서 복제를 마지막 hello 발생 했을 때 알려 주는 값입니다.</span><span class="sxs-lookup"><span data-stu-id="10ed1-119">For blobs, tables, and queues, you can query hello secondary region for a *Last Sync Time* value that tells you when hello last replication from hello primary toohello secondary region occurred.</span></span> <span data-ttu-id="10ed1-120">(현재 RA-GRS 중복 옵션이 없는 Azure File Storage에 대해서는 지원되지 않습니다.)</span><span class="sxs-lookup"><span data-stu-id="10ed1-120">(This is not supported for Azure File storage, which doesn't have RA-GRS redundancy at this time.)</span></span>

* <span data-ttu-id="10ed1-121">Hello 저장소 클라이언트 라이브러리 toointeract hello 기본 또는 보조 지역 중 하나에 hello 데이터와 함께 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="10ed1-121">You can use hello Storage Client Library toointeract with hello data in either hello primary or secondary region.</span></span> <span data-ttu-id="10ed1-122">또한 리디렉션할 수 읽기 요청 toohello 기본 지역 시간이 초과 되 면 읽기 요청 자동으로 toohello 보조 지역입니다.</span><span class="sxs-lookup"><span data-stu-id="10ed1-122">You can also redirect read requests automatically toohello secondary region if a read request toohello primary region times out.</span></span>

* <span data-ttu-id="10ed1-123">기본 지역의 hello hello 데이터의 hello 액세스 가능성에 영향을 주는 주요 문제 이면 hello Azure 팀은 지리적 장애 조치, 이때 toohello 기본 지역 가리키는 DNS 항목을 hello 됩니다 변경 된 toopoint toohello 보조 지역을 트리거할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="10ed1-123">If there is a major issue affecting hello accessibility of hello data in hello primary region, hello Azure team may trigger a geo-failover, at which point hello DNS entries pointing toohello primary region will be changed toopoint toohello secondary region.</span></span>

* <span data-ttu-id="10ed1-124">지리적 장애 조치 발생 하는 경우 Azure는 새 보조 위치를 선택 하 고 hello 데이터 toothat 위치 복제 다음 가리킵니다 hello 보조 DNS 항목 tooit.</span><span class="sxs-lookup"><span data-stu-id="10ed1-124">If a geo-failover occurs, Azure will select a new secondary location and replicate hello data toothat location, then point hello secondary DNS entries tooit.</span></span> <span data-ttu-id="10ed1-125">hello 보조 끝점을 hello 저장소 계정에서 복제를 완료할 때까지 사용할 수 없게 됩니다.</span><span class="sxs-lookup"><span data-stu-id="10ed1-125">hello secondary endpoint will be unavailable until hello storage account has finished replicating.</span></span> <span data-ttu-id="10ed1-126">자세한 내용은 참조 하십시오 [Azure 저장소 중단이 발생할 경우 어떤 toodo](https://docs.microsoft.com/en-us/azure/storage/storage-disaster-recovery-guidance)합니다.</span><span class="sxs-lookup"><span data-stu-id="10ed1-126">For more information, please see [What toodo if an Azure Storage outage occurs](https://docs.microsoft.com/en-us/azure/storage/storage-disaster-recovery-guidance).</span></span>

## <a name="application-design-considerations-when-using-ra-grs"></a><span data-ttu-id="10ed1-127">RA-GRS를 사용하는 경우 응용 프로그램 설계 고려 사항</span><span class="sxs-lookup"><span data-stu-id="10ed1-127">Application design considerations when using RA-GRS</span></span>

<span data-ttu-id="10ed1-128">이 문서의 주요 목적은 hello는 tooshow toodesign에서에서 계속 됩니다 toofunction (하지만 제한 된 용량) hello 주 데이터에서 중요 재해가의 hello 이벤트에도 응용 프로그램의 가운데 어떻게 있습니다.</span><span class="sxs-lookup"><span data-stu-id="10ed1-128">hello main purpose of this article is tooshow you how toodesign an application that will continue toofunction (albeit in a limited capacity) even in hello event of a major disaster at hello primary data center.</span></span> <span data-ttu-id="10ed1-129">문제가 있으면 tooread hello 보조 지역에서 전환 하 고 기본 지역 hello를 다시 사용할 수 있는 경우 되돌리십시오 여 toohandle 일시적이 응용 프로그램 또는 장기 실행 문제를 포함 하면이 작업을 수행 합니다.</span><span class="sxs-lookup"><span data-stu-id="10ed1-129">You do this by having your application toohandle transient or long-running issues by switching tooread from hello secondary region while there is a problem, and switching back when hello primary region is available again.</span></span>

### <a name="using-eventually-consistent-data"></a><span data-ttu-id="10ed1-130">결과적으로 일치하는 데이터 사용</span><span class="sxs-lookup"><span data-stu-id="10ed1-130">Using eventually consistent data</span></span>

<span data-ttu-id="10ed1-131">이 제안된 솔루션 것 이라고 가정 해도 괜 찮 tooreturn 부실 데이터 toohello 호출 응용 프로그램 일 합니다.</span><span class="sxs-lookup"><span data-stu-id="10ed1-131">This proposed solution assumes that it is okay tooreturn what could be stale data toohello calling application.</span></span> <span data-ttu-id="10ed1-132">되기 때문에 hello 보조 데이터는 결국 일치를 hello 데이터가 toohello 기본 기록 있지만 hello 업데이트 toohello 보조 복사본이 hello 기본 지역 액세스할 수 없게 된 경우 복제를 완료 하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="10ed1-132">Because hello secondary data is eventually consistent, it is possible that hello data was written toohello primary but hello update toohello secondary had not finished replicating when hello primary region became inaccessible.</span></span>

<span data-ttu-id="10ed1-133">예를 들어 고객 성공 하는 업데이트를 제출할 수 및 hello 업데이트 되기 전에 보조 전파 toohello hello 기본 다운 될 수는 다음 합니다.</span><span class="sxs-lookup"><span data-stu-id="10ed1-133">For example, your customer could submit an update that is successful, and then hello primary could go down before hello update is propagated toohello secondary.</span></span> <span data-ttu-id="10ed1-134">이 경우 다음 hello 고객 tooread hello를 다시 데이터를 요청 하면 hello 부실 데이터를 업데이트 하는 hello 데이터 대신 수신 합니다.</span><span class="sxs-lookup"><span data-stu-id="10ed1-134">In this case, if hello customer then asks tooread hello data back, he receives hello stale data instead of hello updated data.</span></span> <span data-ttu-id="10ed1-135">Hello 고객 메시지가 방법 이렇게, 그리고 있다면를 결정 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="10ed1-135">You must decide if this is acceptable, and if so, how you will message hello customer.</span></span> <span data-ttu-id="10ed1-136">보조 hello 최신 상태 이면 toocheck에서 마지막 동기화 시간에이 문서 toosee의 뒷부분에 나오는 hello 보조 데이터에 hello 하는 방법을 확인할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="10ed1-136">You'll see how toocheck hello Last Sync Time on hello secondary data later in this article toosee if hello secondary is up-to-date.</span></span>

### <a name="handling-services-separately-or-all-together"></a><span data-ttu-id="10ed1-137">서비스를 개별적으로 또는 모두 함께 처리</span><span class="sxs-lookup"><span data-stu-id="10ed1-137">Handling services separately or all together</span></span>

<span data-ttu-id="10ed1-138">동안 있지 않을 가능성이 있기 하나의 서비스 toobecome 사용할 수 없음에 대 한 hello 다른 서비스는 계속 완벽 하 게 작동 하는 동안.</span><span class="sxs-lookup"><span data-stu-id="10ed1-138">While not likely, it is possible for one service toobecome unavailable while hello other services are still fully functional.</span></span> <span data-ttu-id="10ed1-139">있습니다 수 핸들 hello 다시 시도 되 고 각각에 대해 읽기 전용 모드로 서비스를 별도로 (blob, 큐, 테이블) 또는 모든 hello 저장소 서비스에 대 한 일반적으로 재시도 함께 처리할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="10ed1-139">You can handle hello retries and read-only mode for each service separately (blobs, queues, tables), or you can handle retries generically for all hello storage services together.</span></span>

<span data-ttu-id="10ed1-140">예를 들어 응용 프로그램에서 큐 및 blob을 사용 하는 경우 이러한 각 항목에 대 한 별도 코드 toohandle 다시 시도 가능한 오류가 tooput를 결정할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="10ed1-140">For example, if you use queues and blobs in your application, you may decide tooput in separate code toohandle retryable errors for each of these.</span></span> <span data-ttu-id="10ed1-141">그런 다음 hello blob 서비스에서 다시 시도 가져오지만 hello 큐 서비스가 계속 작동 하는 경우 blob을 처리 하는 응용 프로그램의 hello 부분에만 영향을 미칩니다.</span><span class="sxs-lookup"><span data-stu-id="10ed1-141">Then if you get a retry from hello blob service, but hello queue service is still working, only hello part of your application that handles blobs will be impacted.</span></span> <span data-ttu-id="10ed1-142">결정 한 경우 toohandle 모든 저장소 서비스는 일반적으로 다시 시도 하 고 호출 toohello blob 서비스는 다시 시도 가능한 오류를 반환 합니다. 다음 요청 tooboth hello blob 서비스 및 큐 서비스 hello 영향을 받습니다.</span><span class="sxs-lookup"><span data-stu-id="10ed1-142">If you decide toohandle all storage service retries generically and a call toohello blob service returns a retryable error, then requests tooboth hello blob service and hello queue service will be impacted.</span></span>

<span data-ttu-id="10ed1-143">궁극적으로, 응용 프로그램의 hello 복잡성에 따라 다릅니다.</span><span class="sxs-lookup"><span data-stu-id="10ed1-143">Ultimately, this depends on hello complexity of your application.</span></span> <span data-ttu-id="10ed1-144">서비스에 의해 toohandle hello 실패 하지를 결정할 수 있습니다 하지만 대신 tooredirect 읽은 모든 저장소 서비스 toohello 보조 지역에 대 한 요청 hello 기본 지역에서 모든 저장소 서비스의 문제를 발견 하는 경우 읽기 전용 모드로 hello 응용 프로그램을 실행 합니다.</span><span class="sxs-lookup"><span data-stu-id="10ed1-144">You may decide not toohandle hello failures by service, but instead tooredirect read requests for all storage services toohello secondary region and run hello application in read-only mode when you detect a problem with any storage service in hello primary region.</span></span>

### <a name="other-considerations"></a><span data-ttu-id="10ed1-145">기타 고려 사항</span><span class="sxs-lookup"><span data-stu-id="10ed1-145">Other considerations</span></span>

<span data-ttu-id="10ed1-146">이러한 다른 고려 사항 hello이이 문서의 나머지 부분에 대해 설명 합니다 hello 됩니다.</span><span class="sxs-lookup"><span data-stu-id="10ed1-146">These are hello other considerations we will discuss in hello rest of this article.</span></span>

*   <span data-ttu-id="10ed1-147">Hello 회로 차단기 패턴을 사용 하 여 읽기 요청의 재시도 처리</span><span class="sxs-lookup"><span data-stu-id="10ed1-147">Handling retries of read requests using hello Circuit Breaker pattern</span></span>

*   <span data-ttu-id="10ed1-148">결국 일관 된 데이터 및 hello 마지막 동기화 시간</span><span class="sxs-lookup"><span data-stu-id="10ed1-148">Eventually-consistent data and hello Last Sync Time</span></span>

*   <span data-ttu-id="10ed1-149">테스트</span><span class="sxs-lookup"><span data-stu-id="10ed1-149">Testing</span></span>

## <a name="running-your-application-in-read-only-mode"></a><span data-ttu-id="10ed1-150">읽기 전용 모드에서 응용 프로그램 실행</span><span class="sxs-lookup"><span data-stu-id="10ed1-150">Running your application in read-only mode</span></span>

<span data-ttu-id="10ed1-151">RA-GRS 저장소 toouse 있습니다 수 toohandle 모두 실패 읽기 요청 및 업데이트 요청 수 (이 경우 삽입, 업데이트 및 삭제를 의미 하는 업데이트) 실패 했습니다.</span><span class="sxs-lookup"><span data-stu-id="10ed1-151">toouse RA-GRS storage, you must be able toohandle both failed read requests and failed update requests (with update in this case meaning inserts, updates, and deletions).</span></span> <span data-ttu-id="10ed1-152">Hello 주 데이터 센터 실패 읽기 요청에 리디렉션된 toohello 보조 데이터 센터 수는 있지만 hello 보조 읽기 전용 이므로 업데이트 요청 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="10ed1-152">If hello primary data center fails, read requests can be redirected toohello secondary data center, but update requests cannot because hello secondary is read only.</span></span> <span data-ttu-id="10ed1-153">이 따라서 몇 가지 방식으로 toorun 읽기 전용 모드에서 응용 프로그램이 필요합니다.</span><span class="sxs-lookup"><span data-stu-id="10ed1-153">For this reason, you need some way toorun your application in read-only mode.</span></span>

<span data-ttu-id="10ed1-154">예를 들어 모든 업데이트 요청 toohello 저장소 서비스에 제출 하기 전에 확인 하는 플래그를 설정할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="10ed1-154">For example, you can set a flag that will be checked before submitting any update requests toohello storage service.</span></span> <span data-ttu-id="10ed1-155">를 통해 전달 hello 업데이트 요청 중 하나 것을 건너뛰고 적절 한 응답 toohello 고객을 반환 합니다.</span><span class="sxs-lookup"><span data-stu-id="10ed1-155">When one of hello update requests comes through, you can skip it and return an appropriate response toohello customer.</span></span> <span data-ttu-id="10ed1-156">도 hello 문제가 해결 될 때까지 toodisable 특정 기능을 모두 선택 하 고 이러한 기능은 일시적으로 사용할 수 없는 사용자에 게 알릴 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="10ed1-156">You may even want toodisable certain features altogether until hello problem is resolved and notify users that those features are temporarily unavailable.</span></span>

<span data-ttu-id="10ed1-157">각 서비스에 대 한 toohandle 오류를 별도로 결정 해야 합니다 toohandle hello 기능 toorun 읽기 전용 모드에서 응용 프로그램 서비스에 의해 합니다.</span><span class="sxs-lookup"><span data-stu-id="10ed1-157">If you decide toohandle errors for each service separately, you will also need toohandle hello ability toorun your application in read-only mode by service.</span></span> <span data-ttu-id="10ed1-158">사용할 수 있는 각 서비스에 대 한 읽기 전용 플래그를 지정할 수 있습니다 및 사용 안 함 및 핸들 hello hello 코드의 적절 한 위치에서 적절 한 플래그입니다.</span><span class="sxs-lookup"><span data-stu-id="10ed1-158">You could have read-only flags for each service that can be enabled and disabled and handle hello appropriate flag in hello appropriate places in your code.</span></span>

<span data-ttu-id="10ed1-159">읽기 전용 모드에서 응용 프로그램에 다른 부수적인 혜택 – 제공 수 toorun 되 고 hello 기능 tooensure 주요 응용 프로그램 업그레이드를 사용 하는 동안 기능을 제한 합니다.</span><span class="sxs-lookup"><span data-stu-id="10ed1-159">Being able toorun your application in read-only mode has another side benefit – it gives you hello ability tooensure limited functionality during a major application upgrade.</span></span> <span data-ttu-id="10ed1-160">업그레이드를 수행 하는 동안 hello 기본 지역의 hello 데이터에 액세스 하는 사람이 보장 읽기 전용 모드 및 지점이 toohello 보조 데이터 센터에서 응용 프로그램 toorun 프로그램 트리거할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="10ed1-160">You can trigger your application toorun in read-only mode and point toohello secondary data center, ensuring nobody is accessing hello data in hello primary region while you're making upgrades.</span></span>

## <a name="handling-updates-when-running-in-read-only-mode"></a><span data-ttu-id="10ed1-161">읽기 전용 모드에서 실행하는 경우 업데이트 처리</span><span class="sxs-lookup"><span data-stu-id="10ed1-161">Handling updates when running in read-only mode</span></span>

<span data-ttu-id="10ed1-162">여러 가지 방법으로 읽기 전용 모드에서 실행할 때 toohandle 업데이트를 요청 합니다.</span><span class="sxs-lookup"><span data-stu-id="10ed1-162">There are many ways toohandle update requests when running in read-only mode.</span></span> <span data-ttu-id="10ed1-163">이 내용에 대해서는 포괄적인 경우 대신 일반적인 경우와 몇 가지 고려해야 할 패턴을 언급하겠습니다.</span><span class="sxs-lookup"><span data-stu-id="10ed1-163">We won't cover this comprehensively, but generally, there are a couple of patterns that you consider.</span></span>

1.  <span data-ttu-id="10ed1-164">Tooyour 사용자 응답할 수 있으며 현재 업데이트를 수락 하지 않습니다을 설명할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="10ed1-164">You can respond tooyour user and tell them you are not currently accepting updates.</span></span> <span data-ttu-id="10ed1-165">예를 들어 연락처 관리 시스템 고객 tooaccess 연락처 정보를 사용 하도록 설정 수 있지만 업데이트를 확인 하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="10ed1-165">For example, a contact management system could enable customers tooaccess contact information but not make updates.</span></span>

2.  <span data-ttu-id="10ed1-166">업데이트를 다른 지역의 큐에 넣을 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="10ed1-166">You can enqueue your updates in another region.</span></span> <span data-ttu-id="10ed1-167">이 경우 있습니다는 보류 중인 업데이트 요청 tooa 큐 다른 지역에 작성 한 다음 방식으로 tooprocess 이러한 요청 hello 기본 데이터 센터를 다시 온라인 상태로 돌아온 후.</span><span class="sxs-lookup"><span data-stu-id="10ed1-167">In this case, you would write your pending update requests tooa queue in a different region, and then have a way tooprocess those requests after hello primary data center comes online again.</span></span> <span data-ttu-id="10ed1-168">이 시나리오에서 요청 하는 hello 업데이트는 나중에 처리에 대 한 큐에 대기 알고 hello 고객을 알려야 합니다.</span><span class="sxs-lookup"><span data-stu-id="10ed1-168">In this scenario, you should let hello customer know that hello update requested is queued for later processing.</span></span>

3.  <span data-ttu-id="10ed1-169">업데이트 tooa 저장소 계정이 다른 지역에 작성할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="10ed1-169">You can write your updates tooa storage account in another region.</span></span> <span data-ttu-id="10ed1-170">다음 경우 hello 기본 데이터 센터 온라인 상태가 되 면 할 수 있습니다 방식으로 toomerge hello hello 데이터 구조에 따라 hello 기본 데이터에 해당 업데이트 합니다.</span><span class="sxs-lookup"><span data-stu-id="10ed1-170">Then when hello primary data center comes back online, you can have a way toomerge those updates into hello primary data, depending on hello structure of hello data.</span></span> <span data-ttu-id="10ed1-171">예를 들어 hello 이름에 날짜/시간 스탬프와 별도 파일을 만드는 경우 해당 파일 백 toohello 기본 지역으로 복사할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="10ed1-171">For example, if you are creating separate files with a date/time stamp in hello name, you can copy those files back toohello primary region.</span></span> <span data-ttu-id="10ed1-172">이러한 방식은 로깅 및 iOT 데이터와 같은 워크로드에 적합합니다.</span><span class="sxs-lookup"><span data-stu-id="10ed1-172">This works for some workloads such as logging and iOT data.</span></span>

## <a name="handling-retries"></a><span data-ttu-id="10ed1-173">다시 시도 처리</span><span class="sxs-lookup"><span data-stu-id="10ed1-173">Handling retries</span></span>

<span data-ttu-id="10ed1-174">어떤 오류를 다시 시도할 수 있는지 어떻게 할 수 있을까요?</span><span class="sxs-lookup"><span data-stu-id="10ed1-174">How do you know which errors are retryable?</span></span> <span data-ttu-id="10ed1-175">이 hello 저장소 클라이언트 라이브러리에 의해 결정 됩니다.</span><span class="sxs-lookup"><span data-stu-id="10ed1-175">This is determined by hello storage client library.</span></span> <span data-ttu-id="10ed1-176">예를 들어 404 오류 (리소스를 찾을 수 없습니다.) 없는 경우 다시 시도할 수 아니므로 것을 다시 시도의 성공 가능성 tooresult</span><span class="sxs-lookup"><span data-stu-id="10ed1-176">For example, a 404 error (resource not found) is not retryable because retrying it is not likely tooresult in success.</span></span> <span data-ttu-id="10ed1-177">Hello를 500 오류는 다시 시도할 수 때문에 서버 오류를 일시적인 문제가 단순히는 것입니다.</span><span class="sxs-lookup"><span data-stu-id="10ed1-177">On hello other hand, a 500 error is retryable because it is a server error, and it may simply be a transient issue.</span></span> <span data-ttu-id="10ed1-178">자세한 내용은 체크 아웃 hello [hello ExponentialRetry 클래스에 대 한 소스 코드를 열고](https://github.com/Azure/azure-storage-net/blob/87b84b3d5ee884c7adc10e494e2c7060956515d0/Lib/Common/RetryPolicies/ExponentialRetry.cs) hello.NET 저장소 클라이언트 라이브러리의 합니다.</span><span class="sxs-lookup"><span data-stu-id="10ed1-178">For more details, check out hello [open source code for hello ExponentialRetry class](https://github.com/Azure/azure-storage-net/blob/87b84b3d5ee884c7adc10e494e2c7060956515d0/Lib/Common/RetryPolicies/ExponentialRetry.cs) in hello .NET storage client library.</span></span> <span data-ttu-id="10ed1-179">(ShouldRetry 메서드 hello에 대 한 확인).</span><span class="sxs-lookup"><span data-stu-id="10ed1-179">(Look for hello ShouldRetry method.)</span></span>

### <a name="read-requests"></a><span data-ttu-id="10ed1-180">읽기 요청</span><span class="sxs-lookup"><span data-stu-id="10ed1-180">Read requests</span></span>

<span data-ttu-id="10ed1-181">기본 저장소에 문제가 읽기 요청 리디렉션된 toosecondary 저장 될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="10ed1-181">Read requests can be redirected toosecondary storage if there is a problem with primary storage.</span></span> <span data-ttu-id="10ed1-182">에 앞서 언급 같이 [를 사용 하 여 결국 일관 된 데이터](#using-eventually-consistent-data), 응용 프로그램 toopotentially 부실 데이터를 읽을 수용 가능 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="10ed1-182">As noted above in [Using Eventually Consistent Data](#using-eventually-consistent-data), it must be acceptable for your application toopotentially read stale data.</span></span> <span data-ttu-id="10ed1-183">Hello 저장소 클라이언트 라이브러리 tooaccess RA-GRS 데이터를 사용 하는 경우 hello에 대 한 값을 설정 하 여 hello 다시 시도 동작이 읽기 요청을 지정할 수 있습니다 **LocationMode** 속성 tooone hello 다음 중:</span><span class="sxs-lookup"><span data-stu-id="10ed1-183">If you are using hello storage client library tooaccess RA-GRS data, you can specify hello retry behavior of a read request by setting a value for hello **LocationMode** property tooone of hello following:</span></span>

*   <span data-ttu-id="10ed1-184">**Primaryonly에 따라** (기본 hello)</span><span class="sxs-lookup"><span data-stu-id="10ed1-184">**PrimaryOnly** (hello default)</span></span>

*   <span data-ttu-id="10ed1-185">**PrimaryThenSecondary**</span><span class="sxs-lookup"><span data-stu-id="10ed1-185">**PrimaryThenSecondary**</span></span>

*   <span data-ttu-id="10ed1-186">**SecondaryOnly**</span><span class="sxs-lookup"><span data-stu-id="10ed1-186">**SecondaryOnly**</span></span>

*   <span data-ttu-id="10ed1-187">**SecondaryThenPrimary**</span><span class="sxs-lookup"><span data-stu-id="10ed1-187">**SecondaryThenPrimary**</span></span>

<span data-ttu-id="10ed1-188">Hello를 설정 하는 경우 **LocationMode** 너무**PrimaryThenSecondary**hello 초기 요청 toohello 기본 끝점이 오류로 실패, hello 클라이언트에 자동으로 다른 읽기는 읽기, toohello 보조 끝점을 요청 합니다.</span><span class="sxs-lookup"><span data-stu-id="10ed1-188">When you set hello **LocationMode** too**PrimaryThenSecondary**, if hello initial read request toohello primary endpoint fails with a retryable error, hello client automatically makes another read request toohello secondary endpoint.</span></span> <span data-ttu-id="10ed1-189">Hello 오류는 서버 시간 초과, 다음 hello 클라이언트 경우 toowait timeout tooexpire hello에 대 한 다시 시도 가능한 오류가 hello 서비스에서 받기 전에 있습니다.</span><span class="sxs-lookup"><span data-stu-id="10ed1-189">If hello error is a server timeout, then hello client will have toowait for hello timeout tooexpire before it receives a retryable error from hello service.</span></span>

<span data-ttu-id="10ed1-190">결정할 때 기본적으로 두 가지 시나리오 tooconsider 사항이 어떻게 toorespond tooa 다시 시도 가능한 오류:</span><span class="sxs-lookup"><span data-stu-id="10ed1-190">There are basically two scenarios tooconsider when you are deciding how toorespond tooa retryable error:</span></span>

*   <span data-ttu-id="10ed1-191">격리 된 문제 이며 후속 요청 toohello 기본 끝점 오류로 반환 하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="10ed1-191">This is an isolated problem and subsequent requests toohello primary endpoint will not return a retryable error.</span></span> <span data-ttu-id="10ed1-192">이런 경우가 발생할 수 있는 예는 일시적인 네트워크 오류가 있는 경우입니다.</span><span class="sxs-lookup"><span data-stu-id="10ed1-192">An example of where this might happen is when there is a transient network error.</span></span>

    <span data-ttu-id="10ed1-193">이 시나리오에서는 있는 상당한 성능 저하는 없으며 있는에서 **LocationMode** 도**PrimaryThenSecondary** 만 이런 상황이 발생 빈도가으로 합니다.</span><span class="sxs-lookup"><span data-stu-id="10ed1-193">In this scenario, there is no significant performance penalty in having **LocationMode** set too**PrimaryThenSecondary** as this only happens infrequently.</span></span>

*   <span data-ttu-id="10ed1-194">이 hello 기본 지역의 hello 저장소 서비스 중 하나 이상에 문제가 및 모든 후속 요청 toothat 서비스 hello 기본 지역에 가능성이 tooreturn 다시 시도 가능한 오류 일정 기간에 대 한 합니다.</span><span class="sxs-lookup"><span data-stu-id="10ed1-194">This is a problem with at least one of hello storage services in hello primary region and all subsequent requests toothat service in hello primary region are likely tooreturn retryable errors for a period of time.</span></span> <span data-ttu-id="10ed1-195">이러한 예로 hello 기본 지역 완전히 액세스할 수 없는 경우입니다.</span><span class="sxs-lookup"><span data-stu-id="10ed1-195">An example of this is if hello primary region is completely inaccessible.</span></span>

    <span data-ttu-id="10ed1-196">이 시나리오에서 성능이 저하 되므로 모든 읽기 요청이 됩니다 hello 기본 끝점을 먼저 시도, hello timeout tooexpire 될 때까지 기다린 후 전환 toohello 보조 끝점입니다.</span><span class="sxs-lookup"><span data-stu-id="10ed1-196">In this scenario, there is a performance penalty because all your read requests will try hello primary endpoint first, wait for hello timeout tooexpire, then switch toohello secondary endpoint.</span></span>

<span data-ttu-id="10ed1-197">이러한 시나리오에 대 한 식별 해야 있는지 hello 기본 끝점으로 진행 중인 문제가 되 고 toohello 보조 끝점을 설정 하 여 hello 직접 모든 읽기 요청을 보낼 **LocationMode** 속성 너무 **SecondaryOnly**합니다.</span><span class="sxs-lookup"><span data-stu-id="10ed1-197">For these scenarios, you should identify that there is an ongoing issue with hello primary endpoint and send all read requests directly toohello secondary endpoint by setting hello **LocationMode** property too**SecondaryOnly**.</span></span> <span data-ttu-id="10ed1-198">이번에 읽기 전용 모드에서 응용 프로그램 toorun hello를 변경 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="10ed1-198">At this time, you should also change hello application toorun in read-only mode.</span></span> <span data-ttu-id="10ed1-199">이 방법은 hello 라고 [회로 차단기 패턴](https://msdn.microsoft.com/library/dn589784.aspx)합니다.</span><span class="sxs-lookup"><span data-stu-id="10ed1-199">This approach is known as hello [Circuit Breaker Pattern](https://msdn.microsoft.com/library/dn589784.aspx).</span></span>

### <a name="update-requests"></a><span data-ttu-id="10ed1-200">업데이트 요청</span><span class="sxs-lookup"><span data-stu-id="10ed1-200">Update requests</span></span>

<span data-ttu-id="10ed1-201">hello 회로 차단기 패턴에 적용 된 tooupdate 요청 될 수도 있습니다.</span><span class="sxs-lookup"><span data-stu-id="10ed1-201">hello Circuit Breaker pattern can also be applied tooupdate requests.</span></span> <span data-ttu-id="10ed1-202">그러나 업데이트 요청에 리디렉션된 toosecondary 저장소는 읽기 전용를 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="10ed1-202">However, update requests cannot be redirected toosecondary storage, which is read-only.</span></span> <span data-ttu-id="10ed1-203">이러한 요청에 대 한 유지 해야 합니다. hello **LocationMode** 속성이 너무 설정**primaryonly에 따라** (기본 hello).</span><span class="sxs-lookup"><span data-stu-id="10ed1-203">For these requests, you should leave hello **LocationMode** property set too**PrimaryOnly** (hello default).</span></span> <span data-ttu-id="10ed1-204">toohandle 이러한 오류 행 –에 10 개의 오류와 같은 메트릭 toothese 요청-를 적용 하 고 임계값이 충족 되 면 hello 응용 프로그램을 읽기 전용 모드로 전환할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="10ed1-204">toohandle these errors, you can apply a metric toothese requests – such as 10 failures in a row – and when your threshold is met, switch hello application into read-only mode.</span></span> <span data-ttu-id="10ed1-205">사용할 수 있습니다 hello 회로 차단기 패턴에 대 한 hello 다음 섹션에서 아래 설명 된 것과 tooupdate 모드를 반환 하는 데 동일한 방법을 hello 합니다.</span><span class="sxs-lookup"><span data-stu-id="10ed1-205">You can use hello same methods for returning tooupdate mode as those described below in hello next section about hello Circuit Breaker pattern.</span></span>

## <a name="circuit-breaker-pattern"></a><span data-ttu-id="10ed1-206">회로 차단기 패턴</span><span class="sxs-lookup"><span data-stu-id="10ed1-206">Circuit Breaker pattern</span></span>

<span data-ttu-id="10ed1-207">Hello 회로 차단기 패턴을 사용 하 여 응용 프로그램에서 반복 해 서 가능성이 toofail은 작업을 다시 시도해도 별다른 방지할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="10ed1-207">Using hello Circuit Breaker pattern in your application can prevent it from retrying an operation that is likely toofail repeatedly.</span></span> <span data-ttu-id="10ed1-208">지 수 적으로 hello 작업을 다시 시도 하는 동안 시간을 차지 하는 것이 아니라 응용 프로그램 toocontinue toorun hello 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="10ed1-208">It allows hello application toocontinue toorun rather than taking up time while hello operation is retried exponentially.</span></span> <span data-ttu-id="10ed1-209">또한 hello 오류 수정 되 면, 시간 hello 응용 프로그램을 hello 작업을 다시 시도할 수를 검색 합니다.</span><span class="sxs-lookup"><span data-stu-id="10ed1-209">It also detects when hello fault has been fixed, at which time hello application can try hello operation again.</span></span>

### <a name="how-tooimplement-hello-circuit-breaker-pattern"></a><span data-ttu-id="10ed1-210">어떻게 tooimplement hello 회로 차단기 패턴</span><span class="sxs-lookup"><span data-stu-id="10ed1-210">How tooimplement hello circuit breaker pattern</span></span>

<span data-ttu-id="10ed1-211">tooidentify는 진행 중인 문제가 기본 끝점, hello 클라이언트에서 다시 시도 가능한 오류가 발생 하는 빈도 모니터링할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="10ed1-211">tooidentify that there is an ongoing problem with a primary endpoint, you can monitor how frequently hello client encounters retryable errors.</span></span> <span data-ttu-id="10ed1-212">Toodecide 있는 각각의 경우 다르기 때문에 hello 임계값에 toouse hello 의사 결정 tooswitch toohello 보조 끝점에 대 한을 읽기 전용 모드로 hello 응용 프로그램을 실행 합니다.</span><span class="sxs-lookup"><span data-stu-id="10ed1-212">Because each case is different, you have toodecide on hello threshold you want toouse for hello decision tooswitch toohello secondary endpoint and run hello application in read-only mode.</span></span> <span data-ttu-id="10ed1-213">예를 들어 없는 성공 사용 하 여 행 10 오류가 발생 하는 경우 tooperform hello 스위치를 결정할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="10ed1-213">For example, you could decide tooperform hello switch if there are 10 failures in a row with no successes.</span></span> <span data-ttu-id="10ed1-214">또 다른 예로 2 분 동안에서 hello 요청의 90% 실패 하는 경우 tooswitch 합니다.</span><span class="sxs-lookup"><span data-stu-id="10ed1-214">Another example is tooswitch if 90% of hello requests in a 2-minute period fail.</span></span>

<span data-ttu-id="10ed1-215">Hello 첫 번째 시나리오에서는 단순히 hello 오류 개수 등에 도달 하기 전에 성공 최대, 설정 hello count 백 toozero hello 없을 경우.</span><span class="sxs-lookup"><span data-stu-id="10ed1-215">For hello first scenario, you can simply keep a count of hello failures, and if there is a success before reaching hello maximum, set hello count back toozero.</span></span> <span data-ttu-id="10ed1-216">Hello 두 번째 시나리오에 대 한 한 가지 방법은 tooimplement toouse는 hello MemoryCache 개체 (.NET).</span><span class="sxs-lookup"><span data-stu-id="10ed1-216">For hello second scenario, one way tooimplement it is toouse hello MemoryCache object (in .NET).</span></span> <span data-ttu-id="10ed1-217">각 요청에 대 한 CacheItem toohello 캐시 추가 hello 값 toosuccess (1) 또는 실패 (0)을 설정한 hello 만료 시간 too2 분 지금 (또는 시간 제한 무엇이)에서 설정 합니다.</span><span class="sxs-lookup"><span data-stu-id="10ed1-217">For each request, add a CacheItem toohello cache, set hello value toosuccess (1) or fail (0), and set hello expiration time too2 minutes from now (or whatever your time constraint is).</span></span> <span data-ttu-id="10ed1-218">항목의 만료 시간에 도달 하면 hello 항목이 자동으로 제거 됩니다.</span><span class="sxs-lookup"><span data-stu-id="10ed1-218">When an entry's expiration time is reached, hello entry is automatically removed.</span></span> <span data-ttu-id="10ed1-219">이렇게 하면 2분 기간으로 롤링하게 됩니다.</span><span class="sxs-lookup"><span data-stu-id="10ed1-219">This will give you a rolling 2-minute window.</span></span> <span data-ttu-id="10ed1-220">요청 toohello 저장소 서비스를 만들 때마다 먼저 쿼리를 사용 Linq hello MemoryCache 개체 toocalculate hello 성공 백분율 간에 hello 값 합계를 구하고 hello 수로 나누어 여 합니다.</span><span class="sxs-lookup"><span data-stu-id="10ed1-220">Each time you make a request toohello storage service, you first use a Linq query across hello MemoryCache object toocalculate hello percent success by summing hello values and dividing by hello count.</span></span> <span data-ttu-id="10ed1-221">Hello 성공 백분율 (예: 10%) 일부 임계값 아래로 떨어지면 설정 hello **LocationMode** 속성에 대 한 읽기 요청을 너무**SecondaryOnly** hello 응용 프로그램을 하기 전에 읽기 전용 모드로 전환 계속 진행 합니다.</span><span class="sxs-lookup"><span data-stu-id="10ed1-221">When hello percent success drops below some threshold (such as 10%), set hello **LocationMode** property for read requests too**SecondaryOnly** and switch hello application into read-only mode before continuing.</span></span>

<span data-ttu-id="10ed1-222">오류의 hello 임계값 toodetermine를 사용할 toomake hello 스위치 구성 가능한 매개 변수를 만들어 고려해 야 하므로 응용 프로그램에서 서비스 tooservice에서 달라질 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="10ed1-222">hello threshold of errors used toodetermine when toomake hello switch may vary from service tooservice in your application, so you should consider making them configurable parameters.</span></span> <span data-ttu-id="10ed1-223">이기도 toohandle 각 서비스에서 다시 시도 가능한 오류를 별도로 결정 하는 경우 또는 1로, 이전에 설명한 대로 합니다.</span><span class="sxs-lookup"><span data-stu-id="10ed1-223">This is also where you decide toohandle retryable errors from each service separately or as one, as discussed previously.</span></span>

<span data-ttu-id="10ed1-224">또 다른 고려 사항은 어떻게 toohandle 응용 프로그램의 여러 인스턴스 및 다시 시도 가능한 오류 각 인스턴스를 검색 하는 경우 어떤 toodo 합니다.</span><span class="sxs-lookup"><span data-stu-id="10ed1-224">Another consideration is how toohandle multiple instances of an application, and what toodo when you detect retryable errors in each instance.</span></span> <span data-ttu-id="10ed1-225">예를 들어 20 대의 Vm 동일한 응용 프로그램이 로드 하는 hello로 실행을 할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="10ed1-225">For example, you may have 20 VMs running with hello same application loaded.</span></span> <span data-ttu-id="10ed1-226">각 인스턴스를 별도로 처리할까요?</span><span class="sxs-lookup"><span data-stu-id="10ed1-226">Do you handle each instance separately?</span></span> <span data-ttu-id="10ed1-227">하나의 인스턴스가 시작 하는 데 문제가, toolimit hello 응답 toojust 하나 들어 아니면 tootry toohave 원하는 경우 모든 인스턴스 hello에 동일한 방식으로 때 응답 인스턴스 하나에 문제가 있습니까?</span><span class="sxs-lookup"><span data-stu-id="10ed1-227">If one instance starts having problems, do you want toolimit hello response toojust that one instance, or do you want tootry toohave all instances respond in hello same way when one instance has a problem?</span></span> <span data-ttu-id="10ed1-228">Hello 인스턴스를 별도로 처리 하는 것이 toocoordinate hello 응답을 것 보다 훨씬 더 간단 하지만이 방법은 응용 프로그램의 아키텍처에 따라 달라 집니다.</span><span class="sxs-lookup"><span data-stu-id="10ed1-228">Handling hello instances separately is much simpler than trying toocoordinate hello response across them, but how you do this depends on your application's architecture.</span></span>

### <a name="options-for-monitoring-hello-error-frequency"></a><span data-ttu-id="10ed1-229">Hello 오류 주파수 모니터링 옵션</span><span class="sxs-lookup"><span data-stu-id="10ed1-229">Options for monitoring hello error frequency</span></span>

<span data-ttu-id="10ed1-230">세 가지 옵션이 있습니다 주 toohello 보조 지역 및 변경 tooswitch hello 읽기 전용 모드에서 응용 프로그램 toorun 때 hello 주파수 hello 기본 지역의 순서 toodetermine에 다시 시도 모니터링 합니다.</span><span class="sxs-lookup"><span data-stu-id="10ed1-230">You have three main options for monitoring hello frequency of retries in hello primary region in order toodetermine when tooswitch over toohello secondary region and change hello application toorun in read-only mode.</span></span>

*   <span data-ttu-id="10ed1-231">Hello에 대 한 처리기를 추가 [ **다시 시도 중** ](http://msdn.microsoft.com/en-us/library/microsoft.windowsazure.storage.operationcontext.retrying.aspx) hello에 이벤트 [ **OperationContext** ](http://msdn.microsoft.com/en-us/library/microsoft.windowsazure.storage.operationcontext.aspx) tooyour 저장소 요청을 전달 하면 –이 hello 개체 메서드가이 문서에 표시 되며 hello 함께 나타날 샘플에에서 사용 합니다.</span><span class="sxs-lookup"><span data-stu-id="10ed1-231">Add a handler for hello [**Retrying**](http://msdn.microsoft.com/en-us/library/microsoft.windowsazure.storage.operationcontext.retrying.aspx) event on hello [**OperationContext**](http://msdn.microsoft.com/en-us/library/microsoft.windowsazure.storage.operationcontext.aspx) object you pass tooyour storage requests – this is hello method displayed in this article and used in hello accompanying sample.</span></span> <span data-ttu-id="10ed1-232">Hello 클라이언트는 요청을 다시 시도할 때마다이 이벤트가 발생, 수 있게 해 주는 tootrack 얼마나 자주 hello 클라이언트 기본 끝점에 다시 시도 가능한 오류가 발생 합니다.</span><span class="sxs-lookup"><span data-stu-id="10ed1-232">These events fire whenever hello client retries a request, enabling you tootrack how often hello client encounters retryable errors on a primary endpoint.</span></span>

    ```csharp 
    operationContext.Retrying += (sender, arguments) =>
    {
        // Retrying in hello primary region
        if (arguments.Request.Host == primaryhostname)
            ...
    };
    ```

*   <span data-ttu-id="10ed1-233">Hello에 [ **평가** ](http://msdn.microsoft.com/en-us/library/microsoft.windowsazure.storage.retrypolicies.iextendedretrypolicy.evaluate.aspx) 사용자 지정 다시 시도 정책에 대 한 메서드를 다시 시도 하 여 수행 될 때마다 사용자 지정 코드를 실행할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="10ed1-233">In hello [**Evaluate**](http://msdn.microsoft.com/en-us/library/microsoft.windowsazure.storage.retrypolicies.iextendedretrypolicy.evaluate.aspx) method in a custom retry policy, you can run custom code whenever a retry takes place.</span></span> <span data-ttu-id="10ed1-234">다시 시도 하 여 경우 기회 toomodify 다시 시도 동작이 hello 제공도 또한 toorecording에 있습니다.</span><span class="sxs-lookup"><span data-stu-id="10ed1-234">In addition toorecording when a retry happens, this also gives you hello opportunity toomodify your retry behavior.</span></span>

    ```csharp 
    public RetryInfo Evaluate(RetryContext retryContext,
    OperationContext operationContext)
    {
        var statusCode = retryContext.LastRequestResult.HttpStatusCode;
        if (retryContext.CurrentRetryCount >= this.maximumAttempts
        || ((statusCode &gt;= 300 && statusCode &lt; 500 && statusCode != 408)
        || statusCode == 501 // Not Implemented
        || statusCode == 505 // Version Not Supported
            ))
        {
        // Do not retry
            return null;
        }

        // Monitor retries in hello primary location
        ...

        // Determine RetryInterval and TargetLocation
        RetryInfo info =
            CreateRetryInfo(retryContext.CurrentRetryCount);

        return info;
    }
    ```

*   <span data-ttu-id="10ed1-235">hello 세 번째 방법은 tooimplement 지속적으로 더미 사용 하 여 기본 저장소 끝점을 ping 하는 응용 프로그램에서 사용자 지정 모니터링 구성 요소 읽기 요청 (예: 소규모 blob을 읽는 중) toodetermine의 상태입니다.</span><span class="sxs-lookup"><span data-stu-id="10ed1-235">hello third approach is tooimplement a custom monitoring component in your application that continually pings your primary storage endpoint with dummy read requests (such as reading a small blob) toodetermine its health.</span></span> <span data-ttu-id="10ed1-236">이렇게 하려면 리소스가 소비되지만 그 양은 많지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="10ed1-236">This would take up some resources, but not a significant amount.</span></span> <span data-ttu-id="10ed1-237">임계값에 도달 하는 문제가 발견 되는 경우 다음 수행 hello 스위치 너무**SecondaryOnly** 및 읽기 전용 모드입니다.</span><span class="sxs-lookup"><span data-stu-id="10ed1-237">When a problem is discovered that reaches your threshold, you would then perform hello switch too**SecondaryOnly** and read-only mode.</span></span>

<span data-ttu-id="10ed1-238">어느 시점 부터는 tooswitch 백 toousing hello에 대 한 기본 끝점 및 업데이트 허용 합니다.</span><span class="sxs-lookup"><span data-stu-id="10ed1-238">At some point, you will want tooswitch back toousing hello primary endpoint and allowing updates.</span></span> <span data-ttu-id="10ed1-239">위에 나열 된 hello 처음 두 방법 중 하나를 사용 하는 경우 수을 하기만 하면 뒤로 toohello 기본 끝점을 전환 작업의 수 또는 임의로 선택 된 시간 만큼 수행 된 후 업데이트 모드를 사용 하도록 설정 합니다.</span><span class="sxs-lookup"><span data-stu-id="10ed1-239">If using one of hello first two methods listed above, you could simply switch back toohello primary endpoint and enable update mode after an arbitrarily selected amount of time or number of operations has been performed.</span></span> <span data-ttu-id="10ed1-240">Hello 재시도 논리를 통해 다시 버릴 수 수 있습니다 있습니다.</span><span class="sxs-lookup"><span data-stu-id="10ed1-240">You can then let it go through hello retry logic again.</span></span> <span data-ttu-id="10ed1-241">Hello 문제가 해결 되었는지 toouse hello에 대 한 기본 끝점을 계속 되며 업데이트를 허용 합니다.</span><span class="sxs-lookup"><span data-stu-id="10ed1-241">If hello problem has been fixed, it will continue toouse hello primary endpoint and allow updates.</span></span> <span data-ttu-id="10ed1-242">문제가 계속 되 면 한 번 더 전환지 것입니다 백 toohello 보조 끝점 및 읽기 전용 모드 hello 조건을 설정 하면 실패 한 후.</span><span class="sxs-lookup"><span data-stu-id="10ed1-242">If there is still a problem, it will once more switch back toohello secondary endpoint and read-only mode after failing hello criteria you've set.</span></span>

<span data-ttu-id="10ed1-243">Hello 세 번째 시나리오에 대 한 핑 hello 기본 저장소 끝점 다시, 성공적인 해지면를 트리거할 수 있습니다 hello 스위치 다시 너무**primaryonly에 따라** 하 고 계속 업데이트를 허용 합니다.</span><span class="sxs-lookup"><span data-stu-id="10ed1-243">For hello third scenario, when pinging hello primary storage endpoint becomes successful again, you can trigger hello switch back too**PrimaryOnly** and continue allowing updates.</span></span>

## <a name="handling-eventually-consistent-data"></a><span data-ttu-id="10ed1-244">결과적으로 일치하는 데이터 처리</span><span class="sxs-lookup"><span data-stu-id="10ed1-244">Handling eventually consistent data</span></span>

<span data-ttu-id="10ed1-245">RA-GRS 트랜잭션을 hello 기본 toohello 보조 지역에서 복제 하 여 작동 합니다.</span><span class="sxs-lookup"><span data-stu-id="10ed1-245">RA-GRS works by replicating transactions from hello primary toohello secondary region.</span></span> <span data-ttu-id="10ed1-246">이 복제 프로세스 hello 보조 영역에 있는 hello 데이터 임을 보장 *결국 일관 된*합니다.</span><span class="sxs-lookup"><span data-stu-id="10ed1-246">This replication process guarantees that hello data in hello secondary region is *eventually consistent*.</span></span> <span data-ttu-id="10ed1-247">이 있을 수 있음을 지연 현상이 발생 하기 전에 하지만 hello 기본 지역에 있는 모든 hello 트랜잭션을 결국 hello 보조 영역에 표시 됨을 의미 하 고는 보장은 없습니다 hello 트랜잭션이 동일한 순서와 hello에 hello 보조 지역에 도착 원래 적용 된 hello 기본 지역에서입니다.</span><span class="sxs-lookup"><span data-stu-id="10ed1-247">This means that all hello transactions in hello primary region will eventually appear in hello secondary region, but that there may be a lag before they appear, and that there is no guarantee hello transactions arrive in hello secondary region in hello same order as that in which they were originally applied in hello primary region.</span></span> <span data-ttu-id="10ed1-248">거래 순서를 다르게 hello 보조 지역에 도착 하는 경우 있습니다 *수* hello 서비스에서 처리할 때까지 데이터에 일관성이 없는 상태에 hello 보조 지역 toobe 것이 좋습니다.</span><span class="sxs-lookup"><span data-stu-id="10ed1-248">If your transactions arrive in hello secondary region out of order, you *may* consider your data in hello secondary region toobe in an inconsistent state until hello service catches up.</span></span>

<span data-ttu-id="10ed1-249">hello 다음 표에서 모양의 예제가 나와 직원 toomake의 hello 세부 정보를 업데이트 하는 경우 어떻게 될 그녀는 hello 소속 *관리자* 역할입니다.</span><span class="sxs-lookup"><span data-stu-id="10ed1-249">hello following table shows an example of what might happen when you update hello details of an employee toomake her a member of hello *administrators* role.</span></span> <span data-ttu-id="10ed1-250">이 예의 hello 위해서이 위해서는 hello 업데이트 **직원** 엔터티와 업데이트는 **관리자 역할** hello 관리자의 총 수와 함께 엔터티.</span><span class="sxs-lookup"><span data-stu-id="10ed1-250">For hello sake of this example, this requires you update hello **employee** entity and update an **administrator role** entity with a count of hello total number of administrators.</span></span> <span data-ttu-id="10ed1-251">Hello 업데이트 적용 순서가 hello 보조 지역에 확인 합니다.</span><span class="sxs-lookup"><span data-stu-id="10ed1-251">Notice how hello updates are applied out of order in hello secondary region.</span></span>

| <span data-ttu-id="10ed1-252">**Time**</span><span class="sxs-lookup"><span data-stu-id="10ed1-252">**Time**</span></span> | <span data-ttu-id="10ed1-253">**트랜잭션**</span><span class="sxs-lookup"><span data-stu-id="10ed1-253">**Transaction**</span></span>                                            | <span data-ttu-id="10ed1-254">**복제**</span><span class="sxs-lookup"><span data-stu-id="10ed1-254">**Replication**</span></span>                       | <span data-ttu-id="10ed1-255">**마지막 동기화 시간**</span><span class="sxs-lookup"><span data-stu-id="10ed1-255">**Last Sync Time**</span></span> | <span data-ttu-id="10ed1-256">**결과**</span><span class="sxs-lookup"><span data-stu-id="10ed1-256">**Result**</span></span> |
|----------|------------------------------------------------------------|---------------------------------------|--------------------|------------| 
| <span data-ttu-id="10ed1-257">T0</span><span class="sxs-lookup"><span data-stu-id="10ed1-257">T0</span></span>       | <span data-ttu-id="10ed1-258">트랜잭션 A:</span><span class="sxs-lookup"><span data-stu-id="10ed1-258">Transaction A:</span></span> <br> <span data-ttu-id="10ed1-259">주 지역에</span><span class="sxs-lookup"><span data-stu-id="10ed1-259">Insert employee</span></span> <br> <span data-ttu-id="10ed1-260">직원 엔터티 삽입</span><span class="sxs-lookup"><span data-stu-id="10ed1-260">entity in primary</span></span> |                                   |                    | <span data-ttu-id="10ed1-261">트랜잭션 A tooprimary, 삽입</span><span class="sxs-lookup"><span data-stu-id="10ed1-261">Transaction A inserted tooprimary,</span></span><br> <span data-ttu-id="10ed1-262">아직 복제되지 않음</span><span class="sxs-lookup"><span data-stu-id="10ed1-262">not replicated yet.</span></span> |
| <span data-ttu-id="10ed1-263">T1</span><span class="sxs-lookup"><span data-stu-id="10ed1-263">T1</span></span>       |                                                            | <span data-ttu-id="10ed1-264">트랜잭션 A가</span><span class="sxs-lookup"><span data-stu-id="10ed1-264">Transaction A</span></span> <br> <span data-ttu-id="10ed1-265">보조 지역에</span><span class="sxs-lookup"><span data-stu-id="10ed1-265">replicated to</span></span><br> <span data-ttu-id="10ed1-266">복제됨</span><span class="sxs-lookup"><span data-stu-id="10ed1-266">secondary</span></span> | <span data-ttu-id="10ed1-267">T1</span><span class="sxs-lookup"><span data-stu-id="10ed1-267">T1</span></span> | <span data-ttu-id="10ed1-268">트랜잭션 A toosecondary 복제.</span><span class="sxs-lookup"><span data-stu-id="10ed1-268">Transaction A replicated toosecondary.</span></span> <br><span data-ttu-id="10ed1-269">마지막 동기화 시간이 업데이트됨.</span><span class="sxs-lookup"><span data-stu-id="10ed1-269">Last Sync Time updated.</span></span>    |
| <span data-ttu-id="10ed1-270">T2</span><span class="sxs-lookup"><span data-stu-id="10ed1-270">T2</span></span>       | <span data-ttu-id="10ed1-271">트랜잭션 B:</span><span class="sxs-lookup"><span data-stu-id="10ed1-271">Transaction B:</span></span><br><span data-ttu-id="10ed1-272">주 지역에서</span><span class="sxs-lookup"><span data-stu-id="10ed1-272">Update</span></span><br> <span data-ttu-id="10ed1-273">직원 엔터티</span><span class="sxs-lookup"><span data-stu-id="10ed1-273">employee entity</span></span><br> <span data-ttu-id="10ed1-274">업데이트</span><span class="sxs-lookup"><span data-stu-id="10ed1-274">in primary</span></span>  |                                | <span data-ttu-id="10ed1-275">T1</span><span class="sxs-lookup"><span data-stu-id="10ed1-275">T1</span></span>                 | <span data-ttu-id="10ed1-276">트랜잭션 B tooprimary, 작성</span><span class="sxs-lookup"><span data-stu-id="10ed1-276">Transaction B written tooprimary,</span></span><br> <span data-ttu-id="10ed1-277">아직 복제되지 않음</span><span class="sxs-lookup"><span data-stu-id="10ed1-277">not replicated yet.</span></span>  |
| <span data-ttu-id="10ed1-278">T3</span><span class="sxs-lookup"><span data-stu-id="10ed1-278">T3</span></span>       | <span data-ttu-id="10ed1-279">트랜잭션 C:</span><span class="sxs-lookup"><span data-stu-id="10ed1-279">Transaction C:</span></span><br> <span data-ttu-id="10ed1-280">주 지역에서</span><span class="sxs-lookup"><span data-stu-id="10ed1-280">Update</span></span> <br><span data-ttu-id="10ed1-281">관리자 역할</span><span class="sxs-lookup"><span data-stu-id="10ed1-281">administrator</span></span><br><span data-ttu-id="10ed1-282">엔터티</span><span class="sxs-lookup"><span data-stu-id="10ed1-282">role entity in</span></span><br><span data-ttu-id="10ed1-283">업데이트</span><span class="sxs-lookup"><span data-stu-id="10ed1-283">primary</span></span> |                    | <span data-ttu-id="10ed1-284">T1</span><span class="sxs-lookup"><span data-stu-id="10ed1-284">T1</span></span>                 | <span data-ttu-id="10ed1-285">트랜잭션 기록 tooprimary, C</span><span class="sxs-lookup"><span data-stu-id="10ed1-285">Transaction C written tooprimary,</span></span><br> <span data-ttu-id="10ed1-286">아직 복제되지 않음</span><span class="sxs-lookup"><span data-stu-id="10ed1-286">not replicated yet.</span></span>  |
| <span data-ttu-id="10ed1-287">*T4*</span><span class="sxs-lookup"><span data-stu-id="10ed1-287">*T4*</span></span>     |                                                       | <span data-ttu-id="10ed1-288">트랜잭션 C가</span><span class="sxs-lookup"><span data-stu-id="10ed1-288">Transaction C</span></span> <br><span data-ttu-id="10ed1-289">보조 지역에</span><span class="sxs-lookup"><span data-stu-id="10ed1-289">replicated to</span></span><br> <span data-ttu-id="10ed1-290">복제됨</span><span class="sxs-lookup"><span data-stu-id="10ed1-290">secondary</span></span> | <span data-ttu-id="10ed1-291">T1</span><span class="sxs-lookup"><span data-stu-id="10ed1-291">T1</span></span>         | <span data-ttu-id="10ed1-292">트랜잭션이 C toosecondary를 복제 합니다.</span><span class="sxs-lookup"><span data-stu-id="10ed1-292">Transaction C replicated toosecondary.</span></span><br><span data-ttu-id="10ed1-293">트랜잭션 B가 아직 복제되지 않아서</span><span class="sxs-lookup"><span data-stu-id="10ed1-293">LastSyncTime not updated because</span></span> <br><span data-ttu-id="10ed1-294">LastSyncTime이 업데이트되지 않음</span><span class="sxs-lookup"><span data-stu-id="10ed1-294">transaction B has not been replicated yet.</span></span>|
| <span data-ttu-id="10ed1-295">*T5*</span><span class="sxs-lookup"><span data-stu-id="10ed1-295">*T5*</span></span>     | <span data-ttu-id="10ed1-296">보조 지역의</span><span class="sxs-lookup"><span data-stu-id="10ed1-296">Read entities</span></span> <br><span data-ttu-id="10ed1-297">엔터티 읽기</span><span class="sxs-lookup"><span data-stu-id="10ed1-297">from secondary</span></span>                           |                                  | <span data-ttu-id="10ed1-298">T1</span><span class="sxs-lookup"><span data-stu-id="10ed1-298">T1</span></span>                 | <span data-ttu-id="10ed1-299">Hello 직원에 대 한 오래 된 값을 가져올 수</span><span class="sxs-lookup"><span data-stu-id="10ed1-299">You get hello stale value for employee</span></span> <br> <span data-ttu-id="10ed1-300">않아서 직원 엔터티에 대해</span><span class="sxs-lookup"><span data-stu-id="10ed1-300">entity because transaction B hasn't</span></span> <br> <span data-ttu-id="10ed1-301">부실한 값을 얻음</span><span class="sxs-lookup"><span data-stu-id="10ed1-301">replicated yet.</span></span> <span data-ttu-id="10ed1-302">Hello에 대 한 새 값을 가져올 수</span><span class="sxs-lookup"><span data-stu-id="10ed1-302">You get hello new value for</span></span><br> <span data-ttu-id="10ed1-303">관리자 역할 엔터티에 대해</span><span class="sxs-lookup"><span data-stu-id="10ed1-303">administrator role entity because C has</span></span><br> <span data-ttu-id="10ed1-304">새 값을 얻음</span><span class="sxs-lookup"><span data-stu-id="10ed1-304">replicated.</span></span> <span data-ttu-id="10ed1-305">트랜잭션 B가 복제되지 않았기</span><span class="sxs-lookup"><span data-stu-id="10ed1-305">Last Sync Time still hasn't</span></span><br> <span data-ttu-id="10ed1-306">때문에 마지막 동기화 시간이</span><span class="sxs-lookup"><span data-stu-id="10ed1-306">been updated because transaction B</span></span><br> <span data-ttu-id="10ed1-307">아직 업데이트되지 않음.</span><span class="sxs-lookup"><span data-stu-id="10ed1-307">hasn't replicated.</span></span> <span data-ttu-id="10ed1-308">엔터티 날짜/시간이 마지막</span><span class="sxs-lookup"><span data-stu-id="10ed1-308">You can tell the</span></span><br><span data-ttu-id="10ed1-309">동기화 시간보다 나중이기 때문에</span><span class="sxs-lookup"><span data-stu-id="10ed1-309">administrator role entity is inconsistent</span></span> <br><span data-ttu-id="10ed1-310">hello 엔터티 날짜/시간 이후 이므로</span><span class="sxs-lookup"><span data-stu-id="10ed1-310">because hello entity date/time is after</span></span> <br><span data-ttu-id="10ed1-311">hello 마지막 동기화 시간입니다.</span><span class="sxs-lookup"><span data-stu-id="10ed1-311">hello Last Sync Time.</span></span> |
| <span data-ttu-id="10ed1-312">*T6*</span><span class="sxs-lookup"><span data-stu-id="10ed1-312">*T6*</span></span>     |                                                      | <span data-ttu-id="10ed1-313">트랜잭션 B가</span><span class="sxs-lookup"><span data-stu-id="10ed1-313">Transaction B</span></span><br> <span data-ttu-id="10ed1-314">보조 지역에</span><span class="sxs-lookup"><span data-stu-id="10ed1-314">replicated to</span></span><br> <span data-ttu-id="10ed1-315">복제됨</span><span class="sxs-lookup"><span data-stu-id="10ed1-315">secondary</span></span> | <span data-ttu-id="10ed1-316">T6</span><span class="sxs-lookup"><span data-stu-id="10ed1-316">T6</span></span>                 | <span data-ttu-id="10ed1-317">*T6* – C까지 모든 트랜잭션이</span><span class="sxs-lookup"><span data-stu-id="10ed1-317">*T6* – All transactions through C have</span></span> <br><span data-ttu-id="10ed1-318">복제됨. 마지막 동기화</span><span class="sxs-lookup"><span data-stu-id="10ed1-318">been replicated, Last Sync Time</span></span><br> <span data-ttu-id="10ed1-319">시간이 업데이트됨</span><span class="sxs-lookup"><span data-stu-id="10ed1-319">is updated.</span></span> |

<span data-ttu-id="10ed1-320">이 예제에서는 t 5에 hello 보조 지역에서 hello 클라이언트 스위치 tooreading를 가정 합니다.</span><span class="sxs-lookup"><span data-stu-id="10ed1-320">In this example, assume hello client switches tooreading from hello secondary region at T5.</span></span> <span data-ttu-id="10ed1-321">Hello를 성공적으로 읽을 수 **관리자 역할** 이때 엔터티 하지만 hello 엔터티 hello 수가 일치 하지 않는 관리자 hello 개수에 대 한 값이 포함 된 **직원** 엔터티 이 이번에 hello 보조 지역에서 관리자로 표시 합니다.</span><span class="sxs-lookup"><span data-stu-id="10ed1-321">It can successfully read hello **administrator role** entity at this time, but hello entity contains a value for hello count of administrators that is not consistent with hello number of **employee** entities that are marked as administrators in hello secondary region at this time.</span></span> <span data-ttu-id="10ed1-322">클라이언트는 hello 위험 일관 되지 않은 정보가 인지이 값을 표시 하기만 하면 못했습니다.</span><span class="sxs-lookup"><span data-stu-id="10ed1-322">Your client could simply display this value, with hello risk that it is inconsistent information.</span></span> <span data-ttu-id="10ed1-323">또는 클라이언트 hello을 시도할 수 toodetermine 해당 hello **관리자 역할** hello 업데이트 순서를 다르게 나타나므로 나 다음이 팩트의 hello 사용자에 게 알리는 때문에 잠재적으로 일관성이 없는 상태입니다.</span><span class="sxs-lookup"><span data-stu-id="10ed1-323">Alternatively, hello client could attempt toodetermine that hello **administrator role** is in a potentially inconsistent state because hello updates have happened out of order, and then inform hello user of this fact.</span></span>

<span data-ttu-id="10ed1-324">잠재적으로 일치 하지 않는 데이터가 있는지 toorecognize, hello 클라이언트 hello의 hello 값을 사용할 수 *마지막 동기화 시간* 저장소 서비스를 쿼리하여 언제 든 지 파악할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="10ed1-324">toorecognize that it has potentially inconsistent data, hello client can use hello value of hello *Last Sync Time* that you can get at any time by querying a storage service.</span></span> <span data-ttu-id="10ed1-325">네트워크 인지 hello 보조 영역에 있는 hello 데이터 된 마지막 hello 시간 일관 된 모든 hello 서비스에 적용 될 때 트랜잭션을 이전 toothat 지점 시간에서에 hello 및 합니다.</span><span class="sxs-lookup"><span data-stu-id="10ed1-325">This tells you hello time when hello data in hello secondary region was last consistent and when hello service had applied all hello transactions prior toothat point in time.</span></span> <span data-ttu-id="10ed1-326">Hello 서비스는 hello를 삽입 한 후 위의 hello 예에서 **직원** hello 보조 영역에 엔터티를 hello 마지막 동기화 시간 설정 되어 너무*T1*합니다.</span><span class="sxs-lookup"><span data-stu-id="10ed1-326">In hello example shown above, after hello service inserts hello **employee** entity in hello secondary region, hello last sync time is set too*T1*.</span></span> <span data-ttu-id="10ed1-327">에 그대로 유지 됩니다 *T1* hello 서비스는 hello 업데이트 될 때까지 **직원** hello 너무 설정 되어 있는 경우 보조 영역에 엔터티*T6*합니다.</span><span class="sxs-lookup"><span data-stu-id="10ed1-327">It remains at *T1* until hello service updates hello **employee** entity in hello secondary region when it is set too*T6*.</span></span> <span data-ttu-id="10ed1-328">Hello 클라이언트 hello에 hello 엔터티를 읽을 때 마지막 동기화 시간을 검색 하는 경우 *T5*, hello 엔터티의 hello 타임 스탬프와 비교할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="10ed1-328">If hello client retrieves hello last sync time when it reads hello entity at *T5*, it can compare it with hello timestamp on hello entity.</span></span> <span data-ttu-id="10ed1-329">Hello 엔터티 hello 타임 스탬프 hello 보다 이후인 경우 시간, 마지막 동기화 후 hello 엔터티 잠재적으로 일치 하지 않는 상태 이며 무엇이 hello 응용 프로그램에 대 한 적절 한 조치를 취할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="10ed1-329">If hello timestamp on hello entity is later than hello last sync time, then hello entity is in a potentially inconsistent state, and you can take whatever is hello appropriate action for your application.</span></span> <span data-ttu-id="10ed1-330">이 필드를 사용 하 여 hello 마지막 업데이트 toohello 기본 완료 된 시기를 알고 있어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="10ed1-330">Using this field requires that you know when hello last update toohello primary was completed.</span></span>

## <a name="testing"></a><span data-ttu-id="10ed1-331">테스트</span><span class="sxs-lookup"><span data-stu-id="10ed1-331">Testing</span></span>

<span data-ttu-id="10ed1-332">응용 프로그램의 다시 시도 가능한 오류가 발생 하는 경우 예상 대로 동작 하는 중요 한 tootest 것 합니다.</span><span class="sxs-lookup"><span data-stu-id="10ed1-332">It's important tootest that your application behaves as expected when it encounters retryable errors.</span></span> <span data-ttu-id="10ed1-333">예를 들어 응용 프로그램 스위치 toohello 보조 hello tootest 해야 및 읽기 전용 모드에는 문제가 발견 되 고 전환 합니다. 때 기본 지역 hello를 다시 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="10ed1-333">For example, you need tootest that hello application switches toohello secondary and into read-only mode when it detects a problem, and switches back when hello primary region becomes available again.</span></span> <span data-ttu-id="10ed1-334">toodo이 방식으로 toosimulate 다시 시도 가능한 오류 필요 하 고 발생 빈도 제어 합니다.</span><span class="sxs-lookup"><span data-stu-id="10ed1-334">toodo this, you need a way toosimulate retryable errors and control how often they occur.</span></span>

<span data-ttu-id="10ed1-335">사용할 수 있습니다 [Fiddler](http://www.telerik.com/fiddler) toointercept 및 스크립트에서 HTTP 응답을 수정 합니다.</span><span class="sxs-lookup"><span data-stu-id="10ed1-335">You can use [Fiddler](http://www.telerik.com/fiddler) toointercept and modify HTTP responses in a script.</span></span> <span data-ttu-id="10ed1-336">이 스크립트는 기본 끝점에서 제공 하는 응답을 식별 하 고 hello HTTP 상태 코드 tooone 저장소 클라이언트 라이브러리는 다시 시도 가능한 오류를 인식 하는 hello를 변경할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="10ed1-336">This script can identify responses that come from your primary endpoint and change hello HTTP status code tooone that hello Storage Client Library recognizes as a retryable error.</span></span> <span data-ttu-id="10ed1-337">이 코드 조각은 hello에 대 한 응답 tooread 요청을 차단 하는 Fiddler 스크립트의 간단한 예를 보여 줍니다. **employeedata** 테이블 tooreturn 502 상태:</span><span class="sxs-lookup"><span data-stu-id="10ed1-337">This code snippet shows a simple example of a Fiddler script that intercepts responses tooread requests against hello **employeedata** table tooreturn a 502 status:</span></span>

```java
static function OnBeforeResponse(oSession: Session) {
    ...
    if ((oSession.hostname == "\[yourstorageaccount\].table.core.windows.net")
      && (oSession.PathAndQuery.StartsWith("/employeedata?$filter"))) {
        oSession.responseCode = 502;
    }
}
```

<span data-ttu-id="10ed1-338">이 예제에서는 toointercept 보다 넓은 범위의 요청을 확장 하 고 hello에만 변경할 수 **responseCode** 그 중 일부에 toobetter 실제 시나리오 시뮬레이션 합니다.</span><span class="sxs-lookup"><span data-stu-id="10ed1-338">You could extend this example toointercept a wider range of requests and only change hello **responseCode** on some of them toobetter simulate a real-world scenario.</span></span> <span data-ttu-id="10ed1-339">Fiddler 스크립트를 사용자 지정 하는 방법에 대 한 자세한 내용은 참조 [요청 또는 응답 수정](http://docs.telerik.com/fiddler/KnowledgeBase/FiddlerScript/ModifyRequestOrResponse) hello Fiddler 설명서에에서 있습니다.</span><span class="sxs-lookup"><span data-stu-id="10ed1-339">For more information about customizing Fiddler scripts, see [Modifying a Request or Response](http://docs.telerik.com/fiddler/KnowledgeBase/FiddlerScript/ModifyRequestOrResponse) in hello Fiddler documentation.</span></span>

<span data-ttu-id="10ed1-340">응용 프로그램 tooread 전용 모드에 구성 가능한 전환을 위한 hello 임계값 내용을 보다 쉽게 tootest hello에 대 한 동작 비-프로덕션 트랜잭션 볼륨 됩니다.</span><span class="sxs-lookup"><span data-stu-id="10ed1-340">If you have made hello thresholds for switching your application tooread-only mode configurable, it will be easier tootest hello behavior with non-production transaction volumes.</span></span>

## <a name="next-steps"></a><span data-ttu-id="10ed1-341">다음 단계</span><span class="sxs-lookup"><span data-stu-id="10ed1-341">Next Steps</span></span>

* <span data-ttu-id="10ed1-342">자세한 내용은 대 한 읽기 액세스 지리적 중복을 참조 하십시오 hello LastSyncTime 설정 되는 방법의 다른 예제를 포함 하 여 [Windows Azure 저장소 중복 옵션 및 읽기 액세스 지역 중복 저장소](https://blogs.msdn.microsoft.com/windowsazurestorage/2013/12/11/windows-azure-storage-redundancy-options-and-read-access-geo-redundant-storage/)합니다.</span><span class="sxs-lookup"><span data-stu-id="10ed1-342">For more information about Read Access Geo-Redundancy, including another example of how hello LastSyncTime is set, please see [Windows Azure Storage Redundancy Options and Read Access Geo Redundant Storage](https://blogs.msdn.microsoft.com/windowsazurestorage/2013/12/11/windows-azure-storage-redundancy-options-and-read-access-geo-redundant-storage/).</span></span>

* <span data-ttu-id="10ed1-343">Toomake hello 기본 및 보조 끝점 간에 앞뒤로 스위치 hello 하는 방법을 보여 주는 전체 샘플을 참조 하십시오 [사용 하 여 Azure 예제 – RA-GRS 저장소가 있는 회로 차단기 패턴 hello](https://github.com/Azure-Samples/storage-dotnet-circuit-breaker-pattern-ha-apps-using-ra-grs)합니다.</span><span class="sxs-lookup"><span data-stu-id="10ed1-343">For a complete sample showing how toomake hello switch back and forth between hello Primary and Secondary endpoints, please see [Azure Samples – Using hello Circuit Breaker Pattern with RA-GRS storage](https://github.com/Azure-Samples/storage-dotnet-circuit-breaker-pattern-ha-apps-using-ra-grs).</span></span>
