---
title: "Microsoft Azure 저장소에 대 한 동시성 aaaManaging"
description: "방법에 대 한 동시성 toomanage hello Blob, 큐, 테이블 및 파일 서비스"
services: storage
documentationcenter: 
author: jasontang501
manager: tadb
editor: tysonn
ms.assetid: cc6429c4-23ee-46e3-b22d-50dd68bd4680
ms.service: storage
ms.workload: storage
ms.tgt_pltfrm: na
ms.devlang: dotnet
ms.topic: article
ms.date: 05/11/2017
ms.author: jasontang501
ms.openlocfilehash: 5b8efbe0a9ebc881ded8f3abef5f138e0385f7c6
ms.sourcegitcommit: 523283cc1b3c37c428e77850964dc1c33742c5f0
ms.translationtype: MT
ms.contentlocale: ko-KR
ms.lasthandoff: 10/06/2017
---
# <a name="managing-concurrency-in-microsoft-azure-storage"></a><span data-ttu-id="6ec80-103">Microsoft Azure 저장소에서 동시성 관리</span><span class="sxs-lookup"><span data-stu-id="6ec80-103">Managing Concurrency in Microsoft Azure Storage</span></span>
## <a name="overview"></a><span data-ttu-id="6ec80-104">개요</span><span class="sxs-lookup"><span data-stu-id="6ec80-104">Overview</span></span>
<span data-ttu-id="6ec80-105">최신 인터넷 기반 응용 프로그램에서는 대개 여러 사용자가 데이터를 동시에 보고 업데이트합니다.</span><span class="sxs-lookup"><span data-stu-id="6ec80-105">Modern Internet based applications usually have multiple users viewing and updating data simultaneously.</span></span> <span data-ttu-id="6ec80-106">이렇게 하려면 예측 가능한 a tooprovide tootheir 최종 사용자가 경험 하는 방법에 대 한 신중 하 게 응용 프로그램 개발자가 toothink 특히 동일한 여러 사용자가 업데이트할 수 있는 시나리오 hello에 대 한 데이터입니다.</span><span class="sxs-lookup"><span data-stu-id="6ec80-106">This requires application developers toothink carefully about how tooprovide a predictable experience tootheir end users, particularly for scenarios where multiple users can update hello same data.</span></span> <span data-ttu-id="6ec80-107">개발자가 일반적으로 고려하는 주요 데이터 동시성 전략에는 다음의 세 가지가 있습니다.</span><span class="sxs-lookup"><span data-stu-id="6ec80-107">There are three main data concurrency strategies that developers typically consider:</span></span>  

1. <span data-ttu-id="6ec80-108">낙관적 동시성 – 데이터를 읽는 마지막 업데이트는 해당 업데이트의 일부로 확인 hello 응용 프로그램 이후 hello 데이터가 변경 되었는지 여부는 응용 프로그램이 수행 합니다.</span><span class="sxs-lookup"><span data-stu-id="6ec80-108">Optimistic concurrency – An application performing an update will as part of its update verify if hello data has changed since hello application last read that data.</span></span> <span data-ttu-id="6ec80-109">예를 들어 두 사용자를 한 wiki 페이지 보기 업데이트 toohello 확인 하는 경우 동일한 페이지 hello wiki 플랫폼 해당 hello 두 번째 업데이트 hello 첫 번째 업데이트 –를 덮어쓰지 않습니다을 확인 해야 하 고 두 사용자가 자신의 업데이트가 성공 했는지 여부를 이해 하는 합니다.</span><span class="sxs-lookup"><span data-stu-id="6ec80-109">For example, if two users viewing a wiki page make an update toohello same page then hello wiki platform must ensure that hello second update does not overwrite hello first update – and that both users understand whether their update was successful or not.</span></span> <span data-ttu-id="6ec80-110">이 전략은 웹 응용 프로그램에서 가장 흔히 사용됩니다.</span><span class="sxs-lookup"><span data-stu-id="6ec80-110">This strategy is most often used in web applications.</span></span>
2. <span data-ttu-id="6ec80-111">비관적 동시성 – tooperform 업데이트를 확인 하는 응용 프로그램 다른 사용자 hello 잠금이 해제 될 때까지 hello 데이터를 업데이트 하는 것을 방지 하는 개체를 잠금을 수행 합니다.</span><span class="sxs-lookup"><span data-stu-id="6ec80-111">Pessimistic concurrency – An application looking tooperform an update will take a lock on an object preventing other users from updating hello data until hello lock is released.</span></span> <span data-ttu-id="6ec80-112">예를 들어 마스터/슬레이브 데이터 복제 시나리오만 hello 마스터 업데이트를 수행 하는 hello 마스터에서는 일반적으로 보관 한 단독 잠금을 오랜 시간에 없는 다른 사람이 hello 데이터 tooensure 문자열을 업데이트할 수에 대 한 합니다.</span><span class="sxs-lookup"><span data-stu-id="6ec80-112">For example, in a master/slave data replication scenario where only hello master will perform updates hello master will typically hold an exclusive lock for an extended period of time on hello data tooensure no one else can update it.</span></span>
3. <span data-ttu-id="6ec80-113">마지막 기록자 우선 – hello 응용 프로그램 먼저 hello 데이터를 읽은 후 다른 응용 프로그램 hello 데이터에 업데이트를 확인 하지 않고 모든 업데이트 작업이 tooproceed를 허용 하 합니다.</span><span class="sxs-lookup"><span data-stu-id="6ec80-113">Last writer wins – An approach that allows any update operations tooproceed without verifying if any other application has updated hello data since hello application first read hello data.</span></span> <span data-ttu-id="6ec80-114">이 전략 (또는 정식 전략의 부족)은 여러 사용자가 hello를 액세스 가능성이 없는 인지 하는 방식으로 데이터 분할 되는 위치 사용 일반적으로 동일한 데이터입니다.</span><span class="sxs-lookup"><span data-stu-id="6ec80-114">This strategy (or lack of a formal strategy) is usually used where data is partitioned in such a way that there is no likelihood that multiple users will access hello same data.</span></span> <span data-ttu-id="6ec80-115">일시적인 데이터 스트림을 처리하는 경우에도 이 전략이 유용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="6ec80-115">It can also be useful where short-lived data streams are being processed.</span></span>  

<span data-ttu-id="6ec80-116">이 문서에서는 hello Azure 저장소 플랫폼 이러한 동시성 전략의 세 가지 모두에 대 한 최고 수준의 지원을 제공 하 여 배포를 간소화 하는 방법의 개요를 제공 합니다.</span><span class="sxs-lookup"><span data-stu-id="6ec80-116">This article provides an overview of how hello Azure Storage platform simplifies development by providing first class support for all three of these concurrency strategies.</span></span>  

## <a name="azure-storage--simplifies-cloud-development"></a><span data-ttu-id="6ec80-117">Azure 저장소 - 클라우드 개발 간소화</span><span class="sxs-lookup"><span data-stu-id="6ec80-117">Azure Storage – Simplifies Cloud Development</span></span>
<span data-ttu-id="6ec80-118">hello Azure 저장소 서비스는 어떠한 강력한 일관성 모델 디자인 된 tooembrace 되었기 때문에 낙관적 및 비관적 동시성에 대 한 기능 tooprovide 완전히 지원에 고유한 기능은 없지만 모든 세 가지 전략을 지 원하는 안녕 저장소 서비스 커밋 데이터 삽입 또는 업데이트 작업 이후의 모든 액세스 toothat 데이터가 최신 업데이트 hello 표시 됩니다.</span><span class="sxs-lookup"><span data-stu-id="6ec80-118">hello Azure storage service supports all three strategies, although it is distinctive in its ability tooprovide full support for optimistic and pessimistic concurrency because it was designed tooembrace a strong consistency model which guarantees that when hello Storage service commits a data insert or update operation all further accesses toothat data will see hello latest update.</span></span> <span data-ttu-id="6ec80-119">최고의 일관성 모델이 사용 하는 저장소 플랫폼에 대 한 쓰기 사용자가 수행 될 때 사이는 간격이 존재 하 고 따라서 순서 tooprevent 불일치가 클라이언트 응용 프로그램을 개발 하므로 복잡해 집니다. 다른 사용자가 데이터를 볼 수 hello 업데이트 될 때 최종 사용자가에 영향을 주는 합니다.</span><span class="sxs-lookup"><span data-stu-id="6ec80-119">Storage platforms that use an eventual consistency model have a lag between when a write is performed by one user and when hello updated data can be seen by other users thus complicating development of client applications in order tooprevent inconsistencies from affecting end users.</span></span>  

<span data-ttu-id="6ec80-120">또한 tooselecting 적절 한 동시성 전략 개발자도 알고 있어야 하는 저장소 플랫폼 변경 내용 – 동일한 트랜잭션에 걸쳐 개체 변경 내용 toohello 특히를 격리 하는 방법입니다.</span><span class="sxs-lookup"><span data-stu-id="6ec80-120">In addition tooselecting an appropriate concurrency strategy developers should also be aware of how a storage platform isolates changes – particularly changes toohello same object across transactions.</span></span> <span data-ttu-id="6ec80-121">hello Azure 저장소 서비스는 단일 파티션 내에서 쓰기 작업이 동시에 작업 toohappen 읽기 스냅숏 격리 tooallow를 사용 합니다.</span><span class="sxs-lookup"><span data-stu-id="6ec80-121">hello Azure storage service uses snapshot isolation tooallow read operations toohappen concurrently with write operations within a single partition.</span></span> <span data-ttu-id="6ec80-122">다른 격리 수준이 달리 스냅숏 격리를 사용 하면 모든 읽기 확인 hello 데이터의 일관 된 스냅숏을 업데이트가 발생 – 기본적으로 처리 되는 업데이트 트랜잭션 동안 hello 마지막으로 커밋된 값을 반환 하 여는 동안에 합니다.</span><span class="sxs-lookup"><span data-stu-id="6ec80-122">Unlike other isolation levels, snapshot isolation guarantees that all reads see a consistent snapshot of hello data even while updates are occurring – essentially by returning hello last committed values while an update transaction is being processed.</span></span>  

## <a name="managing-concurrency-in-blob-storage"></a><span data-ttu-id="6ec80-123">Blob 저장소에서 동시성 관리</span><span class="sxs-lookup"><span data-stu-id="6ec80-123">Managing Concurrency in Blob storage</span></span>
<span data-ttu-id="6ec80-124">Toouse 낙관적 또는 비관적 동시성 모델 toomanage 액세스 tooblobs 및 컨테이너에서 hello blob 서비스 중 하나를 선택할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="6ec80-124">You can opt toouse either optimistic or pessimistic concurrency models toomanage access tooblobs and containers in hello blob service.</span></span> <span data-ttu-id="6ec80-125">전략을 명시적으로 지정 하지 않으면 마지막 wins는 hello 기본 기록 합니다.</span><span class="sxs-lookup"><span data-stu-id="6ec80-125">If you do not explicitly specify a strategy last writes wins is hello default.</span></span>  

### <a name="optimistic-concurrency-for-blobs-and-containers"></a><span data-ttu-id="6ec80-126">Blob 및 컨테이너에 대한 낙관적 동시성</span><span class="sxs-lookup"><span data-stu-id="6ec80-126">Optimistic concurrency for blobs and containers</span></span>
<span data-ttu-id="6ec80-127">저장소 서비스 hello 식별자 tooevery 저장 된 개체를 할당 합니다.</span><span class="sxs-lookup"><span data-stu-id="6ec80-127">hello Storage service assigns an identifier tooevery object stored.</span></span> <span data-ttu-id="6ec80-128">이 식별자는 개체에 대해 업데이트 작업을 수행할 때마다 업데이트되며, HTTP 프로토콜 내에 정의된 ETag(엔터티 태그) 헤더를 사용하여 HTTP GET 응답의 일부분으로 클라이언트에 반환됩니다.</span><span class="sxs-lookup"><span data-stu-id="6ec80-128">This identifier is updated every time an update operation is performed on an object.</span></span> <span data-ttu-id="6ec80-129">hello 식별자 toohello 클라이언트 hello HTTP 프로토콜 내에 정의 된 hello (엔터티 태그) ETag 헤더를 사용 하 여 HTTP GET 응답의 일부로 반환 됩니다.</span><span class="sxs-lookup"><span data-stu-id="6ec80-129">hello identifier is returned toohello client as part of an HTTP GET response using hello ETag (entity tag) header that is defined within hello HTTP protocol.</span></span> <span data-ttu-id="6ec80-130">Hello 조건이 hello 저장소 필요 "If-match" 헤더로,이 경우에 특정 조건이 충족 된 경우 업데이트가 발생 하는 조건부 헤더를 tooensure 함께 원래 ETag hello를 수행 하는 사용자에 이러한 개체에 대 한 업데이트를 보낼 수 있습니다. 서비스 tooensure hello hello 업데이트 요청에 지정 된 ETag는 hello 저장소 서비스에에서 저장 된 것과 동일한 hello hello의 값입니다.</span><span class="sxs-lookup"><span data-stu-id="6ec80-130">A user performing an update on such an object can send in hello original ETag along with a conditional header tooensure that an update will only occur if a certain condition has been met – in this case hello condition is an "If-Match" header, which requires hello Storage Service tooensure hello value of hello ETag specified in hello update request is hello same as that stored in hello Storage Service.</span></span>  

<span data-ttu-id="6ec80-131">이 프로세스의 hello 개요는 다음과 같습니다.</span><span class="sxs-lookup"><span data-stu-id="6ec80-131">hello outline of this process is as follows:</span></span>  

1. <span data-ttu-id="6ec80-132">Hello 저장소 서비스에서 blob를 검색, hello 응답 hello hello 저장소 서비스에 hello 개체의 현재 버전을 식별 하는 HTTP ETag 헤더 값을 포함 합니다.</span><span class="sxs-lookup"><span data-stu-id="6ec80-132">Retrieve a blob from hello storage service, hello response includes an HTTP ETag Header value that identifies hello current version of hello object in hello storage service.</span></span>
2. <span data-ttu-id="6ec80-133">Hello blob를 업데이트 하는 경우 hello에 1 단계에서 받은 hello ETag 값이 포함 **If-match** toohello 서비스 보낼 hello 요청의 조건부 헤더입니다.</span><span class="sxs-lookup"><span data-stu-id="6ec80-133">When you update hello blob, include hello ETag value you received in step 1 in hello **If-Match** conditional header of hello request you send toohello service.</span></span>
3. <span data-ttu-id="6ec80-134">hello 서비스 hello 요청의 hello hello blob의 현재 ETag 값을 가진 hello ETag 값을 비교합니다.</span><span class="sxs-lookup"><span data-stu-id="6ec80-134">hello service compares hello ETag value in hello request with hello current ETag value of hello blob.</span></span>
4. <span data-ttu-id="6ec80-135">Hello hello blob의 현재 ETag 값이 서로 다른 버전 hello에 ETag를 hello 보다 **If-match** hello 서비스 hello 요청에 조건부 헤더가 412 오류 toohello 클라이언트를 반환 합니다.</span><span class="sxs-lookup"><span data-stu-id="6ec80-135">If hello current ETag value of hello blob is a different version than hello ETag in hello **If-Match** conditional header in hello request, hello service returns a 412 error toohello client.</span></span> <span data-ttu-id="6ec80-136">이 toohello 클라이언트 hello 클라이언트 것으로 검색 한 이후 다른 프로세스 hello blob가 업데이트를 나타냅니다.</span><span class="sxs-lookup"><span data-stu-id="6ec80-136">This indicates toohello client that another process has updated hello blob since hello client retrieved it.</span></span>
5. <span data-ttu-id="6ec80-137">Hello 현재 ETag hello blob의 값이 동일한 버전으로 hello 경우 ETag hello에 hello **If-match** 조건부 헤더를 요청 hello hello 서비스에서에서 수행 hello 작업 및 업데이트 hello hello blob의 현재 ETag 값 요청 새 버전 만들었음을 tooshow 합니다.</span><span class="sxs-lookup"><span data-stu-id="6ec80-137">If hello current ETag value of hello blob is hello same version as hello ETag in hello **If-Match** conditional header in hello request, hello service performs hello requested operation and updates hello current ETag value of hello blob tooshow that it has created a new version.</span></span>  

<span data-ttu-id="6ec80-138">hello 다음 C# 코드 조각 (클라이언트 저장소 라이브러리 4.2.0 hello를 사용 하 여) 예제를 보여 주는 간단한 방법의 tooconstruct는 **If-match AccessCondition** hello 않은 blob의 hello 속성에서 액세스 하는 ETag 값에 따라 이전에 검색 된 또는 삽입 합니다.</span><span class="sxs-lookup"><span data-stu-id="6ec80-138">hello following C# snippet (using hello Client Storage Library 4.2.0) shows a simple example of how tooconstruct an **If-Match AccessCondition** based on hello ETag value that is accessed from hello properties of a blob that was previously either retrieved or inserted.</span></span> <span data-ttu-id="6ec80-139">Hello 사용 하 여 다음 **AccessCondition** hello blob를 업데이트 하는 경우 개체: hello **AccessCondition** hello를 추가 하는 개체 **If-match** toohello 요청 헤더입니다.</span><span class="sxs-lookup"><span data-stu-id="6ec80-139">It then uses hello **AccessCondition** object when it updates hello blob: hello **AccessCondition** object adds hello **If-Match** header toohello request.</span></span> <span data-ttu-id="6ec80-140">다른 프로세스가 hello blob가 업데이트 면 hello blob 서비스는 HTTP 412 (전제 조건 실패) 상태 메시지를 반환 합니다.</span><span class="sxs-lookup"><span data-stu-id="6ec80-140">If another process has updated hello blob, hello blob service returns an HTTP 412 (Precondition Failed) status message.</span></span> <span data-ttu-id="6ec80-141">전체 샘플 hello 다운로드할 수 있습니다: [Azure 저장소를 사용 하 여 관리 동시성](http://code.msdn.microsoft.com/Managing-Concurrency-using-56018114)합니다.</span><span class="sxs-lookup"><span data-stu-id="6ec80-141">You can download hello full sample here: [Managing Concurrency using Azure Storage](http://code.msdn.microsoft.com/Managing-Concurrency-using-56018114).</span></span>  

```csharp
// Retrieve hello ETag from hello newly created blob
// Etag is already populated as UploadText should cause a PUT Blob call
// toostorage blob service which returns hello etag in response.
string orignalETag = blockBlob.Properties.ETag;

// This code simulates an update by a third party.
string helloText = "Blob updated by a third party.";

// No etag, provided so orignal blob is overwritten (thus generating a new etag)
blockBlob.UploadText(helloText);
Console.WriteLine("Blob updated. Updated ETag = {0}",
blockBlob.Properties.ETag);

// Now try tooupdate hello blob using hello orignal ETag provided when hello blob was created
try
{
    Console.WriteLine("Trying tooupdate blob using orignal etag toogenerate if-match access condition");
    blockBlob.UploadText(helloText,accessCondition:
    AccessCondition.GenerateIfMatchCondition(orignalETag));
}
catch (StorageException ex)
{
    if (ex.RequestInformation.HttpStatusCode == (int)HttpStatusCode.PreconditionFailed)
    {
        Console.WriteLine("Precondition failure as expected. Blob's orignal etag no longer matches");
        // TODO: client can decide on how it wants toohandle hello 3rd party updated content.
    }
    else
        throw;
}  
```

<span data-ttu-id="6ec80-142">저장소 서비스 hello도 포함 되어 추가 조건부 헤더에 대 한 지원 같은 **If-수정-이후**, **If-수정 되지 않은-이후** 및 **없음-If-match** 으로 이들 조합 합니다.</span><span class="sxs-lookup"><span data-stu-id="6ec80-142">hello Storage Service also includes support for additional conditional headers such as **If-Modified-Since**, **If-Unmodified-Since** and **If-None-Match** as well as combinations thereof.</span></span> <span data-ttu-id="6ec80-143">자세한 내용은 MSDN의 [Blob 서비스 작업의 조건부 헤더 지정](http://msdn.microsoft.com/library/azure/dd179371.aspx)을 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="6ec80-143">For more information, see [Specifying Conditional Headers for Blob Service Operations](http://msdn.microsoft.com/library/azure/dd179371.aspx) on MSDN.</span></span>  

<span data-ttu-id="6ec80-144">hello 다음 표에 요약 되어와 같은 조건부 헤더를 허용 하는 hello 컨테이너 작업 **If-match** 에 해당 하며 hello 요청 hello 응답에 ETag 값을 반환 합니다.</span><span class="sxs-lookup"><span data-stu-id="6ec80-144">hello following table summarizes hello container operations that accept conditional headers such as **If-Match** in hello request and that return an ETag value in hello response.</span></span>  

| <span data-ttu-id="6ec80-145">작업</span><span class="sxs-lookup"><span data-stu-id="6ec80-145">Operation</span></span> | <span data-ttu-id="6ec80-146">컨테이너 ETag 값 반환</span><span class="sxs-lookup"><span data-stu-id="6ec80-146">Returns Container ETag value</span></span> | <span data-ttu-id="6ec80-147">추가 헤더 수락</span><span class="sxs-lookup"><span data-stu-id="6ec80-147">Accepts conditional headers</span></span> |
|:--- |:--- |:--- |
| <span data-ttu-id="6ec80-148">컨테이너 만들기</span><span class="sxs-lookup"><span data-stu-id="6ec80-148">Create Container</span></span> |<span data-ttu-id="6ec80-149">예</span><span class="sxs-lookup"><span data-stu-id="6ec80-149">Yes</span></span> |<span data-ttu-id="6ec80-150">아니요</span><span class="sxs-lookup"><span data-stu-id="6ec80-150">No</span></span> |
| <span data-ttu-id="6ec80-151">컨테이너 속성 가져오기</span><span class="sxs-lookup"><span data-stu-id="6ec80-151">Get Container Properties</span></span> |<span data-ttu-id="6ec80-152">예</span><span class="sxs-lookup"><span data-stu-id="6ec80-152">Yes</span></span> |<span data-ttu-id="6ec80-153">아니요</span><span class="sxs-lookup"><span data-stu-id="6ec80-153">No</span></span> |
| <span data-ttu-id="6ec80-154">컨테이너 메타데이터 가져오기</span><span class="sxs-lookup"><span data-stu-id="6ec80-154">Get Container Metadata</span></span> |<span data-ttu-id="6ec80-155">예</span><span class="sxs-lookup"><span data-stu-id="6ec80-155">Yes</span></span> |<span data-ttu-id="6ec80-156">아니요</span><span class="sxs-lookup"><span data-stu-id="6ec80-156">No</span></span> |
| <span data-ttu-id="6ec80-157">컨테이너 메타데이터 설정</span><span class="sxs-lookup"><span data-stu-id="6ec80-157">Set Container Metadata</span></span> |<span data-ttu-id="6ec80-158">예</span><span class="sxs-lookup"><span data-stu-id="6ec80-158">Yes</span></span> |<span data-ttu-id="6ec80-159">예</span><span class="sxs-lookup"><span data-stu-id="6ec80-159">Yes</span></span> |
| <span data-ttu-id="6ec80-160">컨테이너 ACL 가져오기</span><span class="sxs-lookup"><span data-stu-id="6ec80-160">Get Container ACL</span></span> |<span data-ttu-id="6ec80-161">예</span><span class="sxs-lookup"><span data-stu-id="6ec80-161">Yes</span></span> |<span data-ttu-id="6ec80-162">아니요</span><span class="sxs-lookup"><span data-stu-id="6ec80-162">No</span></span> |
| <span data-ttu-id="6ec80-163">컨테이너 ACL 설정</span><span class="sxs-lookup"><span data-stu-id="6ec80-163">Set Container ACL</span></span> |<span data-ttu-id="6ec80-164">예</span><span class="sxs-lookup"><span data-stu-id="6ec80-164">Yes</span></span> |<span data-ttu-id="6ec80-165">예(*)</span><span class="sxs-lookup"><span data-stu-id="6ec80-165">Yes (*)</span></span> |
| <span data-ttu-id="6ec80-166">컨테이너 삭제</span><span class="sxs-lookup"><span data-stu-id="6ec80-166">Delete Container</span></span> |<span data-ttu-id="6ec80-167">아니요</span><span class="sxs-lookup"><span data-stu-id="6ec80-167">No</span></span> |<span data-ttu-id="6ec80-168">예</span><span class="sxs-lookup"><span data-stu-id="6ec80-168">Yes</span></span> |
| <span data-ttu-id="6ec80-169">컨테이너 임대</span><span class="sxs-lookup"><span data-stu-id="6ec80-169">Lease Container</span></span> |<span data-ttu-id="6ec80-170">예</span><span class="sxs-lookup"><span data-stu-id="6ec80-170">Yes</span></span> |<span data-ttu-id="6ec80-171">예</span><span class="sxs-lookup"><span data-stu-id="6ec80-171">Yes</span></span> |
| <span data-ttu-id="6ec80-172">Blob 나열</span><span class="sxs-lookup"><span data-stu-id="6ec80-172">List Blobs</span></span> |<span data-ttu-id="6ec80-173">아니요</span><span class="sxs-lookup"><span data-stu-id="6ec80-173">No</span></span> |<span data-ttu-id="6ec80-174">아니요</span><span class="sxs-lookup"><span data-stu-id="6ec80-174">No</span></span> |

<span data-ttu-id="6ec80-175">(*) hello 권한을 SetContainerACL 정의한 캐시 하 고 업데이트 toothese 사용 권한을 toopropagate는 기간 동안 업데이트 되지 않습니다 보장 toobe 일치 하는 30 초를 수행 합니다.</span><span class="sxs-lookup"><span data-stu-id="6ec80-175">(*) hello permissions defined by SetContainerACL are cached and updates toothese permissions take 30 seconds toopropagate during which period updates are not guaranteed toobe consistent.</span></span>  

<span data-ttu-id="6ec80-176">hello 다음 표에 요약 되어와 같은 조건부 헤더를 허용 하는 hello blob 작업 **If-match** 에 해당 하며 hello 요청 hello 응답에 ETag 값을 반환 합니다.</span><span class="sxs-lookup"><span data-stu-id="6ec80-176">hello following table summarizes hello blob operations that accept conditional headers such as **If-Match** in hello request and that return an ETag value in hello response.</span></span>

| <span data-ttu-id="6ec80-177">작업</span><span class="sxs-lookup"><span data-stu-id="6ec80-177">Operation</span></span> | <span data-ttu-id="6ec80-178">ETag 값 반환</span><span class="sxs-lookup"><span data-stu-id="6ec80-178">Returns ETag value</span></span> | <span data-ttu-id="6ec80-179">추가 헤더 수락</span><span class="sxs-lookup"><span data-stu-id="6ec80-179">Accepts conditional headers</span></span> |
|:--- |:--- |:--- |
| <span data-ttu-id="6ec80-180">Blob 배치</span><span class="sxs-lookup"><span data-stu-id="6ec80-180">Put Blob</span></span> |<span data-ttu-id="6ec80-181">예</span><span class="sxs-lookup"><span data-stu-id="6ec80-181">Yes</span></span> |<span data-ttu-id="6ec80-182">예</span><span class="sxs-lookup"><span data-stu-id="6ec80-182">Yes</span></span> |
| <span data-ttu-id="6ec80-183">Blob 가져오기</span><span class="sxs-lookup"><span data-stu-id="6ec80-183">Get Blob</span></span> |<span data-ttu-id="6ec80-184">예</span><span class="sxs-lookup"><span data-stu-id="6ec80-184">Yes</span></span> |<span data-ttu-id="6ec80-185">예</span><span class="sxs-lookup"><span data-stu-id="6ec80-185">Yes</span></span> |
| <span data-ttu-id="6ec80-186">Blob 속성 가져오기</span><span class="sxs-lookup"><span data-stu-id="6ec80-186">Get Blob Properties</span></span> |<span data-ttu-id="6ec80-187">예</span><span class="sxs-lookup"><span data-stu-id="6ec80-187">Yes</span></span> |<span data-ttu-id="6ec80-188">예</span><span class="sxs-lookup"><span data-stu-id="6ec80-188">Yes</span></span> |
| <span data-ttu-id="6ec80-189">Blob 속성 설정</span><span class="sxs-lookup"><span data-stu-id="6ec80-189">Set Blob Properties</span></span> |<span data-ttu-id="6ec80-190">예</span><span class="sxs-lookup"><span data-stu-id="6ec80-190">Yes</span></span> |<span data-ttu-id="6ec80-191">예</span><span class="sxs-lookup"><span data-stu-id="6ec80-191">Yes</span></span> |
| <span data-ttu-id="6ec80-192">Blob 메타데이터 가져오기</span><span class="sxs-lookup"><span data-stu-id="6ec80-192">Get Blob Metadata</span></span> |<span data-ttu-id="6ec80-193">예</span><span class="sxs-lookup"><span data-stu-id="6ec80-193">Yes</span></span> |<span data-ttu-id="6ec80-194">예</span><span class="sxs-lookup"><span data-stu-id="6ec80-194">Yes</span></span> |
| <span data-ttu-id="6ec80-195">Blob 메타데이터 설정</span><span class="sxs-lookup"><span data-stu-id="6ec80-195">Set Blob Metadata</span></span> |<span data-ttu-id="6ec80-196">예</span><span class="sxs-lookup"><span data-stu-id="6ec80-196">Yes</span></span> |<span data-ttu-id="6ec80-197">예</span><span class="sxs-lookup"><span data-stu-id="6ec80-197">Yes</span></span> |
| <span data-ttu-id="6ec80-198">Blob 임대(*)</span><span class="sxs-lookup"><span data-stu-id="6ec80-198">Lease Blob (*)</span></span> |<span data-ttu-id="6ec80-199">예</span><span class="sxs-lookup"><span data-stu-id="6ec80-199">Yes</span></span> |<span data-ttu-id="6ec80-200">예</span><span class="sxs-lookup"><span data-stu-id="6ec80-200">Yes</span></span> |
| <span data-ttu-id="6ec80-201">Blob 스냅숏</span><span class="sxs-lookup"><span data-stu-id="6ec80-201">Snapshot Blob</span></span> |<span data-ttu-id="6ec80-202">예</span><span class="sxs-lookup"><span data-stu-id="6ec80-202">Yes</span></span> |<span data-ttu-id="6ec80-203">예</span><span class="sxs-lookup"><span data-stu-id="6ec80-203">Yes</span></span> |
| <span data-ttu-id="6ec80-204">Blob 복사</span><span class="sxs-lookup"><span data-stu-id="6ec80-204">Copy Blob</span></span> |<span data-ttu-id="6ec80-205">예</span><span class="sxs-lookup"><span data-stu-id="6ec80-205">Yes</span></span> |<span data-ttu-id="6ec80-206">예(원본 및 대상 Blob의 경우)</span><span class="sxs-lookup"><span data-stu-id="6ec80-206">Yes (for source and destination blob)</span></span> |
| <span data-ttu-id="6ec80-207">Blob 복사 중단</span><span class="sxs-lookup"><span data-stu-id="6ec80-207">Abort Copy Blob</span></span> |<span data-ttu-id="6ec80-208">아니요</span><span class="sxs-lookup"><span data-stu-id="6ec80-208">No</span></span> |<span data-ttu-id="6ec80-209">아니요</span><span class="sxs-lookup"><span data-stu-id="6ec80-209">No</span></span> |
| <span data-ttu-id="6ec80-210">Blob 삭제</span><span class="sxs-lookup"><span data-stu-id="6ec80-210">Delete Blob</span></span> |<span data-ttu-id="6ec80-211">아니요</span><span class="sxs-lookup"><span data-stu-id="6ec80-211">No</span></span> |<span data-ttu-id="6ec80-212">예</span><span class="sxs-lookup"><span data-stu-id="6ec80-212">Yes</span></span> |
| <span data-ttu-id="6ec80-213">블록 배치</span><span class="sxs-lookup"><span data-stu-id="6ec80-213">Put Block</span></span> |<span data-ttu-id="6ec80-214">아니요</span><span class="sxs-lookup"><span data-stu-id="6ec80-214">No</span></span> |<span data-ttu-id="6ec80-215">아니요</span><span class="sxs-lookup"><span data-stu-id="6ec80-215">No</span></span> |
| <span data-ttu-id="6ec80-216">블록 목록 배치</span><span class="sxs-lookup"><span data-stu-id="6ec80-216">Put Block List</span></span> |<span data-ttu-id="6ec80-217">예</span><span class="sxs-lookup"><span data-stu-id="6ec80-217">Yes</span></span> |<span data-ttu-id="6ec80-218">예</span><span class="sxs-lookup"><span data-stu-id="6ec80-218">Yes</span></span> |
| <span data-ttu-id="6ec80-219">블록 목록 가져오기</span><span class="sxs-lookup"><span data-stu-id="6ec80-219">Get Block List</span></span> |<span data-ttu-id="6ec80-220">예</span><span class="sxs-lookup"><span data-stu-id="6ec80-220">Yes</span></span> |<span data-ttu-id="6ec80-221">아니요</span><span class="sxs-lookup"><span data-stu-id="6ec80-221">No</span></span> |
| <span data-ttu-id="6ec80-222">페이지 가져오기</span><span class="sxs-lookup"><span data-stu-id="6ec80-222">Put Page</span></span> |<span data-ttu-id="6ec80-223">예</span><span class="sxs-lookup"><span data-stu-id="6ec80-223">Yes</span></span> |<span data-ttu-id="6ec80-224">예</span><span class="sxs-lookup"><span data-stu-id="6ec80-224">Yes</span></span> |
| <span data-ttu-id="6ec80-225">페이지 범위 가져오기</span><span class="sxs-lookup"><span data-stu-id="6ec80-225">Get Page Ranges</span></span> |<span data-ttu-id="6ec80-226">예</span><span class="sxs-lookup"><span data-stu-id="6ec80-226">Yes</span></span> |<span data-ttu-id="6ec80-227">예</span><span class="sxs-lookup"><span data-stu-id="6ec80-227">Yes</span></span> |

<span data-ttu-id="6ec80-228">(*) Blob 임대 된 blob에서 ETag hello를 변경 되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="6ec80-228">(*) Lease Blob does not change hello ETag on a blob.</span></span>  

### <a name="pessimistic-concurrency-for-blobs"></a><span data-ttu-id="6ec80-229">Blob에 대한 비관적 동시성</span><span class="sxs-lookup"><span data-stu-id="6ec80-229">Pessimistic concurrency for blobs</span></span>
<span data-ttu-id="6ec80-230">toolock 독점적인 사용을 위해 blob을 얻을 수 있습니다는 [임대](http://msdn.microsoft.com/library/azure/ee691972.aspx) 에 있습니다.</span><span class="sxs-lookup"><span data-stu-id="6ec80-230">toolock a blob for exclusive use, you can acquire a [lease](http://msdn.microsoft.com/library/azure/ee691972.aspx) on it.</span></span> <span data-ttu-id="6ec80-231">기간에 대 한 임대를 hello 필요한 지정 임대를 획득 하는 경우:이 수에 대 한 15 too60 초 사이 또는 무한, tooan 단독 잠금을 금액입니다.</span><span class="sxs-lookup"><span data-stu-id="6ec80-231">When you acquire a lease, you specify for how long you need hello lease: this can be for between 15 too60 seconds or infinite, which amounts tooan exclusive lock.</span></span> <span data-ttu-id="6ec80-232">한 있습니다 함께 했으면 모든 임대를 해제할 수 유한 임대 tooextend를 갱신할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="6ec80-232">You can renew a finite lease tooextend it, and you can release any lease when you are finished with it.</span></span> <span data-ttu-id="6ec80-233">hello blob 서비스는 자동으로 만료 될 때 유한 임대를 해제 합니다.</span><span class="sxs-lookup"><span data-stu-id="6ec80-233">hello blob service automatically releases finite leases when they expire.</span></span>  

<span data-ttu-id="6ec80-234">임대 다른 동기화 전략 toobe 지원 단독 쓰기를 포함 하 여 사용 / 읽기, 전용 쓰기 공유 / 단독 읽기 및 쓰기 공유 / 단독 읽기입니다.</span><span class="sxs-lookup"><span data-stu-id="6ec80-234">Leases enable different synchronization strategies toobe supported, including exclusive write / shared read, exclusive write / exclusive read and shared write / exclusive read.</span></span> <span data-ttu-id="6ec80-235">하지만 Hello 저장소 서비스에서 배타적 쓰기 (put, 설정 및 삭제 작업) 한 번에 모든 클라이언트 응용 프로그램 사용 임대 ID와 하나의 해당 클라이언트는 hello 개발자 tooensure 필요 읽기 작업에 대 한 단독으로 사용할 보장 강제로 적용 한 임 대권을 존재 하는 경우 유효한 임대 ID를 가집니다.</span><span class="sxs-lookup"><span data-stu-id="6ec80-235">Where a lease exists hello storage service enforces exclusive writes (put, set and delete operations) however ensuring exclusivity for read operations requires hello developer tooensure that all client applications use a lease ID and that only one client at a time has a valid lease ID.</span></span> <span data-ttu-id="6ec80-236">임대 ID를 포함하지 않는 읽기 작업에서는 공유 읽기가 수행됩니다.</span><span class="sxs-lookup"><span data-stu-id="6ec80-236">Read operations that do not include a lease ID result in shared reads.</span></span>  

<span data-ttu-id="6ec80-237">hello 다음 C# 조각은의 예가 나와 blob에서 30 초 동안 단독 임대를 획득를 hello blob의 hello 콘텐츠를 업데이트 한 다음 hello 임대를 해제 합니다.</span><span class="sxs-lookup"><span data-stu-id="6ec80-237">hello following C# snippet shows an example of acquiring an exclusive lease for 30 seconds on a blob, updating hello content of hello blob, and then releasing hello lease.</span></span> <span data-ttu-id="6ec80-238">이미 있으면 유효한 임대 hello blob에서 새로운 임대 tooacquire 려 할 때, hello blob 서비스는 "HTTP (409) 충돌" 상태 결과 반환 합니다.</span><span class="sxs-lookup"><span data-stu-id="6ec80-238">If there is already a valid lease on hello blob when you try tooacquire a new lease, hello blob service returns an "HTTP (409) Conflict" status result.</span></span> <span data-ttu-id="6ec80-239">hello 다음 코드 조각을 사용 하 여 프로그램 **AccessCondition** hello 저장소 서비스에 요청 tooupdate hello blob는 시 tooencapsulate hello 임대 정보 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="6ec80-239">hello following snippet uses an **AccessCondition** object tooencapsulate hello lease information when it makes a request tooupdate hello blob in hello storage service.</span></span>  <span data-ttu-id="6ec80-240">전체 샘플 hello 다운로드할 수 있습니다: [Azure 저장소를 사용 하 여 관리 동시성](http://code.msdn.microsoft.com/Managing-Concurrency-using-56018114)합니다.</span><span class="sxs-lookup"><span data-stu-id="6ec80-240">You can download hello full sample here: [Managing Concurrency using Azure Storage](http://code.msdn.microsoft.com/Managing-Concurrency-using-56018114).</span></span>

```csharp
// Acquire lease for 15 seconds
string lease = blockBlob.AcquireLease(TimeSpan.FromSeconds(15), null);
Console.WriteLine("Blob lease acquired. Lease = {0}", lease);

// Update blob using lease. This operation will succeed
const string helloText = "Blob updated";
var accessCondition = AccessCondition.GenerateLeaseCondition(lease);
blockBlob.UploadText(helloText, accessCondition: accessCondition);
Console.WriteLine("Blob updated using an exclusive lease");

//Simulate third party update tooblob without lease
try
{
    // Below operation will fail as no valid lease provided
    Console.WriteLine("Trying tooupdate blob without valid lease");
    blockBlob.UploadText("Update without lease, will fail");
}
catch (StorageException ex)
{
    if (ex.RequestInformation.HttpStatusCode == (int)HttpStatusCode.PreconditionFailed)
        Console.WriteLine("Precondition failure as expected. Blob's lease does not match");
    else
        throw;
}  
```

<span data-ttu-id="6ec80-241">Hello 임대 ID를 전달 하지 않고 임대 된 blob에 쓰기 작업을 시도 하면 hello 요청이 412 오류와 함께 실패 합니다.</span><span class="sxs-lookup"><span data-stu-id="6ec80-241">If you attempt a write operation on a leased blob without passing hello lease ID, hello request fails with a 412 error.</span></span> <span data-ttu-id="6ec80-242">참고 경우 hello 임대가 만료 hello를 호출 하기 전에 되 **UploadText** 메서드 있지만 여전히 hello 임대 ID,와 hello 요청도 실패 한 **412** 오류입니다.</span><span class="sxs-lookup"><span data-stu-id="6ec80-242">Note that if hello lease expires before calling hello **UploadText** method but you still pass hello lease ID, hello request also fails with a **412** error.</span></span> <span data-ttu-id="6ec80-243">임대 만료 시간 및 표준 임대 Id 관리 하는 방법에 대 한 자세한 내용은 참조 hello [Blob 임대](http://msdn.microsoft.com/library/azure/ee691972.aspx) REST 설명서입니다.</span><span class="sxs-lookup"><span data-stu-id="6ec80-243">For more information about managing lease expiry times and lease IDs, see hello [Lease Blob](http://msdn.microsoft.com/library/azure/ee691972.aspx) REST documentation.</span></span>  

<span data-ttu-id="6ec80-244">hello 다음 blob 작업 צ ְ ײ 임대 toomanage 비관적 동시성:</span><span class="sxs-lookup"><span data-stu-id="6ec80-244">hello following blob operations can use leases toomanage pessimistic concurrency:</span></span>  

* <span data-ttu-id="6ec80-245">Blob 배치</span><span class="sxs-lookup"><span data-stu-id="6ec80-245">Put Blob</span></span>
* <span data-ttu-id="6ec80-246">Blob 가져오기</span><span class="sxs-lookup"><span data-stu-id="6ec80-246">Get Blob</span></span>
* <span data-ttu-id="6ec80-247">Blob 속성 가져오기</span><span class="sxs-lookup"><span data-stu-id="6ec80-247">Get Blob Properties</span></span>
* <span data-ttu-id="6ec80-248">Blob 속성 설정</span><span class="sxs-lookup"><span data-stu-id="6ec80-248">Set Blob Properties</span></span>
* <span data-ttu-id="6ec80-249">Blob 메타데이터 가져오기</span><span class="sxs-lookup"><span data-stu-id="6ec80-249">Get Blob Metadata</span></span>
* <span data-ttu-id="6ec80-250">Blob 메타데이터 설정</span><span class="sxs-lookup"><span data-stu-id="6ec80-250">Set Blob Metadata</span></span>
* <span data-ttu-id="6ec80-251">Blob 삭제</span><span class="sxs-lookup"><span data-stu-id="6ec80-251">Delete Blob</span></span>
* <span data-ttu-id="6ec80-252">블록 배치</span><span class="sxs-lookup"><span data-stu-id="6ec80-252">Put Block</span></span>
* <span data-ttu-id="6ec80-253">블록 목록 배치</span><span class="sxs-lookup"><span data-stu-id="6ec80-253">Put Block List</span></span>
* <span data-ttu-id="6ec80-254">블록 목록 가져오기</span><span class="sxs-lookup"><span data-stu-id="6ec80-254">Get Block List</span></span>
* <span data-ttu-id="6ec80-255">페이지 가져오기</span><span class="sxs-lookup"><span data-stu-id="6ec80-255">Put Page</span></span>
* <span data-ttu-id="6ec80-256">페이지 범위 가져오기</span><span class="sxs-lookup"><span data-stu-id="6ec80-256">Get Page Ranges</span></span>
* <span data-ttu-id="6ec80-257">스냅숏 Blob - 임대가 있는 경우 임대 ID는 선택 사항임</span><span class="sxs-lookup"><span data-stu-id="6ec80-257">Snapshot Blob - lease ID optional if a lease exists</span></span>
* <span data-ttu-id="6ec80-258">Blob 복사-임대 ID 필요한 hello 대상 blob에 임대가 있는 경우</span><span class="sxs-lookup"><span data-stu-id="6ec80-258">Copy Blob - lease ID required if a lease exists on hello destination blob</span></span>
* <span data-ttu-id="6ec80-259">Blob 복사 중단-임대 ID hello 대상 blob에 무한 임대 존재 하는 경우 필수</span><span class="sxs-lookup"><span data-stu-id="6ec80-259">Abort Copy Blob - lease ID required if an infinite lease exists on hello destination blob</span></span>
* <span data-ttu-id="6ec80-260">Blob 임대</span><span class="sxs-lookup"><span data-stu-id="6ec80-260">Lease Blob</span></span>  

### <a name="pessimistic-concurrency-for-containers"></a><span data-ttu-id="6ec80-261">컨테이너에 대한 비관적 동시성</span><span class="sxs-lookup"><span data-stu-id="6ec80-261">Pessimistic concurrency for containers</span></span>
<span data-ttu-id="6ec80-262">그러나 컨테이너에서 임대 blob에서와 같은 동기화 전략 toobe 지원 hello를 사용 하도록 설정 (단독 쓰기 / 읽기, 전용 쓰기 공유 / 단독 읽기 및 쓰기 공유 단독 읽기 /) 달리 blob 저장소 서비스 hello만 강제 단독으로 사용할 delete 작업입니다.</span><span class="sxs-lookup"><span data-stu-id="6ec80-262">Leases on containers enable hello same synchronization strategies toobe supported as on blobs (exclusive write / shared read, exclusive write / exclusive read and shared write / exclusive read) however unlike blobs hello storage service only enforces exclusivity on delete operations.</span></span> <span data-ttu-id="6ec80-263">활성 임대가 있는 컨테이너 toodelete 클라이언트 hello 삭제 요청에 hello 활성 임대 ID가 포함 되어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="6ec80-263">toodelete a container with an active lease, a client must include hello active lease ID with hello delete request.</span></span> <span data-ttu-id="6ec80-264">다른 모든 컨테이너 작업 하지 않아도 임대 된 컨테이너에서 hello 임대 ID를 포함 하 여 작업을 공유 하는 경우.</span><span class="sxs-lookup"><span data-stu-id="6ec80-264">All other container operations succeed on a leased container without including hello lease ID in which case they are shared operations.</span></span> <span data-ttu-id="6ec80-265">업데이트(배치 또는 설정) 또는 읽기 작업에서 독점성이 필요한 경우 개발자는 모든 클라이언트가 임대 ID를 사용하고 한 번에 한 클라이언트만 유효한 임대 ID를 사용하도록 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="6ec80-265">If exclusivity of update (put or set) or read operations is required then developers should ensure all clients use a lease ID and that only one client at a time has a valid lease ID.</span></span>  

<span data-ttu-id="6ec80-266">hello 다음 컨테이너 작업 צ ְ ײ 임대 toomanage 비관적 동시성:</span><span class="sxs-lookup"><span data-stu-id="6ec80-266">hello following container operations can use leases toomanage pessimistic concurrency:</span></span>  

* <span data-ttu-id="6ec80-267">컨테이너 삭제</span><span class="sxs-lookup"><span data-stu-id="6ec80-267">Delete Container</span></span>
* <span data-ttu-id="6ec80-268">컨테이너 속성 가져오기</span><span class="sxs-lookup"><span data-stu-id="6ec80-268">Get Container Properties</span></span>
* <span data-ttu-id="6ec80-269">컨테이너 메타데이터 가져오기</span><span class="sxs-lookup"><span data-stu-id="6ec80-269">Get Container Metadata</span></span>
* <span data-ttu-id="6ec80-270">컨테이너 메타데이터 설정</span><span class="sxs-lookup"><span data-stu-id="6ec80-270">Set Container Metadata</span></span>
* <span data-ttu-id="6ec80-271">컨테이너 ACL 가져오기</span><span class="sxs-lookup"><span data-stu-id="6ec80-271">Get Container ACL</span></span>
* <span data-ttu-id="6ec80-272">컨테이너 ACL 설정</span><span class="sxs-lookup"><span data-stu-id="6ec80-272">Set Container ACL</span></span>
* <span data-ttu-id="6ec80-273">컨테이너 임대</span><span class="sxs-lookup"><span data-stu-id="6ec80-273">Lease Container</span></span>  

<span data-ttu-id="6ec80-274">자세한 내용은 다음을 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="6ec80-274">For more information, see:</span></span>  

* [<span data-ttu-id="6ec80-275">Blob 서비스 작업의 조건부 헤더 지정</span><span class="sxs-lookup"><span data-stu-id="6ec80-275">Specifying Conditional Headers for Blob Service Operations</span></span>](http://msdn.microsoft.com/library/azure/dd179371.aspx)
* [<span data-ttu-id="6ec80-276">컨테이너 임대</span><span class="sxs-lookup"><span data-stu-id="6ec80-276">Lease Container</span></span>](http://msdn.microsoft.com/library/azure/jj159103.aspx)
* [<span data-ttu-id="6ec80-277">Blob 임대 </span><span class="sxs-lookup"><span data-stu-id="6ec80-277">Lease Blob </span></span>](http://msdn.microsoft.com/library/azure/ee691972.aspx)

## <a name="managing-concurrency-in-hello-table-service"></a><span data-ttu-id="6ec80-278">Hello 테이블 서비스의에서 동시성을 관리합니다.</span><span class="sxs-lookup"><span data-stu-id="6ec80-278">Managing Concurrency in hello Table Service</span></span>
<span data-ttu-id="6ec80-279">hello 테이블 서비스에서는 낙관적 동시성 tooperform 낙관적 동시성 검사를 명시적으로 선택 해야 하는 hello blob 서비스와 달리 엔터티를 사용 하 여 작업할 때 hello 기본 동작으로 검사 합니다.</span><span class="sxs-lookup"><span data-stu-id="6ec80-279">hello table service uses optimistic concurrency checks as hello default behavior when you are working with entities, unlike hello blob service where you must explicitly choose tooperform optimistic concurrency checks.</span></span> <span data-ttu-id="6ec80-280">hello 다른 차이점 hello 테이블 및 blob 서비스는 hello blob 서비스의 컨테이너와 blob hello 동시성을 관리할 수 있습니다 하지만 엔터티 hello 동시성 동작만 관리할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="6ec80-280">hello other difference between hello table and blob services is that you can only manage hello concurrency behavior of entities whereas with hello blob service you can manage hello concurrency of both containers and blobs.</span></span>  

<span data-ttu-id="6ec80-281">toouse 낙관적 동시성 및 toocheck hello 테이블 저장소 서비스에서 검색 한 후 다른 프로세스가 엔터티를 수정 하는 경우에 hello 테이블 서비스 엔터티를 반환 하는 경우 수신 hello ETag 값을 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="6ec80-281">toouse optimistic concurrency and toocheck if another process modified an entity since you retrieved it from hello table storage service, you can use hello ETag value you receive when hello table service returns an entity.</span></span> <span data-ttu-id="6ec80-282">이 프로세스의 hello 개요는 다음과 같습니다.</span><span class="sxs-lookup"><span data-stu-id="6ec80-282">hello outline of this process is as follows:</span></span>  

1. <span data-ttu-id="6ec80-283">Hello 테이블 저장소 서비스에서 엔터티를 검색, hello 응답 hello 저장소 서비스에 해당 엔터티와 관련 된 hello 현재 식별자를 식별 하는 ETag 값을 포함 합니다.</span><span class="sxs-lookup"><span data-stu-id="6ec80-283">Retrieve an entity from hello table storage service, hello response includes an ETag value that identifies hello current identifier associated with that entity in hello storage service.</span></span>
2. <span data-ttu-id="6ec80-284">Hello 엔터티를 업데이트할 때 필수 hello에 1 단계에서 받은 hello ETag 값이 포함 **If-match** toohello 서비스 보낼 hello 요청의 헤더입니다.</span><span class="sxs-lookup"><span data-stu-id="6ec80-284">When you update hello entity, include hello ETag value you received in step 1 in hello mandatory **If-Match** header of hello request you send toohello service.</span></span>
3. <span data-ttu-id="6ec80-285">hello 서비스는 hello 요청의 hello hello 엔터티의 현재 ETag 값을 가진 hello ETag 값을 비교합니다.</span><span class="sxs-lookup"><span data-stu-id="6ec80-285">hello service compares hello ETag value in hello request with hello current ETag value of hello entity.</span></span>
4. <span data-ttu-id="6ec80-286">Hello hello 엔터티의 현재 ETag 값과 다른 필수 hello에 ETag hello 경우 **If-match** hello 서비스 hello 요청에서 헤더 412 오류 toohello 클라이언트를 반환 합니다.</span><span class="sxs-lookup"><span data-stu-id="6ec80-286">If hello current ETag value of hello entity is different than hello ETag in hello mandatory **If-Match** header in hello request, hello service returns a 412 error toohello client.</span></span> <span data-ttu-id="6ec80-287">이 다른 프로세스가 hello 클라이언트 것으로 검색 한 이후 hello 엔터티를 업데이트 하는 toohello 클라이언트를 나타냅니다.</span><span class="sxs-lookup"><span data-stu-id="6ec80-287">This indicates toohello client that another process has updated hello entity since hello client retrieved it.</span></span>
5. <span data-ttu-id="6ec80-288">Hello hello 엔터티의 현재 ETag 값이 필수 hello에 ETag를 hello와 동일 hello는 경우 **If-match** 헤더 hello 요청 또는 hello에 **If-match** 헤더 hello 와일드 카드 문자 (*) hello 서비스 포함 수행 작업 및 업데이트에 업데이트 된 hello 엔터티 tooshow의 현재 ETag 값 hello hello 요청 합니다.</span><span class="sxs-lookup"><span data-stu-id="6ec80-288">If hello current ETag value of hello entity is hello same as hello ETag in hello mandatory **If-Match** header in hello request or hello **If-Match** header contains hello wildcard character (*), hello service performs hello requested operation and updates hello current ETag value of hello entity tooshow that it has been updated.</span></span>  

<span data-ttu-id="6ec80-289">Hello blob 서비스와 달리 hello 테이블 서비스 해야 hello 클라이언트 tooinclude는 **If-match** 업데이트 요청에 헤더입니다.</span><span class="sxs-lookup"><span data-stu-id="6ec80-289">Note that unlike hello blob service, hello table service requires hello client tooinclude an **If-Match** header in update requests.</span></span> <span data-ttu-id="6ec80-290">그러나 가능한 tooforce는 무조건는 (마지막 기록기 wins 전략)를 업데이트 하 고 hello 클라이언트 hello를 설정 하는 경우 동시성 검사를 무시 **If-match** hello 요청에 헤더 toohello 와일드 카드 문자 (*).</span><span class="sxs-lookup"><span data-stu-id="6ec80-290">However, it is possible tooforce an unconditional update (last writer wins strategy) and bypass concurrency checks if hello client sets hello **If-Match** header toohello wildcard character (*) in hello request.</span></span>  

<span data-ttu-id="6ec80-291">다음 C# 조각은 hello 이전에 만들어졌거나 업데이트 자신의 전자 메일 주소를 검색 하는 customer 엔터티를 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="6ec80-291">hello following C# snippet shows a customer entity that was previously either created or retrieved having their email address updated.</span></span> <span data-ttu-id="6ec80-292">hello 초기를 삽입 하거나 hello customer 개체의 작업 저장소 hello ETag 값을 검색할 hello hello를 실행 하는 경우 동일한 개체 인스턴스 바꾸기 작업 hello 샘플에서 사용 하기 때문에, hello ETag 값 백 toohello 테이블 서비스를 자동으로 전송 동시성 위반에 대 한 서비스 toocheck hello를 사용 하도록 설정 합니다.</span><span class="sxs-lookup"><span data-stu-id="6ec80-292">hello initial insert or retrieve operation stores hello ETag value in hello customer object, and because hello sample uses hello same object instance when it executes hello replace operation, it automatically sends hello ETag value back toohello table service, enabling hello service toocheck for concurrency violations.</span></span> <span data-ttu-id="6ec80-293">다른 프로세스가 테이블 저장소의 엔터티에 hello 업데이트 hello 서비스가 HTTP 412 (전제 조건 실패) 상태 메시지를 반환 합니다.</span><span class="sxs-lookup"><span data-stu-id="6ec80-293">If another process has updated hello entity in table storage, hello service returns an HTTP 412 (Precondition Failed) status message.</span></span>  <span data-ttu-id="6ec80-294">전체 샘플 hello 다운로드할 수 있습니다: [Azure 저장소를 사용 하 여 관리 동시성](http://code.msdn.microsoft.com/Managing-Concurrency-using-56018114)합니다.</span><span class="sxs-lookup"><span data-stu-id="6ec80-294">You can download hello full sample here: [Managing Concurrency using Azure Storage](http://code.msdn.microsoft.com/Managing-Concurrency-using-56018114).</span></span>

```csharp
try
{
    customer.Email = "updatedEmail@contoso.org";
    TableOperation replaceCustomer = TableOperation.Replace(customer);
    customerTable.Execute(replaceCustomer);
    Console.WriteLine("Replace operation succeeded.");
}
catch (StorageException ex)
{
    if (ex.RequestInformation.HttpStatusCode == 412)
        Console.WriteLine("Optimistic concurrency violation – entity has changed since it was retrieved.");
    else
        throw;
}  
```

<span data-ttu-id="6ec80-295">tooexplicitly hello 동시성 검사 사용 안 함, hello 설정할지 **ETag** hello 속성 **직원** 너무 개체 "*" hello 바꾸기 작업을 실행 하기 전에.</span><span class="sxs-lookup"><span data-stu-id="6ec80-295">tooexplicitly disable hello concurrency check, you should set hello **ETag** property of hello **employee** object too"*" before you execute hello replace operation.</span></span>  

```csharp
customer.ETag = "*";  
```

<span data-ttu-id="6ec80-296">hello 다음 표에 요약 hello 테이블 엔터티 작업 ETag 값을 사용 하는 방법.</span><span class="sxs-lookup"><span data-stu-id="6ec80-296">hello following table summarizes how hello table entity operations use ETag values:</span></span>

| <span data-ttu-id="6ec80-297">작업</span><span class="sxs-lookup"><span data-stu-id="6ec80-297">Operation</span></span> | <span data-ttu-id="6ec80-298">ETag 값 반환</span><span class="sxs-lookup"><span data-stu-id="6ec80-298">Returns ETag value</span></span> | <span data-ttu-id="6ec80-299">If-Match 요청 헤더 필요 여부</span><span class="sxs-lookup"><span data-stu-id="6ec80-299">Requires If-Match request header</span></span> |
|:--- |:--- |:--- |
| <span data-ttu-id="6ec80-300">엔터티 쿼리</span><span class="sxs-lookup"><span data-stu-id="6ec80-300">Query Entities</span></span> |<span data-ttu-id="6ec80-301">예</span><span class="sxs-lookup"><span data-stu-id="6ec80-301">Yes</span></span> |<span data-ttu-id="6ec80-302">아니요</span><span class="sxs-lookup"><span data-stu-id="6ec80-302">No</span></span> |
| <span data-ttu-id="6ec80-303">엔터티 삽입</span><span class="sxs-lookup"><span data-stu-id="6ec80-303">Insert Entity</span></span> |<span data-ttu-id="6ec80-304">예</span><span class="sxs-lookup"><span data-stu-id="6ec80-304">Yes</span></span> |<span data-ttu-id="6ec80-305">아니요</span><span class="sxs-lookup"><span data-stu-id="6ec80-305">No</span></span> |
| <span data-ttu-id="6ec80-306">엔터티 업데이트</span><span class="sxs-lookup"><span data-stu-id="6ec80-306">Update Entity</span></span> |<span data-ttu-id="6ec80-307">예</span><span class="sxs-lookup"><span data-stu-id="6ec80-307">Yes</span></span> |<span data-ttu-id="6ec80-308">예</span><span class="sxs-lookup"><span data-stu-id="6ec80-308">Yes</span></span> |
| <span data-ttu-id="6ec80-309">엔터티 병합</span><span class="sxs-lookup"><span data-stu-id="6ec80-309">Merge Entity</span></span> |<span data-ttu-id="6ec80-310">예</span><span class="sxs-lookup"><span data-stu-id="6ec80-310">Yes</span></span> |<span data-ttu-id="6ec80-311">예</span><span class="sxs-lookup"><span data-stu-id="6ec80-311">Yes</span></span> |
| <span data-ttu-id="6ec80-312">엔터티 삭제</span><span class="sxs-lookup"><span data-stu-id="6ec80-312">Delete Entity</span></span> |<span data-ttu-id="6ec80-313">아니요</span><span class="sxs-lookup"><span data-stu-id="6ec80-313">No</span></span> |<span data-ttu-id="6ec80-314">예</span><span class="sxs-lookup"><span data-stu-id="6ec80-314">Yes</span></span> |
| <span data-ttu-id="6ec80-315">엔터티 삽입 또는 바꾸기</span><span class="sxs-lookup"><span data-stu-id="6ec80-315">Insert or Replace Entity</span></span> |<span data-ttu-id="6ec80-316">예</span><span class="sxs-lookup"><span data-stu-id="6ec80-316">Yes</span></span> |<span data-ttu-id="6ec80-317">아니요</span><span class="sxs-lookup"><span data-stu-id="6ec80-317">No</span></span> |
| <span data-ttu-id="6ec80-318">엔터티 삽입 또는 병합</span><span class="sxs-lookup"><span data-stu-id="6ec80-318">Insert or Merge Entity</span></span> |<span data-ttu-id="6ec80-319">예</span><span class="sxs-lookup"><span data-stu-id="6ec80-319">Yes</span></span> |<span data-ttu-id="6ec80-320">아니요</span><span class="sxs-lookup"><span data-stu-id="6ec80-320">No</span></span> |

<span data-ttu-id="6ec80-321">해당 hello 참고 **삽입 또는 교체 엔터티** 및 **삽입 또는 병합 엔터티** operations *하지* ETag 값 toohello 보내지 동시성 검사를 수행 합니다. 테이블 서비스입니다.</span><span class="sxs-lookup"><span data-stu-id="6ec80-321">Note that hello **Insert or Replace Entity** and **Insert or Merge Entity** operations do *not* perform any concurrency checks because they do not send an ETag value toohello table service.</span></span>  

<span data-ttu-id="6ec80-322">일반적으로 테이블을 사용하는 개발자는 확장 가능한 응용 프로그램을 개발할 때 낙관적 동시성을 사용해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="6ec80-322">In general developers using tables should rely on optimistic concurrency when developing scalable applications.</span></span> <span data-ttu-id="6ec80-323">비관적 잠금 필요한 한 가지 방법은 개발자 tooassign 각 테이블에 대해 지정 된 blob는 테이블에 액세스할 때 수행할 수 고 hello 테이블을 조작 하기 전에 tootake hello blob에서 임대를 시도 합니다.</span><span class="sxs-lookup"><span data-stu-id="6ec80-323">If pessimistic locking is needed, one approach developers can take when accessing Tables is tooassign a designated blob for each table and try tootake a lease on hello blob before operating on hello table.</span></span> <span data-ttu-id="6ec80-324">이 방법에는 필요 hello 응용 프로그램 tooensure 데이터에 대 한 모든 액세스 경로 hello hello 테이블에서 이전 toooperating 임대를 가져옵니다.</span><span class="sxs-lookup"><span data-stu-id="6ec80-324">This approach does require hello application tooensure all data access paths obtain hello lease prior toooperating on hello table.</span></span> <span data-ttu-id="6ec80-325">hello 최소 임대 시간은 15 초 필요한입니다 확장성을 위해 신중 하 게 고려 점에 유의 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="6ec80-325">You should also note that hello minimum lease time is 15 seconds which requires careful consideration for scalability.</span></span>  

<span data-ttu-id="6ec80-326">자세한 내용은 다음을 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="6ec80-326">For more information, see:</span></span>  

* [<span data-ttu-id="6ec80-327">엔터티에 대한 작업</span><span class="sxs-lookup"><span data-stu-id="6ec80-327">Operations on Entities</span></span>](http://msdn.microsoft.com/library/azure/dd179375.aspx)  

## <a name="managing-concurrency-in-hello-queue-service"></a><span data-ttu-id="6ec80-328">Hello 큐 서비스의에서 동시성을 관리합니다.</span><span class="sxs-lookup"><span data-stu-id="6ec80-328">Managing Concurrency in hello Queue Service</span></span>
<span data-ttu-id="6ec80-329">동시성 hello 큐 서비스의 우려가 하는 한 시나리오는 여러 클라이언트가 큐에서 메시지를 검색 됩니다.</span><span class="sxs-lookup"><span data-stu-id="6ec80-329">One scenario in which concurrency is a concern in hello queueing service is where multiple clients are retrieving messages from a queue.</span></span> <span data-ttu-id="6ec80-330">를 hello 큐에서 메시지를 검색할 때 hello 응답에는 hello 메시지와 필요한 toodelete hello 메시지 popreceipt 값 포함 됩니다.</span><span class="sxs-lookup"><span data-stu-id="6ec80-330">When a message is retrieved from hello queue, hello response includes hello message and a pop receipt value, which is required toodelete hello message.</span></span> <span data-ttu-id="6ec80-331">hello 메시지가 hello 큐에서 자동으로 삭제 되지 않으면 검색 한 후 것만 표시 tooother 클라이언트 hello visibilitytimeout 매개 변수로 지정 된 hello 시간 간격에 대 한 합니다.</span><span class="sxs-lookup"><span data-stu-id="6ec80-331">hello message is not automatically deleted from hello queue, but after it has been retrieved, it is not visible tooother clients for hello time interval specified by hello visibilitytimeout parameter.</span></span> <span data-ttu-id="6ec80-332">hello 전에 지정 된 시간 hello hello 응답의 계산 된 hello visibilitytimeout hello 값에 따라 TimeNextVisible 요소 및 처리 된 후 hello 클라이언트 hello 메시지를 검색 하는 예상된 toodelete hello 메시지 매개 변수입니다.</span><span class="sxs-lookup"><span data-stu-id="6ec80-332">hello client that retrieves hello message is expected toodelete hello message after it has been processed, and before hello time specified by hello TimeNextVisible element of hello response, which is calculated based on hello value of hello visibilitytimeout parameter.</span></span> <span data-ttu-id="6ec80-333">visibilitytimeout hello 값 toohello 시간은 hello 메시지 TimeNextVisible toodetermine hello 값 검색을 추가 합니다.</span><span class="sxs-lookup"><span data-stu-id="6ec80-333">hello value of visibilitytimeout is added toohello time at which hello message is retrieved toodetermine hello value of TimeNextVisible.</span></span>  

<span data-ttu-id="6ec80-334">hello 큐 서비스에 낙관적 또는 비관적 동시성에 대 한 지원 없고이 큐에서 검색 된 메시지를 처리 하는 이유 클라이언트 idempotent 방식으로 메시지를 처리 하기 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="6ec80-334">hello queue service does not have support for either optimistic or pessimistic concurrency and for this reason clients processing messages retrieved from a queue should ensure messages are processed in an idempotent manner.</span></span> <span data-ttu-id="6ec80-335">SetQueueServiceProperties, SetQueueMetaData, SetQueueACL, UpdateMessage 등의 업데이트 작업에는 마지막 작성자의 업데이트 적용 전략이 사용됩니다.</span><span class="sxs-lookup"><span data-stu-id="6ec80-335">A last writer wins strategy is used for update operations such as SetQueueServiceProperties, SetQueueMetaData, SetQueueACL and UpdateMessage.</span></span>  

<span data-ttu-id="6ec80-336">자세한 내용은 다음을 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="6ec80-336">For more information, see:</span></span>  

* [<span data-ttu-id="6ec80-337">큐 서비스 REST API</span><span class="sxs-lookup"><span data-stu-id="6ec80-337">Queue Service REST API</span></span>](http://msdn.microsoft.com/library/azure/dd179363.aspx)
* [<span data-ttu-id="6ec80-338">메시지 가져오기</span><span class="sxs-lookup"><span data-stu-id="6ec80-338">Get Messages</span></span>](http://msdn.microsoft.com/library/azure/dd179474.aspx)  

## <a name="managing-concurrency-in-hello-file-service"></a><span data-ttu-id="6ec80-339">Hello 파일 서비스의에서 동시성을 관리합니다.</span><span class="sxs-lookup"><span data-stu-id="6ec80-339">Managing Concurrency in hello File Service</span></span>
<span data-ttu-id="6ec80-340">hello 파일 서비스는 두 개의 다른 프로토콜 끝점-SMB 및 REST를 사용 하 여 액세스할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="6ec80-340">hello file service can be accessed using two different protocol endpoints – SMB and REST.</span></span> <span data-ttu-id="6ec80-341">hello REST 서비스에 낙관적 잠금 또는 비관적 잠금에 대 한 지원 없고 모든 업데이트는 마지막 기록기 wins 전략을 따를 것입니다.</span><span class="sxs-lookup"><span data-stu-id="6ec80-341">hello REST service does not have support for either optimistic locking or pessimistic locking and all updates will follow a last writer wins strategy.</span></span> <span data-ttu-id="6ec80-342">파일 공유를 탑재 된 SMB 클라이언트 파일 시스템 잠금 메커니즘 toomanage tooshared 파일 액세스 – hello 기능 tooperform 비관적 잠금을 포함 하 여 활용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="6ec80-342">SMB clients that mount file shares can leverage file system locking mechanisms toomanage access tooshared files – including hello ability tooperform pessimistic locking.</span></span> <span data-ttu-id="6ec80-343">Hello 파일 액세스 및 공유를 모두 지정 SMB 클라이언트는 파일을 열면 모드입니다.</span><span class="sxs-lookup"><span data-stu-id="6ec80-343">When an SMB client opens a file, it specifies both hello file access and share mode.</span></span> <span data-ttu-id="6ec80-344">"None"의 파일 공유 모드와 함께 "쓰기" 또는 "읽기/쓰기"의 파일 액세스 옵션을 설정 hello 파일을 닫을 때까지 SMB 클라이언트에 의해 잠기지 hello 파일에서 발생 합니다.</span><span class="sxs-lookup"><span data-stu-id="6ec80-344">Setting a File Access option of "Write" or "Read/Write" along with a File Share mode of "None" will result in hello file being locked by an SMB client until hello file is closed.</span></span> <span data-ttu-id="6ec80-345">SMB 클라이언트 hello 파일이 잠겨에 있는 파일에 대해 REST 작업을 시도 하는 경우 hello REST 서비스는 오류 코드 sharingviolation이 표시와 함께 상태 코드 409 (충돌)를 반환 합니다.</span><span class="sxs-lookup"><span data-stu-id="6ec80-345">If REST operation is attempted on a file where an SMB client has hello file locked hello REST service will return status code 409 (Conflict) with error code SharingViolation.</span></span>  

<span data-ttu-id="6ec80-346">SMB 클라이언트에서 삭제를 위해 파일을 열면 해당 파일에 대해 열린 핸들이 닫힐 때 보류 중인 다른 모든 SMB 클라이언트까지 삭제가 때 hello 파일을 표시 합니다.</span><span class="sxs-lookup"><span data-stu-id="6ec80-346">When an SMB client opens a file for delete, it marks hello file as pending delete until all other SMB client open handles on that file are closed.</span></span> <span data-ttu-id="6ec80-347">파일이 삭제 보류 중으로 표시되어 있는 동안 해당 파일에 대해 REST 작업을 수행하면 상태 코드 409(충돌)와 오류 코드 SMBDeletePending이 반환됩니다.</span><span class="sxs-lookup"><span data-stu-id="6ec80-347">While a file is marked as pending delete, any REST operation on that file will return status code 409 (Conflict) with error code SMBDeletePending.</span></span> <span data-ttu-id="6ec80-348">보류 중인 삭제 플래그 이전 tooclosing hello 파일 hello SMB 클라이언트 tooremove hello에 대 한 수 있기 때문에 상태 코드 404 (찾을 수 없음) 반환 되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="6ec80-348">Status code 404 (Not Found) is not returned since it is possible for hello SMB client tooremove hello pending deletion flag prior tooclosing hello file.</span></span> <span data-ttu-id="6ec80-349">즉, 상태 코드 404 (찾을 수 없음)는 hello 파일 제거 된 경우에 필요 합니다.</span><span class="sxs-lookup"><span data-stu-id="6ec80-349">In other words, status code 404 (Not Found) is only expected when hello file has been removed.</span></span> <span data-ttu-id="6ec80-350">파일을 SMB 삭제 보류 중 상태가 중일 것 포함 되지 않습니다 hello 파일 목록 결과에서 note 합니다.</span><span class="sxs-lookup"><span data-stu-id="6ec80-350">Note that while a file is in an SMB pending delete state, it will not be included in hello List Files results.</span></span> <span data-ttu-id="6ec80-351">또한 hello 파일을 삭제 하는 REST 및 디렉터리를 삭제 하는 REST 작업은 원자성으로 및 보류 중인 삭제 상태에 나타나지 note 합니다.</span><span class="sxs-lookup"><span data-stu-id="6ec80-351">Also, note that hello REST Delete File and REST Delete Directory operations are committed atomically and do not result in a pending delete state.</span></span>  

<span data-ttu-id="6ec80-352">자세한 내용은 다음을 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="6ec80-352">For more information, see:</span></span>  

* [<span data-ttu-id="6ec80-353">파일 잠금 관리</span><span class="sxs-lookup"><span data-stu-id="6ec80-353">Managing File Locks</span></span>](http://msdn.microsoft.com/library/azure/dn194265.aspx)  

## <a name="summary-and-next-steps"></a><span data-ttu-id="6ec80-354">요약 및 다음 단계</span><span class="sxs-lookup"><span data-stu-id="6ec80-354">Summary and Next Steps</span></span>
<span data-ttu-id="6ec80-355">hello Microsoft Azure 저장소 서비스 했습니다 설계 hello 가장 복잡 한 온라인 응용 프로그램의 toomeet hello 요구 개발자 toocompromise 또는 재고 주요 디자인 가정 동시성 및 데이터 일관성 등 tootake를 발견 했을 시작 하지 않고 당연 합니다.</span><span class="sxs-lookup"><span data-stu-id="6ec80-355">hello Microsoft Azure Storage service has been designed toomeet hello needs of hello most complex online applications without forcing developers toocompromise or rethink key design assumptions such as concurrency and data consistency that they have come tootake for granted.</span></span>  

<span data-ttu-id="6ec80-356">Hello에 대 한이 블로그에서 참조 하는 샘플 응용 프로그램을 완료 합니다.</span><span class="sxs-lookup"><span data-stu-id="6ec80-356">For hello complete sample application referenced in this blog:</span></span>  

* [<span data-ttu-id="6ec80-357">Azure 저장소를 사용하여 동시성 관리 - 샘플 응용 프로그램</span><span class="sxs-lookup"><span data-stu-id="6ec80-357">Managing Concurrency using Azure Storage - Sample Application</span></span>](http://code.msdn.microsoft.com/Managing-Concurrency-using-56018114)  

<span data-ttu-id="6ec80-358">Azure 저장소에 대한 자세한 내용은 다음을 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="6ec80-358">For more information on Azure Storage see:</span></span>  

* [<span data-ttu-id="6ec80-359">Microsoft Azure 저장소 홈페이지</span><span class="sxs-lookup"><span data-stu-id="6ec80-359">Microsoft Azure Storage Home Page</span></span>](https://azure.microsoft.com/services/storage/)
* [<span data-ttu-id="6ec80-360">소개 tooAzure 저장소</span><span class="sxs-lookup"><span data-stu-id="6ec80-360">Introduction tooAzure Storage</span></span>](storage-introduction.md)
* <span data-ttu-id="6ec80-361">[Blob](../blobs/storage-dotnet-how-to-use-blobs.md), [테이블](../../cosmos-db/table-storage-how-to-use-dotnet.md), [큐](../storage-dotnet-how-to-use-queues.md) 및 [파일](../storage-dotnet-how-to-use-files.md)에 대한 저장소 시작</span><span class="sxs-lookup"><span data-stu-id="6ec80-361">Storage Getting Started for [Blob](../blobs/storage-dotnet-how-to-use-blobs.md), [Table](../../cosmos-db/table-storage-how-to-use-dotnet.md),  [Queues](../storage-dotnet-how-to-use-queues.md), and [Files](../storage-dotnet-how-to-use-files.md)</span></span>
* <span data-ttu-id="6ec80-362">저장소 아키텍처 – [Azure Storage: 강력한 일관성과 함께 항상 사용 가능한 클라우드 저장소 서비스](http://blogs.msdn.com/b/windowsazurestorage/archive/2011/11/20/windows-azure-storage-a-highly-available-cloud-storage-service-with-strong-consistency.aspx)</span><span class="sxs-lookup"><span data-stu-id="6ec80-362">Storage Architecture – [Azure Storage: A Highly Available Cloud Storage Service with Strong Consistency](http://blogs.msdn.com/b/windowsazurestorage/archive/2011/11/20/windows-azure-storage-a-highly-available-cloud-storage-service-with-strong-consistency.aspx)</span></span>

