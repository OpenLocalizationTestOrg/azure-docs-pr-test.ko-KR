---
title: "aaaAzure 저장소 성능 및 확장성 검사 목록 | Microsoft Docs"
description: "성능이 뛰어난 응용 프로그램 개발 시 Azure 저장소에서 사용하기 위한 검증된 작업 방식에 대한 검사 목록."
services: storage
documentationcenter: 
author: robinsh
manager: timlt
editor: tysonn
ms.assetid: 959d831b-a4fd-4634-a646-0d2c0c462ef8
ms.service: storage
ms.workload: storage
ms.tgt_pltfrm: na
ms.devlang: na
ms.topic: article
ms.date: 12/08/2016
ms.author: robinsh
ms.openlocfilehash: c0cd77da4a1abda42c018255ed93215b71f4fad8
ms.sourcegitcommit: 523283cc1b3c37c428e77850964dc1c33742c5f0
ms.translationtype: MT
ms.contentlocale: ko-KR
ms.lasthandoff: 10/06/2017
---
# <a name="microsoft-azure-storage-performance-and-scalability-checklist"></a><span data-ttu-id="70433-103">Microsoft Azure 저장소 성능 및 확장성 검사 목록</span><span class="sxs-lookup"><span data-stu-id="70433-103">Microsoft Azure Storage Performance and Scalability Checklist</span></span>
## <a name="overview"></a><span data-ttu-id="70433-104">개요</span><span class="sxs-lookup"><span data-stu-id="70433-104">Overview</span></span>
<span data-ttu-id="70433-105">Hello Microsoft Azure 저장소 서비스의 hello 릴리스부터 Microsoft는 이러한 서비스를 사용 하 여 고성능 방식에서에 대 한 검증 된 사례 수를 개발 하며이 문서 역할 tooconsolidate hello 그 중 가장 중요 한 검사 목록 스타일 목록으로 합니다.</span><span class="sxs-lookup"><span data-stu-id="70433-105">Since hello release of hello Microsoft Azure Storage services, Microsoft has developed a number of proven practices for using these services in a performant manner, and this article serves tooconsolidate hello most important of them into a checklist-style list.</span></span> <span data-ttu-id="70433-106">이 문서의 hello 위한 toohelp 응용 프로그램 개발자가 검증 된 사례를 사용 하 여 Azure 저장소 및 toohelp 채택 해야 다른 검증 된 사례를 식별 하는 확인입니다.</span><span class="sxs-lookup"><span data-stu-id="70433-106">hello intention of this article is toohelp application developers verify they are using proven practices with Azure Storage and toohelp them identify other proven practices they should consider adopting.</span></span> <span data-ttu-id="70433-107">이 문서는 하지 toocover 모든 가능한 성능 및 확장성 최적화-미치는 영향이 작거나 광범위 하 게 적용할 수 있는 메서드를 제외 합니다.</span><span class="sxs-lookup"><span data-stu-id="70433-107">This article does not attempt toocover every possible performance and scalability optimization — it excludes those that are small in their impact or not broadly applicable.</span></span> <span data-ttu-id="70433-108">이러한에 초기에 유의 하는 유용한 tookeep는 디자인 중 응용 프로그램의 동작을 hello toohello 익스텐트를 예측할 수 있는 성능 문제를 경험 합니다 tooavoid 디자인 합니다.</span><span class="sxs-lookup"><span data-stu-id="70433-108">toohello extent that hello application's behavior can be predicted during design, it's useful tookeep these in mind early on tooavoid designs that will run into performance problems.</span></span>  

<span data-ttu-id="70433-109">Azure 저장소를 사용 하 여 모든 응용 프로그램 개발자 해야 hello 시간 tooread이이 문서 걸리고의 응용 프로그램의 hello 검증 된 사용법 아래에 나열 된 각을 따르는지 확인 하십시오.</span><span class="sxs-lookup"><span data-stu-id="70433-109">Every application developer using Azure Storage should take hello time tooread this article, and check that his or her application follows each of hello proven practices listed below.</span></span>  

## <a name="checklist"></a><span data-ttu-id="70433-110">검사 목록</span><span class="sxs-lookup"><span data-stu-id="70433-110">Checklist</span></span>
<span data-ttu-id="70433-111">이 문서는 hello 그룹을 다음으로 입증 된 hello 사례를 구성 합니다.</span><span class="sxs-lookup"><span data-stu-id="70433-111">This article organizes hello proven practices into hello following groups.</span></span> <span data-ttu-id="70433-112">검증된 작업 방식이 적용되는 대상은 다음과 같습니다.</span><span class="sxs-lookup"><span data-stu-id="70433-112">Proven practices applicable to:</span></span>  

* <span data-ttu-id="70433-113">모든 Azure 저장소 서비스(Blob, 테이블, 큐, 파일)</span><span class="sxs-lookup"><span data-stu-id="70433-113">All Azure Storage services (blobs, tables, queues, and files)</span></span>
* <span data-ttu-id="70433-114">Blob</span><span class="sxs-lookup"><span data-stu-id="70433-114">Blobs</span></span>
* <span data-ttu-id="70433-115">테이블</span><span class="sxs-lookup"><span data-stu-id="70433-115">Tables</span></span>
* <span data-ttu-id="70433-116">큐</span><span class="sxs-lookup"><span data-stu-id="70433-116">Queues</span></span>  

| <span data-ttu-id="70433-117">완료된</span><span class="sxs-lookup"><span data-stu-id="70433-117">Done</span></span> | <span data-ttu-id="70433-118">영역</span><span class="sxs-lookup"><span data-stu-id="70433-118">Area</span></span> | <span data-ttu-id="70433-119">Category</span><span class="sxs-lookup"><span data-stu-id="70433-119">Category</span></span> | <span data-ttu-id="70433-120">질문</span><span class="sxs-lookup"><span data-stu-id="70433-120">Question</span></span> |
| --- | --- | --- | --- |
| &nbsp; | <span data-ttu-id="70433-121">모든 서비스</span><span class="sxs-lookup"><span data-stu-id="70433-121">All Services</span></span> |<span data-ttu-id="70433-122">확장성 목표</span><span class="sxs-lookup"><span data-stu-id="70433-122">Scalability Targets</span></span> |[<span data-ttu-id="70433-123">설계 된 응용 프로그램 tooavoid 근접 하 고 확장성 목표 hello?</span><span class="sxs-lookup"><span data-stu-id="70433-123">Is your application designed tooavoid approaching hello scalability targets?</span></span>](#subheading1) |
| &nbsp; | <span data-ttu-id="70433-124">모든 서비스</span><span class="sxs-lookup"><span data-stu-id="70433-124">All Services</span></span> |<span data-ttu-id="70433-125">확장성 목표</span><span class="sxs-lookup"><span data-stu-id="70433-125">Scalability Targets</span></span> |[<span data-ttu-id="70433-126">프로그램 명명 규칙 설계 tooenable 낫거나 부하 분산?</span><span class="sxs-lookup"><span data-stu-id="70433-126">Is your naming convention designed tooenable better load-balancing?</span></span>](#subheading47) |
| &nbsp; | <span data-ttu-id="70433-127">모든 서비스</span><span class="sxs-lookup"><span data-stu-id="70433-127">All Services</span></span> |<span data-ttu-id="70433-128">네트워킹</span><span class="sxs-lookup"><span data-stu-id="70433-128">Networking</span></span> |[<span data-ttu-id="70433-129">클라이언트 쪽 장치 충분히 높은 대역폭 및 대기 시간이 짧은 tooachieve hello 성능 필요한 해야 합니까?</span><span class="sxs-lookup"><span data-stu-id="70433-129">Do client side devices have sufficiently high bandwidth and low latency tooachieve hello performance needed?</span></span>](#subheading2) |
| &nbsp; | <span data-ttu-id="70433-130">모든 서비스</span><span class="sxs-lookup"><span data-stu-id="70433-130">All Services</span></span> |<span data-ttu-id="70433-131">네트워킹</span><span class="sxs-lookup"><span data-stu-id="70433-131">Networking</span></span> |[<span data-ttu-id="70433-132">클라이언트 쪽 장치의 링크 품질이 충분히 높습니까?</span><span class="sxs-lookup"><span data-stu-id="70433-132">Do client side devices have a high enough quality link?</span></span>](#subheading3) |
| &nbsp; | <span data-ttu-id="70433-133">모든 서비스</span><span class="sxs-lookup"><span data-stu-id="70433-133">All Services</span></span> |<span data-ttu-id="70433-134">네트워킹</span><span class="sxs-lookup"><span data-stu-id="70433-134">Networking</span></span> |[<span data-ttu-id="70433-135">클라이언트 응용 프로그램 hello 가까이 "" hello 저장소 계정?</span><span class="sxs-lookup"><span data-stu-id="70433-135">Is hello client application located "near" hello storage account?</span></span>](#subheading4) |
| &nbsp; | <span data-ttu-id="70433-136">모든 서비스</span><span class="sxs-lookup"><span data-stu-id="70433-136">All Services</span></span> |<span data-ttu-id="70433-137">콘텐츠 배포</span><span class="sxs-lookup"><span data-stu-id="70433-137">Content Distribution</span></span> |[<span data-ttu-id="70433-138">콘텐츠 배포를 위해 CDN을 사용합니까?</span><span class="sxs-lookup"><span data-stu-id="70433-138">Are you using a CDN for content distribution?</span></span>](#subheading5) |
| &nbsp; | <span data-ttu-id="70433-139">모든 서비스</span><span class="sxs-lookup"><span data-stu-id="70433-139">All Services</span></span> |<span data-ttu-id="70433-140">직접 클라이언트 액세스</span><span class="sxs-lookup"><span data-stu-id="70433-140">Direct Client Access</span></span> |[<span data-ttu-id="70433-141">프록시 대신 SAS 및 CORS tooallow 직접 액세스 toostorage을 사용 하 고 있습니까?</span><span class="sxs-lookup"><span data-stu-id="70433-141">Are you using SAS and CORS tooallow direct access toostorage instead of proxy?</span></span>](#subheading6) |
| &nbsp; | <span data-ttu-id="70433-142">모든 서비스</span><span class="sxs-lookup"><span data-stu-id="70433-142">All Services</span></span> |<span data-ttu-id="70433-143">구성</span><span class="sxs-lookup"><span data-stu-id="70433-143">Caching</span></span> |[<span data-ttu-id="70433-144">응용 프로그램에서 반복적으로 사용되며 거의 변경되지 않는 데이터를 캐시합니까?</span><span class="sxs-lookup"><span data-stu-id="70433-144">Is your application caching data that is repeatedly used and changes rarely?</span></span>](#subheading7) |
| &nbsp; | <span data-ttu-id="70433-145">모든 서비스</span><span class="sxs-lookup"><span data-stu-id="70433-145">All Services</span></span> |<span data-ttu-id="70433-146">구성</span><span class="sxs-lookup"><span data-stu-id="70433-146">Caching</span></span> |[<span data-ttu-id="70433-147">응용 프로그램에서 업데이트를 일괄 처리(클라이언트 쪽에서 업데이트를 캐시한 다음 더 큰 집합으로 업로드)합니까?</span><span class="sxs-lookup"><span data-stu-id="70433-147">Is your application batching updates (caching them client side and then uploading in larger sets)?</span></span>](#subheading8) |
| &nbsp; | <span data-ttu-id="70433-148">모든 서비스</span><span class="sxs-lookup"><span data-stu-id="70433-148">All Services</span></span> |<span data-ttu-id="70433-149">.NET 구성</span><span class="sxs-lookup"><span data-stu-id="70433-149">.NET Configuration</span></span> |[<span data-ttu-id="70433-150">동시 연결 수가 충분 하 여 클라이언트 toouse 구성 했습니까?</span><span class="sxs-lookup"><span data-stu-id="70433-150">Have you configured your client toouse a sufficient number of concurrent connections?</span></span>](#subheading9) |
| &nbsp; | <span data-ttu-id="70433-151">모든 서비스</span><span class="sxs-lookup"><span data-stu-id="70433-151">All Services</span></span> |<span data-ttu-id="70433-152">.NET 구성</span><span class="sxs-lookup"><span data-stu-id="70433-152">.NET Configuration</span></span> |[<span data-ttu-id="70433-153">.NET toouse 충분 한 수의 스레드 구성 했습니까?</span><span class="sxs-lookup"><span data-stu-id="70433-153">Have you configured .NET toouse a sufficient number of threads?</span></span>](#subheading10) |
| &nbsp; | <span data-ttu-id="70433-154">모든 서비스</span><span class="sxs-lookup"><span data-stu-id="70433-154">All Services</span></span> |<span data-ttu-id="70433-155">.NET 구성</span><span class="sxs-lookup"><span data-stu-id="70433-155">.NET Configuration</span></span> |[<span data-ttu-id="70433-156">가비지 수집 기능이 개선된 .NET 4.5 이상을 사용 중입니까?</span><span class="sxs-lookup"><span data-stu-id="70433-156">Are you using .NET 4.5 or later, which has improved garbage collection?</span></span>](#subheading11) |
| &nbsp; | <span data-ttu-id="70433-157">모든 서비스</span><span class="sxs-lookup"><span data-stu-id="70433-157">All Services</span></span> |<span data-ttu-id="70433-158">병렬 처리</span><span class="sxs-lookup"><span data-stu-id="70433-158">Parallelism</span></span> |[<span data-ttu-id="70433-159">클라이언트 기능 또는 hello 확장성 목표를 오버 로드 하지 않는 있도록 병렬 처리 수준 적절 하 게 제한 확인 게?</span><span class="sxs-lookup"><span data-stu-id="70433-159">Have you ensured that parallelism is bounded appropriately so that you don't overload either your client capabilities or hello scalability targets?</span></span>](#subheading12) |
| &nbsp; | <span data-ttu-id="70433-160">모든 서비스</span><span class="sxs-lookup"><span data-stu-id="70433-160">All Services</span></span> |<span data-ttu-id="70433-161">도구</span><span class="sxs-lookup"><span data-stu-id="70433-161">Tools</span></span> |[<span data-ttu-id="70433-162">클라이언트 라이브러리 및 도구를 제공 된 최신 버전의 Microsoft hello를 사용 하 여 하나요?</span><span class="sxs-lookup"><span data-stu-id="70433-162">Are you using hello latest version of Microsoft provided client libraries and tools?</span></span>](#subheading13) |
| &nbsp; | <span data-ttu-id="70433-163">모든 서비스</span><span class="sxs-lookup"><span data-stu-id="70433-163">All Services</span></span> |<span data-ttu-id="70433-164">다시 시도</span><span class="sxs-lookup"><span data-stu-id="70433-164">Retries</span></span> |[<span data-ttu-id="70433-165">제한 시간 및 오류 제한을 위한 지수 백오프 다시 시도 정책을 사용하고 있습니까?</span><span class="sxs-lookup"><span data-stu-id="70433-165">Are you using an exponential backoff retry policy for throttling errors and timeouts?</span></span>](#subheading14) |
| &nbsp; | <span data-ttu-id="70433-166">모든 서비스</span><span class="sxs-lookup"><span data-stu-id="70433-166">All Services</span></span> |<span data-ttu-id="70433-167">다시 시도</span><span class="sxs-lookup"><span data-stu-id="70433-167">Retries</span></span> |[<span data-ttu-id="70433-168">응용 프로그램에서 다시 시도할 수 없는 오류 발생 시에는 작업을 다시 시도하지 않습니까?</span><span class="sxs-lookup"><span data-stu-id="70433-168">Is your application avoiding retries for non-retryable errors?</span></span>](#subheading15) |
| &nbsp; | <span data-ttu-id="70433-169">Blob</span><span class="sxs-lookup"><span data-stu-id="70433-169">Blobs</span></span> |<span data-ttu-id="70433-170">확장성 목표</span><span class="sxs-lookup"><span data-stu-id="70433-170">Scalability Targets</span></span> |[<span data-ttu-id="70433-171">동시에 단일 개체에 액세스하는 클라이언트가 많이 있습니까?</span><span class="sxs-lookup"><span data-stu-id="70433-171">Do you have a large number of clients accessing a single object concurrently?</span></span>](#subheading46) |
| &nbsp; | <span data-ttu-id="70433-172">Blob</span><span class="sxs-lookup"><span data-stu-id="70433-172">Blobs</span></span> |<span data-ttu-id="70433-173">확장성 목표</span><span class="sxs-lookup"><span data-stu-id="70433-173">Scalability Targets</span></span> |[<span data-ttu-id="70433-174">단일 blob에 대 한 hello 대역폭 또는 작업 확장성 목표 내에서 남아 있는 경우 응용 프로그램?</span><span class="sxs-lookup"><span data-stu-id="70433-174">Is your application staying within hello bandwidth or operations scalability target for a single blob?</span></span>](#subheading16) |
| &nbsp; | <span data-ttu-id="70433-175">Blob</span><span class="sxs-lookup"><span data-stu-id="70433-175">Blobs</span></span> |<span data-ttu-id="70433-176">Blob 복사</span><span class="sxs-lookup"><span data-stu-id="70433-176">Copying Blobs</span></span> |[<span data-ttu-id="70433-177">Blob를 효율적으로 복사하고 있습니까?</span><span class="sxs-lookup"><span data-stu-id="70433-177">Are you copying blobs in an efficient manner?</span></span>](#subheading17) |
| &nbsp; | <span data-ttu-id="70433-178">Blob</span><span class="sxs-lookup"><span data-stu-id="70433-178">Blobs</span></span> |<span data-ttu-id="70433-179">Blob 복사</span><span class="sxs-lookup"><span data-stu-id="70433-179">Copying Blobs</span></span> |[<span data-ttu-id="70433-180">대량 Blob 복사에 AzCopy를 사용하고 있습니까?</span><span class="sxs-lookup"><span data-stu-id="70433-180">Are you using AzCopy for bulk copies of blobs?</span></span>](#subheading18) |
| &nbsp; | <span data-ttu-id="70433-181">Blob</span><span class="sxs-lookup"><span data-stu-id="70433-181">Blobs</span></span> |<span data-ttu-id="70433-182">Blob 복사</span><span class="sxs-lookup"><span data-stu-id="70433-182">Copying Blobs</span></span> |[<span data-ttu-id="70433-183">Azure 가져오기/내보내기 tootransfer 매우 많은 양의 데이터를 사용 중 인가요?</span><span class="sxs-lookup"><span data-stu-id="70433-183">Are you using Azure Import/Export tootransfer very large volumes of data?</span></span>](#subheading19) |
| &nbsp; | <span data-ttu-id="70433-184">Blob</span><span class="sxs-lookup"><span data-stu-id="70433-184">Blobs</span></span> |<span data-ttu-id="70433-185">메타데이터 사용</span><span class="sxs-lookup"><span data-stu-id="70433-185">Use Metadata</span></span> |[<span data-ttu-id="70433-186">자주 사용되는 Blob 관련 메타데이터를 해당 메타데이터에 저장하고 있습니까?</span><span class="sxs-lookup"><span data-stu-id="70433-186">Are you storing frequently used metadata about blobs in their metadata?</span></span>](#subheading20) |
| &nbsp; | <span data-ttu-id="70433-187">Blob</span><span class="sxs-lookup"><span data-stu-id="70433-187">Blobs</span></span> |<span data-ttu-id="70433-188">고속 업로드</span><span class="sxs-lookup"><span data-stu-id="70433-188">Uploading Fast</span></span> |[<span data-ttu-id="70433-189">Tooupload blob 하나를 신속 하 게 시도할 때 동시에 블록을 업로드 하 시겠습니까?</span><span class="sxs-lookup"><span data-stu-id="70433-189">When trying tooupload one blob quickly, are you uploading blocks in parallel?</span></span>](#subheading21) |
| &nbsp; | <span data-ttu-id="70433-190">Blob</span><span class="sxs-lookup"><span data-stu-id="70433-190">Blobs</span></span> |<span data-ttu-id="70433-191">고속 업로드</span><span class="sxs-lookup"><span data-stu-id="70433-191">Uploading Fast</span></span> |[<span data-ttu-id="70433-192">를 시도할 때 tooupload 많은 blob 신속 하 게 병렬에서 blob 업로드 하려는?</span><span class="sxs-lookup"><span data-stu-id="70433-192">When trying tooupload many blobs quickly, are you uploading blobs in parallel?</span></span>](#subheading22) |
| &nbsp; | <span data-ttu-id="70433-193">Blob</span><span class="sxs-lookup"><span data-stu-id="70433-193">Blobs</span></span> |<span data-ttu-id="70433-194">올바른 Blob 유형</span><span class="sxs-lookup"><span data-stu-id="70433-194">Correct Blob Type</span></span> |[<span data-ttu-id="70433-195">해당하는 경우 페이지 Blob 또는 블록 Blob를 사용합니까?</span><span class="sxs-lookup"><span data-stu-id="70433-195">Are you using page blobs or block blobs when appropriate?</span></span>](#subheading23) |
| &nbsp; | <span data-ttu-id="70433-196">테이블</span><span class="sxs-lookup"><span data-stu-id="70433-196">Tables</span></span> |<span data-ttu-id="70433-197">확장성 목표</span><span class="sxs-lookup"><span data-stu-id="70433-197">Scalability Targets</span></span> |[<span data-ttu-id="70433-198">초당 엔터티에 대 한 있습니다 근접 hello 확장성 목표?</span><span class="sxs-lookup"><span data-stu-id="70433-198">Are you approaching hello scalability targets for entities per second?</span></span>](#subheading24) |
| &nbsp; | <span data-ttu-id="70433-199">테이블</span><span class="sxs-lookup"><span data-stu-id="70433-199">Tables</span></span> |<span data-ttu-id="70433-200">구성</span><span class="sxs-lookup"><span data-stu-id="70433-200">Configuration</span></span> |[<span data-ttu-id="70433-201">테이블 요청에 JSON을 사용하고 있습니까?</span><span class="sxs-lookup"><span data-stu-id="70433-201">Are you using JSON for your table requests?</span></span>](#subheading25) |
| &nbsp; | <span data-ttu-id="70433-202">테이블</span><span class="sxs-lookup"><span data-stu-id="70433-202">Tables</span></span> |<span data-ttu-id="70433-203">구성</span><span class="sxs-lookup"><span data-stu-id="70433-203">Configuration</span></span> |[<span data-ttu-id="70433-204">하면 해제 한 Nagle 작은 요청의 tooimprove hello 성능을?</span><span class="sxs-lookup"><span data-stu-id="70433-204">Have you turned Nagle off tooimprove hello performance of small requests?</span></span>](#subheading26) |
| &nbsp; | <span data-ttu-id="70433-205">테이블</span><span class="sxs-lookup"><span data-stu-id="70433-205">Tables</span></span> |<span data-ttu-id="70433-206">테이블 및 파티션</span><span class="sxs-lookup"><span data-stu-id="70433-206">Tables and Partitions</span></span> |[<span data-ttu-id="70433-207">데이터를 적절하게 분할했습니까?</span><span class="sxs-lookup"><span data-stu-id="70433-207">Have you properly partitioned your data?</span></span>](#subheading27) |
| &nbsp; | <span data-ttu-id="70433-208">테이블</span><span class="sxs-lookup"><span data-stu-id="70433-208">Tables</span></span> |<span data-ttu-id="70433-209">핫 파티션</span><span class="sxs-lookup"><span data-stu-id="70433-209">Hot Partitions</span></span> |[<span data-ttu-id="70433-210">추가 전용 및 앞에 추가 전용 패턴을 지양하고 있습니까?</span><span class="sxs-lookup"><span data-stu-id="70433-210">Are you avoiding append-only and prepend-only patterns?</span></span>](#subheading28) |
| &nbsp; | <span data-ttu-id="70433-211">테이블</span><span class="sxs-lookup"><span data-stu-id="70433-211">Tables</span></span> |<span data-ttu-id="70433-212">핫 파티션</span><span class="sxs-lookup"><span data-stu-id="70433-212">Hot Partitions</span></span> |[<span data-ttu-id="70433-213">여러 파티션을 대상으로 삽입/업데이트를 수행합니까?</span><span class="sxs-lookup"><span data-stu-id="70433-213">Are your inserts/updates spread across many partitions?</span></span>](#subheading29) |
| &nbsp; | <span data-ttu-id="70433-214">테이블</span><span class="sxs-lookup"><span data-stu-id="70433-214">Tables</span></span> |<span data-ttu-id="70433-215">쿼리 범위</span><span class="sxs-lookup"><span data-stu-id="70433-215">Query Scope</span></span> |[<span data-ttu-id="70433-216">대부분의 경우 및 제한적으로 사용 하는 테이블 쿼리 toobe에 사용 된 지점 쿼리 toobe 프로그램 스키마 tooallow 디자인?</span><span class="sxs-lookup"><span data-stu-id="70433-216">Have you designed your schema tooallow for point queries toobe used in most cases, and table queries toobe used sparingly?</span></span>](#subheading30) |
| &nbsp; | <span data-ttu-id="70433-217">테이블</span><span class="sxs-lookup"><span data-stu-id="70433-217">Tables</span></span> |<span data-ttu-id="70433-218">쿼리 밀도</span><span class="sxs-lookup"><span data-stu-id="70433-218">Query Density</span></span> |[<span data-ttu-id="70433-219">일반적으로 쿼리가 응용 프로그램에서 사용할 행만 스캔하여 반환합니까?</span><span class="sxs-lookup"><span data-stu-id="70433-219">Do your queries typically only scan and return rows that your application will use?</span></span>](#subheading31) |
| &nbsp; | <span data-ttu-id="70433-220">테이블</span><span class="sxs-lookup"><span data-stu-id="70433-220">Tables</span></span> |<span data-ttu-id="70433-221">반환되는 데이터 제한</span><span class="sxs-lookup"><span data-stu-id="70433-221">Limiting Returned Data</span></span> |[<span data-ttu-id="70433-222">필요 하지 않은 필터링 tooavoid 반환 엔터티 사용 중 인가요?</span><span class="sxs-lookup"><span data-stu-id="70433-222">Are you using filtering tooavoid returning entities that are not needed?</span></span>](#subheading32) |
| &nbsp; | <span data-ttu-id="70433-223">테이블</span><span class="sxs-lookup"><span data-stu-id="70433-223">Tables</span></span> |<span data-ttu-id="70433-224">반환되는 데이터 제한</span><span class="sxs-lookup"><span data-stu-id="70433-224">Limiting Returned Data</span></span> |[<span data-ttu-id="70433-225">필요 하지 않은 속성을 반환 하는 프로젝션 tooavoid 사용 중 인가요?</span><span class="sxs-lookup"><span data-stu-id="70433-225">Are you using projection tooavoid returning properties that are not needed?</span></span>](#subheading33) |
| &nbsp; | <span data-ttu-id="70433-226">테이블</span><span class="sxs-lookup"><span data-stu-id="70433-226">Tables</span></span> |<span data-ttu-id="70433-227">비정규화</span><span class="sxs-lookup"><span data-stu-id="70433-227">Denormalization</span></span> |[<span data-ttu-id="70433-228">있어야 하면 비 정규화 된 데이터 tooget 데이터 하려고 할 때 비효율적인 쿼리 또는 여러 읽기 요청 방지 되도록?</span><span class="sxs-lookup"><span data-stu-id="70433-228">Have you denormalized your data such that you avoid inefficient queries or multiple read requests when trying tooget data?</span></span>](#subheading34) |
| &nbsp; | <span data-ttu-id="70433-229">테이블</span><span class="sxs-lookup"><span data-stu-id="70433-229">Tables</span></span> |<span data-ttu-id="70433-230">삽입/업데이트/삭제</span><span class="sxs-lookup"><span data-stu-id="70433-230">Insert/Update/Delete</span></span> |[<span data-ttu-id="70433-231">에 수행할 수 있습니다 hello 동일 또는 toobe를 트랜잭션 필요 여부를 지정 하는 요청을 일괄 처리는 tooreduce 왕복 시간?</span><span class="sxs-lookup"><span data-stu-id="70433-231">Are you batching requests that need toobe transactional or can be done at hello same time tooreduce round-trips?</span></span>](#subheading35) |
| &nbsp; | <span data-ttu-id="70433-232">테이블</span><span class="sxs-lookup"><span data-stu-id="70433-232">Tables</span></span> |<span data-ttu-id="70433-233">삽입/업데이트/삭제</span><span class="sxs-lookup"><span data-stu-id="70433-233">Insert/Update/Delete</span></span> |[<span data-ttu-id="70433-234">엔터티 정당한 toodetermine 검색 방지는 toocall 삽입 또는 업데이트 여부?</span><span class="sxs-lookup"><span data-stu-id="70433-234">Are you avoiding retrieving an entity just toodetermine whether toocall insert or update?</span></span>](#subheading36) |
| &nbsp; | <span data-ttu-id="70433-235">테이블</span><span class="sxs-lookup"><span data-stu-id="70433-235">Tables</span></span> |<span data-ttu-id="70433-236">삽입/업데이트/삭제</span><span class="sxs-lookup"><span data-stu-id="70433-236">Insert/Update/Delete</span></span> |[<span data-ttu-id="70433-237">자주 함께 검색할 일련의 데이터를 여러 엔터티가 아닌 단일 엔터티에 속성으로 저장하는 것을 고려한 적이 있습니까?</span><span class="sxs-lookup"><span data-stu-id="70433-237">Have you considered storing series of data that will frequently be retrieved together in a single entity as properties instead of multiple entities?</span></span>](#subheading37) |
| &nbsp; | <span data-ttu-id="70433-238">테이블</span><span class="sxs-lookup"><span data-stu-id="70433-238">Tables</span></span> |<span data-ttu-id="70433-239">삽입/업데이트/삭제</span><span class="sxs-lookup"><span data-stu-id="70433-239">Insert/Update/Delete</span></span> |[<span data-ttu-id="70433-240">배치로 쓸 수 있으며 항상 함께 검색할 엔터티(예: 시계열 데이터)에 대해 테이블이 아닌 Blob 사용을 고려한 적이 있습니까?</span><span class="sxs-lookup"><span data-stu-id="70433-240">For entities that will always be retrieved together and can be written in batches (e.g. time series data), have you considered using blobs instead of tables?</span></span>](#subheading38) |
| &nbsp; | <span data-ttu-id="70433-241">큐</span><span class="sxs-lookup"><span data-stu-id="70433-241">Queues</span></span> |<span data-ttu-id="70433-242">확장성 목표</span><span class="sxs-lookup"><span data-stu-id="70433-242">Scalability Targets</span></span> |[<span data-ttu-id="70433-243">초당 메시지 수 근접 hello 확장성 목표는 되나요?</span><span class="sxs-lookup"><span data-stu-id="70433-243">Are you approaching hello scalability targets for messages per second?</span></span>](#subheading39) |
| &nbsp; | <span data-ttu-id="70433-244">큐</span><span class="sxs-lookup"><span data-stu-id="70433-244">Queues</span></span> |<span data-ttu-id="70433-245">구성</span><span class="sxs-lookup"><span data-stu-id="70433-245">Configuration</span></span> |[<span data-ttu-id="70433-246">하면 해제 한 Nagle 작은 요청의 tooimprove hello 성능을?</span><span class="sxs-lookup"><span data-stu-id="70433-246">Have you turned Nagle off tooimprove hello performance of small requests?</span></span>](#subheading40) |
| &nbsp; | <span data-ttu-id="70433-247">큐</span><span class="sxs-lookup"><span data-stu-id="70433-247">Queues</span></span> |<span data-ttu-id="70433-248">메시지 크기</span><span class="sxs-lookup"><span data-stu-id="70433-248">Message Size</span></span> |[<span data-ttu-id="70433-249">Compact tooimprove hello 성능 hello 큐의 메시지에는?</span><span class="sxs-lookup"><span data-stu-id="70433-249">Are your messages compact tooimprove hello performance of hello queue?</span></span>](#subheading41) |
| &nbsp; | <span data-ttu-id="70433-250">큐</span><span class="sxs-lookup"><span data-stu-id="70433-250">Queues</span></span> |<span data-ttu-id="70433-251">대량 검색</span><span class="sxs-lookup"><span data-stu-id="70433-251">Bulk Retrieve</span></span> |[<span data-ttu-id="70433-252">단일 "Get" 작업으로 여러 메시지를 검색합니까?</span><span class="sxs-lookup"><span data-stu-id="70433-252">Are you retrieving multiple messages in a single "Get" operation?</span></span>](#subheading42) |
| &nbsp; | <span data-ttu-id="70433-253">큐</span><span class="sxs-lookup"><span data-stu-id="70433-253">Queues</span></span> |<span data-ttu-id="70433-254">폴링 빈도</span><span class="sxs-lookup"><span data-stu-id="70433-254">Polling Frequency</span></span> |[<span data-ttu-id="70433-255">응용 프로그램의 대기 시간을 인식 부족 tooreduce hello 자주 폴링하면?</span><span class="sxs-lookup"><span data-stu-id="70433-255">Are you polling frequently enough tooreduce hello perceived latency of your application?</span></span>](#subheading43) |
| &nbsp; | <span data-ttu-id="70433-256">큐</span><span class="sxs-lookup"><span data-stu-id="70433-256">Queues</span></span> |<span data-ttu-id="70433-257">메시지 업데이트</span><span class="sxs-lookup"><span data-stu-id="70433-257">Update Message</span></span> |[<span data-ttu-id="70433-258">사용 중 인가요 UpdateMessage toostore 진행률 메시지 처리에서에서 오류가 발생 한 경우 tooreprocess hello에 대 한 전체 메시지를 것?</span><span class="sxs-lookup"><span data-stu-id="70433-258">Are you using UpdateMessage toostore progress in processing messages, avoiding having tooreprocess hello entire message if an error occurs?</span></span>](#subheading44) |
| &nbsp; | <span data-ttu-id="70433-259">큐</span><span class="sxs-lookup"><span data-stu-id="70433-259">Queues</span></span> |<span data-ttu-id="70433-260">아키텍처</span><span class="sxs-lookup"><span data-stu-id="70433-260">Architecture</span></span> |[<span data-ttu-id="70433-261">사용 하 고 큐 toomake 확장성이 뛰어난 응용 프로그램 전체를 유지 하 여 하지 hello 중요 한 경로 및 스케일 아웃 장기 실행 작업 후 독립적으로?</span><span class="sxs-lookup"><span data-stu-id="70433-261">Are you using queues toomake your entire application more scalable by keeping long-running workloads out of hello critical path and scale then independently?</span></span>](#subheading45) |

## <span data-ttu-id="70433-262"><a name="allservices"></a>모든 서비스</span><span class="sxs-lookup"><span data-stu-id="70433-262"><a name="allservices"></a>All Services</span></span>
<span data-ttu-id="70433-263">이 섹션의 hello Azure 저장소 서비스 (blob, 테이블, 큐 또는 파일)의 적용 가능한 toohello 사용 하는 검증 된 사례를 나열 합니다.</span><span class="sxs-lookup"><span data-stu-id="70433-263">This section lists proven practices that are applicable toohello use of any of hello Azure Storage services (blobs, tables, queues, or files).</span></span>  

### <span data-ttu-id="70433-264"><a name="subheading1"></a>확장성 목표</span><span class="sxs-lookup"><span data-stu-id="70433-264"><a name="subheading1"></a>Scalability Targets</span></span>
<span data-ttu-id="70433-265">Hello Azure 저장소 서비스의 각 용량 (GB), 트랜잭션 속도 및 대역폭에 대 한 확장성 목표에 있습니다.</span><span class="sxs-lookup"><span data-stu-id="70433-265">Each of hello Azure Storage services has scalability targets for capacity (GB), transaction rate, and bandwidth.</span></span> <span data-ttu-id="70433-266">응용 프로그램에 도달 하거나 한 hello 확장성 목표를 초과, 증가 된 트랜잭션 대기 시간 또는 조정이 발생할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="70433-266">If your application approaches or exceeds any of hello scalability targets, it may encounter increased transaction latencies or throttling.</span></span> <span data-ttu-id="70433-267">저장소 서비스 응용 프로그램을 제한, tooreturn "503 서버 사용 중" 또는 "500 작업 시간 초과" 오류 코드 일부 저장소 트랜잭션에 대 한 hello 서비스를 시작 합니다.</span><span class="sxs-lookup"><span data-stu-id="70433-267">When a Storage service throttles your application, hello service begins tooreturn "503 Server busy" or "500 Operation timeout" error codes for some storage transactions.</span></span> <span data-ttu-id="70433-268">이 섹션에서는 특히 두 hello 일반적인 방법을 toodealing 확장성 목표와 대역폭 확장성 목표를 설명 합니다.</span><span class="sxs-lookup"><span data-stu-id="70433-268">This section discusses both hello general approach toodealing with scalability targets and bandwidth scalability targets in particular.</span></span> <span data-ttu-id="70433-269">개별 저장소 서비스를 처리 하는 이후 섹션에서는 특정 서비스의 hello 컨텍스트에서 확장성 목표를 설명 합니다.</span><span class="sxs-lookup"><span data-stu-id="70433-269">Later sections that deal with individual storage services discuss scalability targets in hello context of that specific service:</span></span>  

* [<span data-ttu-id="70433-270">Blob 대역폭 및 초당 요청 수</span><span class="sxs-lookup"><span data-stu-id="70433-270">Blob bandwidth and requests per second</span></span>](#subheading16)
* [<span data-ttu-id="70433-271">초당 테이블 엔터티 수</span><span class="sxs-lookup"><span data-stu-id="70433-271">Table entities per second</span></span>](#subheading24)
* [<span data-ttu-id="70433-272">초당 큐 메시지 수</span><span class="sxs-lookup"><span data-stu-id="70433-272">Queue messages per second</span></span>](#subheading39)  

#### <span data-ttu-id="70433-273"><a name="sub1bandwidth"></a>모든 서비스에 대한 대역폭 확장성 목표</span><span class="sxs-lookup"><span data-stu-id="70433-273"><a name="sub1bandwidth"></a>Bandwidth Scalability Target for All Services</span></span>
<span data-ttu-id="70433-274">작성 hello 시 hello 대역폭 목표 hello 미국 지역 중복 저장소 (GRS)에 대 한 계정에는 10 기가 비트 / 초 (Gbps) 수신에 대 한 (데이터 전송 됨 toohello 저장소 계정) 및 송신 (hello 저장소 계정에서 보낸 데이터)에 대 한 20 g b p s.</span><span class="sxs-lookup"><span data-stu-id="70433-274">At hello time of writing, hello bandwidth targets in hello US for a geo-redundant storage (GRS) account are 10 gigabits per second (Gbps) for ingress (data sent toohello storage account) and 20 Gbps for egress (data sent from hello storage account).</span></span> <span data-ttu-id="70433-275">로컬 중복 저장소 (LRS) 계정에 대 한 hello 제한은 더 높은 – ingress 및 egress에 대 한 30 g b p s에 대 한 20 g b p s.</span><span class="sxs-lookup"><span data-stu-id="70433-275">For a locally redundant storage (LRS) account, hello limits are higher – 20 Gbps for ingress and 30 Gbps for egress.</span></span>  <span data-ttu-id="70433-276">기타 국가의 대역폭 제한은 이보다 더 낮을 수 있습니다. 관련 정보는 [확장성 목표 페이지](http://msdn.microsoft.com/library/azure/dn249410.aspx)에서 확인할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="70433-276">International bandwidth limits may be lower and can be found on our [scalability targets page](http://msdn.microsoft.com/library/azure/dn249410.aspx).</span></span>  <span data-ttu-id="70433-277">Hello 저장소 중복 옵션에 대 한 자세한 내용은 hello 링크를 참조 하십시오 [유용한 리소스](#sub1useful) 아래 합니다.</span><span class="sxs-lookup"><span data-stu-id="70433-277">For more information on hello storage redundancy options, see hello links in [Useful Resources](#sub1useful) below.</span></span>  

#### <a name="what-toodo-when-approaching-a-scalability-target"></a><span data-ttu-id="70433-278">확장성 목표에 도달할 때 어떤 toodo</span><span class="sxs-lookup"><span data-stu-id="70433-278">What toodo when approaching a scalability target</span></span>
<span data-ttu-id="70433-279">응용 프로그램이 단일 저장소 계정에 대 한 hello 확장성 목표에 도달 하 고, 경우에 hello 다음 방법 중 하나를 채택 하는 것이 좋습니다.</span><span class="sxs-lookup"><span data-stu-id="70433-279">If your application is approaching hello scalability targets for a single storage account, consider adopting one of hello following approaches:</span></span>  

* <span data-ttu-id="70433-280">응용 프로그램 tooapproach 시키는 hello 작업을 다시 고려할 또는 hello 확장성 목표를 초과 합니다.</span><span class="sxs-lookup"><span data-stu-id="70433-280">Reconsider hello workload that causes your application tooapproach or exceed hello scalability target.</span></span> <span data-ttu-id="70433-281">수 디자인 다르게 대역폭 또는 용량 또는 더 적은 수의 트랜잭션을 덜 toouse?</span><span class="sxs-lookup"><span data-stu-id="70433-281">Can you design it differently toouse less bandwidth or capacity, or fewer transactions?</span></span>
* <span data-ttu-id="70433-282">응용 프로그램 해야 hello 확장성 목표 중 하나를 초과 하는 경우 만들어야 여러 저장소 계정 및 파티션 응용 프로그램 데이터는 여러 저장소 계정에서 합니다.</span><span class="sxs-lookup"><span data-stu-id="70433-282">If an application must exceed one of hello scalability targets, you should create multiple storage accounts and partition your application data across those multiple storage accounts.</span></span> <span data-ttu-id="70433-283">이 패턴을 사용 하는 경우 다음 수 있는지 toodesign 응용 프로그램 부하 분산에 대 한 이후 hello에 저장소 계정을 더 추가할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="70433-283">If you use this pattern, then be sure toodesign your application so that you can add more storage accounts in hello future for load balancing.</span></span> <span data-ttu-id="70433-284">작성 시점에 각 Azure 구독 too100 저장소 계정이 있을 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="70433-284">At time of writing, each Azure subscription can have up too100 storage accounts.</span></span>  <span data-ttu-id="70433-285">또한 저장소 계정에는 저장하거나 전송하는 데이터 또는 수행하는 트랜잭션과 관련된 사용 요금 외의 기타 비용은 없습니다.</span><span class="sxs-lookup"><span data-stu-id="70433-285">Storage accounts also have no cost other than your usage in terms of data stored, transactions made, or data transferred.</span></span>
* <span data-ttu-id="70433-286">응용 프로그램 hello 대역폭 목표에 도달 하는 경우에 hello 클라이언트 tooreduce hello 필요한 대역폭 toosend hello 데이터 toohello 저장소 서비스에 데이터를 압축 하는 것이 좋습니다.</span><span class="sxs-lookup"><span data-stu-id="70433-286">If your application hits hello bandwidth targets, consider compressing data in hello client tooreduce hello bandwidth required toosend hello data toohello storage service.</span></span>  <span data-ttu-id="70433-287">이렇게 하면 대역폭을 줄이고 네트워크 성능을 개선할 수는 있지만, 몇 가지 좋지 않은 영향도 있을 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="70433-287">Note that while this may save bandwidth and improve network performance, it can also have some negative impacts.</span></span>  <span data-ttu-id="70433-288">압축 및 압축 해제 하는 클라이언트 hello에에서 데이터 추가 처리 요구 사항 toohello 인해이 hello 성능 영향을 평가 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="70433-288">You should evaluate hello performance impact of this due toohello additional processing requirements for compressing and decompressing data in hello client.</span></span> <span data-ttu-id="70433-289">또한 압축 된 데이터를 저장 하기가 더 어려운 tootroubleshoot 문제의 표준 도구를 사용 하 여 더 어렵게 tooview 저장 된 데이터를 될 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="70433-289">In addition, storing compressed data can make it more difficult tootroubleshoot issues since it could be more difficult tooview stored data using standard tools.</span></span>
* <span data-ttu-id="70433-290">응용 프로그램 hello 확장성 목표에 도달 하는 경우의 재시도 대 한 지 수 백오프를 사용 하 고 있는지 확인 합니다 (참조 [재시도](#subheading14)).</span><span class="sxs-lookup"><span data-stu-id="70433-290">If your application hits hello scalability targets, then ensure that you are using an exponential backoff for retries (see [Retries](#subheading14)).</span></span>  <span data-ttu-id="70433-291">더 나은 toomake (사용 하 여 hello 위에 메서드 중 하나), hello 확장성 목표를 접근 하지 하지만 이렇게 하면 응용 프로그램에 있는지 유지 방금 신속 하 게 다시 시도, hello 나빠지는 제한 하 하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="70433-291">It's better toomake sure you never approach hello scalability targets (by using one of hello above methods), but this will ensure your application won't just keep retrying rapidly, making hello throttling worse.</span></span>  

#### <a name="useful-resources"></a><span data-ttu-id="70433-292">유용한 리소스</span><span class="sxs-lookup"><span data-stu-id="70433-292">Useful Resources</span></span>
<span data-ttu-id="70433-293">링크를 따라 hello 확장성 목표에 추가 세부 정보를 제공 합니다.</span><span class="sxs-lookup"><span data-stu-id="70433-293">hello following links provide additional detail on scalability targets:</span></span>

* <span data-ttu-id="70433-294">확장성 목표에 대한 자세한 내용은 [Azure 저장소 확장성 및 성능 목표](storage-scalability-targets.md) 를 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="70433-294">See [Azure Storage Scalability and Performance Targets](storage-scalability-targets.md) for information about scalability targets.</span></span>
* <span data-ttu-id="70433-295">참조 [Azure 저장소 복제](storage-redundancy.md) hello 블로그 게시물 및 [Azure 저장소 중복 옵션 및 읽기 액세스 지역 중복 저장소](http://blogs.msdn.com/b/windowsazurestorage/archive/2013/12/11/introducing-read-access-geo-replicated-storage-ra-grs-for-windows-azure-storage.aspx) 저장소 중복 옵션에 대 한 정보에 대 한 합니다.</span><span class="sxs-lookup"><span data-stu-id="70433-295">See [Azure Storage replication](storage-redundancy.md) and hello blog post [Azure Storage Redundancy Options and Read Access Geo Redundant Storage](http://blogs.msdn.com/b/windowsazurestorage/archive/2013/12/11/introducing-read-access-geo-replicated-storage-ra-grs-for-windows-azure-storage.aspx) for information about storage redundancy options.</span></span>
* <span data-ttu-id="70433-296">Azure 서비스 가격에 대한 최신 정보는 [Azure 가격 책정](https://azure.microsoft.com/pricing/overview/)을 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="70433-296">For current information about pricing for Azure services, see [Azure pricing](https://azure.microsoft.com/pricing/overview/).</span></span>  

### <span data-ttu-id="70433-297"><a name="subheading47"></a>파티션 명명 규칙</span><span class="sxs-lookup"><span data-stu-id="70433-297"><a name="subheading47"></a>Partition Naming Convention</span></span>
<span data-ttu-id="70433-298">Azure 저장소는 범위 기반 파티션 구성표 tooscale 및 부하 분산 hello 시스템을 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="70433-298">Azure Storage uses a range-based partitioning scheme tooscale and load balance hello system.</span></span> <span data-ttu-id="70433-299">hello 파티션 키는 toopartition 사용 되는 데이터를 범위로 하 고 이러한 범위는 부하 분산 된 hello 시스템 전체에서입니다.</span><span class="sxs-lookup"><span data-stu-id="70433-299">hello partition key is used toopartition data into ranges and these ranges are load-balanced across hello system.</span></span> <span data-ttu-id="70433-300">즉, 어휘 (예: msftpayroll, msftperformance, msftemployees 등)을 순서 지정 또는 타임 스탬프 (log20160101, log20160102, log20160102 등)를 사용 하 여 같은 명명 규칙은 hello에 공동 배치할 잠재적으로 되 고 toohello 파티션에 적합 같은 파티션 서버에 부하 분산 작업을 더 작은 범위로 해당 분할 될 때까지 합니다.</span><span class="sxs-lookup"><span data-stu-id="70433-300">This means naming conventions such as lexical ordering (e.g. msftpayroll, msftperformance, msftemployees, etc) or using time-stamps (log20160101, log20160102, log20160102, etc) will lend itself toohello partitions being potentially co-located on hello same partition server, until a load balancing operation splits them out into smaller ranges.</span></span> <span data-ttu-id="70433-301">예를 들어 hello 이러한 blob에 대 한 부하 필요로 할 때까지 추가 작업 재 분산 hello 파티션 범위 컨테이너 내 모든 blob 단일 서버에 의해 제공 될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="70433-301">For example, all blobs within a container can be served by a single server until hello load on these blobs requires further rebalancing of hello partition ranges.</span></span> <span data-ttu-id="70433-302">마찬가지로, 어휘 순서로 정렬 된 해당 이름으로 부하가 적은 계정의 그룹에서 연결할 수 있습니다는 단일 서버 hello까지 하나에서 로드 하거나 이러한 계정을 모두 필요한 toobe 분할 여러 파티션 서버입니다.</span><span class="sxs-lookup"><span data-stu-id="70433-302">Similarly, a group of lightly loaded accounts with their names arranged in lexical order may be served by a single server until hello load on one or all of these accounts require them toobe split across multiple partitions servers.</span></span> <span data-ttu-id="70433-303">Hello 작업 중 각 부하 분산 작업에서 저장소 호출의 hello 대기 시간 영향을 줄 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="70433-303">Each load balancing operation may impact hello latency of storage calls during hello operation.</span></span> <span data-ttu-id="70433-304">트래픽 tooa 파티션의 갑자기 버스트 hello 로드 작업을 균형 조정 될 때까지 hello 확장성 단일 분할 서버에 의해 제한 되는 hello 시스템의 기능 toohandle 작동 기능 및 hello 파티션 키 범위를 변경 합니다.</span><span class="sxs-lookup"><span data-stu-id="70433-304">hello system's ability toohandle a sudden burst of traffic tooa partition is limited by hello scalability of a single partition server until hello load balancing operation kicks-in and rebalances hello partition key range.</span></span>  

<span data-ttu-id="70433-305">이러한 작업의 몇 가지 모범 사례 tooreduce hello 주파수를 따를 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="70433-305">You can follow some best practices tooreduce hello frequency of such operations.</span></span>  

* <span data-ttu-id="70433-306">계정, 컨테이너, blob, 테이블 및 큐에 대 한 밀접 하 게 사용 하는 hello 명명 규칙을 검사 합니다.</span><span class="sxs-lookup"><span data-stu-id="70433-306">Examine hello naming convention you use for accounts, containers, blobs, tables and queues, closely.</span></span> <span data-ttu-id="70433-307">계정 이름에 요구 사항에 가장 적합한 해싱 함수를 사용하는 3자릿수 해시의 접두사를 추가해 보십시오.</span><span class="sxs-lookup"><span data-stu-id="70433-307">Consider prefixing account names with a 3-digit hash using a hashing function that best suits your needs.</span></span>  
* <span data-ttu-id="70433-308">타임 스탬프 또는 사이의 숫자 식별자를 사용 하 여 데이터를 구성 하는 경우 추가 전용 (또는 앞 으로만 이동 가능한) 트래픽 패턴을 사용 하지 않는 tooensure를 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="70433-308">If you organize your data using timestamps or numerical identifiers, you have tooensure you are not using an append-only (or prepend-only) traffic patterns.</span></span> <span data-ttu-id="70433-309">이러한 패턴은 범위에 적합 하지 않은-기반의 시스템, 분할 및 수 리드 tooall hello 트래픽 하락 tooa 단일 파티션 및 제한 hello 시스템에서 효과적으로 부하 분산 합니다.</span><span class="sxs-lookup"><span data-stu-id="70433-309">These patterns are not suitable for a range -based partitioning system, and could lead tooall hello traffic going tooa single partition and limiting hello system from effectively load balancing.</span></span> <span data-ttu-id="70433-310">예를 들어, 매일 있으면 일일 작업에 대 한 다음 모든 hello 트래픽 yyyymmdd 같은 타임 스탬프를 갖는 blob 개체를 사용 하는 작업 전송 tooa 단일 분할 서버에 의해 제공 되는 단일 개체.</span><span class="sxs-lookup"><span data-stu-id="70433-310">For instance, if you have daily operations that use a blob object with a timestamp such as yyyymmdd, then all hello traffic for that daily operation is directed tooa single object which is served by a single partition server.</span></span> <span data-ttu-id="70433-311">Hello blob 당 제한 여부를 확인 하 고 파티션당 제한 요구 사항을 충족 하 고 필요한 경우 여러 blob으로이 작업을 분할 하는 것이 좋습니다. 합니다.</span><span class="sxs-lookup"><span data-stu-id="70433-311">Look at whether hello per blob limits and per partition limits meet your needs, and consider breaking this operation into multiple blobs if needed.</span></span> <span data-ttu-id="70433-312">마찬가지로, 테이블의 시계열 데이터를 저장 하는 경우 모든 hello 트래픽을 수 toohello hello 키 네임 스페이스의 마지막 부분을 이동 합니다.</span><span class="sxs-lookup"><span data-stu-id="70433-312">Similarly, if you store time series data in your tables, all hello traffic could be directed toohello last part of hello key namespace.</span></span> <span data-ttu-id="70433-313">타임 스탬프 또는 숫자 Id를 사용 해야 하는 경우 3 자리 해시 또는 ssyyyymmdd 같은 hello 시간의 타임 스탬프 hello 초 부분을 접두사의 경우 hello hello id를 접두사입니다.</span><span class="sxs-lookup"><span data-stu-id="70433-313">If you must use timestamps or numerical IDs, prefix hello id with a 3-digit hash, or in hello case of timestamps prefix hello seconds part of hello time such as ssyyyymmdd.</span></span> <span data-ttu-id="70433-314">열거 및 쿼리 작업을 일상적으로 수행하는 경우 쿼리 수를 제한하는 해시 함수를 선택합니다.</span><span class="sxs-lookup"><span data-stu-id="70433-314">If listing and querying operations are routinely performed, choose a hashing function that will limit your number of queries.</span></span> <span data-ttu-id="70433-315">다른 경우에는 임의의 접두사로도 충분할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="70433-315">In other cases, a random prefix may be sufficient.</span></span>  
* <span data-ttu-id="70433-316">Azure 저장소에 사용 되는 체계를 분할 하는 hello에 대 한 자세한 내용은 hello SOSP 문서를 읽을 [여기](http://sigops.org/sosp/sosp11/current/2011-Cascais/printable/11-calder.pdf)합니다.</span><span class="sxs-lookup"><span data-stu-id="70433-316">For additional information on hello partitioning scheme used in Azure Storage, read hello SOSP paper [here](http://sigops.org/sosp/sosp11/current/2011-Cascais/printable/11-calder.pdf).</span></span>

### <a name="networking"></a><span data-ttu-id="70433-317">네트워킹</span><span class="sxs-lookup"><span data-stu-id="70433-317">Networking</span></span>
<span data-ttu-id="70433-318">Hello API 문제를 호출 하는 동안 hello 응용 프로그램의 실제 네트워크 제한 종종 hello 성능에 상당한 영향을는.</span><span class="sxs-lookup"><span data-stu-id="70433-318">While hello API calls matter, often hello physical network constraints of hello application have a significant impact on performance.</span></span> <span data-ttu-id="70433-319">hello 다음 사용자가 발생할 수는 제한 사항 중 일부를 설명 합니다.</span><span class="sxs-lookup"><span data-stu-id="70433-319">hello following describe some of limitations users may encounter.</span></span>  

#### <a name="client-network-capability"></a><span data-ttu-id="70433-320">클라이언트 네트워크 기능</span><span class="sxs-lookup"><span data-stu-id="70433-320">Client Network Capability</span></span>
##### <span data-ttu-id="70433-321"><a name="subheading2"></a>처리량</span><span class="sxs-lookup"><span data-stu-id="70433-321"><a name="subheading2"></a>Throughput</span></span>
<span data-ttu-id="70433-322">대역폭, hello 문제는 종종 hello 클라이언트의 hello 기능입니다.</span><span class="sxs-lookup"><span data-stu-id="70433-322">For bandwidth, hello problem is often hello capabilities of hello client.</span></span> <span data-ttu-id="70433-323">예를 들어, 단일 저장소 계정의 10gbps 이상 ingress 처리할 수 하는 동안 (참조 [대역폭 확장성 목표](#sub1bandwidth)), "Small" Azure 작업자 역할 인스턴스에서 hello 네트워크 속도 약 100 개의 Mbps 수만 있습니다.</span><span class="sxs-lookup"><span data-stu-id="70433-323">For example, while a single storage account can handle 10 Gbps or more of ingress (see [bandwidth scalability targets](#sub1bandwidth)), hello network speed in a "Small" Azure Worker Role instance is only capable of approximately 100 Mbps.</span></span> <span data-ttu-id="70433-324">대규모 Azure 인스턴스에는 용량이 더 많은 NIC가 포함되므로 컴퓨터 하나의 네트워크 제한을 높여야 하는 경우에는 더 큰 인스턴스나 더 많은 VM을 사용하는 것이 좋습니다.</span><span class="sxs-lookup"><span data-stu-id="70433-324">Larger Azure instances have NICs with greater capacity, so you should consider using a larger instance or more VM's if you need higher network limits from a single machine.</span></span> <span data-ttu-id="70433-325">온-프레미스 응용 프로그램에서 저장소 서비스를 액세스 하는 경우 hello 동일한 규칙이 적용 됩니다: hello 클라이언트 장치 및 네트워크 연결 toohello hello Azure 저장소 위치 hello 네트워크 기능을 이해 하 고 보다 개선 필요에 따라 또는 기능 내에서 응용 프로그램 toowork 프로그램을 디자인 합니다.</span><span class="sxs-lookup"><span data-stu-id="70433-325">If you are accessing a Storage service from an on premises application, then hello same rule applies: understand hello network capabilities of hello client device and hello network connectivity toohello Azure Storage location and either improve them as needed or design your application toowork within their capabilities.</span></span>  

##### <span data-ttu-id="70433-326"><a name="subheading3"></a>링크 속도</span><span class="sxs-lookup"><span data-stu-id="70433-326"><a name="subheading3"></a>Link Quality</span></span>
<span data-ttu-id="70433-327">네트워크를 어떤 방식으로 사용하든 네트워크의 상태로 인해 오류와 패킷 손실이 발생하면 효율적인 처리량을 달성하는 시간이 길어집니다.</span><span class="sxs-lookup"><span data-stu-id="70433-327">As with any network usage, be aware that network conditions resulting in errors and packet loss will slow effective throughput.</span></span>  <span data-ttu-id="70433-328">WireShark 또는 NetMon을 사용하면 이 문제를 진단하는 데 도움이 될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="70433-328">Using WireShark or NetMon may help in diagnosing this issue.</span></span>  

##### <a name="useful-resources"></a><span data-ttu-id="70433-329">유용한 리소스</span><span class="sxs-lookup"><span data-stu-id="70433-329">Useful Resources</span></span>
<span data-ttu-id="70433-330">가상 컴퓨터 크기 및 할당된 대역폭에 대한 자세한 내용은 [Windows VM 크기](../virtual-machines/windows/sizes.md?toc=%2fazure%2fvirtual-machines%2fwindows%2ftoc.json) 또는 [Linux VM 크기](../virtual-machines/linux/sizes.md?toc=%2fazure%2fvirtual-machines%2flinux%2ftoc.json)를 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="70433-330">For more information about virtual machine sizes and allocated bandwidth, see [Windows VM sizes](../virtual-machines/windows/sizes.md?toc=%2fazure%2fvirtual-machines%2fwindows%2ftoc.json) or [Linux VM sizes](../virtual-machines/linux/sizes.md?toc=%2fazure%2fvirtual-machines%2flinux%2ftoc.json).</span></span>  

#### <span data-ttu-id="70433-331"><a name="subheading4"></a>위치</span><span class="sxs-lookup"><span data-stu-id="70433-331"><a name="subheading4"></a>Location</span></span>
<span data-ttu-id="70433-332">모든 분산된 환경에서 최상의 성능을 얻으려면 hello에 전달 hello 클라이언트 toohello 서버 근처에 배치 합니다.</span><span class="sxs-lookup"><span data-stu-id="70433-332">In any distributed environment, placing hello client near toohello server delivers in hello best performance.</span></span> <span data-ttu-id="70433-333">대기 시간이 가장 하는 hello 사용 하 여 Azure 저장소 액세스에 대 한 hello 내 클라이언트에 대 한 hello 가장 좋은 위치는 동일한 Azure 지역에 있습니다.</span><span class="sxs-lookup"><span data-stu-id="70433-333">For accessing Azure Storage with hello lowest latency, hello best location for your client is within hello same Azure region.</span></span> <span data-ttu-id="70433-334">예를 들어 Azure 웹 사이트에서 Azure 저장소를 사용하는 경우 웹 사이트와 저장소를 모두 단일 하위 지역(예: 미국 서부 또는 동남 아시아) 내에 배치해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="70433-334">For example, if you have an Azure Web Site that uses Azure Storage, you should locate them both within a single region (for example, US West or Asia Southeast).</span></span> <span data-ttu-id="70433-335">이렇게 하면 hello 대기 시간 및 hello 비용 감소-쓰기의 hello 시 단일 지역 내 대역폭 사용량은 무료입니다.</span><span class="sxs-lookup"><span data-stu-id="70433-335">This reduces hello latency and hello cost — at hello time of writing, bandwidth usage within a single region is free.</span></span>  

<span data-ttu-id="70433-336">응용 프로그램 호스트 되지 Azure 내에서 (모바일 장치 앱 같은 또는 프레미스 엔터프라이즈 서비스), 그리고 클라이언트 대기 시간 일반적으로 인해 됩니다 hello 저장소 계정, 액세스 하는 toohello 장치 가까이 지역에 배치 합니다.</span><span class="sxs-lookup"><span data-stu-id="70433-336">If your client applications are not hosted within Azure (such as mobile device apps or on premises enterprise services), then again placing hello storage account in a region near toohello devices that will access it, will generally reduce latency.</span></span> <span data-ttu-id="70433-337">클라이언트가 일부는 북아메리카에 있고 일부는 유럽에 있는 등 광범위하게 분산되어 있다면 여러 저장소 계정(하나는 북아메리카 지역에 있고 하나는 유럽 지역에 있음)을 사용해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="70433-337">If your clients are broadly distributed (for example, some in North America, and some in Europe), then you should consider using multiple storage accounts: one located in a North American region and one in a European region.</span></span> <span data-ttu-id="70433-338">이 두 지역에서 사용자에 대 한 대기 시간 tooreduce 도움이 됩니다.</span><span class="sxs-lookup"><span data-stu-id="70433-338">This will help tooreduce latency for users in both regions.</span></span> <span data-ttu-id="70433-339">이 방법은 일반적으로 더 쉽게 tooimplement 경우 hello hello 응용 프로그램 데이터 저장소 연결이 특정 tooindividual 사용자 저장소 계정 간에 데이터를 복제 하지 않아도 됩니다.</span><span class="sxs-lookup"><span data-stu-id="70433-339">This approach is usually easier tooimplement if hello data hello application stores is specific tooindividual users, and does not require replicating data between storage accounts.</span></span>  <span data-ttu-id="70433-340">광범위 한 콘텐츠 배포를 위해 CDN을 사용 하는 것이 좋습니다-hello에 대 한 자세한 내용은 다음 섹션을 참조 합니다.</span><span class="sxs-lookup"><span data-stu-id="70433-340">For broad content distribution, a CDN is recommended – see hello next section for more details.</span></span>  

### <span data-ttu-id="70433-341"><a name="subheading5"></a>콘텐츠 배포</span><span class="sxs-lookup"><span data-stu-id="70433-341"><a name="subheading5"></a>Content Distribution</span></span>
<span data-ttu-id="70433-342">경우에 따라 하나에 있는 동일한 콘텐츠 toomany 사용자 (예:: 웹 사이트의 hello 홈 페이지에서 사용 되는 비디오 데모 제품)가 하는 응용 프로그램 요구 tooserve hello hello 동일 또는 여러 영역입니다.</span><span class="sxs-lookup"><span data-stu-id="70433-342">Sometimes, an application needs tooserve hello same content toomany users (e.g. a product demo video used in hello home page of a website), located in either hello same or multiple regions.</span></span> <span data-ttu-id="70433-343">이 시나리오에서 CDN 콘텐츠 배달 네트워크 () 같은 Azure CDN을 사용 해야 하 고 hello CDN은 hello hello 데이터 원본으로 Azure 저장소를 사용 합니다.</span><span class="sxs-lookup"><span data-stu-id="70433-343">In this scenario, you should use a Content Delivery Network (CDN) such as Azure CDN, and hello CDN would use Azure storage as hello origin of hello data.</span></span> <span data-ttu-id="70433-344">단일 지역에 존재 하 고 tooother 영역 짧은 대기 시간으로 콘텐츠를 제공 없습니다 하는 Azure 저장소 계정, 달리 Azure CDN hello 전 세계 여러 데이터 센터에서 서버를 사용 합니다.</span><span class="sxs-lookup"><span data-stu-id="70433-344">Unlike an Azure Storage account that exists in a single region and that cannot deliver content with low latency tooother regions, Azure CDN uses servers in multiple data centers around hello world.</span></span> <span data-ttu-id="70433-345">또한 CDN은 일반적으로 단일 저장소 계정보다 더 높은 송신 제한을 지원합니다.</span><span class="sxs-lookup"><span data-stu-id="70433-345">Additionally, a CDN can typically support much higher egress limits than a single storage account.</span></span>  

<span data-ttu-id="70433-346">Azure CDN에 대한 자세한 내용은 [Azure CDN](https://azure.microsoft.com/services/cdn/)을 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="70433-346">For more information about Azure CDN, see [Azure CDN](https://azure.microsoft.com/services/cdn/).</span></span>  

### <span data-ttu-id="70433-347"><a name="subheading6"></a>SAS 및 CORS 사용</span><span class="sxs-lookup"><span data-stu-id="70433-347"><a name="subheading6"></a>Using SAS and CORS</span></span>
<span data-ttu-id="70433-348">Azure 저장소에서 휴대폰 앱 tooaccess 데이터 또는 사용자의 웹 브라우저에서 JavaScript 같은 tooauthorize 코드 필요한 경우 한 가지 방법은 toouse 프록시로 웹 역할에서 응용 프로그램: hello 사용자의 장치 설정에 hello 웹 역할을 사용 하 여 인증 hello 저장소 서비스를 인증합니다.</span><span class="sxs-lookup"><span data-stu-id="70433-348">When you need tooauthorize code such as JavaScript in a user's web browser or a mobile phone app tooaccess data in Azure Storage, one approach is toouse an application in web role as a proxy: hello user's device authenticates with hello web role, which in turn authenticates with hello storage service.</span></span> <span data-ttu-id="70433-349">이러한 방식을 사용하면 안전하지 않은 장치에서 저장소 계정 키가 노출되는 상황을 방지할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="70433-349">In this way, you can avoid exposing your storage account keys on insecure devices.</span></span> <span data-ttu-id="70433-350">그러나 이렇게 하면 큰 오버 헤드가 hello 웹 역할에서 모든 hello 데이터 hello 사용자의 장치 간에 전송 되 고 hello 저장소 서비스를 통과 해야 hello 웹 역할입니다.</span><span class="sxs-lookup"><span data-stu-id="70433-350">However, this places a big overhead on hello web role because all hello data transferred between hello user's device and hello storage service must pass through hello web role.</span></span> <span data-ttu-id="70433-351">사용 하 여 웹 역할을 프록시로 hello 저장소 서비스에 대 한 공유 액세스 서명 (SAS) 경우에 따라 헤더 크로스-원본 자원 공유 (CORS)와 함께에서 사용 하 여 방지할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="70433-351">You can avoid using a web role as a proxy for hello storage service by using Shared Access Signatures (SAS), sometimes in conjunction with Cross-Origin Resource Sharing headers (CORS).</span></span> <span data-ttu-id="70433-352">SAS를 사용 하 여 사용자의 장치 toomake tooa 저장소 서비스는 제한 된 액세스 토큰을 사용 하 여 직접 요청을 허용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="70433-352">Using SAS, you can allow your user's device toomake requests directly tooa storage service by means of a limited access token.</span></span> <span data-ttu-id="70433-353">예를 들어 사용자가 tooupload 사진 tooyour 응용 프로그램을 웹 역할 수 생성 되 고 toohello 사용자의 장치 (지나면 hello SAS 토큰에 만료) 30 분간 권한 toowrite tooa 특정 blob 이나 hello에 대 한 컨테이너를 부여 하는 SAS 토큰을 보냅니다.</span><span class="sxs-lookup"><span data-stu-id="70433-353">For example, if a user wants tooupload a photo tooyour application, your web role can generate and send toohello user's device a SAS token that grants permission toowrite tooa specific blob or container for hello next 30 minutes (after which hello SAS token expires).</span></span>

<span data-ttu-id="70433-354">일반적으로 브라우저 "PUT" tooanother 도메인과 같은 하나의 도메인 tooperform 특정 작업에 대 한 웹 사이트에서 호스팅되는 페이지에서 JavaScript를 허용 하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="70433-354">Normally, a browser will not allow JavaScript in a page hosted by a website on one domain tooperform specific operations such as a "PUT" tooanother domain.</span></span> <span data-ttu-id="70433-355">예를 들어 "contosomarketing.cloudapp.net"와 원하는 toouse 클라이언트 쪽 JavaScript tooupload "contosoproducts.blob.core.windows.net"에서 blob tooyour 저장소 계정에서 웹 역할을 호스트 하는 경우 브라우저의 hello "동일 원본 정책" 반해 됩니다 작업입니다.</span><span class="sxs-lookup"><span data-stu-id="70433-355">For example, if you host a web role at "contosomarketing.cloudapp.net," and want toouse client side JavaScript tooupload a blob tooyour storage account at "contosoproducts.blob.core.windows.net," hello browser's "same origin policy" will forbid this operation.</span></span> <span data-ttu-id="70433-356">CORS는 hello 대상 도메인 (이 경우 hello 저장소 계정)에서 toocommunicate toohello 브라우저 트러스트 요청 hello 원본 도메인 (이 경우 hello 웹 역할)에서 발생 하는 수 있는 브라우저 기능입니다.</span><span class="sxs-lookup"><span data-stu-id="70433-356">CORS is a browser feature that allows hello target domain (in this case hello storage account) toocommunicate toohello browser that it trusts requests originating in hello source domain (in this case hello web role).</span></span>  

<span data-ttu-id="70433-357">이 두 기술을 사용하면 웹 응용 프로그램에서 불필요한 로드와 병목 현상을 방지할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="70433-357">Both of these technologies can help you avoid unnecessary load (and bottlenecks) on your web application.</span></span>  

#### <a name="useful-resources"></a><span data-ttu-id="70433-358">유용한 리소스</span><span class="sxs-lookup"><span data-stu-id="70433-358">Useful Resources</span></span>
<span data-ttu-id="70433-359">SAS에 대 한 자세한 내용은 참조 [공유 액세스 서명, 1 부: SAS 모델 이해 hello](storage-dotnet-shared-access-signature-part-1.md)합니다.</span><span class="sxs-lookup"><span data-stu-id="70433-359">For more information about SAS, see [Shared Access Signatures, Part 1: Understanding hello SAS Model](storage-dotnet-shared-access-signature-part-1.md).</span></span>  

<span data-ttu-id="70433-360">CORS에 대 한 자세한 내용은 참조 [hello Azure 저장소 서비스에 대 한 크로스-원본 자원 공유 (CORS) 지원을](http://msdn.microsoft.com/library/azure/dn535601.aspx)합니다.</span><span class="sxs-lookup"><span data-stu-id="70433-360">For more information about CORS, see [Cross-Origin Resource Sharing (CORS) Support for hello Azure Storage Services](http://msdn.microsoft.com/library/azure/dn535601.aspx).</span></span>  

### <a name="caching"></a><span data-ttu-id="70433-361">구성</span><span class="sxs-lookup"><span data-stu-id="70433-361">Caching</span></span>
#### <span data-ttu-id="70433-362"><a name="subheading7"></a>데이터 가져오기</span><span class="sxs-lookup"><span data-stu-id="70433-362"><a name="subheading7"></a>Getting Data</span></span>
<span data-ttu-id="70433-363">일반적으로는 서비스에서 데이터를 가져오는 횟수가 적을수록 좋습니다.</span><span class="sxs-lookup"><span data-stu-id="70433-363">In general, getting data from a service once is better than getting it twice.</span></span> <span data-ttu-id="70433-364">50MB blob 콘텐츠 tooa 사용자로 hello 저장소 서비스 tooserve에서 이미 검색에 웹 역할에서 실행 되는 MVC 웹 응용 프로그램의 hello 예제를 참조 하세요.</span><span class="sxs-lookup"><span data-stu-id="70433-364">Consider hello example of an MVC web application running in a web role that has already retrieved a 50MB blob from hello storage service tooserve as content tooa user.</span></span> <span data-ttu-id="70433-365">hello 응용 프로그램 검색할 수 같은 해당 blob 될 때마다 사용자가 요청을 캐시할 수 것 또는 로컬로 후속 사용자 요청에 대 한 toodisk 및 재사용 hello 캐시 된 버전입니다.</span><span class="sxs-lookup"><span data-stu-id="70433-365">hello application could then retrieve that same blob every time a user requests it, or it could cache it locally toodisk and reuse hello cached version for subsequent user requests.</span></span> <span data-ttu-id="70433-366">또한 사용자 hello 데이터를 요청 될 때마다 hello 응용 프로그램 문제를 가져올 수는 조건부 헤더를 사용는 표시 되지 않도록 hello 전체 blob 수정 되지 않은 경우 수정 시간에 대 한 합니다.</span><span class="sxs-lookup"><span data-stu-id="70433-366">Furthermore, whenever a user requests hello data, hello application could issue GET with a conditional header for modification time, which would avoid getting hello entire blob if it hasn't been modified.</span></span> <span data-ttu-id="70433-367">이 동일한 패턴 tooworking 테이블 엔터티를 적용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="70433-367">You can apply this same pattern tooworking with table entities.</span></span>  

<span data-ttu-id="70433-368">경우에 따라 응용 프로그램이 해당 hello blob는, 및을이 기간 hello 하는 동안 응용 프로그램 필요는 없습니다 toocheck hello blob이 수정 된 경우를 검색 한 후 짧은 기간 동안 유효한 상태로 남아 가정할 수를 결정할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="70433-368">In some cases, you may decide that your application can assume that hello blob remains valid for a short period after retrieving it, and that during this period hello application does not need toocheck if hello blob was modified.</span></span>

<span data-ttu-id="70433-369">구성, 조회 및 항상 hello 응용 프로그램에서 사용 되는 기타 데이터 캐싱에 대 한 적합 한 항목 됩니다.</span><span class="sxs-lookup"><span data-stu-id="70433-369">Configuration, lookup, and other data that are always used by hello application are great candidates for caching.</span></span>  

<span data-ttu-id="70433-370">.NET을 사용 하 여 어떻게 tooget 속성 toodiscover hello blob의 마지막으로 수정한 날짜에 대 한 예제 참조 [집합을 검색 속성 및 메타 데이터](storage-properties-metadata.md)합니다.</span><span class="sxs-lookup"><span data-stu-id="70433-370">For an example of how tooget a blob's properties toodiscover hello last modified date using .NET, see [Set and Retrieve Properties and Metadata](storage-properties-metadata.md).</span></span> <span data-ttu-id="70433-371">조건부 다운로드에 대한 자세한 내용은 [Blob의 로컬 복사본을 조건부로 새로 고침](http://msdn.microsoft.com/library/azure/dd179371.aspx)을 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="70433-371">For more information about conditional downloads, see [Conditionally Refresh a Local Copy of a Blob](http://msdn.microsoft.com/library/azure/dd179371.aspx).</span></span>  

#### <span data-ttu-id="70433-372"><a name="subheading8"></a>데이터 일괄 업로드</span><span class="sxs-lookup"><span data-stu-id="70433-372"><a name="subheading8"></a>Uploading Data in Batches</span></span>
<span data-ttu-id="70433-373">데이터를 로컬로 집계한 다음 각 데이터 부분을 즉시 업로드하는 대신 주기적으로 일괄 업로드할 수 있는 응용 프로그램 시나리오가 있습니다.</span><span class="sxs-lookup"><span data-stu-id="70433-373">In some application scenarios, you can aggregate data locally, and then periodically upload it in a batch instead of uploading each piece of data immediately.</span></span> <span data-ttu-id="70433-374">예를 들어 웹 응용 프로그램 작업의 로그 파일을 가질 수 있습니다: hello 응용 프로그램 하나을 업로드할 수 모든 활동의 세부 정보 (엔드가, 저장소 작업 수) 테이블 항목으로 발생 하지 않거나 활동 세부 정보 tooa 로컬 로그 파일을 저장할 수 대로 했다가 구분 기호로 분리 된 파일 tooa blob으로 모든 작업 세부 정보를 주기적으로 업로드 합니다.</span><span class="sxs-lookup"><span data-stu-id="70433-374">For example, a web application might keep a log file of activities: hello application could either upload details of every activity as it happens as a table entity (which requires many storage operations), or it could save activity details tooa local log file, and then periodically upload all activity details as a delimited file tooa blob.</span></span> <span data-ttu-id="70433-375">각 로그 항목은 크기가 1KB, 수천 (단일 트랜잭션 내에서 크기가 too64MB의 blob를 업로드할 수) 단일 "Put Blob" 트랜잭션에서 업로드할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="70433-375">If each log entry is 1KB in size, you can upload thousands in a single "Put Blob" transaction (you can upload a blob of up too64MB in size in a single transaction).</span></span> <span data-ttu-id="70433-376">물론, hello 로컬 컴퓨터에 이전 toohello 업로드 충돌할 경우 잠재적으로 손실 됩니다 일부 로그 데이터: hello 응용 프로그램 개발자 hello 가능성이 클라이언트 장치에 대 한 디자인 하거나 오류를 업로드 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="70433-376">Of course, if hello local machine crashes prior toohello upload, you will potentially lose some log data: hello application developer must design for hello possibility of client device or upload failures.</span></span>  <span data-ttu-id="70433-377">Hello 활동 데이터 toobe (하나가 아니라 활동) 시간에 대 한 다운로드 한 경우, blob는 테이블에 대해 권장 됩니다.</span><span class="sxs-lookup"><span data-stu-id="70433-377">If hello activity data needs toobe downloaded for timespans (not just single activity), then blobs are recommended over tables.</span></span>

### <a name="net-configuration"></a><span data-ttu-id="70433-378">.NET 구성</span><span class="sxs-lookup"><span data-stu-id="70433-378">.NET Configuration</span></span>
<span data-ttu-id="70433-379">.NET Framework hello를 사용 하 여, 하는 경우이 섹션 toomake 성능이 크게 향상 된 기능을 사용할 수 있는 몇 가지 빠른 구성 설정을 나열 합니다.</span><span class="sxs-lookup"><span data-stu-id="70433-379">If using hello .NET Framework, this section lists several quick configuration settings that you can use toomake significant performance improvements.</span></span>  <span data-ttu-id="70433-380">다른 언어를 사용 하 여 비슷한 개념 선택한 언어에 적용 하는 경우 toosee를 확인 합니다.</span><span class="sxs-lookup"><span data-stu-id="70433-380">If using other languages, check toosee if similar concepts apply in your chosen language.</span></span>  

#### <span data-ttu-id="70433-381"><a name="subheading9"></a>기본 연결 제한 늘리기</span><span class="sxs-lookup"><span data-stu-id="70433-381"><a name="subheading9"></a>Increase default connection limit</span></span>
<span data-ttu-id="70433-382">.NET 코드 다음 hello 증가 (이 일반적으로 클라이언트 환경에 2 또는 서버 환경에서 10) hello 기본 연결 제한 too100 합니다.</span><span class="sxs-lookup"><span data-stu-id="70433-382">In .NET, hello following code increases hello default connection limit (which is usually 2 in a client environment or 10 in a server environment) too100.</span></span> <span data-ttu-id="70433-383">일반적으로 응용 프로그램에서 사용 되는 스레드 hello 값 tooapproximately hello 번호를 설정 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="70433-383">Typically, you should set hello value tooapproximately hello number of threads used by your application.</span></span>  

```csharp
ServicePointManager.DefaultConnectionLimit = 100; //(Or More)  
```

<span data-ttu-id="70433-384">모든 연결을 열기 전에 hello 연결도 설정 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="70433-384">You must set hello connection limit before opening any connections.</span></span>  

<span data-ttu-id="70433-385">다른 프로그래밍 언어에 대 한 해당 언어 설명서 toodetermine tooset hello 연결 제한 하는 방법을 참조 하세요.</span><span class="sxs-lookup"><span data-stu-id="70433-385">For other programming languages, see that language's documentation toodetermine how tooset hello connection limit.</span></span>  

<span data-ttu-id="70433-386">자세한 내용은 hello 블로그 게시물을 참조 하십시오. [웹 서비스: 동시 연결](http://blogs.msdn.com/b/darrenj/archive/2005/03/07/386655.aspx)합니다.</span><span class="sxs-lookup"><span data-stu-id="70433-386">For additional information, see hello blog post [Web Services: Concurrent Connections](http://blogs.msdn.com/b/darrenj/archive/2005/03/07/386655.aspx).</span></span>  

#### <span data-ttu-id="70433-387"><a name="subheading10"></a>비동기 작업에서 동기 코드를 사용하는 경우 스레드 풀의 최소 스레드 수 늘리기</span><span class="sxs-lookup"><span data-stu-id="70433-387"><a name="subheading10"></a>Increase ThreadPool Min Threads if using synchronous code with Async Tasks</span></span>
<span data-ttu-id="70433-388">이 코드는 hello 스레드 풀의 min 스레드 증가 합니다.</span><span class="sxs-lookup"><span data-stu-id="70433-388">This code will increase hello thread pool min threads:</span></span>  

```csharp
ThreadPool.SetMinThreads(100,100); //(Determine hello right number for your application)  
```

<span data-ttu-id="70433-389">자세한 내용은 [ThreadPool.SetMinThreads 메서드](http://msdn.microsoft.com/library/system.threading.threadpool.setminthreads%28v=vs.110%29.aspx)를 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="70433-389">For more information, see [ThreadPool.SetMinThreads Method](http://msdn.microsoft.com/library/system.threading.threadpool.setminthreads%28v=vs.110%29.aspx).</span></span>  

#### <span data-ttu-id="70433-390"><a name="subheading11"></a>.NET 4.5 가비지 수집 기능 활용</span><span class="sxs-lookup"><span data-stu-id="70433-390"><a name="subheading11"></a>Take advantage of .NET 4.5 Garbage Collection</span></span>
<span data-ttu-id="70433-391">서버 가비지 수집의 성능 향상의 클라이언트 응용 프로그램 tootake 이점은 hello에 대 한.NET 4.5 이상을 사용 합니다.</span><span class="sxs-lookup"><span data-stu-id="70433-391">Use .NET 4.5 or later for hello client application tootake advantage of performance improvements in server garbage collection.</span></span>

<span data-ttu-id="70433-392">자세한 내용은 hello 문서 참조 [는 개요의 성능 향상.NET 4.5에서](http://msdn.microsoft.com/magazine/hh882452.aspx)합니다.</span><span class="sxs-lookup"><span data-stu-id="70433-392">For more information, see hello article [An Overview of Performance Improvements in .NET 4.5](http://msdn.microsoft.com/magazine/hh882452.aspx).</span></span>  

### <span data-ttu-id="70433-393"><a name="subheading12"></a>제한 없는 병렬 처리</span><span class="sxs-lookup"><span data-stu-id="70433-393"><a name="subheading12"></a>Unbounded Parallelism</span></span>
<span data-ttu-id="70433-394">여러 작업자 tooaccess를 사용 하 여 바인딩되지 않은 병렬 처리 (hello 스레드 및/또는 병렬 요청 수에 제한 없음) tooupload 또는 다운로드 데이터 여러 파티션을 사용 하는 방법에 대 한 병렬 처리 하는 성능에 좋지 동안 조심 (컨테이너, 큐, 또는 파티션 테이블)에 hello 동일한 저장소 계정 또는 tooaccess hello에 여러 항목이 동일한 파티션에 합니다.</span><span class="sxs-lookup"><span data-stu-id="70433-394">While parallelism can be great for performance, be careful about using unbounded parallelism (no limit on hello number of threads and/or parallel requests) tooupload or download data, using multiple workers tooaccess multiple partitions (containers, queues, or table partitions) in hello same storage account or tooaccess multiple items in hello same partition.</span></span> <span data-ttu-id="70433-395">Hello 병렬 처리 수준 제한이 없으면, 응용 프로그램 hello 클라이언트 장치 용량을 초과 하거나 더 긴 대기 시간이 않으며 제한 저장소 계정의 확장성 목표 hello 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="70433-395">If hello parallelism is unbounded, your application can exceed hello client device's capabilities or hello storage account's scalability targets resulting in longer latencies and throttling.</span></span>  

### <span data-ttu-id="70433-396"><a name="subheading13"></a>저장소 클라이언트 라이브러리 및 도구</span><span class="sxs-lookup"><span data-stu-id="70433-396"><a name="subheading13"></a>Storage Client Libraries and Tools</span></span>
<span data-ttu-id="70433-397">항상 hello 최신 Microsoft에서 제공 클라이언트 라이브러리 및 도구를 사용 합니다.</span><span class="sxs-lookup"><span data-stu-id="70433-397">Always use hello latest Microsoft provided client libraries and tools.</span></span> <span data-ttu-id="70433-398">쓰기를 hello 시점에는 다른 언어에 대 한 미리 보기 라이브러리 뿐만 아니라.NET, Windows Phone, Windows 런타임, Java 및 c + +에서 사용할 수 있는 클라이언트 라이브러리입니다.</span><span class="sxs-lookup"><span data-stu-id="70433-398">At hello time of writing, there are client libraries available for .NET, Windows Phone, Windows Runtime, Java, and C++, as well as preview libraries for other languages.</span></span> <span data-ttu-id="70433-399">또한 Microsoft에서는 Azure 저장소 작업을 위해 PowerShell cmdlet 및 Azure CLI 명령도 출시했습니다.</span><span class="sxs-lookup"><span data-stu-id="70433-399">In addition, Microsoft has released PowerShell cmdlets and Azure CLI commands for working with Azure Storage.</span></span> <span data-ttu-id="70433-400">Microsoft은 적극적으로 개발 하 고, 성능 염두에서 함께 이러한 도구, toodate 서로 hello 최신 서비스 버전을 구성 하 게 보관할을 처리 하는 다양 한 성능 사례를 내부적으로 입증 된 hello.</span><span class="sxs-lookup"><span data-stu-id="70433-400">Microsoft actively develops these tools with performance in mind, keeps them up toodate with hello latest service versions, and ensures they handle many of hello proven performance practices internally.</span></span>  

### <a name="retries"></a><span data-ttu-id="70433-401">다시 시도</span><span class="sxs-lookup"><span data-stu-id="70433-401">Retries</span></span>
#### <span data-ttu-id="70433-402"><a name="subheading14"></a>제한/서버 작업 중</span><span class="sxs-lookup"><span data-stu-id="70433-402"><a name="subheading14"></a>Throttling/ServerBusy</span></span>
<span data-ttu-id="70433-403">경우에 따라 hello 저장소 서비스 수 있습니다 제한 응용 프로그램 또는 될 수 있습니다 단순히 일시적인 상태의 경우 toosome 인해 없습니다 tooserve hello 요청일 수 하 고 "503 서버 사용 중" 메시지 또는 "500 Timeout"를 반환 합니다.</span><span class="sxs-lookup"><span data-stu-id="70433-403">In some cases, hello storage service may throttle your application or may simply be unable tooserve hello request due toosome transient condition and return a "503 Server busy" message or "500 Timeout".</span></span>  <span data-ttu-id="70433-404">이 응용 프로그램에 도달 하 고 hello 확장성 목표 중 하나 또는 hello 시스템 처리량이 늘어나며 여 분할 된 데이터 tooallow 리 밸런스는 경우에 발생할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="70433-404">This can happen if your application is approaching any of hello scalability targets, or if hello system is rebalancing your partitioned data tooallow for higher throughput.</span></span>  <span data-ttu-id="70433-405">hello 클라이언트 응용 프로그램 해야 하면 이러한 오류가 발생 하는 hello 작업을 다시 시도 일반적으로: hello 동일 나중에 요청을 시도 성공할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="70433-405">hello client application should typically retry hello operation that causes such an error: attempting hello same request later can succeed.</span></span> <span data-ttu-id="70433-406">그러나 hello 저장소 서비스 응용 프로그램 확장성 목표를 초과 하기 때문에 제한 하거나 hello 서비스는 어떤 다른 이유로 없습니다 tooserve hello 요청에서 하는 경우에 적극적으로 다시 시도 hello 문제가 심각 일반적으로 확인 합니다.</span><span class="sxs-lookup"><span data-stu-id="70433-406">However, if hello storage service is throttling your application because it is exceeding scalability targets, or even if hello service was unable tooserve hello request for some other reason, aggressive retries usually make hello problem worse.</span></span> <span data-ttu-id="70433-407">이러한 이유로 지 수 (hello 클라이언트 라이브러리 기본 toothis 동작) 백오프을 사용 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="70433-407">For this reason, you should use an exponential back off (hello client libraries default toothis behavior).</span></span> <span data-ttu-id="70433-408">예를 들어 응용 프로그램은 작업을 2초, 4초, 10초, 30초 후에 다시 시도한 다음 계속 실패하면 작업을 완전히 포기할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="70433-408">For example, your application may retry after 2 seconds, then 4 seconds, then 10 seconds, then 30 seconds, and then give up completely.</span></span> <span data-ttu-id="70433-409">이 동작은 크게 hello 서비스에서의 로드 줄이는 것이 아니라 모든 문제를 악화 시키는 것에 응용 프로그램에서 발생 합니다.</span><span class="sxs-lookup"><span data-stu-id="70433-409">This behavior results in your application significantly reducing its load on hello service rather than exacerbating any problems.</span></span>  

<span data-ttu-id="70433-410">연결 오류가 다시 시도할 수 즉시 때문에 제한의 결과로 hello 없는 일시적인 예상된 toobe note 합니다.</span><span class="sxs-lookup"><span data-stu-id="70433-410">Note that connectivity errors can be retried immediately, because they are not hello result of throttling and are expected toobe transient.</span></span>  

#### <span data-ttu-id="70433-411"><a name="subheading15"></a>다시 시도할 수 없는 오류</span><span class="sxs-lookup"><span data-stu-id="70433-411"><a name="subheading15"></a>Non-Retryable Errors</span></span>
<span data-ttu-id="70433-412">hello 클라이언트 라이브러리는 오류는 다시 시도 가능한와 하지 않을 인식있지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="70433-412">hello client libraries are aware of which errors are retry-able and which are not.</span></span> <span data-ttu-id="70433-413">그러나 hello 저장소 REST API에 대해 사용자 고유의 코드를 작성 하는 경우 기억 하지 다시 시도해 야 하는 몇 가지 오류가: 400 (잘못 된 요청)이 응답 나타냅니다 hello 클라이언트 응용 프로그램 때문에 처리 하지 못한 요청을 전송 하는 예를 들어 것 예상 된 형태로 없습니다.</span><span class="sxs-lookup"><span data-stu-id="70433-413">However, if you are writing your own code against hello storage REST API, remember there are some errors that you should not retry: for example, a 400 (Bad Request) response indicates that hello client application sent a request that could not be processed because it was not in an expected form.</span></span> <span data-ttu-id="70433-414">이 요청을 다시 전송 될 것을 다시 시도 중에 포인터가 없는 하므로 매번 같은 응답 hello 합니다.</span><span class="sxs-lookup"><span data-stu-id="70433-414">Resending this request will result hello same response every time, so there is no point in retrying it.</span></span> <span data-ttu-id="70433-415">Hello 저장소 REST API에 대해 사용자 고유의 코드를 작성 하는 경우 (또는 비공유) hello 오류 코드 평균과 hello 적절 한 방법은 tooretry 고려해 야 채 각 항목에 대 한 합니다.</span><span class="sxs-lookup"><span data-stu-id="70433-415">If you are writing your own code against hello storage REST API, be aware of what hello error codes mean and hello proper way tooretry (or not) for each of them.</span></span>  

#### <a name="useful-resources"></a><span data-ttu-id="70433-416">유용한 리소스</span><span class="sxs-lookup"><span data-stu-id="70433-416">Useful Resources</span></span>
<span data-ttu-id="70433-417">저장소 오류 코드에 대 한 자세한 내용은 참조 [상태 및 오류 코드](http://msdn.microsoft.com/library/azure/dd179382.aspx) hello Microsoft Azure 웹 사이트에 있습니다.</span><span class="sxs-lookup"><span data-stu-id="70433-417">For more information about storage error codes, see [Status and Error Codes](http://msdn.microsoft.com/library/azure/dd179382.aspx) on hello Microsoft Azure web site.</span></span>  

## <a name="blobs"></a><span data-ttu-id="70433-418">Blob</span><span class="sxs-lookup"><span data-stu-id="70433-418">Blobs</span></span>
<span data-ttu-id="70433-419">에 대 한 사례를 입증 된 더하기 toohello에서 [모든 서비스](#allservices) 앞에서 설명한 검증 된 사용법 hello 다음 특히 toohello blob 서비스를 적용 합니다.</span><span class="sxs-lookup"><span data-stu-id="70433-419">In addition toohello proven practices for [All Services](#allservices) described previously, hello following proven practices apply specifically toohello blob service.</span></span>  

### <a name="blob-specific-scalability-targets"></a><span data-ttu-id="70433-420">Blob 관련 확장성 목표</span><span class="sxs-lookup"><span data-stu-id="70433-420">Blob-Specific Scalability Targets</span></span>
#### <span data-ttu-id="70433-421"><a name="subheading46"></a>동시에 단일 개체를 액세스하는 여러 클라이언트</span><span class="sxs-lookup"><span data-stu-id="70433-421"><a name="subheading46"></a>Multiple clients accessing a single object concurrently</span></span>
<span data-ttu-id="70433-422">단일 개체를 동시에 액세스 하는 클라이언트 수가 많은 경우에 개체 및 저장소 계정 확장성 목표 당 tooconsider를 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="70433-422">If you have a large number of clients accessing a single object concurrently you will need tooconsider per object and storage account scalability targets.</span></span> <span data-ttu-id="70433-423">단일 개체에 액세스할 수 있는 클라이언트의 수를 정확 하 게 hello 메시지가 hello 개체의 크기를 hello hello 개체를 동시에 요청 된 클라이언트 hello 수 등의 요인에 따라 달라 집니다 (네트워크 상태 등).</span><span class="sxs-lookup"><span data-stu-id="70433-423">hello exact number of clients that can access a single object will vary depending on factors such as hello number of clients requesting hello object simultaneously, hello size of hello object, network conditions etc.</span></span>

<span data-ttu-id="70433-424">Hello 개체를 통해 배포할 수 있습니다는 CDN 이미지 또는 비디오와 같은 웹 사이트에서 처리 한 다음 CDN을 사용 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="70433-424">If hello object can be distributed through a CDN such as images or videos served from a website then you should use a CDN.</span></span> <span data-ttu-id="70433-425">[여기](#subheading5)를 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="70433-425">See [here](#subheading5).</span></span>

<span data-ttu-id="70433-426">공학용 시뮬레이션 hello 데이터는 기밀로 유지와 같은 다른 시나리오에서는 두 가지 옵션이 있습니다.</span><span class="sxs-lookup"><span data-stu-id="70433-426">In other scenarios such as scientific simulations where hello data is confidential you have two options.</span></span> <span data-ttu-id="70433-427">hello toostagger 워크 로드의 같은 액세스 개체 hello 하는 동시에 액세스 하는 시간 및 기간을 통해 액세스 되는 있습니다.</span><span class="sxs-lookup"><span data-stu-id="70433-427">hello first is toostagger your workload's access such that hello object is accessed over a period of time vs being accessed simultaneously.</span></span> <span data-ttu-id="70433-428">또는 개체당 및 저장소 계정에서 총 IOP hello 하므로 증가 하는 hello 개체 toomultiple 저장소 계정을 일시적으로 복사할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="70433-428">Alternatively, you can temporarily copy hello object toomultiple storage accounts thus increasing hello total IOPS per object and across storage accounts.</span></span> <span data-ttu-id="70433-429">제한 된 테스트에 약 25 Vm (각 VM의 hello 다운로드 스레드 32 개를 사용 하 여 병렬화 되었습니다) 병렬로 100GB blob를 동시에 다운로드할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="70433-429">In limited testing we found that around 25 VMs could simultaneously download a 100GB blob in parallel (each VM was parallelizing hello download using 32 threads).</span></span> <span data-ttu-id="70433-430">Tooaccess hello 개체가 필요 합니다. 클라이언트 수가 100 개을 설치한 경우 먼저 tooa 두 번째 저장소 계정 및 다음 첫 번째 blob 처음 50 개 Vm 액세스 hello hello가 복사한 50 두 번째 Vm 액세스 hello 두 번째 blob hello 합니다.</span><span class="sxs-lookup"><span data-stu-id="70433-430">If you had 100 clients needing tooaccess hello object, first copy it tooa second storage account and then have hello first 50 VMs access hello first blob and hello second 50 VMs access hello second blob.</span></span> <span data-ttu-id="70433-431">결과는 응용 프로그램 동작에 따라 다르므로 설계 중에 이 동작을 테스트해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="70433-431">Results will vary depending on your applications behavior so you should test this during design.</span></span> 

#### <span data-ttu-id="70433-432"><a name="subheading16"></a>Blob당 대역폭 및 작업</span><span class="sxs-lookup"><span data-stu-id="70433-432"><a name="subheading16"></a>Bandwidth and operations per Blob</span></span>
<span data-ttu-id="70433-433">읽거나 tooa 최대 60MB/초를에서 한 tooa 단일 blob을 쓸 수 있습니다 (이 많은 네트워크 클라이언트 측의 hello 기능을 초과 하는 약 480 Mbps (hello 클라이언트 장치에 물리적 NIC hello 포함).</span><span class="sxs-lookup"><span data-stu-id="70433-433">You can read or write tooa single blob at up tooa maximum of 60 MB/second (this is approximately 480 Mbps which exceeds hello capabilities of many client side networks (including hello physical NIC on hello client device).</span></span> <span data-ttu-id="70433-434">또한 단일 blob 초당 too500 요청을 지원합니다.</span><span class="sxs-lookup"><span data-stu-id="70433-434">In addition, a single blob supports up too500 requests per second.</span></span> <span data-ttu-id="70433-435">Tooread 해야 하는 여러 클라이언트가 있는 경우 hello 동일한 blob 및 될 수 있습니다 이러한 한도 초과 CDN을 사용 하 여 hello blob를 배포 하는 것이 좋습니다.</span><span class="sxs-lookup"><span data-stu-id="70433-435">If you have multiple clients that need tooread hello same blob and you might exceed these limits, you should consider using a CDN for distributing hello blob.</span></span>  

<span data-ttu-id="70433-436">Blob의 목표 처리량에 대한 자세한 내용은 [Azure 저장소 확장성 및 성능 목표](storage-scalability-targets.md)를 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="70433-436">For more information about target throughput for blobs, see [Azure Storage Scalability and Performance Targets](storage-scalability-targets.md).</span></span>  

### <a name="copying-and-moving-blobs"></a><span data-ttu-id="70433-437">Blob 복사 및 이동</span><span class="sxs-lookup"><span data-stu-id="70433-437">Copying and Moving Blobs</span></span>
#### <span data-ttu-id="70433-438"><a name="subheading17"></a>Blob 복사</span><span class="sxs-lookup"><span data-stu-id="70433-438"><a name="subheading17"></a>Copy Blob</span></span>
<span data-ttu-id="70433-439">REST API 버전 2012-02-12 hello 저장소 계정 간에 hello 유용한 기능 toocopy blob 도입: hello 저장소 서비스 toocopy (다른 저장소 계정)에 있는 다른 원본에서 blob를 지시 하 고 hello 하 게 하는 클라이언트 응용 프로그램 수 서비스는 hello 복사본을 비동기적으로 수행 합니다.</span><span class="sxs-lookup"><span data-stu-id="70433-439">hello storage REST API version 2012-02-12 introduced hello useful ability toocopy blobs across accounts: a client application can instruct hello storage service toocopy a blob from another source (possibly in a different storage account), and then let hello service perform hello copy asynchronously.</span></span> <span data-ttu-id="70433-440">Toodownload 필요 하지 않으며 hello 데이터를 업로드 하기 때문에 다른 저장소 계정에서 데이터를 마이그레이션하는 경우 hello 응용 프로그램에 필요 하는 hello 대역폭이 대폭 감소할 수 있습니다이 있습니다.</span><span class="sxs-lookup"><span data-stu-id="70433-440">This can significantly reduce hello bandwidth needed for hello application when you are migrating data from other storage accounts because you do not need toodownload and upload hello data.</span></span>  

<span data-ttu-id="70433-441">하지만 그 중 하나, 저장소 계정 사이 복사할 때 있다는 점입니다 hello 복사본을 완료 하는 경우 시간 보장할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="70433-441">One consideration, however, is that, when copying between storage accounts, there is no time guarantee on when hello copy will complete.</span></span> <span data-ttu-id="70433-442">응용 프로그램에 필요한 toocomplete blob 제어 신속 하 게 복사 하는 경우 더 나은 toocopy hello blob tooa VM을 다운로드 하 고 다음 toohello 대상 업로드 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="70433-442">If your application needs toocomplete a blob copy quickly under your control, it may be better toocopy hello blob by downloading it tooa VM and then uploading it toohello destination.</span></span>  <span data-ttu-id="70433-443">이러한 상황에서는 전체 예측에 대 한 hello 복사본 수행 되도록 hello에서 실행 중인 VM에서 같은 Azure 지역. 그렇지 않으면 네트워크 상태 수 (및이 더) 성능에 영향을 복사 합니다.</span><span class="sxs-lookup"><span data-stu-id="70433-443">For full predictability in that situation, ensure that hello copy is performed by a VM running in hello same Azure region, or else network conditions may (and probably will) affect your copy performance.</span></span>  <span data-ttu-id="70433-444">또한 비동기 복사본의 hello 진행률을 프로그래밍 방식으로 모니터링할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="70433-444">In addition, you can monitor hello progress of an asynchronous copy programmatically.</span></span>  

<span data-ttu-id="70433-445">일반적으로 동일한 저장소 계정 자체 신속 하 게 완료 hello 내에서 복사 하는 참고 합니다.</span><span class="sxs-lookup"><span data-stu-id="70433-445">Note that copies within hello same storage account itself are generally completed quickly.</span></span>  

<span data-ttu-id="70433-446">자세한 내용은 [Blob 복사](http://msdn.microsoft.com/library/azure/dd894037.aspx)를 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="70433-446">For more information, see [Copy Blob](http://msdn.microsoft.com/library/azure/dd894037.aspx).</span></span>  

#### <span data-ttu-id="70433-447"><a name="subheading18"></a>AzCopy 사용</span><span class="sxs-lookup"><span data-stu-id="70433-447"><a name="subheading18"></a>Use AzCopy</span></span>
<span data-ttu-id="70433-448">hello Azure 저장소 팀 "AzCopy" 명령줄 도구를 릴리스 했습니다 업그레이드용은 toohelp 즉, 및 저장소 계정에서 여러 blob를 전송 하는 대량 사용 합니다.</span><span class="sxs-lookup"><span data-stu-id="70433-448">hello Azure Storage team has released a command-line tool "AzCopy" that is meant toohelp with bulk transferring many blobs to, from, and across storage accounts.</span></span>  <span data-ttu-id="70433-449">이 도구는 이러한 시나리오용으로 최적화되어 있으며 높은 전송 속도를 제공할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="70433-449">This tool is optimized for this scenario, and can achieve high transfer rates.</span></span>  <span data-ttu-id="70433-450">대량 업로드, 다운로드 및 복사 시나리오에는 이 도구를 사용하는 것이 좋습니다.</span><span class="sxs-lookup"><span data-stu-id="70433-450">Its use is encouraged for bulk upload, download, and copy scenarios.</span></span> <span data-ttu-id="70433-451">항목에 대 한 자세한 toolearn 다운로드를 참조 하세요 [hello AzCopy 명령줄 유틸리티를 사용 하 여 데이터를 전송](storage-use-azcopy.md)합니다.</span><span class="sxs-lookup"><span data-stu-id="70433-451">toolearn more about it and download it, see [Transfer data with hello AzCopy Command-Line Utility](storage-use-azcopy.md).</span></span>  

#### <span data-ttu-id="70433-452"><a name="subheading19"></a>Azure 가져오기/내보내기 서비스</span><span class="sxs-lookup"><span data-stu-id="70433-452"><a name="subheading19"></a>Azure Import/Export Service</span></span>
<span data-ttu-id="70433-453">데이터 (1TB 이상)의 매우 큰 볼륨 hello Azure 저장소는 hello을 업로드 하 고 하드 드라이브를 배송 하 여 blob 저장소에서 다운로드할 수 있는 가져오기/내보내기 서비스를 제공 합니다.</span><span class="sxs-lookup"><span data-stu-id="70433-453">For very large volumes of data (more than 1TB), hello Azure Storage offers hello Import/Export service, which allows for uploading and downloading from blob storage by shipping hard drives.</span></span>  <span data-ttu-id="70433-454">하드 드라이브에 데이터를 설정 하 고 업로드를 tooMicrosoft 보낼 하거나 빈 하드 드라이브 tooMicrosoft toodownload 데이터를 보낼 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="70433-454">You can put your data on a hard drive and send it tooMicrosoft for upload, or send a blank hard drive tooMicrosoft toodownload data.</span></span>  <span data-ttu-id="70433-455">자세한 내용은 참조 [hello Microsoft Azure 가져오기/내보내기 서비스 tooTransfer 데이터 tooBlob 저장소를 사용 하 여](storage-import-export-service.md)합니다.</span><span class="sxs-lookup"><span data-stu-id="70433-455">For more information, see [Use hello Microsoft Azure Import/Export Service tooTransfer Data tooBlob Storage](storage-import-export-service.md).</span></span>  <span data-ttu-id="70433-456">이 업로드/다운로드 로그 데이터의이 양이 hello 네트워크를 통해 보다 훨씬 더 효율적일 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="70433-456">This can be much more efficient than uploading/downloading this volume of data over hello network.</span></span>  

### <span data-ttu-id="70433-457"><a name="subheading20"></a>메타데이터 사용</span><span class="sxs-lookup"><span data-stu-id="70433-457"><a name="subheading20"></a>Use metadata</span></span>
<span data-ttu-id="70433-458">hello blob 서비스는 hello blob에 대 한 메타 데이터를 포함할 수 있는 헤드 요청을 지원 합니다.</span><span class="sxs-lookup"><span data-stu-id="70433-458">hello blob service supports head requests, which can include metadata about hello blob.</span></span> <span data-ttu-id="70433-459">예를 들어 응용 프로그램이 필요한 사진 부족 hello EXIF 데이터, 경우 hello 사진을 검색 하 고 압축을 풀고 수 것입니다.</span><span class="sxs-lookup"><span data-stu-id="70433-459">For example, if your application needed hello EXIF data out of a photo, it could retrieve hello photo and extract it.</span></span> <span data-ttu-id="70433-460">toosave 대역폭 및 성능 향상, 응용 프로그램 데이터를 저장할 수 hello EXIF hello blob의 메타 데이터에 hello 응용 프로그램 hello 사진 업로드 하는 경우: 다음 데이터를 검색할 수 hello EXIF HEAD 요청만 사용 하 여 메타 데이터에 중요 한 대역폭 절약 고 hello 처리 시간 tooextract hello EXIF 데이터 각 시간 hello blob을 읽이 필요 합니다.</span><span class="sxs-lookup"><span data-stu-id="70433-460">toosave bandwidth and improve performance, your application could store hello EXIF data in hello blob's metadata when hello application uploaded hello photo: you can then retrieve hello EXIF data in metadata using only a HEAD request, saving significant bandwidth and hello processing time needed tooextract hello EXIF data each time hello blob is read.</span></span> <span data-ttu-id="70433-461">이 방법이 필요한 hello 메타 데이터 및 전체 내용을 blob의 hello 시나리오에서 유용 합니다.</span><span class="sxs-lookup"><span data-stu-id="70433-461">This would be useful in scenarios where you only need hello metadata, and not hello full content of a blob.</span></span>  <span data-ttu-id="70433-462">참고 blob 당 8KB만 메타 데이터를 저장할 수 있습니다 (hello 서비스를 허용 하지 것입니다 요청 toostore 그 보다 큰), 가능 하지 않습니다 hello 데이터 크기에 맞지 않을 경우 하므로 수 수 toouse이 방법을이 사용 합니다.</span><span class="sxs-lookup"><span data-stu-id="70433-462">Note that only 8 KB of metadata can be stored per blob (hello service will not accept a request toostore more than that), so if hello data does not fit in that size, you may not be able toouse this approach.</span></span>  

<span data-ttu-id="70433-463">방법의 예에 대 한 tooget.NET을 사용 하 여 blob의 메타 데이터 참조 [집합을 검색 속성 및 메타 데이터](storage-properties-metadata.md)합니다.</span><span class="sxs-lookup"><span data-stu-id="70433-463">For an example of how tooget a blob's metadata using .NET, see [Set and Retrieve Properties and Metadata](storage-properties-metadata.md).</span></span>  

### <a name="uploading-fast"></a><span data-ttu-id="70433-464">고속 업로드</span><span class="sxs-lookup"><span data-stu-id="70433-464">Uploading Fast</span></span>
<span data-ttu-id="70433-465">빠른 tooupload blob, 첫 번째 질문 tooanswer hello는: 업로드 한 blob 또는 많은 입니까?</span><span class="sxs-lookup"><span data-stu-id="70433-465">tooupload blobs fast, hello first question tooanswer is: are you uploading one blob or many?</span></span>  <span data-ttu-id="70433-466">아래 시나리오에 따라 지침 toodetermine hello 적절 한 방법 toouse hello를 사용 합니다.</span><span class="sxs-lookup"><span data-stu-id="70433-466">Use hello below guidance toodetermine hello correct method toouse depending on your scenario.</span></span>  

#### <span data-ttu-id="70433-467"><a name="subheading21"></a>큰 Blob 하나를 빠르게 업로드</span><span class="sxs-lookup"><span data-stu-id="70433-467"><a name="subheading21"></a>Uploading one large blob quickly</span></span>
<span data-ttu-id="70433-468">큰 단일 신속 하 게 blob tooupload, 클라이언트 응용 프로그램의 블록 또는 페이지 (되 고 각 blob 및 전체적으로 hello 저장소 계정에 대 한 hello 확장성 목표에 주의) 동시에 업로드 합니다.</span><span class="sxs-lookup"><span data-stu-id="70433-468">tooupload a single large blob quickly, your client application should upload its blocks or pages in parallel (being mindful of hello scalability targets for individual blobs and hello storage account as a whole).</span></span>  <span data-ttu-id="70433-469">Hello 공식 Microsoft 제공 RTM 저장소 클라이언트 라이브러리 (.NET, Java)가 hello 기능 toodo이 참고 합니다.</span><span class="sxs-lookup"><span data-stu-id="70433-469">Note that hello official Microsoft-provided RTM Storage Client libraries (.NET, Java) have hello ability toodo this.</span></span>  <span data-ttu-id="70433-470">각 hello 라이브러리에 대 한 동시성의 지정 된 개체/속성 tooset hello 수준 보다 hello를 사용 합니다.</span><span class="sxs-lookup"><span data-stu-id="70433-470">For each of hello libraries, use hello below specified object/property tooset hello level of concurrency:</span></span>  

* <span data-ttu-id="70433-471">사용 되는 BlobRequestOptions 개체 toobe.NET: 집합 ParallelOperationThreadCount 합니다.</span><span class="sxs-lookup"><span data-stu-id="70433-471">.NET: Set ParallelOperationThreadCount on a BlobRequestOptions object toobe used.</span></span>
* <span data-ttu-id="70433-472">Java/Android: BlobRequestOptions.setConcurrentRequestCount()를 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="70433-472">Java/Android: Use BlobRequestOptions.setConcurrentRequestCount()</span></span>
* <span data-ttu-id="70433-473">Node.js: hello blob 서비스 또는 hello 요청 옵션 중 하나에서 parallelOperationThreadCount를 사용 합니다.</span><span class="sxs-lookup"><span data-stu-id="70433-473">Node.js: Use parallelOperationThreadCount on either hello request options or on hello blob service.</span></span>
* <span data-ttu-id="70433-474">C + +: hello blob_request_options:: set_parallelism_factor 메서드를 사용 합니다.</span><span class="sxs-lookup"><span data-stu-id="70433-474">C++: Use hello blob_request_options::set_parallelism_factor method.</span></span>

#### <span data-ttu-id="70433-475"><a name="subheading22"></a>여러 Blob을 빠르게 업로드</span><span class="sxs-lookup"><span data-stu-id="70433-475"><a name="subheading22"></a>Uploading many blobs quickly</span></span>
<span data-ttu-id="70433-476">신속 하 게 blob 많은 tooupload 병렬에서 blob 업로드 합니다.</span><span class="sxs-lookup"><span data-stu-id="70433-476">tooupload many blobs quickly, upload blobs in parallel.</span></span> <span data-ttu-id="70433-477">이 hello 저장소 서비스의 여러 파티션에서 hello 업로드 분산 되므로 한 번에 단일 blob을 블록 병렬 업로드와 함께 업로드 하는 보다 빠릅니다.</span><span class="sxs-lookup"><span data-stu-id="70433-477">This is faster than uploading single blobs at a time with parallel block uploads because it spreads hello upload across multiple partitions of hello storage service.</span></span> <span data-ttu-id="70433-478">단일 Blob은 초당 60MB(약 480Mbps)의 처리량만을 지원합니다.</span><span class="sxs-lookup"><span data-stu-id="70433-478">A single blob only supports a throughput of 60 MB/second (approximately 480 Mbps).</span></span> <span data-ttu-id="70433-479">작성 hello 시 미국 LRS 계정에서는 최대 지원 too20 개별 blob에서 지 원하는 hello 처리량 보다 훨씬 많은 g b p s 수신 합니다.</span><span class="sxs-lookup"><span data-stu-id="70433-479">At hello time of writing, a US-based LRS account supports up too20 Gbps ingress which is far more than hello throughput supported by an individual blob.</span></span>  <span data-ttu-id="70433-480">이 시나리오에서는 기본적으로 업로드를 병렬로 수행하는 [AzCopy](#subheading18)를 사용하는 것이 좋습니다.</span><span class="sxs-lookup"><span data-stu-id="70433-480">[AzCopy](#subheading18) performs uploads in parallel by default, and is recommended for this scenario.</span></span>  

### <span data-ttu-id="70433-481"><a name="subheading23"></a>Blob의 hello 올바른 유형을 선택 하면</span><span class="sxs-lookup"><span data-stu-id="70433-481"><a name="subheading23"></a>Choosing hello correct type of blob</span></span>
<span data-ttu-id="70433-482">Azure Storage는 두 가지 형식의 Blob 즉, *페이지* Blob과 *블록* Blob을 지원합니다.</span><span class="sxs-lookup"><span data-stu-id="70433-482">Azure Storage supports two types of blob: *page* blobs and *block* blobs.</span></span> <span data-ttu-id="70433-483">특정된 사용 시나리오의 경우에 대 한 blob 유형 선택한 솔루션의 hello 성능 및 확장성에 영향을 합니다.</span><span class="sxs-lookup"><span data-stu-id="70433-483">For a given usage scenario, your choice of blob type will affect hello performance and scalability of your solution.</span></span> <span data-ttu-id="70433-484">블록 blob는 tooupload 많은 양의 데이터를 효율적으로 하려는 경우 적절 한: tooupload 사진이 나 비디오 tooblob 저장소 클라이언트 응용 프로그램 예를 들어 할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="70433-484">Block blobs are appropriate when you want tooupload large amounts of data efficiently: for example, a client application may need tooupload photos or video tooblob storage.</span></span> <span data-ttu-id="70433-485">페이지 blob는 tooperform hello 데이터에 대해 임의 쓰기를 hello 응용 프로그램에서 필요로 하는 경우에 적합 합니다: 예를 들어 Azure Vhd는 페이지 blob으로 저장 됩니다.</span><span class="sxs-lookup"><span data-stu-id="70433-485">Page blobs are appropriate if hello application needs tooperform random writes on hello data: for example, Azure VHDs are stored as page blobs.</span></span>  

<span data-ttu-id="70433-486">자세한 내용은 [블록 Blob, 추가 Blob 및 페이지 Blob 이해](http://msdn.microsoft.com/library/azure/ee691964.aspx)를 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="70433-486">For more information, see [Understanding Block Blobs, Append Blobs, and Page Blobs](http://msdn.microsoft.com/library/azure/ee691964.aspx).</span></span>  

## <a name="tables"></a><span data-ttu-id="70433-487">테이블</span><span class="sxs-lookup"><span data-stu-id="70433-487">Tables</span></span>
<span data-ttu-id="70433-488">에 대 한 사례를 입증 된 더하기 toohello에서 [모든 서비스](#allservices) 앞에서 설명한 검증 된 사용법 hello 다음 특히 toohello 테이블 서비스를 적용 합니다.</span><span class="sxs-lookup"><span data-stu-id="70433-488">In addition toohello proven practices for [All Services](#allservices) described previously, hello following proven practices apply specifically toohello table service.</span></span>  

### <span data-ttu-id="70433-489"><a name="subheading24"></a>테이블 관련 확장성 목표</span><span class="sxs-lookup"><span data-stu-id="70433-489"><a name="subheading24"></a>Table-Specific Scalability Targets</span></span>
<span data-ttu-id="70433-490">또한 toohello 대역폭의 제한 사항 전체 저장소 계정, 테이블 특정 확장성 한계에 따라 hello를 갖고 있습니다.</span><span class="sxs-lookup"><span data-stu-id="70433-490">In addition toohello bandwidth limitations of an entire storage account, tables have hello following specific scalability limit.</span></span>  <span data-ttu-id="70433-491">Hello 시스템 로드를 균형 조정 하면 트래픽이 증가 함에 따라 되지만 가능 하지 않습니다 트래픽이 급격 한 증가 있으면 즉시 수 tooget 처리량이이 많은 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="70433-491">Note that hello system will load balance as your traffic increases, but if your traffic has sudden bursts, you may not be able tooget this volume of throughput immediately.</span></span>  <span data-ttu-id="70433-492">하는 동안 시간 제한을 hello 저장소 서비스로 자동으로 버스트를 hello 및/또는 toosee 조정 될 때, 패턴에 급증 하는 경우 테이블 아웃 부하를 분산 합니다.</span><span class="sxs-lookup"><span data-stu-id="70433-492">If your pattern has bursts, you should expect toosee throttling and/or timeouts during hello burst as hello storage service automatically load balances out your table.</span></span>  <span data-ttu-id="70433-493">Hello 시스템 시간 tooload 균형을 적절 하 게 제공 하는 대로 더 나은 결과 있을 것으로 예상 일반적으로 느린 있습니다.</span><span class="sxs-lookup"><span data-stu-id="70433-493">Ramping up slowly generally has better results as it gives hello system time tooload balance appropriately.</span></span>  

#### <a name="entities-per-second-account"></a><span data-ttu-id="70433-494">초당 엔터티 수(계정)</span><span class="sxs-lookup"><span data-stu-id="70433-494">Entities per Second (Account)</span></span>
<span data-ttu-id="70433-495">테이블에 액세스 하는 hello 확장성 제한 된 too20, 000 엔터티 (1KB 각) 계정에 대 한 초당 최대입니다.</span><span class="sxs-lookup"><span data-stu-id="70433-495">hello scalability limit for accessing tables is up too20,000 entities (1KB each) per second for an account.</span></span>  <span data-ttu-id="70433-496">일반적으로는 삽입, 업데이트, 삭제 또는 스캔하는 각 엔터티가 이 목표 수 계산에 포함됩니다.</span><span class="sxs-lookup"><span data-stu-id="70433-496">In general, each entity that is inserted, updated, deleted, or scanned counts toward this target.</span></span>  <span data-ttu-id="70433-497">따라서 엔터티 100개가 포함된 일괄 삽입을 수행하면 엔터티가 100개로 계산됩니다.</span><span class="sxs-lookup"><span data-stu-id="70433-497">So a batch insert that contains 100 entities would count as 100 entities.</span></span>  <span data-ttu-id="70433-498">마찬가지로 1,000개 엔터티를 스캔하여 5를 반환하는 쿼리의 경우 엔터티가 1,000개로 계산됩니다.</span><span class="sxs-lookup"><span data-stu-id="70433-498">A query that scans 1000 entities and returns 5 would count as 1000 entities.</span></span>  

#### <a name="entities-per-second-partition"></a><span data-ttu-id="70433-499">초당 엔터티 수(파티션)</span><span class="sxs-lookup"><span data-stu-id="70433-499">Entities per Second (Partition)</span></span>
<span data-ttu-id="70433-500">단일 파티션 내에서 확장성 목표 hello 초당 2, 000 엔터티 (1KB 각)은 테이블에 액세스를 사용 하 여 hello 동일한 계산 hello 이전 섹션에 설명 된 대로 합니다.</span><span class="sxs-lookup"><span data-stu-id="70433-500">Within a single partition, hello scalability target for accessing tables is 2,000 entities (1KB each) per second, using hello same counting as described in hello previous section.</span></span>  

### <a name="configuration"></a><span data-ttu-id="70433-501">구성</span><span class="sxs-lookup"><span data-stu-id="70433-501">Configuration</span></span>
<span data-ttu-id="70433-502">이 섹션에는 hello 테이블 서비스에 toomake 성능이 크게 향상 된 기능을 사용할 수 있는 몇 가지 빠른 구성 설정을 나열 합니다.</span><span class="sxs-lookup"><span data-stu-id="70433-502">This section lists several quick configuration settings that you can use toomake significant performance improvements in hello table service:</span></span>  

#### <span data-ttu-id="70433-503"><a name="subheading25"></a>JSON 사용</span><span class="sxs-lookup"><span data-stu-id="70433-503"><a name="subheading25"></a>Use JSON</span></span>
<span data-ttu-id="70433-504">저장소 서비스 버전 2013-08-15부터 hello 테이블 서비스 hello AtomPub XML 기반 형식 대신 JSON을 사용 하 여 테이블 데이터를 전송 하기 위한 지원 합니다.</span><span class="sxs-lookup"><span data-stu-id="70433-504">Beginning with storage service version 2013-08-15, hello table service supports using JSON instead of hello XML-based AtomPub format for transferring table data.</span></span> <span data-ttu-id="70433-505">75%에서 페이로드 크기를 줄일 수 하 고 응용 프로그램의 hello 성능을 크게 향상 시킬 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="70433-505">This can reduce payload sizes by as much as 75% and can significantly improve hello performance of your application.</span></span>

<span data-ttu-id="70433-506">자세한 내용은 hello 게시물을 참조 하세요. [Microsoft Azure 테이블: JSON 소개](http://blogs.msdn.com/b/windowsazurestorage/archive/2013/12/05/windows-azure-tables-introducing-json.aspx) 및 [테이블 서비스 작업에 대 한 페이로드 형식](http://msdn.microsoft.com/library/azure/dn535600.aspx)합니다.</span><span class="sxs-lookup"><span data-stu-id="70433-506">For more information, see hello post [Microsoft Azure Tables: Introducing JSON](http://blogs.msdn.com/b/windowsazurestorage/archive/2013/12/05/windows-azure-tables-introducing-json.aspx) and [Payload Format for Table Service Operations](http://msdn.microsoft.com/library/azure/dn535600.aspx).</span></span>

#### <span data-ttu-id="70433-507"><a name="subheading26"></a>Nagle 해제</span><span class="sxs-lookup"><span data-stu-id="70433-507"><a name="subheading26"></a>Nagle Off</span></span>
<span data-ttu-id="70433-508">Nagle 알고리즘은 널리 수단 tooimprove 네트워크 성능으로 TCP/IP 네트워크를 통해 구현 됩니다.</span><span class="sxs-lookup"><span data-stu-id="70433-508">Nagle's algorithm is widely implemented across TCP/IP networks as a means tooimprove network performance.</span></span> <span data-ttu-id="70433-509">그러나 대화형 작업을 많이 수행하는 환경 등 일부 상황에서는 이 알고리즘이 적합하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="70433-509">However, it is not optimal in all circumstances (such as highly interactive environments).</span></span> <span data-ttu-id="70433-510">Azure 저장소에 대 한 Nagle 알고리즘에는 요청 toohello 테이블 및 큐 서비스의 hello 성능에 부정적인 영향 및 가능한 경우 비활성화 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="70433-510">For Azure Storage, Nagle's algorithm has a negative impact on hello performance of requests toohello table and queue services, and you should disable it if possible.</span></span>  

<span data-ttu-id="70433-511">자세한 내용은 블로그 게시물을 참조 하십시오. [Nagle 알고리즘은 작은 요청으로 친숙 하지](http://blogs.msdn.com/b/windowsazurestorage/archive/2010/06/25/nagle-s-algorithm-is-not-friendly-towards-small-requests.aspx), Nagle 알고리즘 요청, 테이블 및 큐와 제대로 상호 작용 하 고 표시 이유를 설명 하 방법을 toodisable 클라이언트에서 응용 프로그램입니다.</span><span class="sxs-lookup"><span data-stu-id="70433-511">For more information, see our blog post [Nagle's Algorithm is Not Friendly towards Small Requests](http://blogs.msdn.com/b/windowsazurestorage/archive/2010/06/25/nagle-s-algorithm-is-not-friendly-towards-small-requests.aspx), which explains why Nagle's algorithm interacts poorly with table and queue requests, and shows how toodisable it in your client application.</span></span>  

### <a name="schema"></a><span data-ttu-id="70433-512">스키마</span><span class="sxs-lookup"><span data-stu-id="70433-512">Schema</span></span>
<span data-ttu-id="70433-513">나타내고 데이터를 쿼리는 hello 가장 큰 단일 요소 hello 테이블 서비스의 hello 성능에 영향을 주는입니다.</span><span class="sxs-lookup"><span data-stu-id="70433-513">How you represent and query your data is hello biggest single factor that affects hello performance of hello table service.</span></span> <span data-ttu-id="70433-514">각 응용 프로그램별로 다르기는 하지만 이 섹션에서는 다음 항목과 관련된 일반적인 검증된 작업 방식 중 몇 가지에 대해 간략하게 설명합니다.</span><span class="sxs-lookup"><span data-stu-id="70433-514">While every application is different, this section outlines some general proven practices that relate to:</span></span>  

* <span data-ttu-id="70433-515">테이블 디자인</span><span class="sxs-lookup"><span data-stu-id="70433-515">Table design</span></span>
* <span data-ttu-id="70433-516">효율적인 쿼리</span><span class="sxs-lookup"><span data-stu-id="70433-516">Efficient queries</span></span>
* <span data-ttu-id="70433-517">효율적인 데이터 업데이트</span><span class="sxs-lookup"><span data-stu-id="70433-517">Efficient data updates</span></span>  

#### <span data-ttu-id="70433-518"><a name="subheading27"></a>테이블 및 파티션</span><span class="sxs-lookup"><span data-stu-id="70433-518"><a name="subheading27"></a>Tables and partitions</span></span>
<span data-ttu-id="70433-519">테이블은 파티션으로 구분됩니다.</span><span class="sxs-lookup"><span data-stu-id="70433-519">Tables are divided into partitions.</span></span> <span data-ttu-id="70433-520">저장 된 모든 엔터티를 파티션으로 공유 hello 동일한 파티션 키 및 고유한 행 키 tooidentify에 해당 파티션 내에서.</span><span class="sxs-lookup"><span data-stu-id="70433-520">Every entity stored in a partition shares hello same partition key and has a unique row key tooidentify it within that partition.</span></span> <span data-ttu-id="70433-521">파티션을 사용하는 경우에는 이점도 있지만 확장성 제한도 적용됩니다.</span><span class="sxs-lookup"><span data-stu-id="70433-521">Partitions provide benefits but also introduce scalability limits.</span></span>  

* <span data-ttu-id="70433-522">이점: hello too100 별도 저장소 작업 (총 크기가 4MB 제한)을 포함 하는 단일 원자성 일괄 처리 트랜잭션은 동일한 파티션에의 엔터티를 업데이트할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="70433-522">Benefits: You can update entities in hello same partition in a single, atomic, batch transaction that contains up too100 separate storage operations (limit of 4MB total size).</span></span> <span data-ttu-id="70433-523">동일한 수 hello 가정 엔터티 toobe 검색의 쿼리할 수도 있습니다는 단일 파티션 내에서 데이터 파티션을 (하지만 읽기에서 추가 테이블 데이터 쿼리에 대 한 권장 사항은)에 걸쳐 있는 데이터 보다 더 효율적으로 합니다.</span><span class="sxs-lookup"><span data-stu-id="70433-523">Assuming hello same number of entities toobe retrieved, you can also query data within a single partition more efficiently than data that spans partitions (though read on for further recommendations on querying table data).</span></span>
* <span data-ttu-id="70433-524">확장성 한계: 단일 파티션에 저장 된 액세스 tooentities 없습니다 수 부하 분산 된 파티션을 원자성 일괄 처리 트랜잭션을 지원 합니다.</span><span class="sxs-lookup"><span data-stu-id="70433-524">Scalability limit: Access tooentities stored in a single partition cannot be load-balanced because partitions support atomic batch transactions.</span></span> <span data-ttu-id="70433-525">이러한 이유로 개별 테이블 파티션에 대 한 hello 확장성 목표 보다 낮습니다 hello 테이블 서비스에 대 한 전체.</span><span class="sxs-lookup"><span data-stu-id="70433-525">For this reason, hello scalability target for an individual table partition is lower than for hello table service as a whole.</span></span>  

<span data-ttu-id="70433-526">테이블 및 파티션에의 이러한 특성으로 인해 디자인 원칙을 따르는 hello를 채택 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="70433-526">Because of these characteristics of tables and partitions, you should adopt hello following design principles:</span></span>  

* <span data-ttu-id="70433-527">자주 업데이트 / 쿼리 작업의 동일한 논리 단위에 배치 해야 하는 hello 클라이언트 응용 프로그램 데이터를 동일한 파티션에 hello 합니다.</span><span class="sxs-lookup"><span data-stu-id="70433-527">Data that your client application frequently updated or queried in hello same logical unit of work should be located in hello same partition.</span></span>  <span data-ttu-id="70433-528">응용 프로그램 쓰기를 집계 하기 때문에 또는 원자성 일괄 처리 작업이 tootake 활용 하려고 하기 때문에 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="70433-528">This may be because your application is aggregating writes, or because you want tootake advantage of atomic batch operations.</span></span>  <span data-ttu-id="70433-529">또한 단일 쿼리에서는 여러 파티션에 분산된 데이터보다 단일 파티션의 데이터를 더 효율적으로 쿼리할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="70433-529">Also, data in a single partition can be more efficiently queried in a single query than data across partitions.</span></span>
* <span data-ttu-id="70433-530">클라이언트 응용 프로그램 또는 하지 않는 삽입/업데이트 작업 (예: 단일 쿼리 또는 일괄 처리 업데이트)의 동일한 논리 단위에 배치 해야 하는 hello에 쿼리 데이터를 별도 디스크입니다.</span><span class="sxs-lookup"><span data-stu-id="70433-530">Data that your client application does not insert/update or query in hello same logical unit of work (single query or batch update) should be located in separate partitions.</span></span>  <span data-ttu-id="70433-531">중요 한 정보 하므로 문제가 되지 않습니다 하 고 성능 영향을 주지 않을 파티션 키의 있는 단일 테이블의 파티션 키 수 없는 제한 toohello 된다는 점입니다.</span><span class="sxs-lookup"><span data-stu-id="70433-531">One important note is that there is no limit toohello number of partition keys in a single table, so having millions of partition keys is not a problem and will not impact performance.</span></span>  <span data-ttu-id="70433-532">예를 들어 사용자 로그인을 사용 하는 인기 있는 웹 사이트 응용 프로그램을 사용 하는 경우 hello 사용자 Id를 사용 하 여 hello 파티션 키로 적합 한 선택 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="70433-532">For example, if your application is a popular website with user login, using hello User Id as hello partition key could be a good choice.</span></span>  

#### <a name="hot-partitions"></a><span data-ttu-id="70433-533">핫 파티션</span><span class="sxs-lookup"><span data-stu-id="70433-533">Hot Partitions</span></span>
<span data-ttu-id="70433-534">핫 파티션 하나 hello 트래픽 tooan 계정의 불균형 비율을 수신 하는 이며 없습니다 부하 분산 될 단일 파티션이 있기 때문에 있습니다.</span><span class="sxs-lookup"><span data-stu-id="70433-534">A hot partition is one that is receiving a disproportionate percentage of hello traffic tooan account, and cannot be load balanced because it is a single partition.</span></span>  <span data-ttu-id="70433-535">일반적으로는 다음의 두 가지 방식 중 하나로 핫 파티션을 만듭니다.</span><span class="sxs-lookup"><span data-stu-id="70433-535">In general, hot partitions are created one of two ways:</span></span>  

##### <span data-ttu-id="70433-536"><a name="subheading28"></a>추가 전용 및 앞에 추가 전용 패턴</span><span class="sxs-lookup"><span data-stu-id="70433-536"><a name="subheading28"></a>Append Only and Prepend Only patterns</span></span>
<span data-ttu-id="70433-537">hello "추가" 패턴은 모든 (또는 거의 모든) hello 트래픽 tooa의 PK 제공 증가 하 고 현재 시간에 따라 toohello 감소 위치입니다.</span><span class="sxs-lookup"><span data-stu-id="70433-537">hello "Append Only" pattern is one where all (or nearly all) of hello traffic tooa given PK increases and decreases according toohello current time.</span></span>  <span data-ttu-id="70433-538">예로 경우 응용 프로그램으로 사용 하는 hello 현재 날짜 로그 데이터에 대 한 파티션 키입니다.</span><span class="sxs-lookup"><span data-stu-id="70433-538">An example is if your application used hello current date as a partition key for log data.</span></span>  <span data-ttu-id="70433-539">이 인해 모든 테이블의 마지막 파티션의 toohello 라인으로 전환 하는 hello 삽입 및 hello 쓰기 모두에 테이블의 지속적인 toohello 끝 hello 시스템 균형을 로드할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="70433-539">This results in all of hello inserts going toohello last partition in your table, and hello system cannot load balance because all of hello writes are going toohello end of your table.</span></span>  <span data-ttu-id="70433-540">트래픽 toothat 파티션의 hello 볼륨 hello 파티션 수준 확장성 목표를 초과 하면 제한에서 발생 합니다.</span><span class="sxs-lookup"><span data-stu-id="70433-540">If hello volume of traffic toothat partition exceeds hello partition-level scalability target, then it will result in throttling.</span></span>  <span data-ttu-id="70433-541">것이 더 나은 tooensure 보내지는 트래픽을 toomultiple 파티션을 tooenable 부하 균형 hello 테이블을 통해 요청 합니다.</span><span class="sxs-lookup"><span data-stu-id="70433-541">It's better tooensure that traffic is sent toomultiple partitions, tooenable load balance hello requests across your table.</span></span>  

##### <span data-ttu-id="70433-542"><a name="subheading29"></a>트래픽이 많은 데이터</span><span class="sxs-lookup"><span data-stu-id="70433-542"><a name="subheading29"></a>High-Traffic Data</span></span>
<span data-ttu-id="70433-543">에서는 단일 파티션의 파티션 구성표 결과 방금가 있으면 다른 파티션에 보다 훨씬 더 많은 사용 되는 데이터도 표시 제한 해당 파티션의 단일 파티션에 대 한 확장성 목표 hello 가까워질수록 합니다.</span><span class="sxs-lookup"><span data-stu-id="70433-543">If your partitioning scheme results in a single partition that just has data that is far more used than other partitions, you may also see throttling as that partition approaches hello scalability target for a single partition.</span></span>  <span data-ttu-id="70433-544">것이 더 나은 toomake 있는지 없는 단일 파티션 구성표 결과 근접 hello 확장성 목표를 분할 합니다.</span><span class="sxs-lookup"><span data-stu-id="70433-544">It's better toomake sure that your partition scheme results in no single partition approaching hello scalability targets.</span></span>  

#### <a name="querying"></a><span data-ttu-id="70433-545">쿼리</span><span class="sxs-lookup"><span data-stu-id="70433-545">Querying</span></span>
<span data-ttu-id="70433-546">이 섹션에서는 hello 테이블 서비스를 쿼리 하기 위한 검증 된 사례를 설명 합니다.</span><span class="sxs-lookup"><span data-stu-id="70433-546">This section describes proven practices for querying hello table service.</span></span>  

##### <span data-ttu-id="70433-547"><a name="subheading30"></a>쿼리 범위</span><span class="sxs-lookup"><span data-stu-id="70433-547"><a name="subheading30"></a>Query Scope</span></span>
<span data-ttu-id="70433-548">여러 가지 방법으로 toospecify hello 다양 한 엔터티 tooquery 가지가 있습니다.</span><span class="sxs-lookup"><span data-stu-id="70433-548">There are several ways toospecify hello range of entities tooquery.</span></span>  <span data-ttu-id="70433-549">hello 다음은 각각의 hello 사용에 대 한 내용은입니다.</span><span class="sxs-lookup"><span data-stu-id="70433-549">hello following is a discussion of hello uses of each.</span></span>  

<span data-ttu-id="70433-550">일반적으로 (단일 엔터티 보다 큰 쿼리) 검사를 방지할 하지만 검색 해야 하는 경우 시도 tooorganize 데이터는 사용자 검색 hello 필요한 데이터를 검색 하거나 상당한 양의 않아도 엔터티를 반환 하지 않고 검색 하도록 합니다.</span><span class="sxs-lookup"><span data-stu-id="70433-550">In general, avoid scans (queries larger than a single entity), but if you must scan, try tooorganize your data so that your scans retrieve hello data you need without scanning or returning significant amounts of entities you don't need.</span></span>  

###### <a name="point-queries"></a><span data-ttu-id="70433-551">지점 쿼리</span><span class="sxs-lookup"><span data-stu-id="70433-551">Point Queries</span></span>
<span data-ttu-id="70433-552">지점 쿼리에서는 엔터티를 하나만 검색합니다.</span><span class="sxs-lookup"><span data-stu-id="70433-552">A point query retrieves exactly one entity.</span></span> <span data-ttu-id="70433-553">Hello 파티션 키와 행 키의 hello 엔터티 tooretrieve 지정 하 여 수행 합니다.</span><span class="sxs-lookup"><span data-stu-id="70433-553">It does this by specifying both hello partition key and row key of hello entity tooretrieve.</span></span> <span data-ttu-id="70433-554">이러한 쿼리는 매우 효율적이므로 가능한 경우 항상 사용해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="70433-554">These queries are very efficient, and you should use them wherever possible.</span></span>  

###### <a name="partition-queries"></a><span data-ttu-id="70433-555">파티션 쿼리</span><span class="sxs-lookup"><span data-stu-id="70433-555">Partition Queries</span></span>
<span data-ttu-id="70433-556">파티션 쿼리는 공통 파티션 키를 공유하는 데이터 집합을 검색하는 쿼리입니다.</span><span class="sxs-lookup"><span data-stu-id="70433-556">A partition query is a query that retrieves a set of data that shares a common partition key.</span></span> <span data-ttu-id="70433-557">일반적으로 hello 쿼리는 또한 tooa 파티션 키에 행 키 값의 범위 또는 일부 엔터티 속성의 값 범위를 지정합니다.</span><span class="sxs-lookup"><span data-stu-id="70433-557">Typically, hello query specifies a range of row key values or a range of values for some entity property in addition tooa partition key.</span></span> <span data-ttu-id="70433-558">파티션 쿼리는 지점 쿼리보다 효율성이 낮으므로 꼭 필요할 때만 사용해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="70433-558">These are less efficient than point queries, and should be used sparingly.</span></span>  

###### <a name="table-queries"></a><span data-ttu-id="70433-559">테이블 쿼리</span><span class="sxs-lookup"><span data-stu-id="70433-559">Table Queries</span></span>
<span data-ttu-id="70433-560">테이블 쿼리는 공통 파티션 키를 공유하지 않는 엔터티 집합을 검색하는 쿼리입니다.</span><span class="sxs-lookup"><span data-stu-id="70433-560">A table query is a query that retrieves a set of entities that does not share a common partition key.</span></span> <span data-ttu-id="70433-561">이러한 쿼리는 효율적이지 않으므로 가능하면 사용하지 않아야 합니다.</span><span class="sxs-lookup"><span data-stu-id="70433-561">These queries are not efficient and you should avoid them if possible.</span></span>  

##### <span data-ttu-id="70433-562"><a name="subheading31"></a>쿼리 밀도</span><span class="sxs-lookup"><span data-stu-id="70433-562"><a name="subheading31"></a>Query Density</span></span>
<span data-ttu-id="70433-563">쿼리 효율에 또 다른 핵심 요소는 hello 비교 toohello 스캔 한 toofind hello 설정 반환 되는 엔터티 수로 반환 되는 엔터티 수입니다.</span><span class="sxs-lookup"><span data-stu-id="70433-563">Another key factor in query efficiency is hello number of entities returned as compared toohello number of entities scanned toofind hello returned set.</span></span> <span data-ttu-id="70433-564">응용 프로그램 1의 %만 hello 데이터 공유를 hello 쿼리는 검색는 100 개의 엔터티가 반환 마다 하나의 엔터티에 대 한 속성 값에 대 한 필터와 함께 테이블에 대 한 쿼리를 수행 합니다.</span><span class="sxs-lookup"><span data-stu-id="70433-564">If your application performs a table query with a filter for a property value that only 1% of hello data shares, hello query will scan 100 entities for every one entity it returns.</span></span> <span data-ttu-id="70433-565">hello 설명 하는 테이블 확장성 목표 이전에 모두 검색 하는 엔터티의 toohello 수 및 관련 반환 된 엔터티 수를 hello 하지: 낮은 쿼리 밀도 쉽게 될 수 있습니다 hello 테이블 서비스 toothrottle 응용 프로그램 너무 많은 스캔 해야 하기 때문에 원하는 엔터티 tooretrieve hello 엔터티.</span><span class="sxs-lookup"><span data-stu-id="70433-565">hello table scalability targets discussed previously all relate toohello number of entities scanned, and not hello number of entities returned: a low query density can easily cause hello table service toothrottle your application because it must scan so many entities tooretrieve hello entity you are looking for.</span></span>  <span data-ttu-id="70433-566">아래의 hello 섹션을 참조에 [비 정규화](#subheading34) 방법에 대 한 자세한 내용은 tooavoid이 있습니다.</span><span class="sxs-lookup"><span data-stu-id="70433-566">See hello section below on [denormalization](#subheading34) for more information on how tooavoid this.</span></span>  

##### <a name="limiting-hello-amount-of-data-returned"></a><span data-ttu-id="70433-567">크기의 데이터를 반환 하는 hello 제한</span><span class="sxs-lookup"><span data-stu-id="70433-567">Limiting hello Amount of Data Returned</span></span>
###### <span data-ttu-id="70433-568"><a name="subheading32"></a>필터링</span><span class="sxs-lookup"><span data-stu-id="70433-568"><a name="subheading32"></a>Filtering</span></span>
<span data-ttu-id="70433-569">쿼리 hello 클라이언트 응용 프로그램에서 필요 없는 엔터티를 반환 합니다 있는지 알고 hello 반환 되는 집합의 필터 tooreduce hello 크기를 사용 하는 것이 좋습니다.</span><span class="sxs-lookup"><span data-stu-id="70433-569">Where you know that a query will return entities that you don't need in hello client application, consider using a filter tooreduce hello size of hello returned set.</span></span> <span data-ttu-id="70433-570">Hello 엔터티 반환 되지 않습니다. toohello 클라이언트 hello 확장성 제한에 여전히 포함, 응용 프로그램 성능을 감소 hello 네트워크 페이로드 크기 때문에 향상 되며 클라이언트 응용 프로그램에서 처리 해야 하는 엔터티 수를 줄여 hello .</span><span class="sxs-lookup"><span data-stu-id="70433-570">While hello entities not returned toohello client still count toward hello scalability limits, your application performance will improve because of hello reduced network payload size and hello reduced number of entities that your client application must process.</span></span>  <span data-ttu-id="70433-571">그러나에 참고 위의 참조 [쿼리 밀도](#subheading31), 많은 엔터티를 필터링 하는 쿼리 수 제한 발생할 수, 몇 개의 엔터티가 반환 된 경우에 있으므로 hello 확장성 목표 검색, 엔터티의 toohello 수 관련 – 합니다.</span><span class="sxs-lookup"><span data-stu-id="70433-571">See above note on [Query Density](#subheading31), however – hello scalability targets relate toohello number of entities scanned, so a query that filters out many entities may still result in throttling, even if few entities are returned.</span></span>  

###### <span data-ttu-id="70433-572"><a name="subheading33"></a>프로젝션</span><span class="sxs-lookup"><span data-stu-id="70433-572"><a name="subheading33"></a>Projection</span></span>
<span data-ttu-id="70433-573">클라이언트 응용 프로그램이 제한 된 집합의 테이블에 대 한 hello 엔터티에서 속성을 필요한 경우 데이터 집합을 반환 하는 hello의 프로젝션 toolimit hello 크기를 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="70433-573">If your client application needs only a limited set of properties from hello entities in your table, you can use projection toolimit hello size of hello returned data set.</span></span> <span data-ttu-id="70433-574">필터링와 마찬가지로 이렇게 하면 tooreduce 네트워크 로드 하 고 클라이언트 처리 합니다.</span><span class="sxs-lookup"><span data-stu-id="70433-574">As with filtering, this helps tooreduce network load and client processing.</span></span>  

##### <span data-ttu-id="70433-575"><a name="subheading34"></a>비정규화</span><span class="sxs-lookup"><span data-stu-id="70433-575"><a name="subheading34"></a>Denormalization</span></span>
<span data-ttu-id="70433-576">관계형 데이터베이스를 사용 하는 달리 hello 검증 된 사례 테이블 데이터를 효율적으로 쿼리 하기 위한 될 toodenormalizing 데이터.</span><span class="sxs-lookup"><span data-stu-id="70433-576">Unlike working with relational databases, hello proven practices for efficiently querying table data lead toodenormalizing your data.</span></span> <span data-ttu-id="70433-577">즉, 여러 엔터티에 동일한 데이터를 복제 hello (하나 각 키에 대 한 toofind hello 데이터를 사용할 수 있습니다) toominimize hello toofind hello 데이터 hello 클라이언트 요구 대신 tooscan 수가 많은 엔터티 toofind 쿼리 검사 해야 하는 엔터티 수 hello 데이터 응용 프로그램에 필요 합니다.</span><span class="sxs-lookup"><span data-stu-id="70433-577">That is, duplicating hello same data in multiple entities (one for each key you may use toofind hello data) toominimize hello number of entities that a query must scan toofind hello data hello client needs, rather than having tooscan large numbers of entities toofind hello data your application needs.</span></span>  <span data-ttu-id="70433-578">예를 들어 전자 상거래 웹 사이트에서 좋습니다 toofind 한 정렬을 모두 hello 고객 ID (이 고객의이 주문이 제공)으로 hello 날짜 (제공 주문 날짜에).</span><span class="sxs-lookup"><span data-stu-id="70433-578">For example, in an e-commerce website, you may want toofind an order both by hello customer ID (give me this customer's orders) and by hello date (give me orders on a date).</span></span>  <span data-ttu-id="70433-579">테이블 저장소는 편이 최상의 toostore hello 엔터티 (또는 참조 tooit) 두 번 – 테이블 이름, PK 및 RK toofacilitate 찾기 hello 날짜 여 찾기 toofacilitate 한 번 고객 ID 기준으로 합니다.</span><span class="sxs-lookup"><span data-stu-id="70433-579">In Table Storage, it is best toostore hello entity (or a reference tooit) twice – once with Table Name, PK, and RK toofacilitate finding by customer ID, once toofacilitate finding it by hello date.</span></span>  

#### <a name="insertupdatedelete"></a><span data-ttu-id="70433-580">삽입/업데이트/삭제</span><span class="sxs-lookup"><span data-stu-id="70433-580">Insert/Update/Delete</span></span>
<span data-ttu-id="70433-581">이 섹션에서는 hello 테이블 서비스에 저장 된 엔터티를 수정 하기 위한 검증 된 사례를 설명 합니다.</span><span class="sxs-lookup"><span data-stu-id="70433-581">This section describes proven practices for modifying entities stored in hello table service.</span></span>  

##### <span data-ttu-id="70433-582"><a name="subheading35"></a>일괄 처리</span><span class="sxs-lookup"><span data-stu-id="70433-582"><a name="subheading35"></a>Batching</span></span>
<span data-ttu-id="70433-583">일괄 처리 트랜잭션은으로 엔터티 그룹 트랜잭션 (ETG) Azure 저장소;에 라고 합니다. 단일 테이블에서 단일 파티션에 ETG 내의 모든 hello 작업 이어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="70433-583">Batch transactions are known as Entity Group Transactions (ETG) in Azure Storage; all hello operations within an ETG must be on a single partition in a single table.</span></span> <span data-ttu-id="70433-584">가능한 경우, 일괄 처리로 ETGs tooperform 삽입, 업데이트 및 삭제를 사용 합니다.</span><span class="sxs-lookup"><span data-stu-id="70433-584">Where possible, use ETGs tooperform inserts, updates, and deletes in batches.</span></span> <span data-ttu-id="70433-585">이 클라이언트 응용 프로그램 toohello 서버에서 hello 라운드트립 횟수를 감소, hello 청구 가능 트랜잭션 수 (ETG는 청구 용 단일 트랜잭션으로 계산 하며 too100 저장소 작업을 포함할 수 있습니다.), 줄어들고 원자성을 사용 하도록 설정 (모든 작업이 성공 또는 실패는 ETG 내에서 모든)를 업데이트 합니다.</span><span class="sxs-lookup"><span data-stu-id="70433-585">This reduces hello number of round trips from your client application toohello server, reduces hello number of billable transactions (an ETG counts as a single transaction for billing purposes and can contain up too100 storage operations), and enables atomic updates (all operations succeed or all fail within an ETG).</span></span> <span data-ttu-id="70433-586">모바일 장치와 같이 대기 시간이 긴 환경에서는 ETG를 사용하면 매우 효율적입니다.</span><span class="sxs-lookup"><span data-stu-id="70433-586">Environments with high latencies such as mobile devices will benefit greatly from using ETGs.</span></span>  

##### <span data-ttu-id="70433-587"><a name="subheading36"></a>Upsert</span><span class="sxs-lookup"><span data-stu-id="70433-587"><a name="subheading36"></a>Upsert</span></span>
<span data-ttu-id="70433-588">가능한 경우에는 항상 테이블 **Upsert** 작업을 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="70433-588">Use table **Upsert** operations wherever possible.</span></span> <span data-ttu-id="70433-589">**Upsert**에는 두 가지 형식이 있으며, 두 형식 모두 기존의 **Insert** 및 **Update** 작업보다는 비효율적일 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="70433-589">There are two types of **Upsert**, both of which can be more efficient than a traditional **Insert** and **Update** operations:</span></span>  

* <span data-ttu-id="70433-590">**InsertOrMerge**: tooupload hello 엔터티 속성의 하위 집합을 원하는 경우에 사용 되지만 확실 하지 않은 hello 엔터티 이미 존재 하는지 여부입니다.</span><span class="sxs-lookup"><span data-stu-id="70433-590">**InsertOrMerge**: Use this when you want tooupload a subset of hello entity's properties, but aren't sure whether hello entity already exists.</span></span> <span data-ttu-id="70433-591">이 호출은 hello에 포함 된 hello 속성 hello 엔터티가 존재 하는 경우 업데이트 **Upsert** 작업, 및는 대로 모든 기존 속성을 유지, 엔터티가 없는 경우 hello, hello 새 엔터티를 삽입 합니다.</span><span class="sxs-lookup"><span data-stu-id="70433-591">If hello entity exists, this call updates hello properties included in hello **Upsert** operation, and leaves all existing properties as they are, if hello entity does not exist, it inserts hello new entity.</span></span> <span data-ttu-id="70433-592">쿼리에서 비슷한 toousing 프로젝션 tooupload hello 속성을 변경 하는 해야 한다는 점에서입니다.</span><span class="sxs-lookup"><span data-stu-id="70433-592">This is similar toousing projection in a query, in that you only need tooupload hello properties that are changing.</span></span>
* <span data-ttu-id="70433-593">**InsertOrReplace**: tooupload 완전히 새로운 엔터티의 싶지만 확실 하지 않은 이미 존재 하는지 여부는 경우에 사용 합니다.</span><span class="sxs-lookup"><span data-stu-id="70433-593">**InsertOrReplace**: Use this when you want tooupload an entirely new entity, but you aren't sure whether it already exists.</span></span> <span data-ttu-id="70433-594">이 설정을 사용 해야 hello 이전 엔터티를 완전히 덮어쓰기 때문에 완전히 올바른지 알고 있을 때 해당 hello 엔터티를 새로 업로드 합니다.</span><span class="sxs-lookup"><span data-stu-id="70433-594">You should only use this when you know that hello newly uploaded entity is entirely correct because it completely overwrites hello old entity.</span></span> <span data-ttu-id="70433-595">예를 들어 tooupdate hello 엔터티 hello 응용 프로그램 hello 사용자;에 대 한 위치 데이터에 이전에 저장 하는 여부에 관계 없이 사용자의 현재 위치를 저장 하 시겠습니까 새 위치 엔터티 hello 완료 되며 이전 엔터티만의 모든 정보를 필요가 없습니다.</span><span class="sxs-lookup"><span data-stu-id="70433-595">For example, you want tooupdate hello entity that stores a user's current location regardless of whether or not hello application has previously stored location data for hello user; hello new location entity is complete, and you do not need any information from any previous entity.</span></span>

##### <span data-ttu-id="70433-596"><a name="subheading37"></a>단일 엔터티에 데이터 계열 저장</span><span class="sxs-lookup"><span data-stu-id="70433-596"><a name="subheading37"></a>Storing Data Series in a Single Entity</span></span>
<span data-ttu-id="70433-597">응용 프로그램에서 일련의 필요 하다 고 판단 자주 tooretrieve 한 번에 데이터를 저장 하는 경우에 따라: 예를 들어 응용 프로그램 추적 CPU 사용량 순서 tooplot hello 데이터의 롤링 차트에에서는 시간이 지남에 따라 hello에서 지난 24 시간입니다.</span><span class="sxs-lookup"><span data-stu-id="70433-597">Sometimes, an application stores a series of data that it frequently needs tooretrieve all at once: for example, an application might track CPU usage over time in order tooplot a rolling chart of hello data from hello last 24 hours.</span></span> <span data-ttu-id="70433-598">한 가지 방법은 toohave 한 테이블 엔터티 시간당 각 엔터티는 특정 시간을 나타내고 해당 시간에 대 한 hello CPU 사용량을 저장 합니다.</span><span class="sxs-lookup"><span data-stu-id="70433-598">One approach is toohave one table entity per hour, with each entity representing a specific hour and storing hello CPU usage for that hour.</span></span> <span data-ttu-id="70433-599">tooplot hello 응용 프로그램이 데이터를 tooretrieve hello 엔터티 가장 최근 24 시간 동안 hello에서 hello 데이터를 보유 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="70433-599">tooplot this data, hello application needs tooretrieve hello entities holding hello data from hello 24 most recent hours.</span></span>  

<span data-ttu-id="70433-600">응용 프로그램의 단일 엔터티 별도 속성으로 각 시간에 대 한 hello CPU 사용량을 저장할 수 있습니다 또는: tooupdate 매시간 응용 프로그램 צ ְ ײ 단일 **InsertOrMerge Upsert** tooupdate hello 값 hello에 대 한 호출 가장 최근 시간입니다.</span><span class="sxs-lookup"><span data-stu-id="70433-600">Alternatively, your application could store hello CPU usage for each hour as a separate property of a single entity: tooupdate each hour, your application can use a single **InsertOrMerge Upsert** call tooupdate hello value for hello most recent hour.</span></span> <span data-ttu-id="70433-601">tooplot hello 데이터 hello 응용 프로그램 하기만 tooretrieve 24, 매우 효율적인 쿼리를 만드는 대신 단일 엔터티 (에 토론 위의 참조 [쿼리 범위](#subheading30)).</span><span class="sxs-lookup"><span data-stu-id="70433-601">tooplot hello data, hello application only needs tooretrieve a single entity instead of 24, making for a very efficient query (see above discussion on [query scope](#subheading30)).</span></span>

##### <span data-ttu-id="70433-602"><a name="subheading38"></a>Blob에 구조적 데이터 저장</span><span class="sxs-lookup"><span data-stu-id="70433-602"><a name="subheading38"></a>Storing structured data in blobs</span></span>
<span data-ttu-id="70433-603">구조적 데이터를 테이블에 저장해야 하는 경우도 있지만 엔터티 범위는 항상 함께 검색되며 일괄로 삽입할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="70433-603">Sometimes structured data feels like it should go in tables, but ranges of entities are always retrieved together and can be batch inserted.</span></span>  <span data-ttu-id="70433-604">이와 관련한 좋은 예가 로그 파일입니다.</span><span class="sxs-lookup"><span data-stu-id="70433-604">A good example of this is a log file.</span></span>  <span data-ttu-id="70433-605">몇 분 동안의 로그를 일괄로 생성하여 삽입할 수 있으며 항상 몇 분 동안의 로그를 한 번에 검색할 수도 있습니다.</span><span class="sxs-lookup"><span data-stu-id="70433-605">In this case, you can batch several minutes of logs, insert them, and then you are always retrieving several minutes of logs at a time as well.</span></span>  <span data-ttu-id="70433-606">이 경우 성능을 위해 것 이므로 더 나은 toouse blob, 테이블 대신 있습니다 수 hello 많은 개체 작성/반환을 크게 줄일 뿐만 아니라 일반적으로 수행 해야 하는 요청 수를 hello입니다.</span><span class="sxs-lookup"><span data-stu-id="70433-606">In this case, for performance, it's better toouse blobs instead of tables, since you can significantly reduce hello number of objects written/returned, as well as usually hello number of requests that need made.</span></span>  

## <a name="queues"></a><span data-ttu-id="70433-607">큐</span><span class="sxs-lookup"><span data-stu-id="70433-607">Queues</span></span>
<span data-ttu-id="70433-608">에 대 한 사례를 입증 된 더하기 toohello에서 [모든 서비스](#allservices) 앞에서 설명한 검증 된 사용법 hello 다음 특히 toohello 큐 서비스를 적용 합니다.</span><span class="sxs-lookup"><span data-stu-id="70433-608">In addition toohello proven practices for [All Services](#allservices) described previously, hello following proven practices apply specifically toohello queue service.</span></span>  

### <span data-ttu-id="70433-609"><a name="subheading39"></a>확장성 제한</span><span class="sxs-lookup"><span data-stu-id="70433-609"><a name="subheading39"></a>Scalability Limits</span></span>
<span data-ttu-id="70433-610">단일 큐는 초당 약 2,000개의 메시지(각각 1KB)를 처리할 수 있습니다(여기서는 각 AddMessage, GetMessage 및 DeleteMessage를 메시지로 계산).</span><span class="sxs-lookup"><span data-stu-id="70433-610">A single queue can process approximately 2,000 messages (1KB each) per second (each AddMessage, GetMessage, and DeleteMessage count as a message here).</span></span> <span data-ttu-id="70433-611">응용 프로그램에 대해 충분 하지 않으면에 여러 큐를 사용 하 고 hello 메시지에 이러한 분산 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="70433-611">If this is insufficient for your application, you should use multiple queues and spread hello messages across them.</span></span>  

<span data-ttu-id="70433-612">[Azure 저장소 확장성 및 성능 목표](storage-scalability-targets.md)에서 현재 확장성 목표를 봅니다.</span><span class="sxs-lookup"><span data-stu-id="70433-612">View current scalability targets at [Azure Storage Scalability and Performance Targets](storage-scalability-targets.md).</span></span>  

### <span data-ttu-id="70433-613"><a name="subheading40"></a>Nagle 해제</span><span class="sxs-lookup"><span data-stu-id="70433-613"><a name="subheading40"></a>Nagle Off</span></span>
<span data-ttu-id="70433-614">테이블 구성 hello Nagle 알고리즘을 설명 하는 hello 섹션을 참조 하십시오.-hello Nagle 알고리즘은 일반적으로 큐 요청의 hello 성능에 부정적 하 고 사용 하지 않도록 설정 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="70433-614">See hello section on table configuration that discusses hello Nagle algorithm — hello Nagle algorithm is generally bad for hello performance of queue requests, and you should disable it.</span></span>  

### <span data-ttu-id="70433-615"><a name="subheading41"></a>메시지 크기</span><span class="sxs-lookup"><span data-stu-id="70433-615"><a name="subheading41"></a>Message Size</span></span>
<span data-ttu-id="70433-616">메시지 크기가 증가함에 따라 큐 성능 및 확장성은 감소합니다.</span><span class="sxs-lookup"><span data-stu-id="70433-616">Queue performance and scalability decreases as message size increases.</span></span> <span data-ttu-id="70433-617">메시지에만 hello hello 수신기 필요한 정보를 배치 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="70433-617">You should place only hello information hello receiver needs in a message.</span></span>  

### <span data-ttu-id="70433-618"><a name="subheading42"></a>일괄 검색</span><span class="sxs-lookup"><span data-stu-id="70433-618"><a name="subheading42"></a>Batch Retrieval</span></span>
<span data-ttu-id="70433-619">한 번에 큐에서 too32 메시지를 검색할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="70433-619">You can retrieve up too32 messages from a queue in a single operation.</span></span> <span data-ttu-id="70433-620">모바일 장치 등의 환경에 특히 유용한 hello 클라이언트 응용 프로그램에서 대기 시간이 긴 hello 왕복 횟수를 줄일 수 있습니다이.</span><span class="sxs-lookup"><span data-stu-id="70433-620">This can reduce hello number of roundtrips from hello client application, which is especially useful for environments, such as mobile devices, with high latency.</span></span>  

### <span data-ttu-id="70433-621"><a name="subheading43"></a>큐 폴링 간격</span><span class="sxs-lookup"><span data-stu-id="70433-621"><a name="subheading43"></a>Queue Polling Interval</span></span>
<span data-ttu-id="70433-622">대부분의 응용 프로그램은 해당 응용 프로그램에 대 한 트랜잭션 hello 가장 큰 원인 중 하나일 수 있는 큐에서 메시지를 폴링합니다.</span><span class="sxs-lookup"><span data-stu-id="70433-622">Most applications poll for messages from a queue, which can be one of hello largest sources of transactions for that application.</span></span> <span data-ttu-id="70433-623">폴링 간격을 현명 하 게 선택: 너무 자주 폴링으로 인해 응용 프로그램 tooapproach hello 큐에 대 한 hello 확장성 목표입니다.</span><span class="sxs-lookup"><span data-stu-id="70433-623">Select your polling interval wisely: polling too frequently could cause your application tooapproach hello scalability targets for hello queue.</span></span> <span data-ttu-id="70433-624">그러나 (작성 hello 시점)에 $0.01에 대 한 200000 트랜잭션을에서 한 달에 대 한 초당 비용 보다 작거나 15 센트 않으므로 비용 면 폴링 단일 프로세서 아닌 경우 일반적으로 선택 하는 폴링 간격에 영향을 주는 요인</span><span class="sxs-lookup"><span data-stu-id="70433-624">However, at 200,000 transactions for $0.01 (at hello time of writing), a single processor polling once every second for a month would cost less than 15 cents so cost is not typically a factor that affects your choice of polling interval.</span></span>  

<span data-ttu-id="70433-625">최신 비용 정보는 [Azure Storage 가격 책정](https://azure.microsoft.com/pricing/details/storage/)을 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="70433-625">For up-to-date cost information, see [Azure Storage Pricing](https://azure.microsoft.com/pricing/details/storage/).</span></span>  

### <span data-ttu-id="70433-626"><a name="subheading44"></a>UpdateMessage</span><span class="sxs-lookup"><span data-stu-id="70433-626"><a name="subheading44"></a>UpdateMessage</span></span>
<span data-ttu-id="70433-627">사용할 수 있습니다 **UpdateMessage** tooincrease hello 표시 안 함 시간 제한 또는 tooupdate 상태 정보 메시지입니다.</span><span class="sxs-lookup"><span data-stu-id="70433-627">You can use **UpdateMessage** tooincrease hello invisibility timeout or tooupdate state information of a message.</span></span> <span data-ttu-id="70433-628">강력한 이지만, 각 기억 **UpdateMessage** 작업 hello 확장성 목표에 합산 됩니다.</span><span class="sxs-lookup"><span data-stu-id="70433-628">While this is powerful, remember that each **UpdateMessage** operation counts towards hello scalability target.</span></span> <span data-ttu-id="70433-629">그러나에서 전달 되는 작업 하나의 큐 toohello 다음으로 hello 작업의 각 단계를 완료 하는 대로 워크플로 사용 하는 보다 훨씬 더 효율적인 방법이 될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="70433-629">However, this can be a much more efficient approach than having a workflow that passes a job from one queue toohello next, as each step of hello job is completed.</span></span> <span data-ttu-id="70433-630">Hello를 사용 하 여 **UpdateMessage** 작업 응용 프로그램 toosave hello 작업 상태 toohello 메시지를 허용 하 고 서 hello hello 작업 단계를 완료 될 때마다의 다음 단계에 대 한 hello 메시지를 다시 큐 대신 작업을 계속 합니다.</span><span class="sxs-lookup"><span data-stu-id="70433-630">Using hello **UpdateMessage** operation allows your application toosave hello job state toohello message and then continue working, instead of re-queuing hello message for hello next step of hello job every time a step completes.</span></span>  

<span data-ttu-id="70433-631">자세한 내용은 hello 문서 참조 [하는 방법: 대기 중인된 메시지의 hello 내용을 변경](storage-dotnet-how-to-use-queues.md#change-the-contents-of-a-queued-message)합니다.</span><span class="sxs-lookup"><span data-stu-id="70433-631">For more information, see hello article [How to: Change hello contents of a queued message](storage-dotnet-how-to-use-queues.md#change-the-contents-of-a-queued-message).</span></span>  

### <span data-ttu-id="70433-632"><a name="subheading45"></a>응용 프로그램 아키텍처</span><span class="sxs-lookup"><span data-stu-id="70433-632"><a name="subheading45"></a>Application architecture</span></span>
<span data-ttu-id="70433-633">큐 toomake 확장 가능한 응용 프로그램 아키텍처를 사용 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="70433-633">You should use queues toomake your application architecture scalable.</span></span> <span data-ttu-id="70433-634">hello 다음에는 확장성이 뛰어난 응용 프로그램 큐 toomake를 사용할 수 있는 몇 가지 방법을 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="70433-634">hello following lists some ways you can use queues toomake your application more scalable:</span></span>  

* <span data-ttu-id="70433-635">처리에 대 한 작업의 toocreate 백로그 큐를 사용할 수 있으며 응용 프로그램에서 작업 부하를 매끄럽게 있습니다.</span><span class="sxs-lookup"><span data-stu-id="70433-635">You can use queues toocreate backlogs of work for processing and smooth out workloads in your application.</span></span> <span data-ttu-id="70433-636">예를 들어 사용자가 tooperform 프로세서 업로드 된 이미지 크기 조정 등 많은 작업에서 요청을 큐 대기 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="70433-636">For example, you could queue up requests from users tooperform processor intensive work such as resizing uploaded images.</span></span>
* <span data-ttu-id="70433-637">있습니다 수에 독립적으로 확장할 수 있도록 응용 프로그램의 큐 toodecouple 부분을 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="70433-637">You can use queues toodecouple parts of your application so that you can scale them independently.</span></span> <span data-ttu-id="70433-638">예를 들어 웹 프런트 엔드에서 나중에 분석 및 저장하기 위해 사용자의 설문 조사 결과를 큐에 저장할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="70433-638">For example, a web front-end could place survey results from users into a queue for later analysis and storage.</span></span> <span data-ttu-id="70433-639">더 많은 작업자 역할 인스턴스 tooprocess hello 필요에 따라 큐 데이터를 추가할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="70433-639">You could add more worker role instances tooprocess hello queue data as required.</span></span>  

## <a name="conclusion"></a><span data-ttu-id="70433-640">결론</span><span class="sxs-lookup"><span data-stu-id="70433-640">Conclusion</span></span>
<span data-ttu-id="70433-641">이 문서 검증 된 Azure 저장소를 사용 하는 경우 성능을 최적화 하기 위한 사용법을 가장 일반적인 hello 중 일부에 대해 설명 합니다.</span><span class="sxs-lookup"><span data-stu-id="70433-641">This article discussed some of hello most common, proven practices for optimizing performance when using Azure Storage.</span></span> <span data-ttu-id="70433-642">모든 응용 프로그램 개발자 tooassess 사례 위의 hello 각각에 대해 해당 응용 프로그램 들이 하 고 hello 권장 사항 tooget Azure 저장소를 사용 하는 응용 프로그램에 대 한 뛰어난 성능 작업을 수행 하십시오.</span><span class="sxs-lookup"><span data-stu-id="70433-642">We encourage every application developer tooassess their application against each of hello above practices and consider acting on hello recommendations tooget great performance for their applications that use Azure Storage.</span></span>
