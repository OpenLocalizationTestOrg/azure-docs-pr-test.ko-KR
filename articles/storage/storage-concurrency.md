---
title: "Microsoft Azure 저장소에서 동시성 관리"
description: "Blob, 큐, 테이블 및 파일 서비스의 동시성을 관리하는 방법에 대해 알아봅니다."
services: storage
documentationcenter: 
author: jasontang501
manager: tadb
editor: tysonn
ms.assetid: cc6429c4-23ee-46e3-b22d-50dd68bd4680
ms.service: storage
ms.workload: storage
ms.tgt_pltfrm: na
ms.devlang: dotnet
ms.topic: article
ms.date: 05/11/2017
ms.author: jasontang501
ms.openlocfilehash: 8b894af2f15cd22f04701c545d8250e20b99a094
ms.sourcegitcommit: f537befafb079256fba0529ee554c034d73f36b0
ms.translationtype: MT
ms.contentlocale: ko-KR
ms.lasthandoff: 07/11/2017
---
# <a name="managing-concurrency-in-microsoft-azure-storage"></a><span data-ttu-id="a15a3-103">Microsoft Azure 저장소에서 동시성 관리</span><span class="sxs-lookup"><span data-stu-id="a15a3-103">Managing Concurrency in Microsoft Azure Storage</span></span>
## <a name="overview"></a><span data-ttu-id="a15a3-104">개요</span><span class="sxs-lookup"><span data-stu-id="a15a3-104">Overview</span></span>
<span data-ttu-id="a15a3-105">최신 인터넷 기반 응용 프로그램에서는 대개 여러 사용자가 데이터를 동시에 보고 업데이트합니다.</span><span class="sxs-lookup"><span data-stu-id="a15a3-105">Modern Internet based applications usually have multiple users viewing and updating data simultaneously.</span></span> <span data-ttu-id="a15a3-106">이로 인해 응용 프로그램 개발자는 최종 사용자에게 예측 가능한 환경을 제공하는 방법, 특히 여러 사용자가 같은 데이터를 업데이트할 수 있는 시나리오를 신중하게 고려해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="a15a3-106">This requires application developers to think carefully about how to provide a predictable experience to their end users, particularly for scenarios where multiple users can update the same data.</span></span> <span data-ttu-id="a15a3-107">개발자가 일반적으로 고려하는 주요 데이터 동시성 전략에는 다음의 세 가지가 있습니다.</span><span class="sxs-lookup"><span data-stu-id="a15a3-107">There are three main data concurrency strategies developers will typically consider:</span></span>  

1. <span data-ttu-id="a15a3-108">낙관적 동시성 - 업데이트를 수행하는 응용 프로그램이 업데이트의 일환으로 응용 프로그램이 데이터를 마지막으로 읽은 이후 해당 데이터가 변경되었는지를 확인합니다.</span><span class="sxs-lookup"><span data-stu-id="a15a3-108">Optimistic concurrency – An application performing an update will as part of its update verify if the data has changed since the application last read that data.</span></span> <span data-ttu-id="a15a3-109">예를 들어 Wiki 페이지를 보는 두 사용자가 같은 페이지를 업데이트하면 Wiki 플랫폼은 두 번째 업데이트가 첫 번째 업데이트를 덮어쓰지 않도록 해야 하며, 두 사용자가 모두 자신의 업데이트가 정상적으로 적용되었는지를 파악할 수 있도록 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="a15a3-109">For example, if two users viewing a wiki page make an update to the same page then the wiki platform must ensure that the second update does not overwrite the first update – and that both users understand whether their update was successful or not.</span></span> <span data-ttu-id="a15a3-110">이 전략은 웹 응용 프로그램에서 가장 흔히 사용됩니다.</span><span class="sxs-lookup"><span data-stu-id="a15a3-110">This strategy is most often used in web applications.</span></span>
2. <span data-ttu-id="a15a3-111">비관적 동시성 - 업데이트를 수행하려는 응용 프로그램이 개체를 잠가서 다른 사용자가 잠금이 해제될 때까지 데이터를 업데이트하지 못하도록 합니다.</span><span class="sxs-lookup"><span data-stu-id="a15a3-111">Pessimistic concurrency – An application looking to perform an update will take a lock on an object preventing other users from updating the data until the lock is released.</span></span> <span data-ttu-id="a15a3-112">예를 들어 마스터만 업데이트를 수행하는 마스터/슬레이브 데이터 복제 시나리오에서는 다른 사람이 데이터를 업데이트할 수 없도록 대개 마스터가 데이터에 대해 장시간 배타적 잠금을 적용합니다.</span><span class="sxs-lookup"><span data-stu-id="a15a3-112">For example, in a master/slave data replication scenario where only the master will perform updates the master will typically hold an exclusive lock for an extended period of time on the data to ensure no one else can update it.</span></span>
3. <span data-ttu-id="a15a3-113">마지막 작성자의 업데이트 적용 - 응용 프로그램이 데이터를 처음 읽은 후 다른 응용 프로그램이 데이터를 업데이트했는지 여부를 확인하지 않고 모든 업데이트 작업을 진행하도록 허용하는 방식입니다.</span><span class="sxs-lookup"><span data-stu-id="a15a3-113">Last writer wins – An approach that allows any update operations to proceed without verifying if any other application has updated the data since the application first read the data.</span></span> <span data-ttu-id="a15a3-114">데이터가 분할되어 여러 사용자가 같은 데이터에 액세스할 가능성이 없을 때는 일반적으로 이 전략을 사용하거나 공식적인 전략을 사용하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="a15a3-114">This strategy (or lack of a formal strategy) is usually used where data is partitioned in such a way that there is no likelihood that multiple users will access the same data.</span></span> <span data-ttu-id="a15a3-115">일시적인 데이터 스트림을 처리하는 경우에도 이 전략이 유용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="a15a3-115">It can also be useful where short-lived data streams are being processed.</span></span>  

<span data-ttu-id="a15a3-116">이 문서에서는 Azure 저장소 플랫폼이 이와 같은 모든 세 가지 동시성 전략에 대해 가장 효율적인 지원을 제공함으로써 개발을 간소화하는 방식을 대략적으로 설명합니다.</span><span class="sxs-lookup"><span data-stu-id="a15a3-116">This article provides an overview of how the Azure Storage platform simplifies development by providing first class support for all three of these concurrency strategies.</span></span>  

## <a name="azure-storage--simplifies-cloud-development"></a><span data-ttu-id="a15a3-117">Azure 저장소 - 클라우드 개발 간소화</span><span class="sxs-lookup"><span data-stu-id="a15a3-117">Azure Storage – Simplifies Cloud Development</span></span>
<span data-ttu-id="a15a3-118">Azure 저장소 서비스는 세 가지 전략을 모두 지원하지만 특히 낙관적 동시성과 비관적 동시성을 완벽하게 지원할 수 있습니다. 저장소 서비스가 데이터 삽입 또는 업데이트 작업을 커밋하면 해당 데이터에 대한 모든 추가 액세스 시 최신 업데이트가 표시되도록 보장하는 강력한 동시성 모델을 사용하도록 디자인되었기 때문입니다.</span><span class="sxs-lookup"><span data-stu-id="a15a3-118">The Azure storage service supports all three strategies, although it is distinctive in its ability to provide full support for optimistic and pessimistic concurrency because it was designed to embrace a strong consistency model which guarantees that when the Storage service commits a data insert or update operation all further accesses to that data will see the latest update.</span></span> <span data-ttu-id="a15a3-119">결과적 일관성 모델을 사용하는 저장소 플랫폼에서는 특정 사용자가 쓰기를 수행하는 시점과 다른 사용자에게 업데이트된 데이터가 표시되는 시점 간에 지연 시간이 있으므로, 불일치 사항이 최종 사용자에게 영향을 주지 않도록 하기 위해 클라이언트 응용 프로그램 개발 과정이 복잡해집니다.</span><span class="sxs-lookup"><span data-stu-id="a15a3-119">Storage platforms that use an eventual consistency model have a lag between when a write is performed by one user and when the updated data can be seen by other users thus complicating development of client applications in order to prevent inconsistencies from affecting end users.</span></span>  

<span data-ttu-id="a15a3-120">개발자는 적절한 동시성 전략을 선택해야 할 뿐 아니라 저장소 플랫폼이 변경 내용, 특히 여러 트랜잭션 간의 같은 개체에 대한 변경 내용을 격리하는 방법도 파악해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="a15a3-120">In addition to selecting an appropriate concurrency strategy developers should also be aware of how a storage platform isolates changes – particularly changes to the same object across transactions.</span></span> <span data-ttu-id="a15a3-121">Azure 저장소 서비스는 스냅숏 격리를 사용하여 단일 파티션 내에서 읽기 작업과 쓰기 작업이 동시에 수행되도록 허용합니다.</span><span class="sxs-lookup"><span data-stu-id="a15a3-121">The Azure storage service uses snapshot isolation to allow read operations to happen concurrently with write operations within a single partition.</span></span> <span data-ttu-id="a15a3-122">다른 격리 수준과는 달리 스냅숏 격리에서는 업데이트가 수행되는 동안에도 모든 읽기 시 데이터의 일관된 스냅숏이 표시됩니다. 이를 위해 업데이트 트랜잭션을 처리하는 동안 마지막으로 커밋된 값을 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="a15a3-122">Unlike other isolation levels, snapshot isolation guarantees that all reads see a consistent snapshot of the data even while updates are occurring – essentially by returning the last committed values while an update transaction is being processed.</span></span>  

## <a name="managing-concurrency-in-blob-storage"></a><span data-ttu-id="a15a3-123">Blob 저장소에서 동시성 관리</span><span class="sxs-lookup"><span data-stu-id="a15a3-123">Managing Concurrency in Blob storage</span></span>
<span data-ttu-id="a15a3-124">낙관적 동시성 모델이나 비관적 동시성 모델을 사용하여 Blob 서비스의 컨테이너와 Blob에 대한 액세스를 관리할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="a15a3-124">You can opt to use either optimistic or pessimistic concurrency models to manage access to blobs and containers in the blob service.</span></span> <span data-ttu-id="a15a3-125">전략을 명시적으로 지정하지 않으면 마지막 작성자의 업데이트 적용 전략이 기본적으로 사용됩니다.</span><span class="sxs-lookup"><span data-stu-id="a15a3-125">If you do not explicitly specify a strategy last writes wins is the default.</span></span>  

### <a name="optimistic-concurrency-for-blobs-and-containers"></a><span data-ttu-id="a15a3-126">Blob 및 컨테이너에 대한 낙관적 동시성</span><span class="sxs-lookup"><span data-stu-id="a15a3-126">Optimistic concurrency for blobs and containers</span></span>
<span data-ttu-id="a15a3-127">저장소 서비스는 저장되는 모든 개체에 식별자를 할당합니다.</span><span class="sxs-lookup"><span data-stu-id="a15a3-127">The Storage service assigns an identifier to every object stored.</span></span> <span data-ttu-id="a15a3-128">이 식별자는 개체에 대해 업데이트 작업을 수행할 때마다 업데이트되며, HTTP 프로토콜 내에 정의된 ETag(엔터티 태그) 헤더를 사용하여 HTTP GET 응답의 일부분으로 클라이언트에 반환됩니다.</span><span class="sxs-lookup"><span data-stu-id="a15a3-128">This identifier is updated every time an update operation is performed on an object.</span></span> <span data-ttu-id="a15a3-129">이러한 개체에 대해 업데이트를 수행하는 사용자는 조건부 헤더와 함께 원본 ETag를 보내 특정 조건이 충족된 경우에만 업데이트가 수행되도록 할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="a15a3-129">The identifier is returned to the client as part of an HTTP GET response using the ETag (entity tag) header that is defined within the HTTP protocol.</span></span> <span data-ttu-id="a15a3-130">이 경우 조건은 “If-Match” 헤더로, 저장소 서비스는 업데이트 요청에 지정된 ETag의 값이 저장소 서비스에 저장된 값과 같은지를 확인해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="a15a3-130">A user performing an update on such an object can send in the original ETag along with a conditional header to ensure that an update will only occur if a certain condition has been met – in this case the condition is an "If-Match" header which requires the Storage Service to ensure the value of the ETag specified in the update request is the same as that stored in the Storage Service.</span></span>  

<span data-ttu-id="a15a3-131">이 프로세스는 대략적으로 다음과 같이 수행됩니다.</span><span class="sxs-lookup"><span data-stu-id="a15a3-131">The outline of this process is as follows:</span></span>  

1. <span data-ttu-id="a15a3-132">저장소 서비스에서 Blob를 검색합니다. 응답에는 저장소 서비스에서 개체의 현재 버전을 식별하는 HTTP ETag 헤더 값이 포함됩니다.</span><span class="sxs-lookup"><span data-stu-id="a15a3-132">Retrieve a blob from the storage service, the response includes an HTTP ETag Header value that identifies the current version of the object in the storage service.</span></span>
2. <span data-ttu-id="a15a3-133">Blob를 업데이트할 때는 서비스로 보내는 요청의 **If-Match** 조건부 헤더에 1단계에서 받은 ETag 값을 포함합니다.</span><span class="sxs-lookup"><span data-stu-id="a15a3-133">When you update the blob, include the ETag value you received in step 1 in the **If-Match** conditional header of the request you send to the service.</span></span>
3. <span data-ttu-id="a15a3-134">서비스가 요청의 ETag 값을 Blob의 현재 ETag 값과 비교합니다.</span><span class="sxs-lookup"><span data-stu-id="a15a3-134">The service compares the ETag value in the request with the current ETag value of the blob.</span></span>
4. <span data-ttu-id="a15a3-135">Blob의 현재 ETag 값이 요청의 **If-Match** 조건부 헤더에 포함된 ETag와 다른 버전이면 서비스는 클라이언트에 412 오류를 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="a15a3-135">If the current ETag value of the blob is a different version than the ETag in the **If-Match** conditional header in the request, the service returns a 412 error to the client.</span></span> <span data-ttu-id="a15a3-136">클라이언트는 이 오류를 통해 Blob를 검색한 후 다른 프로세스에서 Blob를 업데이트했음을 확인할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="a15a3-136">This indicates to the client that another process has updated the blob since the client retrieved it.</span></span>
5. <span data-ttu-id="a15a3-137">Blob의 현재 ETag 값이 요청의 **If-Match** 조건부 헤더에 포함된 ETag와 같은 버전이면 서비스는 요청된 작업을 수행하며 Blob의 현재 ETag 값을 업데이트하여 새 버전을 만들었음을 표시합니다.</span><span class="sxs-lookup"><span data-stu-id="a15a3-137">If the current ETag value of the blob is the same version as the ETag in the **If-Match** conditional header in the request, the service performs the requested operation and updates the current ETag value of the blob to show that it has created a new version.</span></span>  

<span data-ttu-id="a15a3-138">클라이언트 저장소 라이브러리 4.2.0을 사용하는 다음 C# 코드 조각은 이전에 검색했거나 삽입한 Blob의 속성에서 액세스할 수 있는 ETag 값을 기준으로 **If-Match AccessCondition** 을 생성하는 방법의 간단한 예제를 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="a15a3-138">The following C# snippet (using the Client Storage Library 4.2.0) shows a simple example of how to construct an **If-Match AccessCondition** based on the ETag value that is accessed from the properties of a blob that was previously either retrieved or inserted.</span></span> <span data-ttu-id="a15a3-139">그런 다음 Blob을 업데이트할 때 **AccessCondition** 개체를 사용합니다: **AccessCondition** 개체는 요청에 **If-Match** 헤더를 추가합니다.</span><span class="sxs-lookup"><span data-stu-id="a15a3-139">It then uses the **AccessCondition** object when it updating the blob: the **AccessCondition** object adds the **If-Match** header to the request.</span></span> <span data-ttu-id="a15a3-140">다른 프로세스가 Blob을 업데이트한 경우 Blob 서비스는 HTTP 412(전재 조건 실패) 상태 메시지를 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="a15a3-140">If another process has updated the blob, the blob service returns an HTTP 412 (Precondition Failed) status message.</span></span> <span data-ttu-id="a15a3-141">[Azure 저장소를 사용하여 동시성 관리](http://code.msdn.microsoft.com/Managing-Concurrency-using-56018114)에서 전체 샘플을 다운로드할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="a15a3-141">You can download the full sample here: [Managing Concurrency using Azure Storage](http://code.msdn.microsoft.com/Managing-Concurrency-using-56018114).</span></span>  

```csharp
// Retrieve the ETag from the newly created blob
// Etag is already populated as UploadText should cause a PUT Blob call
// to storage blob service which returns the etag in response.
string orignalETag = blockBlob.Properties.ETag;

// This code simulates an update by a third party.
string helloText = "Blob updated by a third party.";

// No etag, provided so orignal blob is overwritten (thus generating a new etag)
blockBlob.UploadText(helloText);
Console.WriteLine("Blob updated. Updated ETag = {0}",
blockBlob.Properties.ETag);

// Now try to update the blob using the orignal ETag provided when the blob was created
try
{
    Console.WriteLine("Trying to update blob using orignal etag to generate if-match access condition");
    blockBlob.UploadText(helloText,accessCondition:
    AccessCondition.GenerateIfMatchCondition(orignalETag));
}
catch (StorageException ex)
{
    if (ex.RequestInformation.HttpStatusCode == (int)HttpStatusCode.PreconditionFailed)
    {
        Console.WriteLine("Precondition failure as expected. Blob's orignal etag no longer matches");
        // TODO: client can decide on how it wants to handle the 3rd party updated content.
    }
    else
        throw;
}  
```

<span data-ttu-id="a15a3-142">저장소 서비스는 **If-Modified-Since**, **If-Unmodified-Since** 및 **If-None-Match**와 같은 추가 조건부 헤더 및 이러한 헤더의 조합도 지원합니다.</span><span class="sxs-lookup"><span data-stu-id="a15a3-142">The Storage Service also includes support for additional conditional headers such as **If-Modified-Since**, **If-Unmodified-Since** and **If-None-Match** as well as combinations thereof.</span></span> <span data-ttu-id="a15a3-143">자세한 내용은 MSDN의 [Blob 서비스 작업의 조건부 헤더 지정](http://msdn.microsoft.com/library/azure/dd179371.aspx) 을 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="a15a3-143">For more information see [Specifying Conditional Headers for Blob Service Operations](http://msdn.microsoft.com/library/azure/dd179371.aspx) on MSDN.</span></span>  

<span data-ttu-id="a15a3-144">아래 표에는 요청에서 **If-Match** 와 같은 조건부 헤더를 수락하며 응답에서 ETag 값을 반환하는 컨테이너 작업이 요약되어 있습니다.</span><span class="sxs-lookup"><span data-stu-id="a15a3-144">The following table summarizes the container operations that accept conditional headers such as **If-Match** in the request and that return an ETag value in the response.</span></span>  

| <span data-ttu-id="a15a3-145">작업</span><span class="sxs-lookup"><span data-stu-id="a15a3-145">Operation</span></span> | <span data-ttu-id="a15a3-146">컨테이너 ETag 값 반환</span><span class="sxs-lookup"><span data-stu-id="a15a3-146">Returns Container ETag value</span></span> | <span data-ttu-id="a15a3-147">추가 헤더 수락</span><span class="sxs-lookup"><span data-stu-id="a15a3-147">Accepts conditional headers</span></span> |
|:--- |:--- |:--- |
| <span data-ttu-id="a15a3-148">컨테이너 만들기</span><span class="sxs-lookup"><span data-stu-id="a15a3-148">Create Container</span></span> |<span data-ttu-id="a15a3-149">예</span><span class="sxs-lookup"><span data-stu-id="a15a3-149">Yes</span></span> |<span data-ttu-id="a15a3-150">아니요</span><span class="sxs-lookup"><span data-stu-id="a15a3-150">No</span></span> |
| <span data-ttu-id="a15a3-151">컨테이너 속성 가져오기</span><span class="sxs-lookup"><span data-stu-id="a15a3-151">Get Container Properties</span></span> |<span data-ttu-id="a15a3-152">예</span><span class="sxs-lookup"><span data-stu-id="a15a3-152">Yes</span></span> |<span data-ttu-id="a15a3-153">아니요</span><span class="sxs-lookup"><span data-stu-id="a15a3-153">No</span></span> |
| <span data-ttu-id="a15a3-154">컨테이너 메타데이터 가져오기</span><span class="sxs-lookup"><span data-stu-id="a15a3-154">Get Container Metadata</span></span> |<span data-ttu-id="a15a3-155">예</span><span class="sxs-lookup"><span data-stu-id="a15a3-155">Yes</span></span> |<span data-ttu-id="a15a3-156">아니요</span><span class="sxs-lookup"><span data-stu-id="a15a3-156">No</span></span> |
| <span data-ttu-id="a15a3-157">컨테이너 메타데이터 설정</span><span class="sxs-lookup"><span data-stu-id="a15a3-157">Set Container Metadata</span></span> |<span data-ttu-id="a15a3-158">예</span><span class="sxs-lookup"><span data-stu-id="a15a3-158">Yes</span></span> |<span data-ttu-id="a15a3-159">예</span><span class="sxs-lookup"><span data-stu-id="a15a3-159">Yes</span></span> |
| <span data-ttu-id="a15a3-160">컨테이너 ACL 가져오기</span><span class="sxs-lookup"><span data-stu-id="a15a3-160">Get Container ACL</span></span> |<span data-ttu-id="a15a3-161">예</span><span class="sxs-lookup"><span data-stu-id="a15a3-161">Yes</span></span> |<span data-ttu-id="a15a3-162">아니요</span><span class="sxs-lookup"><span data-stu-id="a15a3-162">No</span></span> |
| <span data-ttu-id="a15a3-163">컨테이너 ACL 설정</span><span class="sxs-lookup"><span data-stu-id="a15a3-163">Set Container ACL</span></span> |<span data-ttu-id="a15a3-164">예</span><span class="sxs-lookup"><span data-stu-id="a15a3-164">Yes</span></span> |<span data-ttu-id="a15a3-165">예(*)</span><span class="sxs-lookup"><span data-stu-id="a15a3-165">Yes (*)</span></span> |
| <span data-ttu-id="a15a3-166">컨테이너 삭제</span><span class="sxs-lookup"><span data-stu-id="a15a3-166">Delete Container</span></span> |<span data-ttu-id="a15a3-167">아니요</span><span class="sxs-lookup"><span data-stu-id="a15a3-167">No</span></span> |<span data-ttu-id="a15a3-168">예</span><span class="sxs-lookup"><span data-stu-id="a15a3-168">Yes</span></span> |
| <span data-ttu-id="a15a3-169">컨테이너 임대</span><span class="sxs-lookup"><span data-stu-id="a15a3-169">Lease Container</span></span> |<span data-ttu-id="a15a3-170">예</span><span class="sxs-lookup"><span data-stu-id="a15a3-170">Yes</span></span> |<span data-ttu-id="a15a3-171">예</span><span class="sxs-lookup"><span data-stu-id="a15a3-171">Yes</span></span> |
| <span data-ttu-id="a15a3-172">Blob 나열</span><span class="sxs-lookup"><span data-stu-id="a15a3-172">List Blobs</span></span> |<span data-ttu-id="a15a3-173">아니요</span><span class="sxs-lookup"><span data-stu-id="a15a3-173">No</span></span> |<span data-ttu-id="a15a3-174">아니요</span><span class="sxs-lookup"><span data-stu-id="a15a3-174">No</span></span> |

<span data-ttu-id="a15a3-175">(*) SetContainerACL이 정의하는 권한은 캐시되며 이러한 권한에 대한 업데이트가 전파되려면 30초가 걸립니다. 이 시간 동안에는 업데이트의 일관성이 보장되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="a15a3-175">(*) The permissions defined by SetContainerACL are cached and updates to these permissions take 30 seconds to propagate during which period updates are not guaranteed to be consistent.</span></span>  

<span data-ttu-id="a15a3-176">아래 표에는 요청에서 **If-Match** 와 같은 조건부 헤더를 수락하며 응답에서 ETag 값을 반환하는 Blob 작업이 요약되어 있습니다.</span><span class="sxs-lookup"><span data-stu-id="a15a3-176">The following table summarizes the blob operations that accept conditional headers such as **If-Match** in the request and that return an ETag value in the response.</span></span>

| <span data-ttu-id="a15a3-177">작업</span><span class="sxs-lookup"><span data-stu-id="a15a3-177">Operation</span></span> | <span data-ttu-id="a15a3-178">ETag 값 반환</span><span class="sxs-lookup"><span data-stu-id="a15a3-178">Returns ETag value</span></span> | <span data-ttu-id="a15a3-179">추가 헤더 수락</span><span class="sxs-lookup"><span data-stu-id="a15a3-179">Accepts conditional headers</span></span> |
|:--- |:--- |:--- |
| <span data-ttu-id="a15a3-180">Blob 배치</span><span class="sxs-lookup"><span data-stu-id="a15a3-180">Put Blob</span></span> |<span data-ttu-id="a15a3-181">예</span><span class="sxs-lookup"><span data-stu-id="a15a3-181">Yes</span></span> |<span data-ttu-id="a15a3-182">예</span><span class="sxs-lookup"><span data-stu-id="a15a3-182">Yes</span></span> |
| <span data-ttu-id="a15a3-183">Blob 가져오기</span><span class="sxs-lookup"><span data-stu-id="a15a3-183">Get Blob</span></span> |<span data-ttu-id="a15a3-184">예</span><span class="sxs-lookup"><span data-stu-id="a15a3-184">Yes</span></span> |<span data-ttu-id="a15a3-185">예</span><span class="sxs-lookup"><span data-stu-id="a15a3-185">Yes</span></span> |
| <span data-ttu-id="a15a3-186">Blob 속성 가져오기</span><span class="sxs-lookup"><span data-stu-id="a15a3-186">Get Blob Properties</span></span> |<span data-ttu-id="a15a3-187">예</span><span class="sxs-lookup"><span data-stu-id="a15a3-187">Yes</span></span> |<span data-ttu-id="a15a3-188">예</span><span class="sxs-lookup"><span data-stu-id="a15a3-188">Yes</span></span> |
| <span data-ttu-id="a15a3-189">Blob 속성 설정</span><span class="sxs-lookup"><span data-stu-id="a15a3-189">Set Blob Properties</span></span> |<span data-ttu-id="a15a3-190">예</span><span class="sxs-lookup"><span data-stu-id="a15a3-190">Yes</span></span> |<span data-ttu-id="a15a3-191">예</span><span class="sxs-lookup"><span data-stu-id="a15a3-191">Yes</span></span> |
| <span data-ttu-id="a15a3-192">Blob 메타데이터 가져오기</span><span class="sxs-lookup"><span data-stu-id="a15a3-192">Get Blob Metadata</span></span> |<span data-ttu-id="a15a3-193">예</span><span class="sxs-lookup"><span data-stu-id="a15a3-193">Yes</span></span> |<span data-ttu-id="a15a3-194">예</span><span class="sxs-lookup"><span data-stu-id="a15a3-194">Yes</span></span> |
| <span data-ttu-id="a15a3-195">Blob 메타데이터 설정</span><span class="sxs-lookup"><span data-stu-id="a15a3-195">Set Blob Metadata</span></span> |<span data-ttu-id="a15a3-196">예</span><span class="sxs-lookup"><span data-stu-id="a15a3-196">Yes</span></span> |<span data-ttu-id="a15a3-197">예</span><span class="sxs-lookup"><span data-stu-id="a15a3-197">Yes</span></span> |
| <span data-ttu-id="a15a3-198">Blob 임대(*)</span><span class="sxs-lookup"><span data-stu-id="a15a3-198">Lease Blob (*)</span></span> |<span data-ttu-id="a15a3-199">예</span><span class="sxs-lookup"><span data-stu-id="a15a3-199">Yes</span></span> |<span data-ttu-id="a15a3-200">예</span><span class="sxs-lookup"><span data-stu-id="a15a3-200">Yes</span></span> |
| <span data-ttu-id="a15a3-201">Blob 스냅숏</span><span class="sxs-lookup"><span data-stu-id="a15a3-201">Snapshot Blob</span></span> |<span data-ttu-id="a15a3-202">예</span><span class="sxs-lookup"><span data-stu-id="a15a3-202">Yes</span></span> |<span data-ttu-id="a15a3-203">예</span><span class="sxs-lookup"><span data-stu-id="a15a3-203">Yes</span></span> |
| <span data-ttu-id="a15a3-204">Blob 복사</span><span class="sxs-lookup"><span data-stu-id="a15a3-204">Copy Blob</span></span> |<span data-ttu-id="a15a3-205">예</span><span class="sxs-lookup"><span data-stu-id="a15a3-205">Yes</span></span> |<span data-ttu-id="a15a3-206">예(원본 및 대상 Blob의 경우)</span><span class="sxs-lookup"><span data-stu-id="a15a3-206">Yes (for source and destination blob)</span></span> |
| <span data-ttu-id="a15a3-207">Blob 복사 중단</span><span class="sxs-lookup"><span data-stu-id="a15a3-207">Abort Copy Blob</span></span> |<span data-ttu-id="a15a3-208">아니요</span><span class="sxs-lookup"><span data-stu-id="a15a3-208">No</span></span> |<span data-ttu-id="a15a3-209">아니요</span><span class="sxs-lookup"><span data-stu-id="a15a3-209">No</span></span> |
| <span data-ttu-id="a15a3-210">Blob 삭제</span><span class="sxs-lookup"><span data-stu-id="a15a3-210">Delete Blob</span></span> |<span data-ttu-id="a15a3-211">아니요</span><span class="sxs-lookup"><span data-stu-id="a15a3-211">No</span></span> |<span data-ttu-id="a15a3-212">예</span><span class="sxs-lookup"><span data-stu-id="a15a3-212">Yes</span></span> |
| <span data-ttu-id="a15a3-213">블록 배치</span><span class="sxs-lookup"><span data-stu-id="a15a3-213">Put Block</span></span> |<span data-ttu-id="a15a3-214">아니요</span><span class="sxs-lookup"><span data-stu-id="a15a3-214">No</span></span> |<span data-ttu-id="a15a3-215">아니요</span><span class="sxs-lookup"><span data-stu-id="a15a3-215">No</span></span> |
| <span data-ttu-id="a15a3-216">블록 목록 배치</span><span class="sxs-lookup"><span data-stu-id="a15a3-216">Put Block List</span></span> |<span data-ttu-id="a15a3-217">예</span><span class="sxs-lookup"><span data-stu-id="a15a3-217">Yes</span></span> |<span data-ttu-id="a15a3-218">예</span><span class="sxs-lookup"><span data-stu-id="a15a3-218">Yes</span></span> |
| <span data-ttu-id="a15a3-219">블록 목록 가져오기</span><span class="sxs-lookup"><span data-stu-id="a15a3-219">Get Block List</span></span> |<span data-ttu-id="a15a3-220">예</span><span class="sxs-lookup"><span data-stu-id="a15a3-220">Yes</span></span> |<span data-ttu-id="a15a3-221">아니요</span><span class="sxs-lookup"><span data-stu-id="a15a3-221">No</span></span> |
| <span data-ttu-id="a15a3-222">페이지 가져오기</span><span class="sxs-lookup"><span data-stu-id="a15a3-222">Put Page</span></span> |<span data-ttu-id="a15a3-223">예</span><span class="sxs-lookup"><span data-stu-id="a15a3-223">Yes</span></span> |<span data-ttu-id="a15a3-224">예</span><span class="sxs-lookup"><span data-stu-id="a15a3-224">Yes</span></span> |
| <span data-ttu-id="a15a3-225">페이지 범위 가져오기</span><span class="sxs-lookup"><span data-stu-id="a15a3-225">Get Page Ranges</span></span> |<span data-ttu-id="a15a3-226">예</span><span class="sxs-lookup"><span data-stu-id="a15a3-226">Yes</span></span> |<span data-ttu-id="a15a3-227">예</span><span class="sxs-lookup"><span data-stu-id="a15a3-227">Yes</span></span> |

<span data-ttu-id="a15a3-228">(*) Blob 임대에서는 Blob의 ETag가 변경되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="a15a3-228">(*) Lease Blob does not change the ETag on a blob.</span></span>  

### <a name="pessimistic-concurrency-for-blobs"></a><span data-ttu-id="a15a3-229">Blob에 대한 비관적 동시성</span><span class="sxs-lookup"><span data-stu-id="a15a3-229">Pessimistic concurrency for blobs</span></span>
<span data-ttu-id="a15a3-230">단독 사용을 위해 Blob를 잠그려는 경우 Blob에 대한 [임대](http://msdn.microsoft.com/library/azure/ee691972.aspx)를 획득할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="a15a3-230">To lock a blob for exclusive use, you can acquire a [lease](http://msdn.microsoft.com/library/azure/ee691972.aspx) on it.</span></span> <span data-ttu-id="a15a3-231">임대를 획득하는 경우 임대에 필요한 기간을 지정합니다. 이 기간은 15초에서 60초 사이이거나 배타적 잠금 상태가 되는 무한일 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="a15a3-231">When you acquire a lease, you specify for how long you need the lease: this can be for between 15 to 60 seconds or infinite which amounts to an exclusive lock.</span></span> <span data-ttu-id="a15a3-232">유한 임대는 갱신하여 연장할 수 있으며 완료된 임대는 해제할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="a15a3-232">You can renew a finite lease to extend it, and you can release any lease when you are finished with it.</span></span> <span data-ttu-id="a15a3-233">Blob 서비스는 만료된 유한 임대를 자동으로 해제합니다.</span><span class="sxs-lookup"><span data-stu-id="a15a3-233">The blob service automatically releases finite leases when they expire.</span></span>  

<span data-ttu-id="a15a3-234">임대를 사용하면 배타적 쓰기/공유 읽기, 배타적 쓰기/배타적 읽기, 공유 쓰기/배타적 읽기 등의 다양한 동기화 전략을 지원할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="a15a3-234">Leases enable different synchronization strategies to be supported, including exclusive write / shared read, exclusive write / exclusive read and shared write / exclusive read.</span></span> <span data-ttu-id="a15a3-235">임대가 있는 상태에서 저장소 서비스가 배타적 쓰기(배치, 설정 및 삭제 작업)를 강제로 수행하지만 읽기 작업에 대해 독점성을 보장하는 경우 개발자는 모든 클라이언트 응용 프로그램에서 임대 ID를 사용하고 한 번에 한 클라이언트만 유효한 임대 ID를 사용하도록 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="a15a3-235">Where a lease exists the storage service enforces exclusive writes (put, set and delete operations) however ensuring exclusivity for read operations requires the developer to ensure that all client applications use a lease ID and that only one client at a time has a valid lease ID.</span></span> <span data-ttu-id="a15a3-236">임대 ID를 포함하지 않는 읽기 작업에서는 공유 읽기가 수행됩니다.</span><span class="sxs-lookup"><span data-stu-id="a15a3-236">Read operations that do not include a lease ID result in shared reads.</span></span>  

<span data-ttu-id="a15a3-237">다음 C# 코드 조각은 Blob에 대해 30초 동안 배타적 임대를 획득하고 Blob의 내용을 업데이트한 후에 임대를 해제하는 예제를 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="a15a3-237">The following C# snippet shows an example of acquiring an exclusive lease for 30 seconds on a blob, updating the content of the blob, and then releasing the lease.</span></span> <span data-ttu-id="a15a3-238">새 임대를 획득하려 할 때 Blob에 대해 유효한 임대가 이미 있으면 Blob service는 “HTTP(409) 충돌” 상태 결과를 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="a15a3-238">If there is already a valid lease on the blob when you try to acquire a new lease, the blob service returns an "HTTP (409) Conflict" status result.</span></span> <span data-ttu-id="a15a3-239">아래 코드 조각은 저장소 서비스에서 Blob를 업데이트하기 위한 요청을 할 때 **AccessCondition** 개체를 사용하여 임대 정보를 캡슐화합니다.</span><span class="sxs-lookup"><span data-stu-id="a15a3-239">The snippet below uses an **AccessCondition** object to encapsulate the lease information when it makes a request to update the blob in the storage service.</span></span>  <span data-ttu-id="a15a3-240">[Azure 저장소를 사용하여 동시성 관리](http://code.msdn.microsoft.com/Managing-Concurrency-using-56018114)에서 전체 샘플을 다운로드할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="a15a3-240">You can download the full sample here: [Managing Concurrency using Azure Storage](http://code.msdn.microsoft.com/Managing-Concurrency-using-56018114).</span></span>

```csharp
// Acquire lease for 15 seconds
string lease = blockBlob.AcquireLease(TimeSpan.FromSeconds(15), null);
Console.WriteLine("Blob lease acquired. Lease = {0}", lease);

// Update blob using lease. This operation will succeed
const string helloText = "Blob updated";
var accessCondition = AccessCondition.GenerateLeaseCondition(lease);
blockBlob.UploadText(helloText, accessCondition: accessCondition);
Console.WriteLine("Blob updated using an exclusive lease");

//Simulate third party update to blob without lease
try
{
    // Below operation will fail as no valid lease provided
    Console.WriteLine("Trying to update blob without valid lease");
    blockBlob.UploadText("Update without lease, will fail");
}
catch (StorageException ex)
{
    if (ex.RequestInformation.HttpStatusCode == (int)HttpStatusCode.PreconditionFailed)
        Console.WriteLine("Precondition failure as expected. Blob's lease does not match");
    else
        throw;
}  
```

<span data-ttu-id="a15a3-241">임대 ID를 전달하지 않고 임대한 Blob에 대해 쓰기 작업을 시도하면 요청이 실패하고 412 오류가 발생합니다.</span><span class="sxs-lookup"><span data-stu-id="a15a3-241">If you attempt a write operation on a leased blob without passing the lease ID, the request fails with a 412 error.</span></span> <span data-ttu-id="a15a3-242">**UploadText** 메서드를 호출하기 전에 임대가 만료되었는데 임대 ID를 전달하는 경우에도 요청이 실패하고 **412** 오류가 발생합니다.</span><span class="sxs-lookup"><span data-stu-id="a15a3-242">Note that if the lease expires before calling the **UploadText** method but you still pass the lease ID, the request also fails with a **412** error.</span></span> <span data-ttu-id="a15a3-243">임대 만료 시간 및 임대 ID를 관리하는 방법에 대한 자세한 내용은 [Blob 임대](http://msdn.microsoft.com/library/azure/ee691972.aspx) REST 문서를 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="a15a3-243">For more information about managing lease expiry times and lease ids, see the [Lease Blob](http://msdn.microsoft.com/library/azure/ee691972.aspx) REST documentation.</span></span>  

<span data-ttu-id="a15a3-244">다음 Blob 작업에서는 임대를 사용하여 비관적 동시성을 관리할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="a15a3-244">The following blob operations can use leases to manage pessimistic concurrency:</span></span>  

* <span data-ttu-id="a15a3-245">Blob 배치</span><span class="sxs-lookup"><span data-stu-id="a15a3-245">Put Blob</span></span>
* <span data-ttu-id="a15a3-246">Blob 가져오기</span><span class="sxs-lookup"><span data-stu-id="a15a3-246">Get Blob</span></span>
* <span data-ttu-id="a15a3-247">Blob 속성 가져오기</span><span class="sxs-lookup"><span data-stu-id="a15a3-247">Get Blob Properties</span></span>
* <span data-ttu-id="a15a3-248">Blob 속성 설정</span><span class="sxs-lookup"><span data-stu-id="a15a3-248">Set Blob Properties</span></span>
* <span data-ttu-id="a15a3-249">Blob 메타데이터 가져오기</span><span class="sxs-lookup"><span data-stu-id="a15a3-249">Get Blob Metadata</span></span>
* <span data-ttu-id="a15a3-250">Blob 메타데이터 설정</span><span class="sxs-lookup"><span data-stu-id="a15a3-250">Set Blob Metadata</span></span>
* <span data-ttu-id="a15a3-251">Blob 삭제</span><span class="sxs-lookup"><span data-stu-id="a15a3-251">Delete Blob</span></span>
* <span data-ttu-id="a15a3-252">블록 배치</span><span class="sxs-lookup"><span data-stu-id="a15a3-252">Put Block</span></span>
* <span data-ttu-id="a15a3-253">블록 목록 배치</span><span class="sxs-lookup"><span data-stu-id="a15a3-253">Put Block List</span></span>
* <span data-ttu-id="a15a3-254">블록 목록 가져오기</span><span class="sxs-lookup"><span data-stu-id="a15a3-254">Get Block List</span></span>
* <span data-ttu-id="a15a3-255">페이지 가져오기</span><span class="sxs-lookup"><span data-stu-id="a15a3-255">Put Page</span></span>
* <span data-ttu-id="a15a3-256">페이지 범위 가져오기</span><span class="sxs-lookup"><span data-stu-id="a15a3-256">Get Page Ranges</span></span>
* <span data-ttu-id="a15a3-257">스냅숏 Blob - 임대가 있는 경우 임대 ID는 선택 사항임</span><span class="sxs-lookup"><span data-stu-id="a15a3-257">Snapshot Blob - lease ID optional if a lease exists</span></span>
* <span data-ttu-id="a15a3-258">Blob 복사 - 대상 Blob에 대한 임대가 있는 경우 임대 ID는 필수임</span><span class="sxs-lookup"><span data-stu-id="a15a3-258">Copy Blob - lease ID required if a lease exists on the destination blob</span></span>
* <span data-ttu-id="a15a3-259">Blob 복사 중단 - 대상 Blob에 대한 무한 임대가 있는 경우 임대 ID는 필수임</span><span class="sxs-lookup"><span data-stu-id="a15a3-259">Abort Copy Blob - lease ID required if an infinite lease exists on the destination blob</span></span>
* <span data-ttu-id="a15a3-260">Blob 임대</span><span class="sxs-lookup"><span data-stu-id="a15a3-260">Lease Blob</span></span>  

### <a name="pessimistic-concurrency-for-containers"></a><span data-ttu-id="a15a3-261">컨테이너에 대한 비관적 동시성</span><span class="sxs-lookup"><span data-stu-id="a15a3-261">Pessimistic concurrency for containers</span></span>
<span data-ttu-id="a15a3-262">컨테이너에 대해 임대를 사용하면 배타적 쓰기/공유 읽기, 배타적 쓰기/배타적 읽기, 공유 쓰기/배타적 읽기 등 Blob에서와 같은 동기화 전략을 지원할 수 있습니다. 그러나 Blob와 달리 저장소 서비스에서는 삭제 작업에 대해서만 독점성을 적용합니다.</span><span class="sxs-lookup"><span data-stu-id="a15a3-262">Leases on containers enable the same synchronization strategies to be supported as on blobs (exclusive write / shared read, exclusive write / exclusive read and shared write / exclusive read) however unlike blobs the storage service only enforces exclusivity on delete operations.</span></span> <span data-ttu-id="a15a3-263">임대가 활성 상태인 컨테이너를 삭제하려면 클라이언트가 삭제 요청에 활성 임대 ID를 포함해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="a15a3-263">To delete a container with an active lease, a client must include the active lease ID with the delete request.</span></span> <span data-ttu-id="a15a3-264">기타 모든 컨테이너 작업은 임대 ID를 포함하지 않아도 임대한 컨테이너에서 성공합니다. 이 경우 해당 작업은 공유 작업입니다.</span><span class="sxs-lookup"><span data-stu-id="a15a3-264">All other container operations succeed on a leased container without including the lease ID in which case they are shared operations.</span></span> <span data-ttu-id="a15a3-265">업데이트(배치 또는 설정) 또는 읽기 작업에서 독점성이 필요한 경우 개발자는 모든 클라이언트가 임대 ID를 사용하고 한 번에 한 클라이언트만 유효한 임대 ID를 사용하도록 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="a15a3-265">If exclusivity of update (put or set) or read operations is required then developers should ensure all clients use a lease ID and that only one client at a time has a valid lease ID.</span></span>  

<span data-ttu-id="a15a3-266">다음 컨테이너 작업에서는 임대를 사용하여 비관적 동시성을 관리할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="a15a3-266">The following container operations can use leases to manage pessimistic concurrency:</span></span>  

* <span data-ttu-id="a15a3-267">컨테이너 삭제</span><span class="sxs-lookup"><span data-stu-id="a15a3-267">Delete Container</span></span>
* <span data-ttu-id="a15a3-268">컨테이너 속성 가져오기</span><span class="sxs-lookup"><span data-stu-id="a15a3-268">Get Container Properties</span></span>
* <span data-ttu-id="a15a3-269">컨테이너 메타데이터 가져오기</span><span class="sxs-lookup"><span data-stu-id="a15a3-269">Get Container Metadata</span></span>
* <span data-ttu-id="a15a3-270">컨테이너 메타데이터 설정</span><span class="sxs-lookup"><span data-stu-id="a15a3-270">Set Container Metadata</span></span>
* <span data-ttu-id="a15a3-271">컨테이너 ACL 가져오기</span><span class="sxs-lookup"><span data-stu-id="a15a3-271">Get Container ACL</span></span>
* <span data-ttu-id="a15a3-272">컨테이너 ACL 설정</span><span class="sxs-lookup"><span data-stu-id="a15a3-272">Set Container ACL</span></span>
* <span data-ttu-id="a15a3-273">컨테이너 임대</span><span class="sxs-lookup"><span data-stu-id="a15a3-273">Lease Container</span></span>  

<span data-ttu-id="a15a3-274">자세한 내용은 다음을 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="a15a3-274">For more information see:</span></span>  

* [<span data-ttu-id="a15a3-275">Blob 서비스 작업의 조건부 헤더 지정</span><span class="sxs-lookup"><span data-stu-id="a15a3-275">Specifying Conditional Headers for Blob Service Operations</span></span>](http://msdn.microsoft.com/library/azure/dd179371.aspx)
* [<span data-ttu-id="a15a3-276">컨테이너 임대</span><span class="sxs-lookup"><span data-stu-id="a15a3-276">Lease Container</span></span>](http://msdn.microsoft.com/library/azure/jj159103.aspx)
* [<span data-ttu-id="a15a3-277">Blob 임대 </span><span class="sxs-lookup"><span data-stu-id="a15a3-277">Lease Blob </span></span>](http://msdn.microsoft.com/library/azure/ee691972.aspx)

## <a name="managing-concurrency-in-the-table-service"></a><span data-ttu-id="a15a3-278">테이블 서비스에서 동시성 관리</span><span class="sxs-lookup"><span data-stu-id="a15a3-278">Managing Concurrency in the Table Service</span></span>
<span data-ttu-id="a15a3-279">낙관적 동시성 검사를 수행하도록 명시적으로 선택해야 하는 Blob 서비스에서와는 달리 테이블 서비스에서는 엔터티로 작업할 때 낙관적 동시성 검사를 기본 동작으로 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="a15a3-279">The table service uses optimistic concurrency checks as the default behavior when you are working with entities, unlike the blob service where you must explicitly choose to perform optimistic concurrency checks.</span></span> <span data-ttu-id="a15a3-280">테이블 서비스와 Blob 서비스의 또 다른 차이점은, 테이블 서비스에서는 엔터티의 동시성 동작만 관리할 수 있는 반면 Blob 서비스에서는 컨테이너와 Blob의 동시성을 모두 관리할 수 있다는 것입니다.</span><span class="sxs-lookup"><span data-stu-id="a15a3-280">The other difference between the table and blob services is that you can only manage the concurrency behavior of entities whereas with the blob service you can manage the concurrency of both containers and blobs.</span></span>  

<span data-ttu-id="a15a3-281">낙관적 동시성을 사용하고 엔터티를 테이블 저장소 서비스에서 검색한 이후 다른 프로세스에서 해당 엔터티를 수정했는지 확인하려는 경우 테이블 서비스에서 엔터티를 반환할 때 수신되는 ETag 값을 사용하면 됩니다.</span><span class="sxs-lookup"><span data-stu-id="a15a3-281">To use optimistic concurrency and to check if another process modified an entity since you retrieved it from the table storage service, you can use the ETag value you receive when the table service returns an entity.</span></span> <span data-ttu-id="a15a3-282">이 프로세스는 대략적으로 다음과 같이 수행됩니다.</span><span class="sxs-lookup"><span data-stu-id="a15a3-282">The outline of this process is as follows:</span></span>  

1. <span data-ttu-id="a15a3-283">테이블 저장소 서비스에서 엔터티를 검색합니다. 응답에는 저장소 서비스에서 해당 엔터티와 연결된 현재 식별자를 식별하는 ETag 값이 포함됩니다.</span><span class="sxs-lookup"><span data-stu-id="a15a3-283">Retrieve an entity from the table storage service, the response includes an ETag value that identifies the current identifier associated with that entity in the storage service.</span></span>
2. <span data-ttu-id="a15a3-284">엔터티를 업데이트할 때는 서비스로 보내는 요청의 필수 **If-Match** 헤더에 1단계에서 받은 ETag 값을 포함합니다.</span><span class="sxs-lookup"><span data-stu-id="a15a3-284">When you update the entity, include the ETag value you received in step 1 in the mandatory **If-Match** header of the request you send to the service.</span></span>
3. <span data-ttu-id="a15a3-285">서비스가 요청의 ETag 값을 엔터티의 현재 ETag 값과 비교합니다.</span><span class="sxs-lookup"><span data-stu-id="a15a3-285">The service compares the ETag value in the request with the current ETag value of the entity.</span></span>
4. <span data-ttu-id="a15a3-286">엔터티의 현재 ETag 값이 요청의 필수 **If-Match** 헤더에 포함된 ETag와 다르면 서비스는 클라이언트에 412 오류를 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="a15a3-286">If the current ETag value of the entity is different than the ETag in the mandatory **If-Match** header in the request, the service returns a 412 error to the client.</span></span> <span data-ttu-id="a15a3-287">클라이언트는 이 오류를 통해 엔터티를 검색한 후 다른 프로세스에서 Blob를 업데이트했음을 확인할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="a15a3-287">This indicates to the client that another process has updated the entity since the client retrieved it.</span></span>
5. <span data-ttu-id="a15a3-288">엔터티의 현재 ETag 값이 요청의 필수 **If-Match** 헤더에 포함된 ETag와 같거나 **If-Match** 헤더에 와일드카드 문자(*)가 포함되어 있으면 서비스는 요청된 작업을 수행하며 엔터티의 현재 ETag 값을 업데이트하여 엔터티가 업데이트되었음을 표시합니다.</span><span class="sxs-lookup"><span data-stu-id="a15a3-288">If the current ETag value of the entity is the same as the ETag in the mandatory **If-Match** header in the request or the **If-Match** header contains the wildcard character (*), the service performs the requested operation and updates the current ETag value of the entity to show that it has been updated.</span></span>  

<span data-ttu-id="a15a3-289">Blob 서비스와 달리 테이블 서비스에서는 클라이언트가 업데이트 요청에 **If-Match** 헤더를 포함해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="a15a3-289">Note that unlike the blob service, the table service requires the client to include an **If-Match** header in update requests.</span></span> <span data-ttu-id="a15a3-290">그러나 클라이언트가 요청에서 **If-Match** 헤더를 와일드카드 문자(*)로 설정하는 경우에는 무조건 업데이트(마지막 작성자의 업데이트 적용 전략)를 강제 지정하고 동시성 검사를 무시할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="a15a3-290">However, it is possible to force an unconditional update (last writer wins strategy) and bypass concurrency checks if the client sets the **If-Match** header to the wildcard character (*) in the request.</span></span>  

<span data-ttu-id="a15a3-291">다음 C# 코드 조각은 이전에 만들거나 검색한 customer 엔터티의 메일 주소를 업데이트하는 작업을 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="a15a3-291">The following C# snippet shows a customer entity that was previously either created or retrieved having their email address updated.</span></span> <span data-ttu-id="a15a3-292">초기 삽입 또는 검색 작업에서는 ETag 값을 customer 개체에 저장합니다. 이 샘플은 바꾸기 작업을 실행할 때 같은 개체 인스턴스를 사용하므로 ETag 값을 테이블 서비스에 자동으로 다시 보내기 때문에 서비스가 동시성 위반을 검사할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="a15a3-292">The initial insert or retrieve operation stores the ETag value in the customer object, and because the sample uses the same object instance when it executes the replace operation, it automatically sends the ETag value back to the table service, enabling the service to check for concurrency violations.</span></span> <span data-ttu-id="a15a3-293">다른 프로세스가 테이블 저장소에서 엔터티를 업데이트한 경우 서비스는 HTTP 412(전재 조건 실패) 상태 메시지를 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="a15a3-293">If another process has updated the entity in table storage, the service returns an HTTP 412 (Precondition Failed) status message.</span></span>  <span data-ttu-id="a15a3-294">[Azure 저장소를 사용하여 동시성 관리](http://code.msdn.microsoft.com/Managing-Concurrency-using-56018114)에서 전체 샘플을 다운로드할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="a15a3-294">You can download the full sample here: [Managing Concurrency using Azure Storage](http://code.msdn.microsoft.com/Managing-Concurrency-using-56018114).</span></span>

```csharp
try
{
    customer.Email = "updatedEmail@contoso.org";
    TableOperation replaceCustomer = TableOperation.Replace(customer);
    customerTable.Execute(replaceCustomer);
    Console.WriteLine("Replace operation succeeded.");
}
catch (StorageException ex)
{
    if (ex.RequestInformation.HttpStatusCode == 412)
        Console.WriteLine("Optimistic concurrency violation – entity has changed since it was retrieved.");
    else
        throw;
}  
```

<span data-ttu-id="a15a3-295">동시성 검사를 명시적으로 사용하지 않도록 설정하려면 바꾸기 작업을 실행하기 전에 **employee** 개체의 **ETag** 속성을 “*”로 설정해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="a15a3-295">To explicitly disable the concurrency check, you should set the **ETag** property of the **employee** object to "*" before you execute the replace operation.</span></span>  

```csharp
customer.ETag = "*";  
```

<span data-ttu-id="a15a3-296">다음 표에는 테이블 엔터티 작업이 ETag 값을 사용하는 방식이 요약되어 있습니다.</span><span class="sxs-lookup"><span data-stu-id="a15a3-296">The following table summarizes how the table entity operations use ETag values:</span></span>

| <span data-ttu-id="a15a3-297">작업</span><span class="sxs-lookup"><span data-stu-id="a15a3-297">Operation</span></span> | <span data-ttu-id="a15a3-298">ETag 값 반환</span><span class="sxs-lookup"><span data-stu-id="a15a3-298">Returns ETag value</span></span> | <span data-ttu-id="a15a3-299">If-Match 요청 헤더 필요 여부</span><span class="sxs-lookup"><span data-stu-id="a15a3-299">Requires If-Match request header</span></span> |
|:--- |:--- |:--- |
| <span data-ttu-id="a15a3-300">엔터티 쿼리</span><span class="sxs-lookup"><span data-stu-id="a15a3-300">Query Entities</span></span> |<span data-ttu-id="a15a3-301">예</span><span class="sxs-lookup"><span data-stu-id="a15a3-301">Yes</span></span> |<span data-ttu-id="a15a3-302">아니요</span><span class="sxs-lookup"><span data-stu-id="a15a3-302">No</span></span> |
| <span data-ttu-id="a15a3-303">엔터티 삽입</span><span class="sxs-lookup"><span data-stu-id="a15a3-303">Insert Entity</span></span> |<span data-ttu-id="a15a3-304">예</span><span class="sxs-lookup"><span data-stu-id="a15a3-304">Yes</span></span> |<span data-ttu-id="a15a3-305">아니요</span><span class="sxs-lookup"><span data-stu-id="a15a3-305">No</span></span> |
| <span data-ttu-id="a15a3-306">엔터티 업데이트</span><span class="sxs-lookup"><span data-stu-id="a15a3-306">Update Entity</span></span> |<span data-ttu-id="a15a3-307">예</span><span class="sxs-lookup"><span data-stu-id="a15a3-307">Yes</span></span> |<span data-ttu-id="a15a3-308">예</span><span class="sxs-lookup"><span data-stu-id="a15a3-308">Yes</span></span> |
| <span data-ttu-id="a15a3-309">엔터티 병합</span><span class="sxs-lookup"><span data-stu-id="a15a3-309">Merge Entity</span></span> |<span data-ttu-id="a15a3-310">예</span><span class="sxs-lookup"><span data-stu-id="a15a3-310">Yes</span></span> |<span data-ttu-id="a15a3-311">예</span><span class="sxs-lookup"><span data-stu-id="a15a3-311">Yes</span></span> |
| <span data-ttu-id="a15a3-312">엔터티 삭제</span><span class="sxs-lookup"><span data-stu-id="a15a3-312">Delete Entity</span></span> |<span data-ttu-id="a15a3-313">아니요</span><span class="sxs-lookup"><span data-stu-id="a15a3-313">No</span></span> |<span data-ttu-id="a15a3-314">예</span><span class="sxs-lookup"><span data-stu-id="a15a3-314">Yes</span></span> |
| <span data-ttu-id="a15a3-315">엔터티 삽입 또는 바꾸기</span><span class="sxs-lookup"><span data-stu-id="a15a3-315">Insert or Replace Entity</span></span> |<span data-ttu-id="a15a3-316">예</span><span class="sxs-lookup"><span data-stu-id="a15a3-316">Yes</span></span> |<span data-ttu-id="a15a3-317">아니요</span><span class="sxs-lookup"><span data-stu-id="a15a3-317">No</span></span> |
| <span data-ttu-id="a15a3-318">엔터티 삽입 또는 병합</span><span class="sxs-lookup"><span data-stu-id="a15a3-318">Insert or Merge Entity</span></span> |<span data-ttu-id="a15a3-319">예</span><span class="sxs-lookup"><span data-stu-id="a15a3-319">Yes</span></span> |<span data-ttu-id="a15a3-320">아니요</span><span class="sxs-lookup"><span data-stu-id="a15a3-320">No</span></span> |

<span data-ttu-id="a15a3-321">**엔터티 삽입 또는 바꾸기**와 **엔터티 삽입 또는 병합** 작업에서는 테이블 서비스에 ETag 값을 보내지 않으므로 동시성 검사를 수행하지 *않습니다*.</span><span class="sxs-lookup"><span data-stu-id="a15a3-321">Note that the **Insert or Replace Entity** and **Insert or Merge Entity** operations do *not* perform any concurrency checks because they do not send an ETag value to the table service.</span></span>  

<span data-ttu-id="a15a3-322">일반적으로 테이블을 사용하는 개발자는 확장 가능한 응용 프로그램을 개발할 때 낙관적 동시성을 사용해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="a15a3-322">In general developers using tables should rely on optimistic concurrency when developing scalable applications.</span></span> <span data-ttu-id="a15a3-323">비관적 잠금이 필요한 경우 개발자가 테이블에 액세스할 때 사용할 수 있는 한 가지 방법은 각 테이블에 대해 지정된 Blob를 할당하고 테이블에 작업을 수행하기 전에 Blob에 대한 임대를 받는 것입니다.</span><span class="sxs-lookup"><span data-stu-id="a15a3-323">If pessimistic locking is needed, one approach developers can take when accessing Tables is to assign a designated blob for each table and try to take a lease on the blob before operating on the table.</span></span> <span data-ttu-id="a15a3-324">이 방식을 사용하는 경우 응용 프로그램은 테이블에 작업을 수행하기 전에 모든 데이터 액세스 경로가 임대를 획득하는지 확인해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="a15a3-324">This approach does require the application to ensure all data access paths obtain the lease prior to operating on the table.</span></span> <span data-ttu-id="a15a3-325">또한 최소 임대 시간은 15초이므로 확장성을 신중하게 고려해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="a15a3-325">You should also note that the minimum lease time is 15 seconds which requires careful consideration for scalability.</span></span>  

<span data-ttu-id="a15a3-326">자세한 내용은 다음을 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="a15a3-326">For more information see:</span></span>  

* [<span data-ttu-id="a15a3-327">엔터티에 대한 작업</span><span class="sxs-lookup"><span data-stu-id="a15a3-327">Operations on Entities</span></span>](http://msdn.microsoft.com/library/azure/dd179375.aspx)  

## <a name="managing-concurrency-in-the-queue-service"></a><span data-ttu-id="a15a3-328">큐 서비스에서 동시성 관리</span><span class="sxs-lookup"><span data-stu-id="a15a3-328">Managing Concurrency in the Queue Service</span></span>
<span data-ttu-id="a15a3-329">큐 서비스에서 동시성이 중요한 시나리오 중 하나는 여러 클라이언트가 큐에서 메시지를 검색할 때입니다.</span><span class="sxs-lookup"><span data-stu-id="a15a3-329">One scenario in which concurrency is a concern in the queueing service is where multiple clients are retrieving messages from a queue.</span></span> <span data-ttu-id="a15a3-330">큐에서 메시지를 검색할 때 응답에는 메시지와 PopReceipt 값(메시지를 삭제할 때 필요함)이 포함됩니다.</span><span class="sxs-lookup"><span data-stu-id="a15a3-330">When a message is retrieved from the queue, the response includes the message and a pop receipt value, which is required to delete the message.</span></span> <span data-ttu-id="a15a3-331">메시지는 큐에서 자동으로 삭제되지 않으며 검색된 후 visibilitytimeout 매개 변수로 지정된 시간 간격 동안 다른 클라이언트에는 표시되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="a15a3-331">The message is not automatically deleted from the queue, but after it has been retrieved, it is not visible to other clients for the time interval specified by the visibilitytimeout parameter.</span></span> <span data-ttu-id="a15a3-332">메시지를 검색하는 클라이언트는 메시지가 처리된 후 응답의 TimeNextVisible 요소로 지정된 시간 전에 메시지를 삭제해야 합니다. 이 시간은 visibilitytimeout 매개 변수의 값을 기준으로 계산됩니다.</span><span class="sxs-lookup"><span data-stu-id="a15a3-332">The client that retrieves the message is expected to delete the message after it has been processed, and before the time specified by the TimeNextVisible element of the response, which is calculated based on the value of the visibilitytimeout parameter.</span></span> <span data-ttu-id="a15a3-333">visibilitytimeout의 값을 메시지가 검색된 시간에 합하여 TimeNextVisible의 값을 결정합니다.</span><span class="sxs-lookup"><span data-stu-id="a15a3-333">The value of visibilitytimeout is added to the time at which the message is retrieved to determine the value of TimeNextVisible.</span></span>  

<span data-ttu-id="a15a3-334">큐 서비스는 낙관적 동시성이나 비관적 동시성을 지원하지 않으므로 큐에서 검색된 메시지를 처리하는 클라이언트는 메시지가 idempotent 방식으로 처리되는지를 확인해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="a15a3-334">The queue service does not have support for either optimistic or pessimistic concurrency and for this reason clients processing messages retrieved from a queue should ensure messages are processed in an idempotent manner.</span></span> <span data-ttu-id="a15a3-335">SetQueueServiceProperties, SetQueueMetaData, SetQueueACL, UpdateMessage 등의 업데이트 작업에는 마지막 작성자의 업데이트 적용 전략이 사용됩니다.</span><span class="sxs-lookup"><span data-stu-id="a15a3-335">A last writer wins strategy is used for update operations such as SetQueueServiceProperties, SetQueueMetaData, SetQueueACL and UpdateMessage.</span></span>  

<span data-ttu-id="a15a3-336">자세한 내용은 다음을 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="a15a3-336">For more information see:</span></span>  

* [<span data-ttu-id="a15a3-337">큐 서비스 REST API</span><span class="sxs-lookup"><span data-stu-id="a15a3-337">Queue Service REST API</span></span>](http://msdn.microsoft.com/library/azure/dd179363.aspx)
* [<span data-ttu-id="a15a3-338">메시지 가져오기</span><span class="sxs-lookup"><span data-stu-id="a15a3-338">Get Messages</span></span>](http://msdn.microsoft.com/library/azure/dd179474.aspx)  

## <a name="managing-concurrency-in-the-file-service"></a><span data-ttu-id="a15a3-339">파일 서비스에서 동시성 관리</span><span class="sxs-lookup"><span data-stu-id="a15a3-339">Managing Concurrency in the File Service</span></span>
<span data-ttu-id="a15a3-340">서로 다른 두 프로토콜 끝점인 SMB와 REST를 사용하여 파일 서비스에 액세스할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="a15a3-340">The file service can be accessed using two different protocol endpoints – SMB and REST.</span></span> <span data-ttu-id="a15a3-341">REST 서비스는 낙관적 잠금이나 비관적 잠금을 지원하지 않으며 모든 업데이트는 마지막 작성자의 업데이트 적용 전략을 따릅니다.</span><span class="sxs-lookup"><span data-stu-id="a15a3-341">The REST service does not have support for either optimistic locking or pessimistic locking and all updates will follow a last writer wins strategy.</span></span> <span data-ttu-id="a15a3-342">파일 공유를 탑재하는 SMB 클라이언트는 파일 시스템 잠금 메커니즘을 활용하여 공유 파일에 대한 액세스를 관리할 수 있습니다. 여기에는 비관적 잠금을 수행하는 기능이 포함됩니다.</span><span class="sxs-lookup"><span data-stu-id="a15a3-342">SMB clients that mount file shares can leverage file system locking mechanisms to manage access to shared files – including the ability to perform pessimistic locking.</span></span> <span data-ttu-id="a15a3-343">SMB 클라이언트는 파일을 열 때 파일 액세스 및 공유 모드를 모두 지정합니다.</span><span class="sxs-lookup"><span data-stu-id="a15a3-343">When an SMB client opens a file, it specifies both the file access and share mode.</span></span> <span data-ttu-id="a15a3-344">파일 공유 모드를 "없음"으로 지정하는 동시에 파일 액세스 옵션을 "쓰기" 또는 "읽기/쓰기"로 설정하면 파일을 닫을 때까지 SMB 클라이언트가 파일을 잠급니다.</span><span class="sxs-lookup"><span data-stu-id="a15a3-344">Setting a File Access option of "Write" or "Read/Write" along with a File Share mode of "None" will result in the file being locked by an SMB client until the file is closed.</span></span> <span data-ttu-id="a15a3-345">SMB 클라이언트가 파일을 잠근 경우 해당 파일에 대해 REST 작업을 시도하면 REST 서비스가 상태 코드 409(충돌) 및 오류 코드 SharingViolation을 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="a15a3-345">If REST operation is attempted on a file where an SMB client has the file locked the REST service will return status code 409 (Conflict) with error code SharingViolation.</span></span>  

<span data-ttu-id="a15a3-346">SMB 클라이언트는 삭제를 위해 파일을 열 때 해당 파일에 대한 기타 모든 SMB 클라이언트 열기 핸들이 닫힐 때까지 파일을 삭제 보류 중으로 표시합니다.</span><span class="sxs-lookup"><span data-stu-id="a15a3-346">When an SMB client opens a file for delete, it marks the file as pending delete until all other SMB client open handles on that file are closed.</span></span> <span data-ttu-id="a15a3-347">파일이 삭제 보류 중으로 표시되어 있는 동안 해당 파일에 대해 REST 작업을 수행하면 상태 코드 409(충돌)와 오류 코드 SMBDeletePending이 반환됩니다.</span><span class="sxs-lookup"><span data-stu-id="a15a3-347">While a file is marked as pending delete, any REST operation on that file will return status code 409 (Conflict) with error code SMBDeletePending.</span></span> <span data-ttu-id="a15a3-348">SMB 클라이언트가 파일을 닫기 전에 삭제 보류 중 플래그를 제거할 수 있으므로 상태 코드 404(찾을 수 없음)는 반환되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="a15a3-348">Status code 404 (Not Found) is not returned since it is possible for the SMB client to remove the pending deletion flag prior to closing the file.</span></span> <span data-ttu-id="a15a3-349">즉, 파일이 제거된 경우에만 상태 코드 404(찾을 수 없음)가 반환됩니다.</span><span class="sxs-lookup"><span data-stu-id="a15a3-349">In other words, status code 404 (Not Found) is only expected when the file has been removed.</span></span> <span data-ttu-id="a15a3-350">SMB 삭제 보류 중 상태인 파일은 파일 나열 결과에 표시되지 않습니다. 또한 REST 파일 삭제 및 REST 디렉터리 삭제 작업은 자동으로 커밋되므로 파일이 삭제 보류 중 상태가 되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="a15a3-350">Note that while a file is in a SMB pending delete state, it will not be included in the List Files results.Also note that the REST Delete File and REST Delete Directory operations are committed atomically and do not result in pending delete state.</span></span>  

<span data-ttu-id="a15a3-351">자세한 내용은 다음을 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="a15a3-351">For more information see:</span></span>  

* [<span data-ttu-id="a15a3-352">파일 잠금 관리</span><span class="sxs-lookup"><span data-stu-id="a15a3-352">Managing File Locks</span></span>](http://msdn.microsoft.com/library/azure/dn194265.aspx)  

## <a name="summary-and-next-steps"></a><span data-ttu-id="a15a3-353">요약 및 다음 단계</span><span class="sxs-lookup"><span data-stu-id="a15a3-353">Summary and Next Steps</span></span>
<span data-ttu-id="a15a3-354">Microsoft Azure 저장소 서비스는 개발자가 기본적으로 제공하려는 동시성 및 데이터 일관성과 같은 주요 디자인 가정 사항을 다시 고려하거나 절충하지 않고도 매우 복잡한 온라인 응용 프로그램의 요구 사항을 충족할 수 있도록 디자인되었습니다.</span><span class="sxs-lookup"><span data-stu-id="a15a3-354">The Microsoft Azure Storage service has been designed to meet the needs of the most complex online applications without forcing developers to compromise or rethink key design assumptions such as concurrency and data consistency that they have come to take for granted.</span></span>  

<span data-ttu-id="a15a3-355">이 블로그에서 참조하는 전체 샘플 응용 프로그램은 다음 문서를 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="a15a3-355">For the complete sample application referenced in this blog:</span></span>  

* [<span data-ttu-id="a15a3-356">Azure 저장소를 사용하여 동시성 관리 - 샘플 응용 프로그램</span><span class="sxs-lookup"><span data-stu-id="a15a3-356">Managing Concurrency using Azure Storage - Sample Application</span></span>](http://code.msdn.microsoft.com/Managing-Concurrency-using-56018114)  

<span data-ttu-id="a15a3-357">Azure 저장소에 대한 자세한 내용은 다음을 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="a15a3-357">For more information on Azure Storage see:</span></span>  

* [<span data-ttu-id="a15a3-358">Microsoft Azure 저장소 홈페이지</span><span class="sxs-lookup"><span data-stu-id="a15a3-358">Microsoft Azure Storage Home Page</span></span>](https://azure.microsoft.com/services/storage/)
* [<span data-ttu-id="a15a3-359">Azure 저장소 소개</span><span class="sxs-lookup"><span data-stu-id="a15a3-359">Introduction to Azure Storage</span></span>](storage-introduction.md)
* <span data-ttu-id="a15a3-360">[Blob](storage-dotnet-how-to-use-blobs.md), [테이블](storage-dotnet-how-to-use-tables.md), [큐](storage-dotnet-how-to-use-queues.md) 및 [파일](storage-dotnet-how-to-use-files.md)에 대한 저장소 시작</span><span class="sxs-lookup"><span data-stu-id="a15a3-360">Storage Getting Started for [Blob](storage-dotnet-how-to-use-blobs.md), [Table](storage-dotnet-how-to-use-tables.md),  [Queues](storage-dotnet-how-to-use-queues.md), and [Files](storage-dotnet-how-to-use-files.md)</span></span>
* <span data-ttu-id="a15a3-361">저장소 아키텍처 – [Azure 저장소: 강력한 일관성과 함께 항상 사용 가능한 클라우드 저장소 서비스](http://blogs.msdn.com/b/windowsazurestorage/archive/2011/11/20/windows-azure-storage-a-highly-available-cloud-storage-service-with-strong-consistency.aspx)</span><span class="sxs-lookup"><span data-stu-id="a15a3-361">Storage Architecture – [Azure Storage : A Highly Available Cloud Storage Service with Strong Consistency](http://blogs.msdn.com/b/windowsazurestorage/archive/2011/11/20/windows-azure-storage-a-highly-available-cloud-storage-service-with-strong-consistency.aspx)</span></span>

