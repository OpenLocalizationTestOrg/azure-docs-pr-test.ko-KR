---
title: "Azure Premium Storage: 성능을 위한 설계 | Microsoft Docs"
description: "Azure 프리미엄 저장소를 사용하여 고성능 응용 프로그램을 설계합니다. 프리미엄 저장소는 Azure 가상 컴퓨터에서 실행되는 I/O 사용량이 많은 작업에 대해 대기 시간이 짧은 고성능 디스크 지원을 제공합니다."
services: storage
documentationcenter: na
author: aungoo-msft
manager: tadb
editor: tysonn
ms.assetid: e6a409c3-d31a-4704-a93c-0a04fdc95960
ms.service: storage
ms.workload: storage
ms.tgt_pltfrm: na
ms.devlang: na
ms.topic: article
ms.date: 06/27/2017
ms.author: aungoo
ms.openlocfilehash: 7bd38be9f8e1160ebf0d7c5ed51fd31d89481881
ms.sourcegitcommit: f537befafb079256fba0529ee554c034d73f36b0
ms.translationtype: MT
ms.contentlocale: ko-KR
ms.lasthandoff: 07/11/2017
---
# <a name="azure-premium-storage-design-for-high-performance"></a><span data-ttu-id="5a457-104">Azure 프리미엄 저장소: 고성능을 위한 설계</span><span class="sxs-lookup"><span data-stu-id="5a457-104">Azure Premium Storage: Design for High Performance</span></span>
## <a name="overview"></a><span data-ttu-id="5a457-105">개요</span><span class="sxs-lookup"><span data-stu-id="5a457-105">Overview</span></span>
<span data-ttu-id="5a457-106">이 문서는 Azure 프리미엄 저장소를 사용하여 고성능 응용 프로그램을 구축하기 위한 지침을 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="5a457-106">This article provides guidelines for building high performance applications using Azure Premium Storage.</span></span> <span data-ttu-id="5a457-107">응용 프로그램에서 사용되는 기술에 적용 가능한 성능 모범 사례가 결합된 이 문서에 제공된 지침을 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="5a457-107">You can use the instructions provided in this document combined with performance best practices applicable to technologies used by your application.</span></span> <span data-ttu-id="5a457-108">지침을 설명하기 위해 이 문서 전체에서 한 예로 프리미엄 저장소에서 실행되는 SQL Server를 사용했습니다.</span><span class="sxs-lookup"><span data-stu-id="5a457-108">To illustrate the guidelines, we have used SQL Server running on Premium Storage as an example throughout this document.</span></span>

<span data-ttu-id="5a457-109">이 문서에서는 저장소 계층에 대한 성능 시나리오를 해결하지만 사용자는 응용 프로그램 계층을 최적화해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="5a457-109">While we address performance scenarios for the Storage layer in this article, you will need to optimize the application layer.</span></span> <span data-ttu-id="5a457-110">예를 들어 Azure 프리미엄 저장소에 SharePoint 팜을 호스팅하는 경우 데이터베이스 서버를 최적화하기 위해 이 문서에서 SQL Server 예제를 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="5a457-110">For example, if you are hosting a SharePoint Farm on Azure Premium Storage, you can use the SQL Server examples from this article to optimize the database server.</span></span> <span data-ttu-id="5a457-111">또한 최적의 성능을 얻기 위해 SharePoint 팜의 웹 서버 및 응용 프로그램 서버를 최적화합니다.</span><span class="sxs-lookup"><span data-stu-id="5a457-111">Additionally, optimize the SharePoint Farm's Web server and Application server to get the most performance.</span></span>

<span data-ttu-id="5a457-112">이 문서에서는 Azure 프리미엄 저장소에서 응용 프로그램 성능을 최적화하는 방법에 대한 다음과 같은 일반적인 질문에 대답합니다.</span><span class="sxs-lookup"><span data-stu-id="5a457-112">This article will help answer following common questions about optimizing application performance on Azure Premium Storage,</span></span>

* <span data-ttu-id="5a457-113">응용 프로그램 성능을 측정하는 방법은 무엇입니까?</span><span class="sxs-lookup"><span data-stu-id="5a457-113">How to measure your application performance?</span></span>  
* <span data-ttu-id="5a457-114">예상되는 고성능이 표시되지 않는 이유는 무엇입니까?</span><span class="sxs-lookup"><span data-stu-id="5a457-114">Why are you not seeing expected high performance?</span></span>  
* <span data-ttu-id="5a457-115">프리미엄 저장소에서 응용 프로그램 성능에 영향을 주는 요인은 무엇입니까?</span><span class="sxs-lookup"><span data-stu-id="5a457-115">Which factors influence your application performance on Premium Storage?</span></span>  
* <span data-ttu-id="5a457-116">이러한 요소가 프리미엄 저장소의 응용 프로그램 성능에 주는 영향은 무엇입니까?</span><span class="sxs-lookup"><span data-stu-id="5a457-116">How do these factors influence performance of your application on Premium Storage?</span></span>  
* <span data-ttu-id="5a457-117">IOPS, 대역폭 및 대기 시간을 최적화하는 방법은 무엇입니까?</span><span class="sxs-lookup"><span data-stu-id="5a457-117">How can you optimize for IOPS, Bandwidth and Latency?</span></span>  

<span data-ttu-id="5a457-118">프리미엄 저장소에서 실행되는 작업은 성능이 매우 중요하므로 특별히 프리미엄 저장소에 대한 지침을 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="5a457-118">We have provided these guidelines specifically for Premium Storage because workloads running on Premium Storage are highly performance sensitive.</span></span> <span data-ttu-id="5a457-119">적절한 예제를 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="5a457-119">We have provided examples where appropriate.</span></span> <span data-ttu-id="5a457-120">표준 저장소 디스크가 있는 IaaS VM에서 실행되는 응용 프로그램에 이러한 지침 중 일부를 적용할 수도 있습니다.</span><span class="sxs-lookup"><span data-stu-id="5a457-120">You can also apply some of these guidelines to applications running on IaaS VMs with Standard Storage disks.</span></span>

<span data-ttu-id="5a457-121">시작하기 전에 Premium Storage를 처음 사용하는 경우 먼저 [Premium Storage: Azure 가상 컴퓨터 워크로드를 위한 고성능 저장소](storage-premium-storage.md) 및 [Azure Storage 확장성 및 성능 목표](storage-scalability-targets.md) 문서를 읽어 보세요.</span><span class="sxs-lookup"><span data-stu-id="5a457-121">Before you begin, if you are new to Premium Storage, first read the [Premium Storage: High-Performance Storage for Azure Virtual Machine Workloads](storage-premium-storage.md) and [Azure Storage Scalability and Performance Targets](storage-scalability-targets.md) articles.</span></span>

## <a name="application-performance-indicators"></a><span data-ttu-id="5a457-122">응용 프로그램 성과 지표</span><span class="sxs-lookup"><span data-stu-id="5a457-122">Application Performance Indicators</span></span>
<span data-ttu-id="5a457-123">응용 프로그램이 사용자 요청을 얼마나 빨리 처리하는지, 응용 프로그램이 요청 당 얼마나 많은 데이터를 처리하는지, 응용 프로그램이 특정 기간 동안 얼마나 많은 요청을 처리하는지, 사용자가 요청을 제출한 후 응답을 받기까지 얼마나 오래 기다려야 하는지와 같은 성과 지표를 사용하여 응용 프로그램이 잘 수행하는지 여부를 평가합니다.</span><span class="sxs-lookup"><span data-stu-id="5a457-123">We assess whether an application is performing well or not using performance indicators like, how fast an application is processing a user request, how much data an application is processing per request, how many requests is an application processing in a specific period of time, how long a user has to wait to get a response after submitting their request.</span></span> <span data-ttu-id="5a457-124">이러한 성과 지표에 대한 기술 용어는 IOPS, 처리량 또는 대역폭 및 대기 시간입니다.</span><span class="sxs-lookup"><span data-stu-id="5a457-124">The technical terms for these performance indicators are, IOPS, Throughput or Bandwidth, and Latency.</span></span>

<span data-ttu-id="5a457-125">이 섹션에서는 프리미엄 저장소의 컨텍스트에서 일반적인 성과 지표를 설명합니다.</span><span class="sxs-lookup"><span data-stu-id="5a457-125">In this section, we will discuss the common performance indicators in the context of Premium Storage.</span></span> <span data-ttu-id="5a457-126">다음 섹션, 응용 프로그램 요구 사항 수집에서는 응용 프로그램에 대한 이러한 성과 지표를 측정하는 방법을 배웁니다.</span><span class="sxs-lookup"><span data-stu-id="5a457-126">In the following section, Gathering Application Requirements, you will learn how to measure these performance indicators for your application.</span></span> <span data-ttu-id="5a457-127">응용 프로그램 성능 최적화의 뒷부분에서 이러한 성과 지표 및 최적화를 위한 권장 사항에 영향을 주는 요소에 대해 배웁니다.</span><span class="sxs-lookup"><span data-stu-id="5a457-127">Later in Optimizing Application Performance, you will learn about the factors affecting these performance indicators and recommendations to optimize them.</span></span>

## <a name="iops"></a><span data-ttu-id="5a457-128">IOPS</span><span class="sxs-lookup"><span data-stu-id="5a457-128">IOPS</span></span>
<span data-ttu-id="5a457-129">IOPS는 응용 프로그램에서 저장소 디스크에 1초 동안 보내는 요청 수입니다.</span><span class="sxs-lookup"><span data-stu-id="5a457-129">IOPS is number of requests that your application is sending to the storage disks in one second.</span></span> <span data-ttu-id="5a457-130">입력/출력 작업은 읽기나 쓰기, 순차 또는 임의가 될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="5a457-130">An input/output operation could be read or write, sequential or random.</span></span> <span data-ttu-id="5a457-131">온라인 소매 웹 사이트와 같은 OLTP 응용 프로그램은 많은 동시 사용자 요청을 즉시 처리해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="5a457-131">OLTP applications like an online retail website need to process many concurrent user requests immediately.</span></span> <span data-ttu-id="5a457-132">사용자 요청은 응용 프로그램에서 신속하게 처리해야 할 삽입 및 업데이트 집약적 데이터베이스 트랜잭션입니다.</span><span class="sxs-lookup"><span data-stu-id="5a457-132">The user requests are insert and update intensive database transactions, which the application must process quickly.</span></span> <span data-ttu-id="5a457-133">따라서 OLTP 응용 프로그램에는 매우 높은 IOPS가 필요합니다.</span><span class="sxs-lookup"><span data-stu-id="5a457-133">Therefore, OLTP applications require very high IOPS.</span></span> <span data-ttu-id="5a457-134">이러한 응용 프로그램에서는 수백만 개의 작고 임의의 IO 요청을 처리합니다.</span><span class="sxs-lookup"><span data-stu-id="5a457-134">Such applications handle millions of small and random IO requests.</span></span> <span data-ttu-id="5a457-135">이러한 응용 프로그램을 사용하는 경우 IOPS에 대해 최적화하기 위해 응용 프로그램 인프라를 설계해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="5a457-135">If you have such an application, you must design the application infrastructure to optimize for IOPS.</span></span> <span data-ttu-id="5a457-136">이후 섹션 *응용 프로그램 성능 최적화*에서 높은 IOPS를 얻기 위해는 고려해야 하는 모든 요소를 자세히 설명합니다.</span><span class="sxs-lookup"><span data-stu-id="5a457-136">In the later section, *Optimizing Application Performance*, we discuss in detail all the factors that you must consider to get high IOPS.</span></span>

<span data-ttu-id="5a457-137">높은 확장성의 VM에 프리미엄 저장소에 디스크를 연결하는 경우 Azure는 디스크 사양에 따라 보장된 IOPS 수에 대해 프로비전합니다.</span><span class="sxs-lookup"><span data-stu-id="5a457-137">When you attach a premium storage disk to your high scale VM, Azure provisions for you a guaranteed number of IOPS as per the disk specification.</span></span> <span data-ttu-id="5a457-138">예를 들어 P50 디스크는 7500IOPS를 프로비전합니다.</span><span class="sxs-lookup"><span data-stu-id="5a457-138">For example, a P50 disk provisions 7500 IOPS.</span></span> <span data-ttu-id="5a457-139">각 높은 확장성의 VM 크기에는 유지할 수 있는 특정 IOPS 제한이 있습니다.</span><span class="sxs-lookup"><span data-stu-id="5a457-139">Each high scale VM size also has a specific IOPS limit that it can sustain.</span></span> <span data-ttu-id="5a457-140">예를 들어 표준 GS5 VM에는 80,000 IOPS 제한이 있습니다.</span><span class="sxs-lookup"><span data-stu-id="5a457-140">For example, a Standard GS5 VM has 80,000 IOPS limit.</span></span>

## <a name="throughput"></a><span data-ttu-id="5a457-141">처리량</span><span class="sxs-lookup"><span data-stu-id="5a457-141">Throughput</span></span>
<span data-ttu-id="5a457-142">처리량 또는 대역폭은 응용 프로그램이 지정된 간격의 저장소 디스크에 보내는 데이터의 양입니다.</span><span class="sxs-lookup"><span data-stu-id="5a457-142">Throughput or Bandwidth is the amount of data that your application is sending to the storage disks in a specified interval.</span></span> <span data-ttu-id="5a457-143">응용 프로그램이 대량 IO 단위 크기를 사용하여 입력/출력 작업을 수행하는 경우 높은 처리량이 필요합니다.</span><span class="sxs-lookup"><span data-stu-id="5a457-143">If your application is performing input/output operations with large IO unit sizes, it requires high Throughput.</span></span> <span data-ttu-id="5a457-144">데이터 웨어하우스 응용 프로그램은 한 번에 많은 양의 데이터에 액세스하고 일반적으로 대량 작업을 수행하는 스캔 집약적인 작업을 실행하는 경향이 있습니다.</span><span class="sxs-lookup"><span data-stu-id="5a457-144">Data warehouse applications tend to issue scan intensive operations that access large portions of data at a time and commonly perform bulk operations.</span></span> <span data-ttu-id="5a457-145">즉, 이러한 응용 프로그램에는 더 높은 처리량이 필요합니다.</span><span class="sxs-lookup"><span data-stu-id="5a457-145">In other words, such applications require higher Throughput.</span></span> <span data-ttu-id="5a457-146">이러한 응용 프로그램을 사용하는 경우 처리량에 대해 최적화하기 위해 해당 인프라를 설계해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="5a457-146">If you have such an application, you must design its infrastructure to optimize for Throughput.</span></span> <span data-ttu-id="5a457-147">다음 섹션에서 이를 달성하기 위해 조정해야 하는 요인을 자세히 설명합니다.</span><span class="sxs-lookup"><span data-stu-id="5a457-147">In the next section, we discuss in detail the factors you must tune to achieve this.</span></span>

<span data-ttu-id="5a457-148">프리미엄 저장소 디스크를 높은 확장성의 VM에 연결하는 경우 Azure는 해당 디스크 사양에 따라 처리량을 프로비전합니다.</span><span class="sxs-lookup"><span data-stu-id="5a457-148">When you attach a premium storage disk to a high scale VM, Azure provisions Throughput as per that disk specification.</span></span> <span data-ttu-id="5a457-149">예를 들어 P50 디스크는 초당 250MB 디스크 처리량을 프로비전합니다.</span><span class="sxs-lookup"><span data-stu-id="5a457-149">For example, a P50 disk provisions 250 MB per second disk Throughput.</span></span> <span data-ttu-id="5a457-150">높은 확장성의 VM 크기마다 유지할 수 있는 특정 처리량 제한이 있습니다.</span><span class="sxs-lookup"><span data-stu-id="5a457-150">Each high scale VM size also has as specific Throughput limit that it can sustain.</span></span> <span data-ttu-id="5a457-151">예를 들어 표준 GS5 VM에는 초당 2,000MB의 최대 처리량이 있습니다.</span><span class="sxs-lookup"><span data-stu-id="5a457-151">For example, Standard GS5 VM has a maximum throughput of 2,000 MB per second.</span></span> 

<span data-ttu-id="5a457-152">아래 수식에 표시된 것처럼 처리량과 IOPS 간에 관계가 있습니다.</span><span class="sxs-lookup"><span data-stu-id="5a457-152">There is a relation between Throughput and IOPS as shown in the formula below.</span></span>

![](media/storage-premium-storage-performance/image1.png)

<span data-ttu-id="5a457-153">따라서 응용 프로그램에 필요한 최적의 처리량 및 IOPS 값을 결정하는 것이 중요합니다.</span><span class="sxs-lookup"><span data-stu-id="5a457-153">Therefore, it is important to determine the optimal Throughput and IOPS values that your application requires.</span></span> <span data-ttu-id="5a457-154">하나를 최적화하려고 할 때 다른 하나도 영향을 받습니다.</span><span class="sxs-lookup"><span data-stu-id="5a457-154">As you try to optimize one, the other also gets affected.</span></span> <span data-ttu-id="5a457-155">이후 섹션 *응용 프로그램 성능 최적화*에서 IOPS 및 처리량 최적화에 대한 자세한 정보에 대해 설명합니다.</span><span class="sxs-lookup"><span data-stu-id="5a457-155">In a later section, *Optimizing Application Performance*, we will discuss in more details about optimizing IOPS and Throughput.</span></span>

## <a name="latency"></a><span data-ttu-id="5a457-156">대기 시간</span><span class="sxs-lookup"><span data-stu-id="5a457-156">Latency</span></span>
<span data-ttu-id="5a457-157">대기 시간은 응용 프로그램이 단일 요청을 수신하고 이를 저장소 디스크에 보내고 클라이언트에 응답을 보내는데 걸리는 시간입니다.</span><span class="sxs-lookup"><span data-stu-id="5a457-157">Latency is the time it takes an application to receive a single request, send it to the storage disks and send the response to the client.</span></span> <span data-ttu-id="5a457-158">이는 IOPS 및 처리량 외에도 응용 프로그램의 성능에 대한 중요한 측정입니다.</span><span class="sxs-lookup"><span data-stu-id="5a457-158">This is a critical measure of an application's performance in addition to IOPS and Throughput.</span></span> <span data-ttu-id="5a457-159">프리미엄 저장소 디스크의 대기 시간은 요청에 대한 정보를 검색하고 응용 프로그램에게 다시 전달하는데 걸리는 시간입니다.</span><span class="sxs-lookup"><span data-stu-id="5a457-159">The Latency of a premium storage disk is the time it takes to retrieve the information for a request and communicate it back to your application.</span></span> <span data-ttu-id="5a457-160">프리미엄 저장소는 일관된 낮은 대기 시간을 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="5a457-160">Premium Storage provides consistent low latencies.</span></span> <span data-ttu-id="5a457-161">프리미엄 저장소 디스크에 읽기 전용 호스트 캐싱을 사용하는 경우 훨씬 더 낮은 읽기 대기 시간을 얻을 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="5a457-161">If you enable ReadOnly host caching on premium storage disks, you can get much lower read latency.</span></span> <span data-ttu-id="5a457-162">*응용 프로그램 성능 최적화*의 이후 섹션에서 디스크 캐싱에 대해 자세히 설명합니다.</span><span class="sxs-lookup"><span data-stu-id="5a457-162">We will discuss Disk Caching in more detail in later section on *Optimizing Application Performance*.</span></span>

<span data-ttu-id="5a457-163">높은 IOPS 및 처리량을 얻기 위해 응용 프로그램을 최적화하는 경우 응용 프로그램의 대기 시간에 영향을 줍니다.</span><span class="sxs-lookup"><span data-stu-id="5a457-163">When you are optimizing your application to get higher IOPS and Throughput, it will affect the Latency of your application.</span></span> <span data-ttu-id="5a457-164">응용 프로그램 성능 튜닝 후 예기치 않은 대기 시간 동작을 방지하도록 항상 응용 프로그램의 대기 시간을 평가합니다.</span><span class="sxs-lookup"><span data-stu-id="5a457-164">After tuning the application performance, always evaluate the Latency of the application to avoid unexpected high latency behavior.</span></span>

## <a name="gather-application-performance-requirements"></a><span data-ttu-id="5a457-165">응용 프로그램 성능 요구 사항 수집</span><span class="sxs-lookup"><span data-stu-id="5a457-165">Gather Application Performance Requirements</span></span>
<span data-ttu-id="5a457-166">Azure 프리미엄 저장소에서 실행되는 고성능 응용 프로그램을 설계하는 첫 번째 단계는 응용 프로그램의 성능 요구 사항을 이해하는 것입니다.</span><span class="sxs-lookup"><span data-stu-id="5a457-166">The first step in designing high performance applications running on Azure Premium Storage is, to understand the performance requirements of your application.</span></span> <span data-ttu-id="5a457-167">성능 요구 사항을 수집한 후에 최적의 성능을 얻을 수 있도록 응용 프로그램을 최적화할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="5a457-167">After you gather performance requirements, you can optimize your application to achieve the most optimal performance.</span></span>

<span data-ttu-id="5a457-168">이전 섹션에서 일반적인 성과 지표, IOPS, 처리량 및 대기 시간을 설명했습니다.</span><span class="sxs-lookup"><span data-stu-id="5a457-168">In the previous section, we explained the common performance indicators, IOPS, Throughput and Latency.</span></span> <span data-ttu-id="5a457-169">원하는 사용자 환경을 제공하기 위해 어떤 성과 지표가 응용 프로그램에 중요한지 식별해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="5a457-169">You must identify which of these performance indicators are critical to your application to deliver the desired user experience.</span></span> <span data-ttu-id="5a457-170">예를 들어 초당 수백만 개의 트랜잭션을 처리하는 OLTP 응용 프로그램에는 높은 IOPS가 가장 중요합니다.</span><span class="sxs-lookup"><span data-stu-id="5a457-170">For example, high IOPS matters most to OLTP applications processing millions of transactions in a second.</span></span> <span data-ttu-id="5a457-171">반면 초당 많은 양의 데이터를 처리하는 데이터 웨어하우스 응용 프로그램에는 높은 처리량이 중요합니다.</span><span class="sxs-lookup"><span data-stu-id="5a457-171">Whereas, high Throughput is critical for Data Warehouse applications processing large amounts of data in a second.</span></span> <span data-ttu-id="5a457-172">라이브 비디오 스트리밍 웹 사이트와 같은 실시간 응용 프로그램에는 매우 짧은 대기 시간이 중요합니다.</span><span class="sxs-lookup"><span data-stu-id="5a457-172">Extremely low Latency is crucial for real-time applications like live video streaming websites.</span></span>

<span data-ttu-id="5a457-173">다음으로 해당 수명 주기 동안 응용 프로그램의 최대 성능 요구 사항을 측정합니다.</span><span class="sxs-lookup"><span data-stu-id="5a457-173">Next, measure the maximum performance requirements of your application throughout its lifetime.</span></span> <span data-ttu-id="5a457-174">시작으로 아래 샘플 검사 목록을 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="5a457-174">Use the sample checklist below as a start.</span></span> <span data-ttu-id="5a457-175">일반, 최고 및 작업 시간 외 작업 기간 동안 최대 성능 요구 사항을 기록합니다.</span><span class="sxs-lookup"><span data-stu-id="5a457-175">Record the maximum performance requirements during normal, peak and off-hours workload periods.</span></span> <span data-ttu-id="5a457-176">모든 작업 수준에 대한 요구 사항을 파악하여 응용 프로그램의 전반적인 성능 요구 사항을 확인할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="5a457-176">By identifying requirements for all workloads levels, you will be able to determine the overall performance requirement of your application.</span></span> <span data-ttu-id="5a457-177">예를 들어 전자 상거래 웹 사이트의 일반 작업은 1년 중 대부분 동안 제공하는 트랜잭션이 됩니다.</span><span class="sxs-lookup"><span data-stu-id="5a457-177">For example, the normal workload of an e-commerce website will be the transactions it serves during most days in a year.</span></span> <span data-ttu-id="5a457-178">웹 사이트의 최대 작업은 축제 시즌 또는 특별 판매 이벤트 동안 제공하는 트랜잭션이 됩니다.</span><span class="sxs-lookup"><span data-stu-id="5a457-178">The peak workload of the website will be the transactions it serves during holiday season or special sale events.</span></span> <span data-ttu-id="5a457-179">최대 작업은 일반적으로 제한된 기간에 대해 숙련되지만 응용 프로그램이 두 번 이상 해당 일반 작업을 확장해야 할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="5a457-179">The peak workload is typically experienced for a limited period, but can require your application to scale two or more times its normal operation.</span></span> <span data-ttu-id="5a457-180">50 백분위수, 90 백분위수 및 99 백분위수 요구 사항에 알아봅니다.</span><span class="sxs-lookup"><span data-stu-id="5a457-180">Find out the 50 percentile, 90 percentile and 99 percentile requirements.</span></span> <span data-ttu-id="5a457-181">이렇게 하면 성능 요구 사항에서 모든 이상값을 필터링하고 올바른 값에 대한 최적화에 노력을 집중할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="5a457-181">This helps filter out any outliers in the performance requirements and you can focus your efforts on optimizing for the right values.</span></span>

<span data-ttu-id="5a457-182">**응용 프로그램 성능 요구 사항 검사 목록**</span><span class="sxs-lookup"><span data-stu-id="5a457-182">**Application Performance Requirements Checklist**</span></span>

| <span data-ttu-id="5a457-183">**성능 요구 사항**</span><span class="sxs-lookup"><span data-stu-id="5a457-183">**Performance requirements**</span></span> | <span data-ttu-id="5a457-184">**50 백분위수**</span><span class="sxs-lookup"><span data-stu-id="5a457-184">**50 Percentile**</span></span> | <span data-ttu-id="5a457-185">**90 백분위수**</span><span class="sxs-lookup"><span data-stu-id="5a457-185">**90 Percentile**</span></span> | <span data-ttu-id="5a457-186">**99 백분위수**</span><span class="sxs-lookup"><span data-stu-id="5a457-186">**99  Percentile**</span></span> |
| --- | --- | --- | --- |
| <span data-ttu-id="5a457-187">최대</span><span class="sxs-lookup"><span data-stu-id="5a457-187">Max.</span></span> <span data-ttu-id="5a457-188">초당 트랜잭션 수</span><span class="sxs-lookup"><span data-stu-id="5a457-188">Transactions per second</span></span> | | | |
| <span data-ttu-id="5a457-189">% 읽기 작업</span><span class="sxs-lookup"><span data-stu-id="5a457-189">% Read operations</span></span> | | | |
| <span data-ttu-id="5a457-190">% 쓰기 작업</span><span class="sxs-lookup"><span data-stu-id="5a457-190">% Write operations</span></span> | | | |
| <span data-ttu-id="5a457-191">% 임의 작업</span><span class="sxs-lookup"><span data-stu-id="5a457-191">% Random operations</span></span> | | | |
| <span data-ttu-id="5a457-192">% 순차적 작업</span><span class="sxs-lookup"><span data-stu-id="5a457-192">% Sequential operations</span></span> | | | |
| <span data-ttu-id="5a457-193">IO 요청 크기</span><span class="sxs-lookup"><span data-stu-id="5a457-193">IO request size</span></span> | | | |
| <span data-ttu-id="5a457-194">평균 처리량</span><span class="sxs-lookup"><span data-stu-id="5a457-194">Average Throughput</span></span> | | | |
| <span data-ttu-id="5a457-195">최대</span><span class="sxs-lookup"><span data-stu-id="5a457-195">Max.</span></span> <span data-ttu-id="5a457-196">처리량</span><span class="sxs-lookup"><span data-stu-id="5a457-196">Throughput</span></span> | | | |
| <span data-ttu-id="5a457-197">최소</span><span class="sxs-lookup"><span data-stu-id="5a457-197">Min.</span></span> <span data-ttu-id="5a457-198">대기 시간</span><span class="sxs-lookup"><span data-stu-id="5a457-198">Latency</span></span> | | | |
| <span data-ttu-id="5a457-199">평균 대기 시간</span><span class="sxs-lookup"><span data-stu-id="5a457-199">Average Latency</span></span> | | | |
| <span data-ttu-id="5a457-200">최대</span><span class="sxs-lookup"><span data-stu-id="5a457-200">Max.</span></span> <span data-ttu-id="5a457-201">CPU</span><span class="sxs-lookup"><span data-stu-id="5a457-201">CPU</span></span> | | | |
| <span data-ttu-id="5a457-202">평균 CPU</span><span class="sxs-lookup"><span data-stu-id="5a457-202">Average CPU</span></span> | | | |
| <span data-ttu-id="5a457-203">최대</span><span class="sxs-lookup"><span data-stu-id="5a457-203">Max.</span></span> <span data-ttu-id="5a457-204">메모리</span><span class="sxs-lookup"><span data-stu-id="5a457-204">Memory</span></span> | | | |
| <span data-ttu-id="5a457-205">평균 메모리</span><span class="sxs-lookup"><span data-stu-id="5a457-205">Average Memory</span></span> | | | |
| <span data-ttu-id="5a457-206">큐 크기</span><span class="sxs-lookup"><span data-stu-id="5a457-206">Queue Depth</span></span> | | | |

> [!NOTE]
> <span data-ttu-id="5a457-207">응용 프로그램의 예상된 향후 성장에 따라 이러한 숫자를 확장하는 것이 좋습니다.</span><span class="sxs-lookup"><span data-stu-id="5a457-207">You should consider scaling these numbers based on expected future growth of your application.</span></span> <span data-ttu-id="5a457-208">나중에 성능 향상을 위한 인프라를 변경하기가 더 어려울 수 있으므로 사전 확장을 계획하는 것이 좋습니다.</span><span class="sxs-lookup"><span data-stu-id="5a457-208">It is a good idea to plan for growth ahead of time, because it could be harder to change the infrastructure for improving performance later.</span></span>
>
>

<span data-ttu-id="5a457-209">기존 응용 프로그램이 있고 프리미엄 저장소로 이동하려는 경우 먼저 기존 응용 프로그램에 대해 위의 검사 목록을 빌드합니다.</span><span class="sxs-lookup"><span data-stu-id="5a457-209">If you have an existing application and want to move to Premium Storage, first build the checklist above for the existing application.</span></span> <span data-ttu-id="5a457-210">그런 다음 프리미엄 저장소에 있는 응용 프로그램의 프로토타입을 빌드하고 이 문서의 이후 섹션의 *응용 프로그램 성능 최적화* 에 설명된 지침에 따라 응용 프로그램을 설계합니다.</span><span class="sxs-lookup"><span data-stu-id="5a457-210">Then, build a prototype of your application on Premium Storage and design the application based on guidelines described in *Optimizing Application Performance* in a later section of this document.</span></span> <span data-ttu-id="5a457-211">다음 섹션에서는 성능 측정값을 수집하는데 사용할 수 있는 도구를 설명합니다.</span><span class="sxs-lookup"><span data-stu-id="5a457-211">The next section describes the tools you can use to gather the performance measurements.</span></span>

<span data-ttu-id="5a457-212">프로토타입에 대한 기존 응용 프로그램과 비슷한 검사 목록을 만듭니다.</span><span class="sxs-lookup"><span data-stu-id="5a457-212">Create a checklist similar to your existing application for the prototype.</span></span> <span data-ttu-id="5a457-213">벤치마킹 도구를 사용하여 작업을 시뮬레이션하고 프로토타입 응용 프로그램의 성능을 측정할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="5a457-213">Using Benchmarking tools you can simulate the workloads and measure performance on the prototype application.</span></span> <span data-ttu-id="5a457-214">자세한 내용은 [벤치마킹](#benchmarking) 의 섹션을 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="5a457-214">See the section on [Benchmarking](#benchmarking) to learn more.</span></span> <span data-ttu-id="5a457-215">이렇게 하여 프리미엄 저장소가 응용 프로그램 성능 요구 사항에 일치하거나 능가할 수 있는지 여부를 결정할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="5a457-215">By doing so you can determine whether Premium Storage can match or surpass your application performance requirements.</span></span> <span data-ttu-id="5a457-216">그런 다음 프로덕션 응용 프로그램에 대해 동일한 지침을 구현할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="5a457-216">Then you can implement the same guidelines for your production application.</span></span>

### <a name="counters-to-measure-application-performance-requirements"></a><span data-ttu-id="5a457-217">응용 프로그램 성능 요구 사항을 측정하기 위한 카운터</span><span class="sxs-lookup"><span data-stu-id="5a457-217">Counters to measure application performance requirements</span></span>
<span data-ttu-id="5a457-218">응용 프로그램의 성능 요구 사항을 측정하는 가장 좋은 방법은 서버의 운영 체제에서 제공하는 성능 모니터링 도구를 사용하는 것입니다.</span><span class="sxs-lookup"><span data-stu-id="5a457-218">The best way to measure performance requirements of your application, is to use performance-monitoring tools provided by the operating system of the server.</span></span> <span data-ttu-id="5a457-219">Windows용 PerfMon 및 Linux용 iostat를 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="5a457-219">You can use PerfMon for Windows and iostat for Linux.</span></span> <span data-ttu-id="5a457-220">이러한 도구는 위의 섹션에서 설명된 각 측정에 해당하는 카운터를 캡처합니다.</span><span class="sxs-lookup"><span data-stu-id="5a457-220">These tools capture counters corresponding to each measure explained in the above section.</span></span> <span data-ttu-id="5a457-221">응용 프로그램이 일반, 최고 및 작업 시간 외 작업을 실행하는 경우 이러한 카운터의 값을 캡처해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="5a457-221">You must capture the values of these counters when your application is running its normal, peak and off-hours workloads.</span></span>

<span data-ttu-id="5a457-222">PerfMon 카운터는 프로세서, 메모리, 각 논리 디스크 및 서버의 실제 디스크에 대해 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="5a457-222">The PerfMon counters are available for processor, memory and, each logical disk and physical disk of your server.</span></span> <span data-ttu-id="5a457-223">VM에서 프리미엄 저장소 디스크를 사용하는 경우 실제 디스크 카운터는 각 프리미엄 저장소 디스크에 대한 것이며 논리 디스크 카운터는 프리미엄 저장소 디스크에 생성된 각 볼륨에 대한 것입니다.</span><span class="sxs-lookup"><span data-stu-id="5a457-223">When you use premium storage disks with a VM, the physical disk counters are for each premium storage disk, and logical disk counters are for each volume created on the premium storage disks.</span></span> <span data-ttu-id="5a457-224">응용 프로그램 작업을 호스팅하는 디스크에 대한 값을 캡처해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="5a457-224">You must capture the values for the disks that host your application workload.</span></span> <span data-ttu-id="5a457-225">논리 및 실제 디스크 간에 일대일 매핑이 있는 경우 실제 디스크 카운터를 참조할 수 있으며 그렇지 않은 경우 논리 디스크 카운터를 참조합니다.</span><span class="sxs-lookup"><span data-stu-id="5a457-225">If there is a one to one mapping between logical and physical disks, you can refer to physical disk counters; otherwise refer to the logical disk counters.</span></span> <span data-ttu-id="5a457-226">Linux에서 iostat 명령은 CPU 및 디스크 사용률 보고서를 생성합니다.</span><span class="sxs-lookup"><span data-stu-id="5a457-226">On Linux, the iostat command generates a CPU and disk utilization report.</span></span> <span data-ttu-id="5a457-227">디스크 사용률 보고서는 물리적 장치 또는 파티션당 통계를 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="5a457-227">The disk utilization report provides statistics per physical device or partition.</span></span> <span data-ttu-id="5a457-228">별도 디스크에 해당 데이터와 로그가 있는 데이터베이스 서버가 있는 경우 두 디스크에 대한 이 데이터를 수집합니다.</span><span class="sxs-lookup"><span data-stu-id="5a457-228">If you have a database server with its data and log on separate disks, collect this data for both disks.</span></span> <span data-ttu-id="5a457-229">아래 표에서 디스크, 프로세서 및 메모리에 대한 카운터를 설명합니다.</span><span class="sxs-lookup"><span data-stu-id="5a457-229">Below table describes counters for disks, processor and memory:</span></span>

| <span data-ttu-id="5a457-230">카운터</span><span class="sxs-lookup"><span data-stu-id="5a457-230">Counter</span></span> | <span data-ttu-id="5a457-231">설명</span><span class="sxs-lookup"><span data-stu-id="5a457-231">Description</span></span> | <span data-ttu-id="5a457-232">PerfMon</span><span class="sxs-lookup"><span data-stu-id="5a457-232">PerfMon</span></span> | <span data-ttu-id="5a457-233">Iostat</span><span class="sxs-lookup"><span data-stu-id="5a457-233">Iostat</span></span> |
| --- | --- | --- | --- |
| <span data-ttu-id="5a457-234">**초당 IOPS 또는 트랜잭션**</span><span class="sxs-lookup"><span data-stu-id="5a457-234">**IOPS or Transactions per second**</span></span> |<span data-ttu-id="5a457-235">저장소 디스크에 발급된 초당 I/O 요청 수입니다.</span><span class="sxs-lookup"><span data-stu-id="5a457-235">Number of I/O requests issued to the storage disk per second.</span></span> |<span data-ttu-id="5a457-236">디스크 읽기/초 </span><span class="sxs-lookup"><span data-stu-id="5a457-236">Disk Reads/sec</span></span> <br> <span data-ttu-id="5a457-237">디스크 쓰기/초</span><span class="sxs-lookup"><span data-stu-id="5a457-237">Disk Writes/sec</span></span> |<span data-ttu-id="5a457-238">tps </span><span class="sxs-lookup"><span data-stu-id="5a457-238">tps</span></span> <br> <span data-ttu-id="5a457-239">r/s </span><span class="sxs-lookup"><span data-stu-id="5a457-239">r/s</span></span> <br> <span data-ttu-id="5a457-240">w/s</span><span class="sxs-lookup"><span data-stu-id="5a457-240">w/s</span></span> |
| <span data-ttu-id="5a457-241">**디스크 읽기 및 쓰기**</span><span class="sxs-lookup"><span data-stu-id="5a457-241">**Disk Reads and Writes**</span></span> |<span data-ttu-id="5a457-242">디스크에서 수행되는 읽기 및 쓰기 작업의 %입니다.</span><span class="sxs-lookup"><span data-stu-id="5a457-242">% of Reads and Write operations performed on the disk.</span></span> |<span data-ttu-id="5a457-243">% 디스크 읽기 시간 </span><span class="sxs-lookup"><span data-stu-id="5a457-243">% Disk Read Time</span></span> <br> <span data-ttu-id="5a457-244">% 디스크 쓰기 시간</span><span class="sxs-lookup"><span data-stu-id="5a457-244">% Disk Write Time</span></span> |<span data-ttu-id="5a457-245">r/s </span><span class="sxs-lookup"><span data-stu-id="5a457-245">r/s</span></span> <br> <span data-ttu-id="5a457-246">w/s</span><span class="sxs-lookup"><span data-stu-id="5a457-246">w/s</span></span> |
| <span data-ttu-id="5a457-247">**처리량**</span><span class="sxs-lookup"><span data-stu-id="5a457-247">**Throughput**</span></span> |<span data-ttu-id="5a457-248">초당 디스크에서 읽거나 디스크에 쓴 데이터 양입니다.</span><span class="sxs-lookup"><span data-stu-id="5a457-248">Amount of data read from or written to the disk per second.</span></span> |<span data-ttu-id="5a457-249">디스크 읽기 바이트/초 </span><span class="sxs-lookup"><span data-stu-id="5a457-249">Disk Read Bytes/sec</span></span> <br> <span data-ttu-id="5a457-250">디스크 쓰기 바이트/초</span><span class="sxs-lookup"><span data-stu-id="5a457-250">Disk Write Bytes/sec</span></span> |<span data-ttu-id="5a457-251">kB_read/s</span><span class="sxs-lookup"><span data-stu-id="5a457-251">kB_read/s</span></span> <br> <span data-ttu-id="5a457-252">kB_wrtn/s</span><span class="sxs-lookup"><span data-stu-id="5a457-252">kB_wrtn/s</span></span> |
| <span data-ttu-id="5a457-253">**대기 시간**</span><span class="sxs-lookup"><span data-stu-id="5a457-253">**Latency**</span></span> |<span data-ttu-id="5a457-254">디스크 IO 요청을 완료하는 총 시간입니다.</span><span class="sxs-lookup"><span data-stu-id="5a457-254">Total time to complete a disk IO request.</span></span> |<span data-ttu-id="5a457-255">평균 디스크 초/읽기 </span><span class="sxs-lookup"><span data-stu-id="5a457-255">Average Disk sec/Read</span></span> <br> <span data-ttu-id="5a457-256">평균 디스크 초/쓰기</span><span class="sxs-lookup"><span data-stu-id="5a457-256">Average disk sec/Write</span></span> |<span data-ttu-id="5a457-257">await </span><span class="sxs-lookup"><span data-stu-id="5a457-257">await</span></span> <br> <span data-ttu-id="5a457-258">svctm</span><span class="sxs-lookup"><span data-stu-id="5a457-258">svctm</span></span> |
| <span data-ttu-id="5a457-259">**IO 크기**</span><span class="sxs-lookup"><span data-stu-id="5a457-259">**IO size**</span></span> |<span data-ttu-id="5a457-260">I/O의 요청의 크기는 저장소 디스크에 발급합니다.</span><span class="sxs-lookup"><span data-stu-id="5a457-260">The size of I/O requests issues to the storage disks.</span></span> |<span data-ttu-id="5a457-261">평균 디스크 바이트/읽기 </span><span class="sxs-lookup"><span data-stu-id="5a457-261">Average Disk Bytes/Read</span></span> <br> <span data-ttu-id="5a457-262">평균 디스크 바이트/쓰기</span><span class="sxs-lookup"><span data-stu-id="5a457-262">Average Disk Bytes/Write</span></span> |<span data-ttu-id="5a457-263">avgrq-sz</span><span class="sxs-lookup"><span data-stu-id="5a457-263">avgrq-sz</span></span> |
| <span data-ttu-id="5a457-264">**큐 크기**</span><span class="sxs-lookup"><span data-stu-id="5a457-264">**Queue Depth**</span></span> |<span data-ttu-id="5a457-265">저장소 디스크에서 읽거나 저장소 디스크에 쓰도록 대기 중인 미해결 I/O 요청의 수입니다.</span><span class="sxs-lookup"><span data-stu-id="5a457-265">Number of outstanding I/O requests waiting to be read form or written to the storage disk.</span></span> |<span data-ttu-id="5a457-266">현재 디스크 큐 길이</span><span class="sxs-lookup"><span data-stu-id="5a457-266">Current Disk Queue Length</span></span> |<span data-ttu-id="5a457-267">avgqu-sz</span><span class="sxs-lookup"><span data-stu-id="5a457-267">avgqu-sz</span></span> |
| <span data-ttu-id="5a457-268">**최대 메모리**</span><span class="sxs-lookup"><span data-stu-id="5a457-268">**Max. Memory**</span></span> |<span data-ttu-id="5a457-269">응용 프로그램을 원활하게 실행하는데 필요한 메모리의 양</span><span class="sxs-lookup"><span data-stu-id="5a457-269">Amount of memory required to run application smoothly</span></span> |<span data-ttu-id="5a457-270">% 사용 중인 커밋된 바이트</span><span class="sxs-lookup"><span data-stu-id="5a457-270">% Committed Bytes in Use</span></span> |<span data-ttu-id="5a457-271">vmstat 사용</span><span class="sxs-lookup"><span data-stu-id="5a457-271">Use vmstat</span></span> |
| <span data-ttu-id="5a457-272">**최대 CPU**</span><span class="sxs-lookup"><span data-stu-id="5a457-272">**Max. CPU**</span></span> |<span data-ttu-id="5a457-273">응용 프로그램을 원활하게 실행하는데 필요한 CPU 양</span><span class="sxs-lookup"><span data-stu-id="5a457-273">Amount CPU required to run application smoothly</span></span> |<span data-ttu-id="5a457-274">% 프로세서 시간</span><span class="sxs-lookup"><span data-stu-id="5a457-274">% Processor time</span></span> |<span data-ttu-id="5a457-275">%util</span><span class="sxs-lookup"><span data-stu-id="5a457-275">%util</span></span> |

<span data-ttu-id="5a457-276">[iostat](http://linuxcommand.org/man_pages/iostat1.html) 및 [PerfMon](https://msdn.microsoft.com/library/aa645516.aspx)에 대해 자세히 알아봅니다.</span><span class="sxs-lookup"><span data-stu-id="5a457-276">Learn more about [iostat](http://linuxcommand.org/man_pages/iostat1.html) and [PerfMon](https://msdn.microsoft.com/library/aa645516.aspx).</span></span>

## <a name="optimizing-application-performance"></a><span data-ttu-id="5a457-277">응용 프로그램 성능 최적화</span><span class="sxs-lookup"><span data-stu-id="5a457-277">Optimizing Application Performance</span></span>
<span data-ttu-id="5a457-278">프리미엄 저장소에서 실행 중인 응용 프로그램의 성능에 영향을 주는 주요 요인은 IO 요청의 특성, VM 크기, 디스크 크기, 디스크 수, 디스크 캐싱, 멀티 스레드 및 큐 크기입니다.</span><span class="sxs-lookup"><span data-stu-id="5a457-278">The main factors that influence performance of an application running on Premium Storage are Nature of IO Requests, VM size, Disk size, Number of disks, Disk Caching, Multithreading and Queue Depth.</span></span> <span data-ttu-id="5a457-279">이러한 요소 중 일부는 시스템에서 제공하는 노브를 사용하여 제어할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="5a457-279">You can control some of these factors with knobs provided by the system.</span></span> <span data-ttu-id="5a457-280">대부분의 응용 프로그램은 IO 크기 및 큐 크기를 직접 변경할 수 있는 옵션을 제공하지 못할 수도 있습니다.</span><span class="sxs-lookup"><span data-stu-id="5a457-280">Most applications may not give you an option to alter the IO size and Queue Depth directly.</span></span> <span data-ttu-id="5a457-281">예를 들어 SQL Server를 사용하는 경우 IO 크기 및 큐 길이를 선택할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="5a457-281">For example, if you are using SQL Server, you cannot choose the IO size and queue depth.</span></span> <span data-ttu-id="5a457-282">SQL Server에서는 최적의 성능을 얻기 위해 최적의 IO 크기 및 큐 크기 값을 선택합니다.</span><span class="sxs-lookup"><span data-stu-id="5a457-282">SQL Server chooses the optimal IO size and queue depth values to get the most performance.</span></span> <span data-ttu-id="5a457-283">성능 요구 사항에 맞게 적절한 리소스를 프로비전할 수 있도록 두 요소 형식이 응용 프로그램 성능에 미치는 영향을 이해하는 것이 중요합니다.</span><span class="sxs-lookup"><span data-stu-id="5a457-283">It is important to understand the effects of both types of factors on your application performance, so that you can provision appropriate resources to meet performance needs.</span></span>

<span data-ttu-id="5a457-284">이 섹션 전체에서 응용 프로그램 성능을 최적화하기 위해 필요한 정도를 식별하도록 만든 응용 프로그램 요구 사항 검사 목록을 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="5a457-284">Throughout this section, refer to the application requirements checklist that you created, to identify how much you need to optimize your application performance.</span></span> <span data-ttu-id="5a457-285">그에 따라 이 섹션에서 조정할 요인을 확인할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="5a457-285">Based on that, you will be able to determine which factors from this section you will need to tune.</span></span> <span data-ttu-id="5a457-286">각 요인이 응용 프로그램 성능에 미치는 영향을 감시하려면 응용 프로그램 설치에서 벤치마킹 도구를 실행합니다.</span><span class="sxs-lookup"><span data-stu-id="5a457-286">To witness the effects of each factor on your application performance, run benchmarking tools on your application setup.</span></span> <span data-ttu-id="5a457-287">Windows 및 Linux VM에서 일반적인 벤치마킹 도구를 실행하는 단계에 대한 문서의 마지막에 있는 [벤치마킹](#Benchmarking) 섹션을 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="5a457-287">Refer to the [Benchmarking](#Benchmarking) section at the end of this article for steps to run common benchmarking tools on Windows and Linux VMs.</span></span>

### <a name="optimizing-iops-throughput-and-latency-at-a-glance"></a><span data-ttu-id="5a457-288">한 눈에 IOPS, 처리량 및 대기 시간 최적화</span><span class="sxs-lookup"><span data-stu-id="5a457-288">Optimizing IOPS, Throughput and Latency at a glance</span></span>
<span data-ttu-id="5a457-289">다음 표에서 모든 성능 요소 및 IOPS, 처리량 및 대기 시간을 최적화하는 단계를 요약합니다.</span><span class="sxs-lookup"><span data-stu-id="5a457-289">The table below summarizes all the performance factors and the steps to optimize IOPS, Throughput and Latency.</span></span> <span data-ttu-id="5a457-290">이 요약에 이어지는 섹션에서는 각 요인을 더 자세히 설명합니다.</span><span class="sxs-lookup"><span data-stu-id="5a457-290">The sections following this summary will describe each factor is much more depth.</span></span>

| &nbsp; | <span data-ttu-id="5a457-291">**IOPS**</span><span class="sxs-lookup"><span data-stu-id="5a457-291">**IOPS**</span></span> | <span data-ttu-id="5a457-292">**처리량**</span><span class="sxs-lookup"><span data-stu-id="5a457-292">**Throughput**</span></span> | <span data-ttu-id="5a457-293">**대기 시간**</span><span class="sxs-lookup"><span data-stu-id="5a457-293">**Latency**</span></span> |
| --- | --- | --- | --- |
| <span data-ttu-id="5a457-294">**예제 시나리오**</span><span class="sxs-lookup"><span data-stu-id="5a457-294">**Example Scenario**</span></span> |<span data-ttu-id="5a457-295">초당 비율로 매우 높은 트랜잭션이 필요한 엔터프라이즈 OLTP 응용 프로그램입니다.</span><span class="sxs-lookup"><span data-stu-id="5a457-295">Enterprise OLTP application requiring very high transactions per second rate.</span></span> |<span data-ttu-id="5a457-296">다량의 데이터를 처리하는 엔터프라이즈 데이터 웨어하우징 응용 프로그램입니다.</span><span class="sxs-lookup"><span data-stu-id="5a457-296">Enterprise Data warehousing application processing large amounts of data.</span></span> |<span data-ttu-id="5a457-297">온라인 게임과 같은 사용자 요청에 대한 즉각적인 응답이 필요한 거의 실시간 응용 프로그램입니다.</span><span class="sxs-lookup"><span data-stu-id="5a457-297">Near real-time applications requiring instant responses to user requests, like online gaming.</span></span> |
| <span data-ttu-id="5a457-298">성능 요인</span><span class="sxs-lookup"><span data-stu-id="5a457-298">Performance factors</span></span> | &nbsp; | &nbsp; | &nbsp; |
| <span data-ttu-id="5a457-299">**IO 크기**</span><span class="sxs-lookup"><span data-stu-id="5a457-299">**IO size**</span></span> |<span data-ttu-id="5a457-300">작은 크기의 IO는 더 높은 IOPS를 생성합니다.</span><span class="sxs-lookup"><span data-stu-id="5a457-300">Smaller IO size yields higher IOPS.</span></span> |<span data-ttu-id="5a457-301">큰 IO 크기는 더 높은 처리량을 생성합니다.</span><span class="sxs-lookup"><span data-stu-id="5a457-301">Larger IO size to yields higher Throughput.</span></span> | &nbsp;|
| <span data-ttu-id="5a457-302">**VM 크기**</span><span class="sxs-lookup"><span data-stu-id="5a457-302">**VM size**</span></span> |<span data-ttu-id="5a457-303">응용 프로그램 요구 사항보다 큰 IOPS를 제공하는 VM 크기를 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="5a457-303">Use a VM size that offers IOPS greater than your application requirement.</span></span> <span data-ttu-id="5a457-304">VM 크기 및 IOPS 한계는 여기를 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="5a457-304">See VM sizes and their IOPS limits here.</span></span> |<span data-ttu-id="5a457-305">응용 프로그램 요구 사항보다 큰 처리량 한계가 있는 VM 크기를 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="5a457-305">Use a VM size with Throughput limit greater than your application requirement.</span></span> <span data-ttu-id="5a457-306">VM 크기 및 처리량 한계는 여기를 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="5a457-306">See VM sizes and their Throughput limits here.</span></span> |<span data-ttu-id="5a457-307">응용 프로그램 요구 사항보다 큰 규모 제한을 제공하는 VM 크기를 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="5a457-307">Use a VM size that offers scale limits greater than your application requirement.</span></span> <span data-ttu-id="5a457-308">VM 크기 및 한계는 여기를 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="5a457-308">See VM sizes and their limits here.</span></span> |
| <span data-ttu-id="5a457-309">**디스크 크기**</span><span class="sxs-lookup"><span data-stu-id="5a457-309">**Disk size**</span></span> |<span data-ttu-id="5a457-310">응용 프로그램 요구 사항보다 큰 IOPS를 제공하는 디스크 크기를 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="5a457-310">Use a disk size that offers IOPS greater than your application requirement.</span></span> <span data-ttu-id="5a457-311">디스크 크기 및 IOPS 한계는 여기를 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="5a457-311">See disk sizes and their IOPS limits here.</span></span> |<span data-ttu-id="5a457-312">응용 프로그램 요구 사항보다 큰 처리량 한계가 있는 디스크 크기를 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="5a457-312">Use a disk size with Throughput limit greater than your application requirement.</span></span> <span data-ttu-id="5a457-313">디스크 크기 및 처리량 한계는 여기를 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="5a457-313">See disk sizes and their Throughput limits here.</span></span> |<span data-ttu-id="5a457-314">응용 프로그램 요구 사항보다 큰 규모 제한을 제공하는 디스크 크기를 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="5a457-314">Use a disk size that offers scale limits greater than your application requirement.</span></span> <span data-ttu-id="5a457-315">디스크 크기 및 한계는 여기를 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="5a457-315">See disk sizes and their limits here.</span></span> |
| <span data-ttu-id="5a457-316">**VM 및 디스크 규모 제한**</span><span class="sxs-lookup"><span data-stu-id="5a457-316">**VM and Disk Scale Limits**</span></span> |<span data-ttu-id="5a457-317">선택한 VM 크기의 IOPS 제한은 연결된 프리미엄 저장소 디스크에 의해 발생하는 총 IOPS보다 커야 합니다.</span><span class="sxs-lookup"><span data-stu-id="5a457-317">IOPS limit of the VM size chosen should be greater than total IOPS driven by premium storage disks attached to it.</span></span> |<span data-ttu-id="5a457-318">선택한 VM 크기의 처리량 제한은 연결된 프리미엄 저장소 디스크에 의한 총 처리량보다 커야 합니다.</span><span class="sxs-lookup"><span data-stu-id="5a457-318">Throughput limit of the VM size chosen should be greater than total Throughput driven by premium storage disks attached to it.</span></span> |<span data-ttu-id="5a457-319">선택한 VM 크기의 규모 제한은 연결된 프리미엄 저장소 디스크의 총 규모 제한보다 커야 합니다.</span><span class="sxs-lookup"><span data-stu-id="5a457-319">Scale limits of the VM size chosen must be greater than total scale limits of attached premium storage disks.</span></span> |
| <span data-ttu-id="5a457-320">**디스크 캐싱**</span><span class="sxs-lookup"><span data-stu-id="5a457-320">**Disk Caching**</span></span> |<span data-ttu-id="5a457-321">더 많은 읽기 IOPS를 얻기 위해 많은 읽기 작업과 함께 프리미엄 저장소 디스크의 읽기 전용 캐시를 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="5a457-321">Enable ReadOnly Cache on premium storage disks with Read heavy operations to get higher Read IOPS.</span></span> | &nbsp; |<span data-ttu-id="5a457-322">더 짧은 읽기 대기 시간을 얻기 위해 많은 읽기 작업과 함께 프리미엄 저장소 디스크의 ReadOnly 캐시를 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="5a457-322">Enable ReadOnly Cache on premium storage disks with Ready heavy operations to get very low Read latencies.</span></span> |
| <span data-ttu-id="5a457-323">**디스크 스트라이프**</span><span class="sxs-lookup"><span data-stu-id="5a457-323">**Disk Striping**</span></span> |<span data-ttu-id="5a457-324">결합된 높은 IOPS 및 처리량 한계를 얻기 위해 여러 디스크 및 디스크 스트라이프를 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="5a457-324">Use multiple disks and stripe them together to get a combined higher IOPS and Throughput limit.</span></span> <span data-ttu-id="5a457-325">VM당 결합된 한계는 연결된 프리미엄 디스크의 결합된 제한보다 높아야 합니다.</span><span class="sxs-lookup"><span data-stu-id="5a457-325">Note that the combined limit per VM should be higher than the combined limits of attached premium disks.</span></span> | &nbsp; | &nbsp; |
| <span data-ttu-id="5a457-326">**스트라이프 크기**</span><span class="sxs-lookup"><span data-stu-id="5a457-326">**Stripe Size**</span></span> |<span data-ttu-id="5a457-327">OLTP 응용 프로그램에 표시된 작은 임의 IO 패턴에 대한 더 작은 스트라이프 크기입니다.</span><span class="sxs-lookup"><span data-stu-id="5a457-327">Smaller stripe size for random small IO pattern seen in OLTP applications.</span></span> <span data-ttu-id="5a457-328">예: SQL Server OLTP 응용 프로그램에 대해 64KB의 스트라이프 크기를 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="5a457-328">E.g., use stripe size of 64KB for SQL Server OLTP application.</span></span> |<span data-ttu-id="5a457-329">데이터 웨어하우스에 응용 프로그램에 표시된 대형 순차 IO 패턴에 대한 더 큰 스트라이프 크기입니다.</span><span class="sxs-lookup"><span data-stu-id="5a457-329">Larger stripe size for sequential large IO pattern seen in Data Warehouse applications.</span></span> <span data-ttu-id="5a457-330">예: SQL Server 데이터 웨어하우스 응용 프로그램에 대해 256KB의 스트라이프 크기를 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="5a457-330">E.g., use 256KB stripe size for SQL Server Data warehouse application.</span></span> | &nbsp; |
| <span data-ttu-id="5a457-331">**멀티 스레드**</span><span class="sxs-lookup"><span data-stu-id="5a457-331">**Multithreading**</span></span> |<span data-ttu-id="5a457-332">높은 IOPS 및 처리량을 얻도록 하는 프리미엄 저장소에 더 높은 요청 수를 밀어 넣도록 멀티 스레드를 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="5a457-332">Use multithreading to push higher number of requests to Premium Storage that will lead to higher IOPS and Throughput.</span></span> <span data-ttu-id="5a457-333">예를 들어 SQL Server에서 SQL Server에 더 많은 CPU를 할당하는 높은 MAXDOP 값을 설정합니다.</span><span class="sxs-lookup"><span data-stu-id="5a457-333">For example, on SQL Server set a high MAXDOP value to allocate more CPUs to SQL Server.</span></span> | &nbsp; | &nbsp; |
| <span data-ttu-id="5a457-334">**큐 크기**</span><span class="sxs-lookup"><span data-stu-id="5a457-334">**Queue Depth**</span></span> |<span data-ttu-id="5a457-335">더 큰 큐 크기는 더 높은 IOPS를 생성합니다.</span><span class="sxs-lookup"><span data-stu-id="5a457-335">Larger Queue Depth yields higher IOPS.</span></span> |<span data-ttu-id="5a457-336">더 큰 큐 크기는 더 높은 처리량을 생성합니다.</span><span class="sxs-lookup"><span data-stu-id="5a457-336">Larger Queue Depth yields higher Throughput.</span></span> |<span data-ttu-id="5a457-337">더 작은 큐 크기는 더 짧은 대기 시간을 생성합니다.</span><span class="sxs-lookup"><span data-stu-id="5a457-337">Smaller Queue Depth yields lower latencies.</span></span> |

## <a name="nature-of-io-requests"></a><span data-ttu-id="5a457-338">IO 요청의 특성</span><span class="sxs-lookup"><span data-stu-id="5a457-338">Nature of IO Requests</span></span>
<span data-ttu-id="5a457-339">IO 요청은 응용 프로그램에서 수행하는 입력/출력 작업의 단위입니다.</span><span class="sxs-lookup"><span data-stu-id="5a457-339">An IO request is a unit of input/output operation that your application will be performing.</span></span> <span data-ttu-id="5a457-340">IO 요청, 임의 또는 순차, 읽기 또는 쓰기, 소형 또는 대형의 특성을 식별하면 응용 프로그램의 성능 요구 사항을 결정하는데 도움이 됩니다.</span><span class="sxs-lookup"><span data-stu-id="5a457-340">Identifying the nature of IO requests, random or sequential, read or write, small or large, will help you determine the performance requirements of your application.</span></span> <span data-ttu-id="5a457-341">응용 프로그램 인프라를 설계할 때 올바른 결정을 내릴 수 있도록 IO 요청의 특성을 이해하는 것은 중요합니다.</span><span class="sxs-lookup"><span data-stu-id="5a457-341">It is very important to understand the nature of IO requests, to make the right decisions when designing your application infrastructure.</span></span>

<span data-ttu-id="5a457-342">IO 크기는 더 중요한 요소 중 하나입니다.</span><span class="sxs-lookup"><span data-stu-id="5a457-342">IO size is one of the more important factors.</span></span> <span data-ttu-id="5a457-343">IO 크기는 응용 프로그램에 의해 생성된 입력/출력 작업 요청의 크기입니다.</span><span class="sxs-lookup"><span data-stu-id="5a457-343">The IO size is the size of the input/output operation request generated by your application.</span></span> <span data-ttu-id="5a457-344">IO 크기는 응용 프로그램에서 달성할 수 있는 성능 특히 IOPS 및 대역폭에 큰 영향을 줍니다.</span><span class="sxs-lookup"><span data-stu-id="5a457-344">The IO size has a significant impact on performance especially on the IOPS and Bandwidth that the application is able to achieve.</span></span> <span data-ttu-id="5a457-345">다음 수식은 IOPS 간의 관계, IO 크기 및 대역폭/처리량을 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="5a457-345">The following formula shows the relationship between IOPS, IO size and Bandwidth/Throughput.</span></span>  
    ![](media/storage-premium-storage-performance/image1.png)

<span data-ttu-id="5a457-346">일부 응용 프로그램은 해당 IO 크기 변경을 허용하지만 일부 응용 프로그램은 그렇지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="5a457-346">Some applications allow you to alter their IO size, while some applications do not.</span></span> <span data-ttu-id="5a457-347">예를 들어 SQL Server는 자체적으로 최적의 IO 크기를 결정하고 변경할 수 있는 노브를 사용자에게 제공하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="5a457-347">For example, SQL Server determines the optimal IO size itself, and does not provide users with any knobs to change it.</span></span> <span data-ttu-id="5a457-348">반대로 Oracle은 데이터베이스의 I/O 요청 크기를 구성할 수 있는 [DB\_BLOCK\_SIZE](https://docs.oracle.com/cd/B19306_01/server.102/b14211/iodesign.htm#i28815)라는 매개 변수를 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="5a457-348">On the other hand, Oracle provides a parameter called [DB\_BLOCK\_SIZE](https://docs.oracle.com/cd/B19306_01/server.102/b14211/iodesign.htm#i28815) using which you can configure the I/O request size of the database.</span></span>

<span data-ttu-id="5a457-349">IO 크기 변경을 허용하지 않는 응용 프로그램을 사용하는 경우 이 문서의 지침을 사용하여 응용 프로그램에 가장 관련이 있는 성능 KPI를 최적화합니다.</span><span class="sxs-lookup"><span data-stu-id="5a457-349">If you are using an application, which does not allow you to change the IO size, use the guidelines in this article to optimize the performance KPI that is most relevant to your application.</span></span> <span data-ttu-id="5a457-350">예를 들면 다음과 같습니다.</span><span class="sxs-lookup"><span data-stu-id="5a457-350">For example,</span></span>

* <span data-ttu-id="5a457-351">OLTP 응용 프로그램에서는 수백만 개의 작고 임의적인 IO 요청을 생성합니다.</span><span class="sxs-lookup"><span data-stu-id="5a457-351">An OLTP application generates millions of small and random IO requests.</span></span> <span data-ttu-id="5a457-352">이러한 유형의 IO 요청을 처리하려면 높은 IOPS를 얻도록 응용 프로그램 인프라를 설계해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="5a457-352">To handle these type of IO requests, you must design your application infrastructure to get higher IOPS.</span></span>  
* <span data-ttu-id="5a457-353">데이터 웨어하우징 응용 프로그램은 크고 순차적인 IO 요청을 생성합니다.</span><span class="sxs-lookup"><span data-stu-id="5a457-353">A data warehousing application generates large and sequential IO requests.</span></span> <span data-ttu-id="5a457-354">이러한 형식의 IO 요청을 처리하려면 높은 대역폭 또는 처리량을 얻도록 응용 프로그램 인프라를 설계해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="5a457-354">To handle these type of IO requests, you must design your application infrastructure to get higher Bandwidth or Throughput.</span></span>

<span data-ttu-id="5a457-355">IO 크기를 변경할 수 있는 응용 프로그램을 사용하는 경우 다른 성능 지침 외에도 IO 크기에 대한 이 규칙을 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="5a457-355">If you are using an application, which allows you to change the IO size, use this rule of thumb for the IO size in addition to other performance guidelines,</span></span>

* <span data-ttu-id="5a457-356">작은 크기의 IO는 더 높은 IOPS를 얻습니다.</span><span class="sxs-lookup"><span data-stu-id="5a457-356">Smaller IO size to get higher IOPS.</span></span> <span data-ttu-id="5a457-357">예를 들어 OLTP 응용 프로그램의 경우 8KB입니다.</span><span class="sxs-lookup"><span data-stu-id="5a457-357">For example, 8 KB for an OLTP application.</span></span>  
* <span data-ttu-id="5a457-358">더 높은 대역폭/처리량을 얻기 위한 더 큰 크기의 IO입니다.</span><span class="sxs-lookup"><span data-stu-id="5a457-358">Larger IO size to get higher Bandwidth/Throughput.</span></span> <span data-ttu-id="5a457-359">예를 들어 데이터 웨어하우스 응용 프로그램의 경우 1024KB입니다.</span><span class="sxs-lookup"><span data-stu-id="5a457-359">For example, 1024 KB for a data warehouse application.</span></span>

<span data-ttu-id="5a457-360">응용 프로그램에 대한 IOPS 및 처리량/대역폭을 계산하는 방법에 대한 예입니다.</span><span class="sxs-lookup"><span data-stu-id="5a457-360">Here is an example on how you can calculate the IOPS and Throughput/Bandwidth for your application.</span></span> <span data-ttu-id="5a457-361">P30 디스크를 사용하여 응용 프로그램을 고려합니다.</span><span class="sxs-lookup"><span data-stu-id="5a457-361">Consider an application using a P30 disk.</span></span> <span data-ttu-id="5a457-362">최대 IOPS 및 처리량/대역폭 P30 디스크는 각각 초당 5000 IOPS와 200MB를 얻을 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="5a457-362">The maximum IOPS and Throughput/Bandwidth a P30 disk can achieve is 5000 IOPS and 200 MB per second respectively.</span></span> <span data-ttu-id="5a457-363">이제 응용 프로그램이 P30 디스크에서 최대 IOPS가 필요하고 8KB와 같은 작은 IO 크기를 사용하는 경우 얻을 수 결과 대역폭은 초당 40MB입니다.</span><span class="sxs-lookup"><span data-stu-id="5a457-363">Now, if your application requires the maximum IOPS from the P30 disk and you use a smaller IO size like 8 KB, the resulting Bandwidth you will be able to get is 40 MB per second.</span></span> <span data-ttu-id="5a457-364">그러나 응용 프로그램이 P30 디스크에서 최대 처리량/대역폭이 필요하고 1024KB와 같은 큰 IO 크기를 사용하는 경우 결과 IOPS는 200 IOPS 미만입니다.</span><span class="sxs-lookup"><span data-stu-id="5a457-364">However, if your application requires the maximum Throughput/Bandwidth from P30 disk, and you use a larger IO size like 1024 KB, the resulting IOPS will be less, 200 IOPS.</span></span> <span data-ttu-id="5a457-365">따라서 두 응용 프로그램의 IOPS 및 처리량/대역폭 요구 사항이 충족되도록 IO 크기를 조정합니다.</span><span class="sxs-lookup"><span data-stu-id="5a457-365">Therefore, tune the IO size such that it meets both your application's IOPS and Throughput/Bandwidth requirement.</span></span> <span data-ttu-id="5a457-366">아래 표에서 P30 디스크에 대한 다양한 IO 크기 및 해당 IOPS와 처리량을 요약합니다.</span><span class="sxs-lookup"><span data-stu-id="5a457-366">Table below summarizes the different IO sizes and their corresponding IOPS and Throughput for a P30 disk.</span></span>

| <span data-ttu-id="5a457-367">응용 프로그램 요구 사항</span><span class="sxs-lookup"><span data-stu-id="5a457-367">Application Requirement</span></span> | <span data-ttu-id="5a457-368">I/O 크기</span><span class="sxs-lookup"><span data-stu-id="5a457-368">I/O size</span></span> | <span data-ttu-id="5a457-369">IOPS</span><span class="sxs-lookup"><span data-stu-id="5a457-369">IOPS</span></span> | <span data-ttu-id="5a457-370">처리량/대역폭</span><span class="sxs-lookup"><span data-stu-id="5a457-370">Throughput/Bandwidth</span></span> |
| --- | --- | --- | --- |
| <span data-ttu-id="5a457-371">최대 IOPS</span><span class="sxs-lookup"><span data-stu-id="5a457-371">Max IOPS</span></span> |<span data-ttu-id="5a457-372">8KB</span><span class="sxs-lookup"><span data-stu-id="5a457-372">8 KB</span></span> |<span data-ttu-id="5a457-373">5, 000</span><span class="sxs-lookup"><span data-stu-id="5a457-373">5,000</span></span> |<span data-ttu-id="5a457-374">초당 40MB</span><span class="sxs-lookup"><span data-stu-id="5a457-374">40 MB per second</span></span> |
| <span data-ttu-id="5a457-375">최대 처리량</span><span class="sxs-lookup"><span data-stu-id="5a457-375">Max Throughput</span></span> |<span data-ttu-id="5a457-376">1024KB</span><span class="sxs-lookup"><span data-stu-id="5a457-376">1024 KB</span></span> |<span data-ttu-id="5a457-377">200</span><span class="sxs-lookup"><span data-stu-id="5a457-377">200</span></span> |<span data-ttu-id="5a457-378">초당 200MB</span><span class="sxs-lookup"><span data-stu-id="5a457-378">200 MB per second</span></span> |
| <span data-ttu-id="5a457-379">최대 처리량 + 높은 IOPS</span><span class="sxs-lookup"><span data-stu-id="5a457-379">Max Throughput + high IOPS</span></span> |<span data-ttu-id="5a457-380">64KB</span><span class="sxs-lookup"><span data-stu-id="5a457-380">64 KB</span></span> |<span data-ttu-id="5a457-381">3,200</span><span class="sxs-lookup"><span data-stu-id="5a457-381">3,200</span></span> |<span data-ttu-id="5a457-382">초당 200MB</span><span class="sxs-lookup"><span data-stu-id="5a457-382">200 MB per second</span></span> |
| <span data-ttu-id="5a457-383">최대 IOPS + 높은 처리량</span><span class="sxs-lookup"><span data-stu-id="5a457-383">Max IOPS + high Throughput</span></span> |<span data-ttu-id="5a457-384">32KB</span><span class="sxs-lookup"><span data-stu-id="5a457-384">32 KB</span></span> |<span data-ttu-id="5a457-385">5, 000</span><span class="sxs-lookup"><span data-stu-id="5a457-385">5,000</span></span> |<span data-ttu-id="5a457-386">초당 160MB</span><span class="sxs-lookup"><span data-stu-id="5a457-386">160 MB per second</span></span> |

<span data-ttu-id="5a457-387">단일 프리미엄 저장소 디스크의 최대값보다 높은 IOPS 및 대역폭을 얻으려면 함께 스트라이프된 여러 프리미엄 디스크를 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="5a457-387">To get IOPS and Bandwidth higher than the maximum value of a single premium storage disk, use multiple premium disks striped together.</span></span> <span data-ttu-id="5a457-388">예를 들어 10000 IOPS의 결합된 IOPS 또는 초당 400MB의 결합된 처리량을 얻으려면 두 P30 디스크를 스트라이프합니다.</span><span class="sxs-lookup"><span data-stu-id="5a457-388">For example, stripe two P30 disks to get a combined IOPS of 10,000 IOPS or a combined Throughput of 400 MB per second.</span></span> <span data-ttu-id="5a457-389">다음 섹션에서 설명한 것과 같이 결합된 디스크 IOPS 및 처리량을 지원하는 VM 크기를 사용해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="5a457-389">As explained in the next section, you must use a VM size that supports the combined disk IOPS and Throughput.</span></span>

> [!NOTE]
> <span data-ttu-id="5a457-390">IOPS 또는 처리량을 늘리면 다른 쪽 또한 증가하므로 둘 중 하나를 늘리는 경우 디스크 또는 VM의 처리량 또는 IOPS 제한에 도달하지 않도록 합니다.</span><span class="sxs-lookup"><span data-stu-id="5a457-390">As you increase either IOPS or Throughput the other also increases, make sure you do not hit throughput or IOPS limits of the disk or VM when increasing either one.</span></span>
>
>

<span data-ttu-id="5a457-391">응용 프로그램 성능에 미치는 IO 크기의 영향을 감시하려면 VM 및 디스크에서 벤치마킹 도구를 실행할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="5a457-391">To witness the effects of IO size on application performance, you can run benchmarking tools on your VM and disks.</span></span> <span data-ttu-id="5a457-392">여러 테스트 실행을 만들고 각 실행에 대한 다른 IO 크기를 사용하여 어떤 영향이 있는지 확인합니다.</span><span class="sxs-lookup"><span data-stu-id="5a457-392">Create multiple test runs and use different IO size for each run to see the impact.</span></span> <span data-ttu-id="5a457-393">자세한 내용은 이 문서의 마지막 부분에 있는 [벤치마킹](#Benchmarking) 섹션을 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="5a457-393">Refer to the [Benchmarking](#Benchmarking) section at the end of this article for more details.</span></span>

## <a name="high-scale-vm-sizes"></a><span data-ttu-id="5a457-394">높은 확장성의 VM 크기</span><span class="sxs-lookup"><span data-stu-id="5a457-394">High Scale VM Sizes</span></span>
<span data-ttu-id="5a457-395">응용 프로그램 설계를 시작할 때 실행할 첫 번째 작업 중 하나는 응용 프로그램을 호스팅할 VM을 선택하는 것입니다.</span><span class="sxs-lookup"><span data-stu-id="5a457-395">When you start designing an application, one of the first things to do is, choose a VM to host your application.</span></span> <span data-ttu-id="5a457-396">프리미엄 저장소는 높은 계산 능력 및 높은 로컬 디스크 I/O 성능이 필요한 응용 프로그램을 실행할 수 있는 높은 확장성의 VM 크기와 함께 제공됩니다.</span><span class="sxs-lookup"><span data-stu-id="5a457-396">Premium Storage comes with High Scale VM sizes that can run applications requiring higher compute power and a high local disk I/O performance.</span></span> <span data-ttu-id="5a457-397">이러한 VM은 로컬 디스크에 대한 빠른 프로세서, 더 높은 메모리-코어 비율 및 SSD(반도체 드라이브)를 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="5a457-397">These VMs provide faster processors, a higher memory-to-core ratio, and a Solid-State Drive (SSD) for the local disk.</span></span> <span data-ttu-id="5a457-398">프리미엄 저장소를 지원하는 높은 확장성의 VM의 예는 DS, DSv2 및 GS 시리즈 VM입니다.</span><span class="sxs-lookup"><span data-stu-id="5a457-398">Examples of High Scale VMs supporting Premium Storage are the DS, DSv2 and GS series VMs.</span></span>

<span data-ttu-id="5a457-399">높은 확장성의 VM은 다양한 수의 CPU 코어, 메모리, OS 및 임시 디스크 크기와 함께 다양한 크기에서 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="5a457-399">High Scale VMs are available in different sizes with a different number of CPU cores, memory, OS and temporary disk size.</span></span> <span data-ttu-id="5a457-400">각 VM 크기에는 또한 VM에 연결할 수 있는 데이터 디스크의 최대 수가 있습니다.</span><span class="sxs-lookup"><span data-stu-id="5a457-400">Each VM size also has maximum number of data disks that you can attach to the VM.</span></span> <span data-ttu-id="5a457-401">따라서 선택한 VM 크기는 응용 프로그램에 대해 사용할 수 있는 프로세스, 메모리 및 저장소 용량에 영향을 줍니다.</span><span class="sxs-lookup"><span data-stu-id="5a457-401">Therefore, the chosen VM size will affect how much processing, memory, and storage capacity is available for your application.</span></span> <span data-ttu-id="5a457-402">계산 및 저장소 비용에도 영향을 줍니다.</span><span class="sxs-lookup"><span data-stu-id="5a457-402">It also affects the Compute and Storage cost.</span></span> <span data-ttu-id="5a457-403">예를 들어 아래는 DS 시리즈, DSv2 시리즈 및 GS 시리즈에서 가장 큰 VM 크기의 사양입니다.</span><span class="sxs-lookup"><span data-stu-id="5a457-403">For example, below are the specifications of the largest VM size in a DS series, DSv2 series and a GS series:</span></span>

| <span data-ttu-id="5a457-404">VM 크기</span><span class="sxs-lookup"><span data-stu-id="5a457-404">VM size</span></span> | <span data-ttu-id="5a457-405">CPU 코어</span><span class="sxs-lookup"><span data-stu-id="5a457-405">CPU cores</span></span> | <span data-ttu-id="5a457-406">메모리</span><span class="sxs-lookup"><span data-stu-id="5a457-406">Memory</span></span> | <span data-ttu-id="5a457-407">VM 디스크 크기</span><span class="sxs-lookup"><span data-stu-id="5a457-407">VM disk sizes</span></span> | <span data-ttu-id="5a457-408">최대</span><span class="sxs-lookup"><span data-stu-id="5a457-408">Max.</span></span> <span data-ttu-id="5a457-409">데이터 디스크</span><span class="sxs-lookup"><span data-stu-id="5a457-409">data disks</span></span> | <span data-ttu-id="5a457-410">캐시 크기</span><span class="sxs-lookup"><span data-stu-id="5a457-410">Cache size</span></span> | <span data-ttu-id="5a457-411">IOPS</span><span class="sxs-lookup"><span data-stu-id="5a457-411">IOPS</span></span> | <span data-ttu-id="5a457-412">대역폭 캐시 IO 제한</span><span class="sxs-lookup"><span data-stu-id="5a457-412">Bandwidth Cache IO limits</span></span> |
| --- | --- | --- | --- | --- | --- | --- | --- |
| <span data-ttu-id="5a457-413">Standard_DS14</span><span class="sxs-lookup"><span data-stu-id="5a457-413">Standard_DS14</span></span> |<span data-ttu-id="5a457-414">16</span><span class="sxs-lookup"><span data-stu-id="5a457-414">16</span></span> |<span data-ttu-id="5a457-415">112GB</span><span class="sxs-lookup"><span data-stu-id="5a457-415">112 GB</span></span> |<span data-ttu-id="5a457-416">OS = 1023GB </span><span class="sxs-lookup"><span data-stu-id="5a457-416">OS = 1023 GB</span></span> <br> <span data-ttu-id="5a457-417">로컬 SSD = 224GB</span><span class="sxs-lookup"><span data-stu-id="5a457-417">Local SSD = 224 GB</span></span> |<span data-ttu-id="5a457-418">32</span><span class="sxs-lookup"><span data-stu-id="5a457-418">32</span></span> |<span data-ttu-id="5a457-419">576GB</span><span class="sxs-lookup"><span data-stu-id="5a457-419">576 GB</span></span> |<span data-ttu-id="5a457-420">50,000 IOPS </span><span class="sxs-lookup"><span data-stu-id="5a457-420">50,000 IOPS</span></span> <br> <span data-ttu-id="5a457-421">초당 512MB</span><span class="sxs-lookup"><span data-stu-id="5a457-421">512 MB per second</span></span> |<span data-ttu-id="5a457-422">4,000 IOPS 및 초당 33MB</span><span class="sxs-lookup"><span data-stu-id="5a457-422">4,000 IOPS and 33 MB per second</span></span> |
| <span data-ttu-id="5a457-423">Standard_GS5</span><span class="sxs-lookup"><span data-stu-id="5a457-423">Standard_GS5</span></span> |<span data-ttu-id="5a457-424">32</span><span class="sxs-lookup"><span data-stu-id="5a457-424">32</span></span> |<span data-ttu-id="5a457-425">448GB</span><span class="sxs-lookup"><span data-stu-id="5a457-425">448 GB</span></span> |<span data-ttu-id="5a457-426">OS = 1023GB </span><span class="sxs-lookup"><span data-stu-id="5a457-426">OS = 1023 GB</span></span> <br> <span data-ttu-id="5a457-427">로컬 SSD = 896GB</span><span class="sxs-lookup"><span data-stu-id="5a457-427">Local SSD = 896 GB</span></span> |<span data-ttu-id="5a457-428">64</span><span class="sxs-lookup"><span data-stu-id="5a457-428">64</span></span> |<span data-ttu-id="5a457-429">4224GB</span><span class="sxs-lookup"><span data-stu-id="5a457-429">4224 GB</span></span> |<span data-ttu-id="5a457-430">80,000 IOPS </span><span class="sxs-lookup"><span data-stu-id="5a457-430">80,000 IOPS</span></span> <br> <span data-ttu-id="5a457-431">초당 2,000MB</span><span class="sxs-lookup"><span data-stu-id="5a457-431">2,000 MB per second</span></span> |<span data-ttu-id="5a457-432">5,000 IOPS 및 초당 50MB</span><span class="sxs-lookup"><span data-stu-id="5a457-432">5,000 IOPS and 50 MB per second</span></span> |

<span data-ttu-id="5a457-433">사용 가능한 모든 Azure VM 크기의 전체 목록을 보려면 [Windows VM 크기](../virtual-machines/windows/sizes.md?toc=%2fazure%2fvirtual-machines%2fwindows%2ftoc.json) 또는 [Linux VM 크기](../virtual-machines/linux/sizes.md?toc=%2fazure%2fvirtual-machines%2flinux%2ftoc.json)를 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="5a457-433">To view a complete list of all available Azure VM sizes, refer to [Windows VM sizes](../virtual-machines/windows/sizes.md?toc=%2fazure%2fvirtual-machines%2fwindows%2ftoc.json) or [Linux VM sizes](../virtual-machines/linux/sizes.md?toc=%2fazure%2fvirtual-machines%2flinux%2ftoc.json).</span></span> <span data-ttu-id="5a457-434">원하는 응용 프로그램 성능 요구 사항에 충족하고 확장할 수 있는 VM 크기를 선택합니다.</span><span class="sxs-lookup"><span data-stu-id="5a457-434">Choose a VM size that can meet and scale to your desired application performance requirements.</span></span> <span data-ttu-id="5a457-435">이 외에도 VM 크기를 선택할 때 다음 중요한 고려 사항을 고려합니다.</span><span class="sxs-lookup"><span data-stu-id="5a457-435">In addition to this, take into account following important considerations when choosing VM sizes.</span></span>

<span data-ttu-id="5a457-436">*규모 제한*</span><span class="sxs-lookup"><span data-stu-id="5a457-436">*Scale Limits*</span></span>  
<span data-ttu-id="5a457-437">VM당 및 디스크당 최대 IOPS 제한은 서로 다르고 독립적입니다.</span><span class="sxs-lookup"><span data-stu-id="5a457-437">The maximum IOPS limits per VM and per disk are different and independent of each other.</span></span> <span data-ttu-id="5a457-438">응용 프로그램이 연결된 프리미엄 디스크 뿐만 아니라 VM의 제한 내에서 IOPS를 구동하는지 확인합니다.</span><span class="sxs-lookup"><span data-stu-id="5a457-438">Make sure that the application is driving IOPS within the limits of the VM as well as the premium disks attached to it.</span></span> <span data-ttu-id="5a457-439">그렇지 않은 경우 응용 프로그램 성능에 제한이 발생합니다.</span><span class="sxs-lookup"><span data-stu-id="5a457-439">Otherwise, application performance will experience throttling.</span></span>

<span data-ttu-id="5a457-440">한 예로 응용 프로그램 요구 사항이 최대 4,000 IOPS라 가정합니다.</span><span class="sxs-lookup"><span data-stu-id="5a457-440">As an example, suppose an application requirement is a maximum of 4,000 IOPS.</span></span> <span data-ttu-id="5a457-441">이를 위해 DS1 VM에서 P30 디스크를 프로비전합니다.</span><span class="sxs-lookup"><span data-stu-id="5a457-441">To achieve this, you provision a P30 disk on a DS1 VM.</span></span> <span data-ttu-id="5a457-442">P30 디스크는 최대 5,000 IOPS를 제공할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="5a457-442">The P30 disk can deliver up to 5,000 IOPS.</span></span> <span data-ttu-id="5a457-443">그러나 DS1 VM은 3,200 IOPS로 제한됩니다.</span><span class="sxs-lookup"><span data-stu-id="5a457-443">However, the DS1 VM is limited to 3,200 IOPS.</span></span> <span data-ttu-id="5a457-444">따라서 응용 프로그램 성능은 3,200 IOPS에서 VM 한계로 제한이 적용되고 성능이 저하됩니다.</span><span class="sxs-lookup"><span data-stu-id="5a457-444">Consequently, the application performance will be constrained by the VM limit at 3,200 IOPS and there will be degraded performance.</span></span> <span data-ttu-id="5a457-445">이러한 상황을 방지하려면 응용 프로그램 요구 사항을 충족하는 VM 및 디스크 크기를 선택합니다.</span><span class="sxs-lookup"><span data-stu-id="5a457-445">To prevent this situation, choose a VM and disk size that will both meet application requirements.</span></span>

<span data-ttu-id="5a457-446">*작업 비용*</span><span class="sxs-lookup"><span data-stu-id="5a457-446">*Cost of Operation*</span></span>  
<span data-ttu-id="5a457-447">대부분의 경우에서 프리미엄 저장소를 사용하는 작업의 전체 비용은 표준 저장소를 사용하는 비용보다 낮을 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="5a457-447">In many cases, it is possible that your overall cost of operation using Premium Storage is lower than using Standard Storage.</span></span>

<span data-ttu-id="5a457-448">예를 들어 16,000 IOPS를 필요로 하는 응용 프로그램을 가정합니다.</span><span class="sxs-lookup"><span data-stu-id="5a457-448">For example, consider an application requiring 16,000 IOPS.</span></span> <span data-ttu-id="5a457-449">이 성능을 달성하려면 32개의 표준 저장소 1TB 디스크를 사용하여 16,000의 최대 IOPS를 제공할 수 있는 Standard\_D14 Azure IaaS VM이 필요합니다.</span><span class="sxs-lookup"><span data-stu-id="5a457-449">To achieve this performance, you will need a Standard\_D14 Azure IaaS VM, which can give a maximum IOPS of 16,000 using 32 standard storage 1TB disks.</span></span> <span data-ttu-id="5a457-450">각 1TB 표준 저장소 디스크는 최대 500 IOPS를 달성할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="5a457-450">Each 1TB standard storage disk can achieve a maximum of 500 IOPS.</span></span> <span data-ttu-id="5a457-451">월별 이 VM의 예상된 비용은 $1,570가 됩니다.</span><span class="sxs-lookup"><span data-stu-id="5a457-451">The estimated cost of this VM per month will be $1,570.</span></span> <span data-ttu-id="5a457-452">32개의 표준 저장소 디스크의 월간 비용은 $1,638가 됩니다.</span><span class="sxs-lookup"><span data-stu-id="5a457-452">The monthly cost of 32 standard storage disks will be $1,638.</span></span> <span data-ttu-id="5a457-453">예상되는 총 월간 비용은 $3,208가 됩니다.</span><span class="sxs-lookup"><span data-stu-id="5a457-453">The estimated total monthly cost will be $3,208.</span></span>

<span data-ttu-id="5a457-454">그러나 프리미엄 저장소에 동일한 응용 프로그램을 호스팅한 경우 더 작은 VM 크기와 적은 프리미엄 저장소 디스크가 필요하므로 전반적인 비용이 절감됩니다.</span><span class="sxs-lookup"><span data-stu-id="5a457-454">However, if you hosted the same application on Premium Storage, you will need a smaller VM size and fewer premium storage disks, thus reducing the overall cost.</span></span> <span data-ttu-id="5a457-455">Standard\_DS13 VM은 4개의 P30 디스크를 사용하여 16,000 IOPS 요구 사항을 충족할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="5a457-455">A Standard\_DS13 VM can meet the 16,000 IOPS requirement using four P30 disks.</span></span> <span data-ttu-id="5a457-456">DS13 VM은 25,600의 최대 IOPS를 가지고 각 P30 디스크는 5,000의 최대 IOPS를 가집니다.</span><span class="sxs-lookup"><span data-stu-id="5a457-456">The DS13 VM has a maximum IOPS of 25,600 and each P30 disk has a maximum IOPS of 5,000.</span></span> <span data-ttu-id="5a457-457">전체적으로 이 구성은 5,000 x 4 = 20,000 IOPS를 달성할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="5a457-457">Overall, this configuration can achieve 5,000 x 4 = 20,000 IOPS.</span></span> <span data-ttu-id="5a457-458">예상되는 이 VM의 월별 비용은 $1,003입니다.</span><span class="sxs-lookup"><span data-stu-id="5a457-458">The estimated cost of this VM per month will be $1,003.</span></span> <span data-ttu-id="5a457-459">4개의 P30 프리미엄 저장소 디스크의 월간 비용은 $544.34가 됩니다.</span><span class="sxs-lookup"><span data-stu-id="5a457-459">The monthly cost of four P30 premium storage disks will be $544.34.</span></span> <span data-ttu-id="5a457-460">예상되는 총 월별 비용은 $1,544입니다.</span><span class="sxs-lookup"><span data-stu-id="5a457-460">The estimated total monthly cost will be $1,544.</span></span>

<span data-ttu-id="5a457-461">다음 표에서 표준 및 프리미엄 저장소에 대한 이 시나리오의 비용 분석을 요약합니다.</span><span class="sxs-lookup"><span data-stu-id="5a457-461">Table below summarizes the cost breakdown of this scenario for Standard and Premium Storage.</span></span>

| &nbsp; | <span data-ttu-id="5a457-462">**Standard**</span><span class="sxs-lookup"><span data-stu-id="5a457-462">**Standard**</span></span> | <span data-ttu-id="5a457-463">**Premium**</span><span class="sxs-lookup"><span data-stu-id="5a457-463">**Premium**</span></span> |
| --- | --- | --- |
| <span data-ttu-id="5a457-464">**월별 VM 비용**</span><span class="sxs-lookup"><span data-stu-id="5a457-464">**Cost of VM per month**</span></span> |<span data-ttu-id="5a457-465">$1,570.58(Standard\_D14)</span><span class="sxs-lookup"><span data-stu-id="5a457-465">$1,570.58 (Standard\_D14)</span></span> |<span data-ttu-id="5a457-466">$1,003.66(Standard\_DS13)</span><span class="sxs-lookup"><span data-stu-id="5a457-466">$1,003.66 (Standard\_DS13)</span></span> |
| <span data-ttu-id="5a457-467">**월별 디스크 비용**</span><span class="sxs-lookup"><span data-stu-id="5a457-467">**Cost of Disks per month**</span></span> |<span data-ttu-id="5a457-468">$1,638.40(32 x 1 TB 디스크)</span><span class="sxs-lookup"><span data-stu-id="5a457-468">$1,638.40 (32 x 1 TB disks)</span></span> |<span data-ttu-id="5a457-469">$544.34(4 x P30 디스크)</span><span class="sxs-lookup"><span data-stu-id="5a457-469">$544.34 (4 x P30 disks)</span></span> |
| <span data-ttu-id="5a457-470">**월별 전체 비용**</span><span class="sxs-lookup"><span data-stu-id="5a457-470">**Overall Cost per month**</span></span> |<span data-ttu-id="5a457-471">$3,208.98</span><span class="sxs-lookup"><span data-stu-id="5a457-471">$3,208.98</span></span> |<span data-ttu-id="5a457-472">$1,544.34</span><span class="sxs-lookup"><span data-stu-id="5a457-472">$1,544.34</span></span> |

<span data-ttu-id="5a457-473">*Linux 배포판*</span><span class="sxs-lookup"><span data-stu-id="5a457-473">*Linux Distros*</span></span>  

<span data-ttu-id="5a457-474">Azure 프리미엄 저장소를 사용하여 Windows 및 Linux를 실행하는 VM에 대해 동일한 성능 수준을 얻습니다.</span><span class="sxs-lookup"><span data-stu-id="5a457-474">With Azure Premium Storage, you get the same level of Performance for VMs running Windows and Linux.</span></span> <span data-ttu-id="5a457-475">Linux 배포판의 여러 버전을 지원하고 [여기](../virtual-machines/linux/endorsed-distros.md?toc=%2fazure%2fvirtual-machines%2flinux%2ftoc.json)에서 전체 목록을 볼 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="5a457-475">We support many flavors of Linux distros, and you can see the complete list [here](../virtual-machines/linux/endorsed-distros.md?toc=%2fazure%2fvirtual-machines%2flinux%2ftoc.json).</span></span> <span data-ttu-id="5a457-476">다양한 배포판은 다양한 유형의 작업에 더 적합합니다.</span><span class="sxs-lookup"><span data-stu-id="5a457-476">It is important to note that different distros are better suited for different types of workloads.</span></span> <span data-ttu-id="5a457-477">작업이 실행 중인 배포판에 따라 다른 수준의 성능을 확인할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="5a457-477">You will see different levels of performance depending on the distro your workload is running on.</span></span> <span data-ttu-id="5a457-478">응용 프로그램을 사용하여 Linux 배포판을 테스트하고 가장 잘 작동하는 것을 선택합니다.</span><span class="sxs-lookup"><span data-stu-id="5a457-478">Test the Linux distros with your application and choose the one that works best.</span></span>

<span data-ttu-id="5a457-479">프리미엄 저장소를 사용하여 Linux를 실행할 때 높은 성능을 보장하기 위해 필요한 드라이버에 대한 최신 업데이트를 확인합니다.</span><span class="sxs-lookup"><span data-stu-id="5a457-479">When running Linux with Premium Storage, check the latest updates about required drivers to ensure high performance.</span></span>

## <a name="premium-storage-disk-sizes"></a><span data-ttu-id="5a457-480">프리미엄 저장소 디스크 크기</span><span class="sxs-lookup"><span data-stu-id="5a457-480">Premium Storage Disk Sizes</span></span>
<span data-ttu-id="5a457-481">Azure Premium Storage는 현재 일곱 가지 디스크 크기를 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="5a457-481">Azure Premium Storage offers seven disk sizes currently.</span></span> <span data-ttu-id="5a457-482">각 디스크 크기는 IOPS, 대역폭 및 저장소에 대한 다른 규모 한도를 가집니다.</span><span class="sxs-lookup"><span data-stu-id="5a457-482">Each disk size has a different scale limit for IOPS, Bandwidth and Storage.</span></span> <span data-ttu-id="5a457-483">응용 프로그램 요구 사항 및 높은 확장성의 VM 크기에 따라 올바른 프리미엄 저장소 디스크 크기를 선택합니다.</span><span class="sxs-lookup"><span data-stu-id="5a457-483">Choose the right Premium Storage Disk size depending on the application requirements and the high scale VM size.</span></span> <span data-ttu-id="5a457-484">아래 표에서 일곱 가지 디스크 크기와 해당 기능을 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="5a457-484">The table below shows the seven disks sizes and their capabilities.</span></span> <span data-ttu-id="5a457-485">P4 및 P6 크기는 현재 Managed Disks에 대해서만 지원됩니다.</span><span class="sxs-lookup"><span data-stu-id="5a457-485">P4 and P6 sizes are currently only supported for Managed Disks.</span></span>

| <span data-ttu-id="5a457-486">프리미엄 디스크 유형</span><span class="sxs-lookup"><span data-stu-id="5a457-486">Premium Disks Type</span></span>  | <span data-ttu-id="5a457-487">P4</span><span class="sxs-lookup"><span data-stu-id="5a457-487">P4</span></span>    | <span data-ttu-id="5a457-488">P6</span><span class="sxs-lookup"><span data-stu-id="5a457-488">P6</span></span>    | <span data-ttu-id="5a457-489">P10</span><span class="sxs-lookup"><span data-stu-id="5a457-489">P10</span></span>   | <span data-ttu-id="5a457-490">P20</span><span class="sxs-lookup"><span data-stu-id="5a457-490">P20</span></span>   | <span data-ttu-id="5a457-491">P30</span><span class="sxs-lookup"><span data-stu-id="5a457-491">P30</span></span>   | <span data-ttu-id="5a457-492">P40</span><span class="sxs-lookup"><span data-stu-id="5a457-492">P40</span></span>   | <span data-ttu-id="5a457-493">P50</span><span class="sxs-lookup"><span data-stu-id="5a457-493">P50</span></span>   | 
|---------------------|-------|-------|-------|-------|-------|-------|-------|
| <span data-ttu-id="5a457-494">디스크 크기</span><span class="sxs-lookup"><span data-stu-id="5a457-494">Disk size</span></span>           | <span data-ttu-id="5a457-495">32GB</span><span class="sxs-lookup"><span data-stu-id="5a457-495">32 GB</span></span> | <span data-ttu-id="5a457-496">64GB</span><span class="sxs-lookup"><span data-stu-id="5a457-496">64 GB</span></span> | <span data-ttu-id="5a457-497">128GB</span><span class="sxs-lookup"><span data-stu-id="5a457-497">128 GB</span></span>| <span data-ttu-id="5a457-498">512GB</span><span class="sxs-lookup"><span data-stu-id="5a457-498">512 GB</span></span>            | <span data-ttu-id="5a457-499">1,024GB(1TB)</span><span class="sxs-lookup"><span data-stu-id="5a457-499">1024 GB (1 TB)</span></span>    | <span data-ttu-id="5a457-500">2,048GB(2TB)</span><span class="sxs-lookup"><span data-stu-id="5a457-500">2048 GB (2 TB)</span></span>    | <span data-ttu-id="5a457-501">4,095GB(4TB)</span><span class="sxs-lookup"><span data-stu-id="5a457-501">4095 GB (4 TB)</span></span>    | 
| <span data-ttu-id="5a457-502">디스크당 IOPS</span><span class="sxs-lookup"><span data-stu-id="5a457-502">IOPS per disk</span></span>       | <span data-ttu-id="5a457-503">120</span><span class="sxs-lookup"><span data-stu-id="5a457-503">120</span></span>   | <span data-ttu-id="5a457-504">240</span><span class="sxs-lookup"><span data-stu-id="5a457-504">240</span></span>   | <span data-ttu-id="5a457-505">500</span><span class="sxs-lookup"><span data-stu-id="5a457-505">500</span></span>   | <span data-ttu-id="5a457-506">2,300</span><span class="sxs-lookup"><span data-stu-id="5a457-506">2300</span></span>              | <span data-ttu-id="5a457-507">5,000</span><span class="sxs-lookup"><span data-stu-id="5a457-507">5000</span></span>              | <span data-ttu-id="5a457-508">7,500</span><span class="sxs-lookup"><span data-stu-id="5a457-508">7500</span></span>              | <span data-ttu-id="5a457-509">7,500</span><span class="sxs-lookup"><span data-stu-id="5a457-509">7500</span></span>              | 
| <span data-ttu-id="5a457-510">디스크당 처리량</span><span class="sxs-lookup"><span data-stu-id="5a457-510">Throughput per disk</span></span> | <span data-ttu-id="5a457-511">초당 25MB</span><span class="sxs-lookup"><span data-stu-id="5a457-511">25 MB per second</span></span>  | <span data-ttu-id="5a457-512">초당 50MB</span><span class="sxs-lookup"><span data-stu-id="5a457-512">50 MB per second</span></span>  | <span data-ttu-id="5a457-513">초당 100MB</span><span class="sxs-lookup"><span data-stu-id="5a457-513">100 MB per second</span></span> | <span data-ttu-id="5a457-514">초당 150MB</span><span class="sxs-lookup"><span data-stu-id="5a457-514">150 MB per second</span></span> | <span data-ttu-id="5a457-515">초당 200MB</span><span class="sxs-lookup"><span data-stu-id="5a457-515">200 MB per second</span></span> | <span data-ttu-id="5a457-516">초당 250MB</span><span class="sxs-lookup"><span data-stu-id="5a457-516">250 MB per second</span></span> | <span data-ttu-id="5a457-517">초당 250MB</span><span class="sxs-lookup"><span data-stu-id="5a457-517">250 MB per second</span></span> | 


<span data-ttu-id="5a457-518">선택하는 디스크의 수는 선택한 디스크 크기에 따라 달라집니다.</span><span class="sxs-lookup"><span data-stu-id="5a457-518">How many disks you choose depends on the disk size chosen.</span></span> <span data-ttu-id="5a457-519">응용 프로그램 요구 사항에 맞게 하나의 P50 디스크 또는 여러 P10 디스크를 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="5a457-519">You could use a single P50 disk or multiple P10 disks to meet your application requirement.</span></span> <span data-ttu-id="5a457-520">선택할 때 다음에 나열된 고려 사항을 고려합니다.</span><span class="sxs-lookup"><span data-stu-id="5a457-520">Take into account considerations listed below when making the choice.</span></span>

<span data-ttu-id="5a457-521">*규모 제한(IOPS 및 처리량)*</span><span class="sxs-lookup"><span data-stu-id="5a457-521">*Scale Limits (IOPS and Throughput)*</span></span>  
<span data-ttu-id="5a457-522">각 프리미엄 디스크 크기의 IOPS 및 처리량 한계는 VM 규모 제한과 서로 다르며 독립적입니다.</span><span class="sxs-lookup"><span data-stu-id="5a457-522">The IOPS and Throughput limits of each Premium disk size is different and independent from the VM scale limits.</span></span> <span data-ttu-id="5a457-523">디스크에서 총 IOPS 및 처리량이 선택한 VM 크기의 규모 제한 내에 있는지 확인합니다.</span><span class="sxs-lookup"><span data-stu-id="5a457-523">Make sure that the total IOPS and Throughput from the disks are within scale limits of the chosen VM size.</span></span>

<span data-ttu-id="5a457-524">예를 들어 응용 프로그램 요구 사항이 최대 250MB/초의 처리량이고 단일 P30 디스크와 함께 DS4 VM을 사용하는 경우를 가정합니다.</span><span class="sxs-lookup"><span data-stu-id="5a457-524">For example, if an application requirement is a maximum of 250 MB/sec Throughput and you are using a DS4 VM with a single P30 disk.</span></span> <span data-ttu-id="5a457-525">DS4 VM은 최대 256MB/초의 처리량을 제공할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="5a457-525">The DS4 VM can give up to 256 MB/sec Throughput.</span></span> <span data-ttu-id="5a457-526">그러나 단일 P30 디스크는 200MB/초의 처리량 제한이 있습니다.</span><span class="sxs-lookup"><span data-stu-id="5a457-526">However, a single P30 disk has Throughput limit of 200 MB/sec.</span></span> <span data-ttu-id="5a457-527">따라서 디스크 제한으로 인해 응용 프로그램에 200MB/초로 제한이 적용됩니다.</span><span class="sxs-lookup"><span data-stu-id="5a457-527">Consequently, the application will be constrained at 200 MB/sec due to the disk limit.</span></span> <span data-ttu-id="5a457-528">이 제한을 극복하기 위해 VM에 둘 이상의 데이터 디스크를 프로비전하거나 디스크의 크기를 P40 또는 P50으로 조정합니다.</span><span class="sxs-lookup"><span data-stu-id="5a457-528">To overcome this limit, provision more than one data disks to the VM or resize your disks to P40 or P50.</span></span>

> [!NOTE]
> <span data-ttu-id="5a457-529">캐시에서 제공하는 읽기는 디스크 IOPS 및 처리량에 포함되지 않으므로 디스크 제한이 없습니다.</span><span class="sxs-lookup"><span data-stu-id="5a457-529">Reads served by the cache are not included in the disk IOPS and Throughput, hence not subject to disk limits.</span></span> <span data-ttu-id="5a457-530">캐시에는 VM당 별도 IOPS 및 처리량 제한이 있습니다.</span><span class="sxs-lookup"><span data-stu-id="5a457-530">Cache has its separate IOPS and Throughput limit per VM.</span></span>
>
> <span data-ttu-id="5a457-531">예를 들어 처음에 읽기 및 쓰기는 각각 60MB/초 및 40MB/초입니다.</span><span class="sxs-lookup"><span data-stu-id="5a457-531">For example, initially your reads and writes are 60MB/sec and 40MB/sec respectively.</span></span> <span data-ttu-id="5a457-532">시간이 지남에 따라 캐시는 가동 준비하고 캐시에서 더 많은 읽기를 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="5a457-532">Over time, the cache warms up and serves more and more of the reads from the cache.</span></span> <span data-ttu-id="5a457-533">그런 다음 디스크에서 더 높은 쓰기 처리량을 얻을 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="5a457-533">Then, you can get higher write Throughput from the disk.</span></span>
>
>

<span data-ttu-id="5a457-534">*디스크 수*</span><span class="sxs-lookup"><span data-stu-id="5a457-534">*Number of Disks*</span></span>  
<span data-ttu-id="5a457-535">응용 프로그램 요구 사항을 평가하여 필요한 디스크 수를 결정합니다.</span><span class="sxs-lookup"><span data-stu-id="5a457-535">Determine the number of disks you will need by assessing application requirements.</span></span> <span data-ttu-id="5a457-536">각 VM 크기는 VM에 연결할 수 있는 디스크 수의 제한 또한 있습니다.</span><span class="sxs-lookup"><span data-stu-id="5a457-536">Each VM size also has a limit on the number of disks that you can attach to the VM.</span></span> <span data-ttu-id="5a457-537">일반적으로 코어 수의 두 배입니다.</span><span class="sxs-lookup"><span data-stu-id="5a457-537">Typically, this is twice the number of cores.</span></span> <span data-ttu-id="5a457-538">선택한 VM 크기가 필요한 디스크 수를 지원할 수 있는지 확인합니다.</span><span class="sxs-lookup"><span data-stu-id="5a457-538">Ensure that the VM size you choose can support the number of disks needed.</span></span>

<span data-ttu-id="5a457-539">프리미엄 저장소 디스크에는 표준 저장소 디스크에 비해 더 높은 성능 기능이 있습니다.</span><span class="sxs-lookup"><span data-stu-id="5a457-539">Remember, the Premium Storage disks have higher performance capabilities compared to Standard Storage disks.</span></span> <span data-ttu-id="5a457-540">따라서 표준 저장소를 사용하여 Azure IaaS VM에서 응용 프로그램을 프리미엄 저장소로 마이그레이션하는 경우 응용 프로그램에 대해 동일 하거나 더 높은 성능을 얻을 수 있도록 더 적은 프리미엄 디스크가 필요할 가능성이 있습니다.</span><span class="sxs-lookup"><span data-stu-id="5a457-540">Therefore, if you are migrating your application from Azure IaaS VM using Standard Storage to Premium Storage, you will likely need fewer premium disks to achieve the same or higher performance for your application.</span></span>

## <a name="disk-caching"></a><span data-ttu-id="5a457-541">디스크 캐싱</span><span class="sxs-lookup"><span data-stu-id="5a457-541">Disk Caching</span></span>
<span data-ttu-id="5a457-542">Azure 프리미엄 저장소를 활용하는 높은 확장성의 VM에는 BlobCache 라는 다중 계층 캐싱 기술이 있습니다.</span><span class="sxs-lookup"><span data-stu-id="5a457-542">High Scale VMs that leverage Azure Premium Storage have a multi-tier caching technology called BlobCache.</span></span> <span data-ttu-id="5a457-543">BlobCache는 캐싱에 대해 가상 컴퓨터 RAM 및 로컬 SSD의 조합을 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="5a457-543">BlobCache uses a combination of the Virtual Machine RAM and local SSD for caching.</span></span> <span data-ttu-id="5a457-544">이 캐시는 프리미엄 저장소 영구 디스크 및 VM 로컬 디스크에 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="5a457-544">This cache is available for the Premium Storage persistent disks and the VM local disks.</span></span> <span data-ttu-id="5a457-545">기본적으로 이 캐시 설정은 OS 디스크에 대해 읽기/쓰기로 프리미엄 저장소에서 호스팅되는 데이터 디스크에 대해 읽기 전용으로 설정됩니다.</span><span class="sxs-lookup"><span data-stu-id="5a457-545">By default, this cache setting is set to Read/Write for OS disks and ReadOnly for data disks hosted on Premium Storage.</span></span> <span data-ttu-id="5a457-546">프리미엄 저장소 디스크에서 디스크 캐싱을 사용하면 높은 확장성의 VM은 기본 디스크 성능을 초과하는 매우 높은 수준의 성능을 얻을 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="5a457-546">With disk caching enabled on the Premium Storage disks, the high scale VMs can achieve extremely high levels of performance that exceed the underlying disk performance.</span></span>

> [!WARNING]
> <span data-ttu-id="5a457-547">Azure 디스크의 캐시 설정을 변경하면 대상 디스크가 분리되었다가 다시 연결됩니다.</span><span class="sxs-lookup"><span data-stu-id="5a457-547">Changing the cache setting of an Azure disk detaches and re-attaches the target disk.</span></span> <span data-ttu-id="5a457-548">운영 체제 디스크인 경우 VM이 다시 시작됩니다.</span><span class="sxs-lookup"><span data-stu-id="5a457-548">If it is the operating system disk, the VM is restarted.</span></span> <span data-ttu-id="5a457-549">디스크 캐시 설정을 변경하기 전에 이 중단의 영향을 받을 수 있는 모든 응용 프로그램/서비스를 중지합니다.</span><span class="sxs-lookup"><span data-stu-id="5a457-549">Stop all applications/services that might be affected by this disruption before changing the disk cache setting.</span></span>
>
>

<span data-ttu-id="5a457-550">BlobCache를 작동하는 방법에 대한 자세한 내용은 내부 [Azure 프리미엄 저장소](https://azure.microsoft.com/blog/azure-premium-storage-now-generally-available-2/) 블로그 게시물을 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="5a457-550">To learn more about how BlobCache works, refer to the Inside [Azure Premium Storage](https://azure.microsoft.com/blog/azure-premium-storage-now-generally-available-2/) blog post.</span></span>

<span data-ttu-id="5a457-551">올바른 디스크 집합에 캐시를 사용하는 것이 중요합니다.</span><span class="sxs-lookup"><span data-stu-id="5a457-551">It is important to enable cache on the right set of disks.</span></span> <span data-ttu-id="5a457-552">프리미엄 디스크에 디스크 캐싱을 사용하도록 설정할지 여부는 디스크가 처리될 작업 패턴에 따라 달라집니다.</span><span class="sxs-lookup"><span data-stu-id="5a457-552">Whether you should enable disk caching on a premium disk or not will depend on the workload pattern that disk will be handling.</span></span> <span data-ttu-id="5a457-553">다음 표에서 OS 및 데이터 디스크에 대한 기본 캐시 설정을 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="5a457-553">Table below shows the default cache settings for OS and Data disks.</span></span>

| <span data-ttu-id="5a457-554">**디스크 유형**</span><span class="sxs-lookup"><span data-stu-id="5a457-554">**Disk Type**</span></span> | <span data-ttu-id="5a457-555">**기본 캐시 설정**</span><span class="sxs-lookup"><span data-stu-id="5a457-555">**Default Cache Setting**</span></span> |
| --- | --- |
| <span data-ttu-id="5a457-556">OS 디스크</span><span class="sxs-lookup"><span data-stu-id="5a457-556">OS disk</span></span> |<span data-ttu-id="5a457-557">ReadWrite</span><span class="sxs-lookup"><span data-stu-id="5a457-557">ReadWrite</span></span> |
| <span data-ttu-id="5a457-558">데이터 디스크 </span><span class="sxs-lookup"><span data-stu-id="5a457-558">Data disk</span></span> |<span data-ttu-id="5a457-559">없음</span><span class="sxs-lookup"><span data-stu-id="5a457-559">None</span></span> |

<span data-ttu-id="5a457-560">다음은 데이터 디스크에 대한 권장 디스크 캐시 설정입니다.</span><span class="sxs-lookup"><span data-stu-id="5a457-560">Following are the recommended disk cache settings for data disks,</span></span>

| <span data-ttu-id="5a457-561">**디스크 캐싱 설정**</span><span class="sxs-lookup"><span data-stu-id="5a457-561">**Disk Caching Setting**</span></span> | <span data-ttu-id="5a457-562">**이 설정을 사용하는 시점에 대한 권장 사항**</span><span class="sxs-lookup"><span data-stu-id="5a457-562">**Recommendation on when to use this setting**</span></span> |
| --- | --- |
| <span data-ttu-id="5a457-563">없음</span><span class="sxs-lookup"><span data-stu-id="5a457-563">None</span></span> |<span data-ttu-id="5a457-564">쓰기 전용 및 쓰기가 많은 디스크에 대해 None으로 호스트-캐시를 구성합니다.</span><span class="sxs-lookup"><span data-stu-id="5a457-564">Configure host-cache as None for write-only and write-heavy disks.</span></span> |
| <span data-ttu-id="5a457-565">ReadOnly</span><span class="sxs-lookup"><span data-stu-id="5a457-565">ReadOnly</span></span> |<span data-ttu-id="5a457-566">읽기 전용 및 읽기-쓰기 디스크에 대해 ReadOnly로 호스트-캐시를 구성합니다.</span><span class="sxs-lookup"><span data-stu-id="5a457-566">Configure host-cache as ReadOnly for read-only and read-write disks.</span></span> |
| <span data-ttu-id="5a457-567">ReadWrite</span><span class="sxs-lookup"><span data-stu-id="5a457-567">ReadWrite</span></span> |<span data-ttu-id="5a457-568">응용 프로그램이 필요할 때 영구 디스크에 캐시된 데이터 쓰기를 올바르게 처리하는 경우 ReadWrite로 호스트-캐시를 구성합니다.</span><span class="sxs-lookup"><span data-stu-id="5a457-568">Configure host-cache as ReadWrite only if your application properly  handles writing cached data to persistent disks when needed.</span></span> |

<span data-ttu-id="5a457-569">*ReadOnly*</span><span class="sxs-lookup"><span data-stu-id="5a457-569">*ReadOnly*</span></span>  
<span data-ttu-id="5a457-570">프리미엄 저장소 데이터 디스크에 ReadOnly 캐싱을 구성하여 짧은 읽기 대기 시간을 달성하고 응용 프로그램에 대한 매우 높은 읽기 IOPS 및 처리량을 얻을 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="5a457-570">By configuring ReadOnly caching on Premium Storage data disks, you can achieve low Read latency and get very high Read IOPS and Throughput for your application.</span></span> <span data-ttu-id="5a457-571">다음 두 가지 이유로 인한 것입니다.</span><span class="sxs-lookup"><span data-stu-id="5a457-571">This is due two reasons,</span></span>

1. <span data-ttu-id="5a457-572">VM 메모리 및 로컬 SSD에 있는 캐시에서 수행되는 읽기는 Azure Blob 저장소에 있는 데이터 디스크에서 읽기보다 훨씬 빠릅니다.</span><span class="sxs-lookup"><span data-stu-id="5a457-572">Reads performed from cache, which is on the VM memory and local SSD, are much faster than reads from the data disk, which is on the Azure blob storage.</span></span>  
2. <span data-ttu-id="5a457-573">프리미엄 저장소는 디스크 IOPS 및 처리량으로 캐시에서 제공된 읽기를 계산하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="5a457-573">Premium Storage does not count the Reads served from cache, towards the disk IOPS and Throughput.</span></span> <span data-ttu-id="5a457-574">따라서 응용 프로그램은 더 높은 총 IOPS 및 처리량을 달성할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="5a457-574">Therefore, your application is able to achieve higher total IOPS and Throughput.</span></span>

<span data-ttu-id="5a457-575">*ReadWrite*</span><span class="sxs-lookup"><span data-stu-id="5a457-575">*ReadWrite*</span></span>  
<span data-ttu-id="5a457-576">기본적으로 OS 디스크는 ReadWrite 캐싱을 사용하도록 설정합니다.</span><span class="sxs-lookup"><span data-stu-id="5a457-576">By default, the OS disks have ReadWrite caching enabled.</span></span> <span data-ttu-id="5a457-577">최근에 데이터 디스크에 ReadWrite 캐싱에 대한 지원을 추가했습니다.</span><span class="sxs-lookup"><span data-stu-id="5a457-577">We have recently added support for ReadWrite caching on data disks as well.</span></span> <span data-ttu-id="5a457-578">ReadWrite 캐싱을 사용하는 경우 영구 디스크에 캐시의 데이터를 기록하는 적절한 방법이 있어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="5a457-578">If you are using ReadWrite caching, you must have a proper way to write the data from cache to persistent disks.</span></span> <span data-ttu-id="5a457-579">예를 들어 SQL Server는 자체적으로 영구 저장소 디스크에 캐시된 데이터 쓰기를 처리합니다.</span><span class="sxs-lookup"><span data-stu-id="5a457-579">For example, SQL Server handles writing cached data to the persistent storage disks on its own.</span></span> <span data-ttu-id="5a457-580">필요한 데이터를 유지하도록 처리하지 않는 응용 프로그램에 ReadWrite 캐시를 사용하면 VM이 충돌할 경우 데이터 손실이 발생할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="5a457-580">Using ReadWrite cache with an application that does not handle persisting the required data can lead to data loss, if the VM crashes.</span></span>

<span data-ttu-id="5a457-581">한 예로 다음을 수행하여 프리미엄 저장소에서 실행 중인 SQL Server에 이러한 지침을 적용할 수 있습니다</span><span class="sxs-lookup"><span data-stu-id="5a457-581">As an example, you can apply these guidelines to SQL Server running on Premium Storage by doing the following,</span></span>

1. <span data-ttu-id="5a457-582">데이터 파일을 호스트하는 Premium Storage 디스크에 “ReadOnly” 캐시를 구성합니다.</span><span class="sxs-lookup"><span data-stu-id="5a457-582">Configure "ReadOnly" cache on premium storage disks hosting data files.</span></span>  
   <span data-ttu-id="5a457-583">a.</span><span class="sxs-lookup"><span data-stu-id="5a457-583">a.</span></span>  <span data-ttu-id="5a457-584">데이터 페이지는 데이터 디스크에서 직접 검색하는 것보다 캐시에서 훨씬 빨리 검색하므로 캐시에서 빠른 읽기는 SQL Server 쿼리 시간을 낮춥니다.</span><span class="sxs-lookup"><span data-stu-id="5a457-584">The fast reads from cache lower the SQL Server query time since data pages are retrieved much faster from the cache compared to directly from the data disks.</span></span>  
   <span data-ttu-id="5a457-585">b.</span><span class="sxs-lookup"><span data-stu-id="5a457-585">b.</span></span>  <span data-ttu-id="5a457-586">캐시에서 읽기 제공은 프리미엄 데이터 디스크에서 사용할 수 있는 추가 처리량이 있음을 의미합니다.</span><span class="sxs-lookup"><span data-stu-id="5a457-586">Serving reads from cache, means there is additional Throughput available from premium data disks.</span></span> <span data-ttu-id="5a457-587">SQL Server는 이 추가 처리량을 사용하여 더 많은 데이터 페이지와 백업/복원, 배치 처리 및 인덱스 다시 빌드와 같은 다른 작업을 검색할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="5a457-587">SQL Server can use this additional Throughput towards retrieving more data pages and other operations like backup/restore, batch loads, and index rebuilds.</span></span>  
2. <span data-ttu-id="5a457-588">로그 파일을 호스트하는 Premium Storage 디스크에 “None” 캐시를 구성합니다.</span><span class="sxs-lookup"><span data-stu-id="5a457-588">Configure "None" cache on premium storage disks hosting the log files.</span></span>  
   <span data-ttu-id="5a457-589">a.</span><span class="sxs-lookup"><span data-stu-id="5a457-589">a.</span></span>  <span data-ttu-id="5a457-590">로그 파일은 주로 많은 쓰기 작업을 가집니다.</span><span class="sxs-lookup"><span data-stu-id="5a457-590">Log files have primarily write-heavy operations.</span></span> <span data-ttu-id="5a457-591">따라서 ReadOnly 캐시에서 유용하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="5a457-591">Therefore, they do not benefit from the ReadOnly cache.</span></span>

## <a name="disk-striping"></a><span data-ttu-id="5a457-592">디스크 스트라이프</span><span class="sxs-lookup"><span data-stu-id="5a457-592">Disk Striping</span></span>
<span data-ttu-id="5a457-593">높은 확장성의 VM이 여러 프리미엄 저장소 영구 디스크와 연결되어 있는 경우 디스크는 해당 IOP, 대역폭 및 저장소 용량을 집계하도록 함께 스트라이프될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="5a457-593">When a high scale VM is attached with several premium storage persistent disks, the disks can be striped together to aggregate their IOPs, bandwidth, and storage capacity.</span></span>

<span data-ttu-id="5a457-594">Windows에서 저장소 공간을 사용하여 디스크를 함께 스트라이프할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="5a457-594">On Windows, you can use Storage Spaces to stripe disks together.</span></span> <span data-ttu-id="5a457-595">풀에서 각 디스크마다 하나의 열을 구성해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="5a457-595">You must configure one column for each disk in a pool.</span></span> <span data-ttu-id="5a457-596">그렇지 않은 경우 디스크에서의 고르지 못한 트래픽 분배로 예상보다 스트라이프 볼륨의 전반적인 성능이 저하될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="5a457-596">Otherwise, the overall performance of striped volume can be lower than expected, due to uneven distribution of traffic across the disks.</span></span>

<span data-ttu-id="5a457-597">중요: 서버 관리자 UI를 사용하여 스트라이프 볼륨에 대해 최대 8개까지 열의 총 수를 설정할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="5a457-597">Important: Using Server Manager UI, you can set the total number of columns up to 8 for a striped volume.</span></span> <span data-ttu-id="5a457-598">8개 이상의 디스크를 연결하는 경우 PowerShell을 사용하여 볼륨을 만듭니다.</span><span class="sxs-lookup"><span data-stu-id="5a457-598">When attaching more than 8 disks, use PowerShell to create the volume.</span></span> <span data-ttu-id="5a457-599">PowerShell을 사용하여 디스크 수와 동일한 열 수를 설정할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="5a457-599">Using PowerShell, you can set the number of columns equal to the number of disks.</span></span> <span data-ttu-id="5a457-600">예를 들어 단일 스트라이프 집합에 16개의 디스크가 있는 경우 *New-VirtualDisk* PowerShell cmdlet의 *NumberOfColumns* 매개 변수에 16개의 열을 지정합니다.</span><span class="sxs-lookup"><span data-stu-id="5a457-600">For example, if there are 16 disks in a single stripe set; specify 16 columns in the *NumberOfColumns* parameter of the *New-VirtualDisk* PowerShell cmdlet.</span></span>

<span data-ttu-id="5a457-601">Linux에서 MDADM 유틸리티를 사용하여 디스크를 함께 스트라이프합니다.</span><span class="sxs-lookup"><span data-stu-id="5a457-601">On Linux, use the MDADM utility to stripe disks together.</span></span> <span data-ttu-id="5a457-602">Linux에서 디스크 스트라이프에 대한 자세한 단계는 [Linux에서 소프트웨어 RAID 구성](../virtual-machines/linux/configure-raid.md?toc=%2fazure%2fvirtual-machines%2flinux%2ftoc.json)을 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="5a457-602">For detailed steps on striping disks on Linux refer to [Configure Software RAID on Linux](../virtual-machines/linux/configure-raid.md?toc=%2fazure%2fvirtual-machines%2flinux%2ftoc.json).</span></span>

<span data-ttu-id="5a457-603">*스트라이프 크기*</span><span class="sxs-lookup"><span data-stu-id="5a457-603">*Stripe Size*</span></span>  
<span data-ttu-id="5a457-604">디스크 스트라이프에서 중요한 구성은 스트라이프 크기입니다.</span><span class="sxs-lookup"><span data-stu-id="5a457-604">An important configuration in disk striping is the stripe size.</span></span> <span data-ttu-id="5a457-605">스트라이프 크기 또는 블록 크기는 응용 프로그램이 스트라이프 볼륨을 해결할 수 있는 데이터의 가장 작은 청크입니다.</span><span class="sxs-lookup"><span data-stu-id="5a457-605">The stripe size or block size is the smallest chunk of data that application can address on a striped volume.</span></span> <span data-ttu-id="5a457-606">구성한 스트라이프 크기는 응용 프로그램 및 해당 요청 패턴의 형식에 따라 달라집니다.</span><span class="sxs-lookup"><span data-stu-id="5a457-606">The stripe size you configure depends on the type of application and its request pattern.</span></span> <span data-ttu-id="5a457-607">잘못된 스트라이프 크기를 선택하는 경우 응용 프로그램의 성능이 저하되는 IO 정렬 문제가 발생할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="5a457-607">If you choose the wrong stripe size, it could lead to IO misalignment, which leads to degraded performance of your application.</span></span>

<span data-ttu-id="5a457-608">예를 들어 응용 프로그램에 의해 생성된 IO 요청이 디스크 스트라이프 크기보다 큰 경우 저장소 시스템은 둘 이상의 디스크에 스트라이프 단위 경계를 넘어 작성합니다.</span><span class="sxs-lookup"><span data-stu-id="5a457-608">For example, if an IO request generated by your application is bigger than the disk stripe size, the storage system writes it across stripe unit boundaries on more than one disk.</span></span> <span data-ttu-id="5a457-609">해당 데이터에 액세스할 때 요청을 완료하려면 둘 이상의 스트라이프 단위 간을 검색해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="5a457-609">When it is time to access that data, it will have to seek across more than one stripe units to complete the request.</span></span> <span data-ttu-id="5a457-610">이러한 동작의 누적 된 효과로 성능이 상당히 저하될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="5a457-610">The cumulative effect of such behavior can lead to substantial performance degradation.</span></span> <span data-ttu-id="5a457-611">반면에 IO 요청 크기가 스트라이프 크기보다 작고 기본적으로 임의일 경우 IO 요청은 병목 상태가 발생하고 궁극적으로 IO 성능이 저하되는 동일한 디스크에 추가할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="5a457-611">On the other hand, if the IO request size is smaller than stripe size, and if it is random in nature, the IO requests may add up on the same disk causing a bottleneck and ultimately degrading the IO performance.</span></span>

<span data-ttu-id="5a457-612">응용 프로그램이 실행하는 작업의 유형에 따라 적절한 스트라이프 크기를 선택합니다.</span><span class="sxs-lookup"><span data-stu-id="5a457-612">Depending on the type of workload your application is running, choose an appropriate stripe size.</span></span> <span data-ttu-id="5a457-613">작은 임의 IO 요청의 경우 더 작은 스트라이프 크기를 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="5a457-613">For random small IO requests, use a smaller stripe size.</span></span> <span data-ttu-id="5a457-614">반면 큰 순차 IO 요청의 경우 더 큰 스트라이프 크기를 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="5a457-614">Whereas, for large sequential IO requests use a larger stripe size.</span></span> <span data-ttu-id="5a457-615">프리미엄 저장소에서 실행되는 응용 프로그램에 대한 스트라이프 크기 권장 사항에 대해 알아봅니다.</span><span class="sxs-lookup"><span data-stu-id="5a457-615">Find out the stripe size recommendations for the application you will be running on Premium Storage.</span></span> <span data-ttu-id="5a457-616">SQL Server의 경우 OLTP 작업에 대해 64KB의 스트라이프 크기, 데이터 웨어하우징 작업에 대해 256KB의 스트라이프 크기를 구성합니다.</span><span class="sxs-lookup"><span data-stu-id="5a457-616">For SQL Server, configure stripe size of 64KB for OLTP workloads and 256KB for data warehousing workloads.</span></span> <span data-ttu-id="5a457-617">자세한 내용은 [Azure VM의 SQL Server에 대한 성능 모범 사례](../virtual-machines/windows/sql/virtual-machines-windows-sql-performance.md#disks-guidance) 를 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="5a457-617">See [Performance best practices for SQL Server on Azure VMs](../virtual-machines/windows/sql/virtual-machines-windows-sql-performance.md#disks-guidance) to learn more.</span></span>

> [!NOTE]
> <span data-ttu-id="5a457-618">DS 시리즈 VM에 최대 32개의 프리미엄 저장소 디스크를 GS 시리즈 VM에 64개의 프리미엄 저장소 디스크를 함께 스트라이프할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="5a457-618">You can stripe together a maximum of 32 premium storage disks on a DS series VM and 64 premium storage disks on a GS series VM.</span></span>
>
>

## <a name="multi-threading"></a><span data-ttu-id="5a457-619">다중 스레드</span><span class="sxs-lookup"><span data-stu-id="5a457-619">Multi-threading</span></span>
<span data-ttu-id="5a457-620">Azure는 대규모로 병렬되도록 프리미엄 저장소 플랫폼을 설계합니다.</span><span class="sxs-lookup"><span data-stu-id="5a457-620">Azure has designed Premium Storage platform to be massively parallel.</span></span> <span data-ttu-id="5a457-621">따라서 다중 스레드 응용 프로그램은 단일 스레드 응용 프로그램에 비해 훨씬 더 높은 성능을 얻을 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="5a457-621">Therefore, a multi-threaded application achieves much higher performance than a single-threaded application.</span></span> <span data-ttu-id="5a457-622">다중 스레드 응용 프로그램은 여러 스레드로 해당 작업을 분할하고 VM 및 디스크 리소스를 최대한으로 활용하여 해당 실행의 효율성을 높입니다.</span><span class="sxs-lookup"><span data-stu-id="5a457-622">A multi-threaded application splits up its tasks across multiple threads and increases efficiency of its execution by utilizing the VM and disk resources to the maximum.</span></span>

<span data-ttu-id="5a457-623">예를 들어 응용 프로그램이 두 개의 스레드를 사용하여 단일 코어 VM에서 실행 중인 경우 CPU는 효율성을 달성하기 위해 두 스레드 사이를 전환할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="5a457-623">For example, if your application is running on a single core VM using two threads, the CPU can switch between the two threads to achieve efficiency.</span></span> <span data-ttu-id="5a457-624">한 스레드가 디스크 IO 완료를 대기하는 동안 CPU에서 다른 스레드로 전환할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="5a457-624">While one thread is waiting on a disk IO to complete, the CPU can switch to the other thread.</span></span> <span data-ttu-id="5a457-625">이러한 방식으로 두 스레드는 단일 스레드보다 더 많은 작업을 수행할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="5a457-625">In this way, two threads can accomplish more than a single thread would.</span></span> <span data-ttu-id="5a457-626">VM에 두 개 이상의 코어가 있는 경우 각 코어는 병렬로 작업을 실행할 수 있으므로 실행 시간이 더 줄어듭니다.</span><span class="sxs-lookup"><span data-stu-id="5a457-626">If the VM has more than one core, it further decreases running time since each core can execute tasks in parallel.</span></span>

<span data-ttu-id="5a457-627">기존의 응용 프로그램이 단일 스레딩 또는 다중 스레딩을 구현하는 방식을 변경할 수 없을 수도 있습니다.</span><span class="sxs-lookup"><span data-stu-id="5a457-627">You may not be able to change the way an off-the-shelf application implements single threading or multi-threading.</span></span> <span data-ttu-id="5a457-628">예를 들어 SQL Server는 다중 CPU 및 다중 코어를 처리할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="5a457-628">For example, SQL Server is capable of handling multi-CPU and multi-core.</span></span> <span data-ttu-id="5a457-629">그러나 SQL Server는 어떤 조건에서 쿼리를 처리하도록 하나 이상의 스레드를 활용할지를 결정합니다.</span><span class="sxs-lookup"><span data-stu-id="5a457-629">However, SQL Server decides under what conditions it will leverage one or more threads to process a query.</span></span> <span data-ttu-id="5a457-630">다중 스레드를 사용하여 쿼리를 실행하고 인덱스를 작성할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="5a457-630">It can run queries and build indexes using multi-threading.</span></span> <span data-ttu-id="5a457-631">사용자에게 반환하기 전에 큰 테이블 결합 및 데이터 정렬을 포함하는 쿼리의 경우 SQL Server는 다중 스레드를 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="5a457-631">For a query that involves joining large tables and sorting data before returning to the user, SQL Server will likely use multiple threads.</span></span> <span data-ttu-id="5a457-632">그러나 사용자는 SQL Server에서 단일 스레드 또는 다중 스레드를 사용하여 쿼리를 실행할지 여부를 제어할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="5a457-632">However, a user cannot control whether SQL Server executes a query using a single thread or multiple threads.</span></span>

<span data-ttu-id="5a457-633">이 다중 스레딩 또는 응용 프로그램의 병렬 처리에 영향을 주도록 변경할 수 있는 구성 설정이 있습니다.</span><span class="sxs-lookup"><span data-stu-id="5a457-633">There are configuration settings that you can alter to influence this multi-threading or parallel processing of an application.</span></span> <span data-ttu-id="5a457-634">예를 들어 SQL Server의 경우 병렬 구성의 최대 수준입니다.</span><span class="sxs-lookup"><span data-stu-id="5a457-634">For example, in case of SQL Server it is the maximum Degree of Parallelism configuration.</span></span> <span data-ttu-id="5a457-635">이 설정은 MAXDOP로 SQL Server에서 병렬 처리 시 사용할 수는 프로세서의 최대 수를 구성할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="5a457-635">This setting called MAXDOP, allows you to configure the maximum number of processors SQL Server can use when parallel processing.</span></span> <span data-ttu-id="5a457-636">개별 쿼리 또는 인덱스 작업에 대한 MAXDOP를 구성할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="5a457-636">You can configure MAXDOP for individual queries or index operations.</span></span> <span data-ttu-id="5a457-637">이것은 성능이 중요한 응용 프로그램에 대한 시스템의 리소스 균형을 유지하려는 경우에 유용합니다.</span><span class="sxs-lookup"><span data-stu-id="5a457-637">This is beneficial when you want to balance resources of your system for a performance critical application.</span></span>

<span data-ttu-id="5a457-638">예를 들어 SQL Server를 사용하는 응용 프로그램이 큰 쿼리와 인덱스 작업을 동시에 실행한다고 가정합니다.</span><span class="sxs-lookup"><span data-stu-id="5a457-638">For example, say your application using SQL Server is executing a large query and an index operation at the same time.</span></span> <span data-ttu-id="5a457-639">인덱스 작업이 큰 쿼리보다 성능이 높아지길 원한다고 가정해 보겠습니다.</span><span class="sxs-lookup"><span data-stu-id="5a457-639">Let us assume that you wanted the index operation to be more performant compared to the large query.</span></span> <span data-ttu-id="5a457-640">이러한 경우 쿼리에 대한 MAXDOP 값보다 높도록 인덱스 작업의 MAXDOP 값을 설정할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="5a457-640">In such a case, you can set MAXDOP value of the index operation to be higher than the MAXDOP value for the query.</span></span> <span data-ttu-id="5a457-641">이러한 방식으로 SQL Server는 더 큰 쿼리에 사용할 수는 프로세서 수에 비해 인덱스 작업에 활용할 수 있는 더 많은 프로세서 수를 가집니다.</span><span class="sxs-lookup"><span data-stu-id="5a457-641">This way, SQL Server has more number of processors that it can leverage for the index operation compared to the number of processors it can dedicate to the large query.</span></span> <span data-ttu-id="5a457-642">SQL Server에서 각 작업에 사용할 스레드 수를 제어하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="5a457-642">Remember, you do not control the number of threads SQL Server will use for each operation.</span></span> <span data-ttu-id="5a457-643">다중 스레딩에 사용되는 프로세서의 최대 수를 제어할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="5a457-643">You can control the maximum number of processors being dedicated for multi-threading.</span></span>

<span data-ttu-id="5a457-644">SQL Server에 [병렬 처리의 정도](https://technet.microsoft.com/library/ms188611.aspx) 에 대한 자세한 정보가 있습니다.</span><span class="sxs-lookup"><span data-stu-id="5a457-644">Learn more about [Degrees of Parallelism](https://technet.microsoft.com/library/ms188611.aspx) in SQL Server.</span></span> <span data-ttu-id="5a457-645">성능을 최적화하도록 응용 프로그램의 다중 스레딩 및 해당 구성에 영향을 주는 설정을 확인합니다.</span><span class="sxs-lookup"><span data-stu-id="5a457-645">Find out such settings that influence multi-threading in your application and their configurations to optimize performance.</span></span>

## <a name="queue-depth"></a><span data-ttu-id="5a457-646">큐 크기</span><span class="sxs-lookup"><span data-stu-id="5a457-646">Queue Depth</span></span>
<span data-ttu-id="5a457-647">큐 크기 또는 큐 길이 또는 큐 크기는 시스템에서 보류 중인 IO 요청 횟수입니다.</span><span class="sxs-lookup"><span data-stu-id="5a457-647">The Queue Depth or Queue Length or Queue Size is the number of pending IO requests in the system.</span></span> <span data-ttu-id="5a457-648">큐 크기의 값은 응용 프로그램이 응용 프로그램이 저장소 디스크에서 처리되는 얼마나 많은 IO 작업을 줄 세울 수 있을지 결정합니다.</span><span class="sxs-lookup"><span data-stu-id="5a457-648">The value of Queue Depth determines how many IO operations your application can line up, which the storage disks will be processing.</span></span> <span data-ttu-id="5a457-649">이는 이 문서에서 설명한 세 가지 응용 프로그램 성능 지표인 IOPS, 처리량 및 대기 시간 모두에 영향을 줍니다.</span><span class="sxs-lookup"><span data-stu-id="5a457-649">It affects all the three application performance indicators that we discussed in this article viz., IOPS, Throughput and Latency.</span></span>

<span data-ttu-id="5a457-650">큐 크기 및 다중 스레딩은 밀접한 관련이 있습니다.</span><span class="sxs-lookup"><span data-stu-id="5a457-650">Queue Depth and multi-threading are closely related.</span></span> <span data-ttu-id="5a457-651">큐 크기 값은 얼마나 많은 다중 스레딩을 응용 프로그램에서 수행할 수 있는지를 나타냅니다.</span><span class="sxs-lookup"><span data-stu-id="5a457-651">The Queue Depth value indicates how much multi-threading can be achieved by the application.</span></span> <span data-ttu-id="5a457-652">큐 크기가 클 경우 응용 프로그램은 동시에 더 많은 작업 즉 다중 스레딩을 실행할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="5a457-652">If the Queue Depth is large, application can execute more operations concurrently, in other words, more multi-threading.</span></span> <span data-ttu-id="5a457-653">큐 크기가 작은 경우 응용 프로그램이 다중 스레드이더라도 동시 실행에 대한 충분한 요청이 없습니다.</span><span class="sxs-lookup"><span data-stu-id="5a457-653">If the Queue Depth is small, even though application is multi-threaded, it will not have enough requests lined up for concurrent execution.</span></span>

<span data-ttu-id="5a457-654">일반적으로 잘못 설정한 경우 해가 되므로 기존 응용 프로그램을 통해 큐 크기를 변경할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="5a457-654">Typically, off the shelf applications do not allow you to change the queue depth, because if set incorrectly it will do more harm than good.</span></span> <span data-ttu-id="5a457-655">응용 프로그램은 최적의 성능을 얻기 위해 올바른 값의 큐 크기를 설정합니다.</span><span class="sxs-lookup"><span data-stu-id="5a457-655">Applications will set the right value of queue depth to get the optimal performance.</span></span> <span data-ttu-id="5a457-656">그러나 응용 프로그램의 성능 문제를 해결할 수 있도록 이 개념을 이해하는 것이 중요합니다.</span><span class="sxs-lookup"><span data-stu-id="5a457-656">However, it is important to understand this concept so that you can troubleshoot performance issues with your application.</span></span> <span data-ttu-id="5a457-657">또한 시스템의 벤치마킹 도구를 실행하여 큐 크기의 효과를 확인할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="5a457-657">You can also observe the effects of queue depth by running benchmarking tools on your system.</span></span>

<span data-ttu-id="5a457-658">일부 응용 프로그램은 큐 크기에 영향을 미칠 수 있는 설정을 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="5a457-658">Some applications provide settings to influence the Queue Depth.</span></span> <span data-ttu-id="5a457-659">예를 들어 이전 섹션에서 설명한 SQL Server의 MAXDOP(최대 수준의 병렬 처리) 설정입니다.</span><span class="sxs-lookup"><span data-stu-id="5a457-659">For example, the MAXDOP (maximum degree of parallelism) setting in SQL Server explained in previous section.</span></span> <span data-ttu-id="5a457-660">MAXDOP는 SQL Server의 큐 크기 값을 직접 변경하지는 않지만 큐 크기 및 다중 스레딩에 영향을 주는 방법입니다.</span><span class="sxs-lookup"><span data-stu-id="5a457-660">MAXDOP is a way to influence Queue Depth and multi-threading, although it does not directly change the Queue Depth value of SQL Server.</span></span>

<span data-ttu-id="5a457-661">*높은 큐 크기*</span><span class="sxs-lookup"><span data-stu-id="5a457-661">*High Queue Depth*</span></span>  
<span data-ttu-id="5a457-662">높은 큐 크기는 디스크에 더 많은 작업을 정렬합니다.</span><span class="sxs-lookup"><span data-stu-id="5a457-662">A high queue depth lines up more operations on the disk.</span></span> <span data-ttu-id="5a457-663">디스크는 해당 큐에서 미리 다음 요청을 알고 있습니다.</span><span class="sxs-lookup"><span data-stu-id="5a457-663">The disk knows the next request in its queue ahead of time.</span></span> <span data-ttu-id="5a457-664">따라서 디스크는 미리 작업을 예약하고 최적의 순서로 작업을 처리할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="5a457-664">Consequently, the disk can schedule operations ahead of time and process them in an optimal sequence.</span></span> <span data-ttu-id="5a457-665">응용 프로그램이 디스크에 더 많은 요청을 보내므로 디스크는 더 많은 병렬 IO를 처리할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="5a457-665">Since the application is sending more requests to the disk, the disk can process more parallel IOs.</span></span> <span data-ttu-id="5a457-666">궁극적으로 응용 프로그램은 더 높은 IOPS를 끌어낼 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="5a457-666">Ultimately, the application will be able to achieve higher IOPS.</span></span> <span data-ttu-id="5a457-667">응용 프로그램이 더 많은 요청을 처리하므로 응용 프로그램의 총 처리량도 증가합니다.</span><span class="sxs-lookup"><span data-stu-id="5a457-667">Since application is processing more requests, the total Throughput of the application also increases.</span></span>

<span data-ttu-id="5a457-668">일반적으로 응용 프로그램에서 연결된 디스크당 8-16+ 미해결 IO로 최대 처리량을 달성할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="5a457-668">Typically, an application can achieve maximum Throughput with 8-16+ outstanding IOs per attached disk.</span></span> <span data-ttu-id="5a457-669">큐 크기가 하나인 경우 응용 프로그램은 시스템에 충분한 IO를 푸시하지 않고 지정된 기간 동안 적은 양을 처리합니다.</span><span class="sxs-lookup"><span data-stu-id="5a457-669">If a Queue Depth is one, application is not pushing enough IOs to the system, and it will process less amount of in a given period.</span></span> <span data-ttu-id="5a457-670">즉, 적은 처리량입니다.</span><span class="sxs-lookup"><span data-stu-id="5a457-670">In other words, less Throughput.</span></span>

<span data-ttu-id="5a457-671">예를 들어 SQL Server에서 쿼리에 대한 MAXDOP 값을 "4"로 설정하면 SQL Server에 쿼리를 실행하는데 최대 4개의 코어를 사용할 수 있음을 알립니다.</span><span class="sxs-lookup"><span data-stu-id="5a457-671">For example, in SQL Server, setting the MAXDOP value for a query to "4" informs SQL Server that it can use up to four cores to execute the query.</span></span> <span data-ttu-id="5a457-672">SQL Server는 쿼리 실행에 대한 최적의 큐 크기 값 및 코어 수를 결정합니다.</span><span class="sxs-lookup"><span data-stu-id="5a457-672">SQL Server will determine what is best queue depth value and the number of cores for the query execution.</span></span>

<span data-ttu-id="5a457-673">*최적의 큐 크기*</span><span class="sxs-lookup"><span data-stu-id="5a457-673">*Optimal Queue Depth*</span></span>  
<span data-ttu-id="5a457-674">매우 높은 큐 크기 값 또한 단점이 있습니다.</span><span class="sxs-lookup"><span data-stu-id="5a457-674">Very high queue depth value also has its drawbacks.</span></span> <span data-ttu-id="5a457-675">큐 크기 값이 너무 높으면 응용 프로그램은 매우 높은 IOPS를 구동하려고 합니다.</span><span class="sxs-lookup"><span data-stu-id="5a457-675">If queue depth value is too high, the application will try to drive very high IOPS.</span></span> <span data-ttu-id="5a457-676">응용 프로그램에 프로비전된 충분한 IOPS의 영구 디스크가 있지 않는 한 응용 프로그램 대기 시간이 늘어날 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="5a457-676">Unless application has persistent disks with sufficient provisioned IOPS, this can negatively affect application latencies.</span></span> <span data-ttu-id="5a457-677">다음 수식은 IOPS, 대기 시간 및 큐 크기 간의 관계를 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="5a457-677">Following formula shows the relationship between IOPS, Latency and Queue Depth.</span></span>  
    ![](media/storage-premium-storage-performance/image6.png)

<span data-ttu-id="5a457-678">큐 크기를 대기 시간에 영향을 주지 않고 응용 프로그램에 충분한 IOPS를 제공할 수 있는 최적의 값이 아닌 높은 값을 구성해서는 안됩니다.</span><span class="sxs-lookup"><span data-stu-id="5a457-678">You should not configure Queue Depth to any high value, but to an optimal value, which can deliver enough IOPS for the application without affecting latencies.</span></span> <span data-ttu-id="5a457-679">예를 들어 응용 프로그램 대기 시간에 1밀리초가 필요한 경우 5,000개의 IOPS를 달성하기 위해 필요한 큐 크기는 QD = 5000 x 0.001 = 5입니다.</span><span class="sxs-lookup"><span data-stu-id="5a457-679">For example, if the application latency needs to be 1 millisecond, the Queue Depth required to achieve 5,000 IOPS is, QD = 5000 x 0.001 = 5.</span></span>

<span data-ttu-id="5a457-680">*스트라이프 볼륨에 대한 큐 크기*</span><span class="sxs-lookup"><span data-stu-id="5a457-680">*Queue Depth for Striped Volume*</span></span>  
<span data-ttu-id="5a457-681">그러한 충분한 큐 크기를 유지하는 스트라이프 볼륨의 경우 모든 디스크는 개별적으로 최대 큐 크기를 가집니다.</span><span class="sxs-lookup"><span data-stu-id="5a457-681">For a striped volume, maintain a high enough queue depth such that, every disk has a peak queue depth individually.</span></span> <span data-ttu-id="5a457-682">예를 들어 2의 큐 크기를 푸시하는 응용 프로그램과 스트라이프에 4개의 디스크가 있다고 가정합니다.</span><span class="sxs-lookup"><span data-stu-id="5a457-682">For example, consider an application that pushes a queue depth of 2 and there are 4 disks in the stripe.</span></span> <span data-ttu-id="5a457-683">두 개의 IO 요청은 2개의 디스크로 이동하고 나머지 두 디스크는 유휴 상태가 됩니다.</span><span class="sxs-lookup"><span data-stu-id="5a457-683">The two IO requests will go to two disks and remaining two disks will be idle.</span></span> <span data-ttu-id="5a457-684">따라서 모든 디스크가 사용 중일 수 있도록 큐 크기를 구성합니다.</span><span class="sxs-lookup"><span data-stu-id="5a457-684">Therefore, configure the queue depth such that all the disks can be busy.</span></span> <span data-ttu-id="5a457-685">다음 수식에서는 스트라이프 볼륨의 큐 크기를 결정하는 방법을 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="5a457-685">Formula below shows how to determine the queue depth of striped volumes.</span></span>  
    ![](media/storage-premium-storage-performance/image7.png)

## <a name="throttling"></a><span data-ttu-id="5a457-686">제한</span><span class="sxs-lookup"><span data-stu-id="5a457-686">Throttling</span></span>
<span data-ttu-id="5a457-687">Azure 프리미엄 저장소는 선택한 VM 크기 및 디스크 크기에 따라 지정된 IOPS 수 및 처리량을 프로비전합니다.</span><span class="sxs-lookup"><span data-stu-id="5a457-687">Azure Premium Storage provisions specified number of IOPS and Throughput depending on the VM sizes and disk sizes you choose.</span></span> <span data-ttu-id="5a457-688">응용 프로그램이 VM 또는 디스크가 처리할 수 있는 한도를 초과하여 IOPS 또는 처리량을 구동하려 할 때 프리미엄 저장소는 이를 제한합니다.</span><span class="sxs-lookup"><span data-stu-id="5a457-688">Anytime your application tries to drive IOPS or Throughput above these limits of what the VM or disk can handle, Premium Storage will throttle it.</span></span> <span data-ttu-id="5a457-689">이는 응용 프로그램에서 성능 저하의 형태로 나타납니다.</span><span class="sxs-lookup"><span data-stu-id="5a457-689">This manifests in the form of degraded performance in your application.</span></span> <span data-ttu-id="5a457-690">이는 더 높은 대기 시간, 더 낮은 처리량 또는 더 낮은 IOPS를 의미할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="5a457-690">This can mean higher latency, lower Throughput or lower IOPS.</span></span> <span data-ttu-id="5a457-691">프리미엄 저장소가 제한하지 않는 경우 응용 프로그램은 리소스가 달성할 수 있는 한도를 초과하여 완전히 실패할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="5a457-691">If Premium Storage does not throttle, your application could completely fail by exceeding what its resources are capable of achieving.</span></span> <span data-ttu-id="5a457-692">따라서 제한으로 인한 성능 문제를 방지하려면 항상 응용 프로그램에 대한 충분한 리소스를 프로비전합니다.</span><span class="sxs-lookup"><span data-stu-id="5a457-692">So, to avoid performance issues due to throttling, always provision sufficient resources for your application.</span></span> <span data-ttu-id="5a457-693">위의 VM 크기 및 디스크 크기 섹션에서 설명한 것을 고려합니다.</span><span class="sxs-lookup"><span data-stu-id="5a457-693">Take into consideration what we discussed in the VM sizes and Disk sizes sections above.</span></span> <span data-ttu-id="5a457-694">벤치마킹은 응용 프로그램을 호스팅하는데 필요한 리소스를 찾는데 가장 적합합니다.</span><span class="sxs-lookup"><span data-stu-id="5a457-694">Benchmarking is the best way to figure out what resources you will need to host your application.</span></span>

## <a name="benchmarking"></a><span data-ttu-id="5a457-695">벤치마킹</span><span class="sxs-lookup"><span data-stu-id="5a457-695">Benchmarking</span></span>
<span data-ttu-id="5a457-696">벤치마킹은 응용 프로그램에서 다양한 작업을 시뮬레이션하고 각 작업에 대한 응용 프로그램 성능을 측정하는 과정입니다.</span><span class="sxs-lookup"><span data-stu-id="5a457-696">Benchmarking is the process of simulating different workloads on your application and measuring the application performance for each workload.</span></span> <span data-ttu-id="5a457-697">이전 섹션에서 설명한 단계를 사용하여 응용 프로그램 성능 요구 사항을 수집했습니다.</span><span class="sxs-lookup"><span data-stu-id="5a457-697">Using the steps described in an earlier section, you have gathered the application performance requirements.</span></span> <span data-ttu-id="5a457-698">응용 프로그램을 호스팅하는 VM에서 벤치마킹 도구를 실행하여 프리미엄 저장소를 통해 응용 프로그램이 얻을 수 있는 성능 수준을 확인할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="5a457-698">By running benchmarking tools on the VMs hosting the application, you can determine the performance levels that your application can achieve with Premium Storage.</span></span> <span data-ttu-id="5a457-699">이 섹션에서는 Azure 프리미엄 저장소 디스크로 프로비전된 Standard DS14 VM 벤치마킹의 예를 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="5a457-699">In this section, we provide you examples of benchmarking a Standard DS14 VM provisioned with Azure Premium Storage disks.</span></span>

<span data-ttu-id="5a457-700">Windows 및 Linux용으로 각각 일반 벤치마킹 도구 Iometer 및 FIO를 사용했습니다.</span><span class="sxs-lookup"><span data-stu-id="5a457-700">We have used common benchmarking tools Iometer and FIO, for Windows and Linux respectively.</span></span> <span data-ttu-id="5a457-701">이러한 도구는 작업과 같은 프로덕션을 시뮬레이션하는 여러 스레드를 생성하고 시스템 성능을 측정합니다.</span><span class="sxs-lookup"><span data-stu-id="5a457-701">These tools spawn multiple threads simulating a production like workload, and measure the system performance.</span></span> <span data-ttu-id="5a457-702">도구를 사용하여 일반적으로 응용 프로그램에 대해 변경할 수 없는 블록 크기 및 큐 크기와 같은 매개 변수를 구성할 수도 있습니다.</span><span class="sxs-lookup"><span data-stu-id="5a457-702">Using the tools you can also configure parameters like block size and queue depth, which you normally cannot change for an application.</span></span> <span data-ttu-id="5a457-703">응용 프로그램 작업의 다양한 유형에 대해 프리미엄 디스크로 프로비전된 높은 확장성의 VM에 최대 성능을 구동하도록 유연성을 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="5a457-703">This gives you more flexibility to drive the maximum performance on a high scale VM provisioned with premium disks for different types of application workloads.</span></span> <span data-ttu-id="5a457-704">각 벤치마킹 도구에 대한 자세한 내용은 [Iometer](http://www.iometer.org/) 및 [FIO](http://freecode.com/projects/fio)를 방문하세요.</span><span class="sxs-lookup"><span data-stu-id="5a457-704">To learn more about each benchmarking tool visit [Iometer](http://www.iometer.org/) and [FIO](http://freecode.com/projects/fio).</span></span>

<span data-ttu-id="5a457-705">아래 예제를 수행하려면 Standard DS14 VM을 만들고 VM에 11개의 프리미엄 저장소 디스크를 연결합니다.</span><span class="sxs-lookup"><span data-stu-id="5a457-705">To follow the examples below, create a Standard DS14 VM and attach 11 Premium Storage disks to the VM.</span></span> <span data-ttu-id="5a457-706">11개의 디스크는 “None”으로 호스트 캐싱을 사용하여 10개의 디스크를 구성하고 NoCacheWrites라는 볼륨으로 스트라이프합니다.</span><span class="sxs-lookup"><span data-stu-id="5a457-706">Of the 11 disks, configure 10 disks with host caching as "None" and stripe them into a volume called NoCacheWrites.</span></span> <span data-ttu-id="5a457-707">나머지 디스크에 “ReadOnly”로 호스트 캐싱을 구성하고 이 디스크를 사용하여 CacheReads라는 볼륨을 만듭니다.</span><span class="sxs-lookup"><span data-stu-id="5a457-707">Configure host caching as "ReadOnly" on the remaining disk and create a volume called CacheReads with this disk.</span></span> <span data-ttu-id="5a457-708">이 설치를 사용하여 Standard DS14 VM에서 최대 읽기 및 쓰기 성능을 확인할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="5a457-708">Using this setup, you will be able to see the maximum Read and Write performance from a Standard DS14 VM.</span></span> <span data-ttu-id="5a457-709">프리미엄 디스크가 있는 DS14 VM을 만드는 방법에 대한 자세한 단계는 [가상 컴퓨터 데이터 디스크에 대한 Premium Storage 계정 만들기 및 사용](storage-premium-storage.md)을 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="5a457-709">For detailed steps about creating a DS14 VM with premium disks, go to [Create and use a Premium Storage account for a virtual machine data disk](storage-premium-storage.md).</span></span>

<span data-ttu-id="5a457-710">*캐시 준비 중*</span><span class="sxs-lookup"><span data-stu-id="5a457-710">*Warming up the Cache*</span></span>  
<span data-ttu-id="5a457-711">ReadOnly 호스트 캐싱을 사용한 디스크는 디스크 제한보다 더 높은 IOPS를 부여할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="5a457-711">The disk with ReadOnly host caching will be able to give higher IOPS than the disk limit.</span></span> <span data-ttu-id="5a457-712">호스트 캐시에서 이 최대 읽기 성능을 얻으려면 먼저 이 디스크의 캐시를 준비해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="5a457-712">To get this maximum read performance from the host cache, first you must warm up the cache of this disk.</span></span> <span data-ttu-id="5a457-713">이렇게 하면 벤치마킹 도구에서 CacheReads 볼륨을 구동하는 읽기 IO는 실제로 디스크가 아닌 캐시에 도달합니다.</span><span class="sxs-lookup"><span data-stu-id="5a457-713">This ensures that the Read IOs which benchmarking tool will drive on CacheReads volume actually hits the cache and not the disk directly.</span></span> <span data-ttu-id="5a457-714">캐시는 단일 캐시가 사용된 디스크에서 추가 IOPS 결과에 도달합니다.</span><span class="sxs-lookup"><span data-stu-id="5a457-714">The cache hits result in additional IOPS from the single cache enabled disk.</span></span>

> <span data-ttu-id="5a457-715">**중요:**</span><span class="sxs-lookup"><span data-stu-id="5a457-715">**Important:**</span></span>  
> <span data-ttu-id="5a457-716">VM을 다시 부팅할 때마다 벤치마킹을 실행하기 전에 캐시를 준비해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="5a457-716">You must warm up the cache before running benchmarking, every time VM is rebooted.</span></span>
>
>

#### <a name="iometer"></a><span data-ttu-id="5a457-717">Iometer</span><span class="sxs-lookup"><span data-stu-id="5a457-717">Iometer</span></span>
<span data-ttu-id="5a457-718">[Iometer 도구를 다운로드](http://sourceforge.net/projects/iometer/files/iometer-stable/2006-07-27/iometer-2006.07.27.win32.i386-setup.exe/download) 합니다.</span><span class="sxs-lookup"><span data-stu-id="5a457-718">[Download the Iometer tool](http://sourceforge.net/projects/iometer/files/iometer-stable/2006-07-27/iometer-2006.07.27.win32.i386-setup.exe/download) on the VM.</span></span>

<span data-ttu-id="5a457-719">*테스트 파일*</span><span class="sxs-lookup"><span data-stu-id="5a457-719">*Test file*</span></span>  
<span data-ttu-id="5a457-720">Iometer는 벤치마킹 테스트를 실행할 볼륨에 저장된 테스트 파일을 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="5a457-720">Iometer uses a test file that is stored on the volume on which you will run the benchmarking test.</span></span> <span data-ttu-id="5a457-721">IOPS 디스크 및 처리량을 측정하도록 이 테스트 파일에 읽기 및 쓰기를 구동합니다.</span><span class="sxs-lookup"><span data-stu-id="5a457-721">It drives Reads and Writes on this test file to measure the disk IOPS and Throughput.</span></span> <span data-ttu-id="5a457-722">Iometer는 이 테스트 파일을 제공받지 않은 경우 만듭니다.</span><span class="sxs-lookup"><span data-stu-id="5a457-722">Iometer creates this test file if you have not provided one.</span></span> <span data-ttu-id="5a457-723">CacheReads 및 NoCacheWrites 볼륨에 iobw.tst라는 200GB 테스트 파일을 만듭니다.</span><span class="sxs-lookup"><span data-stu-id="5a457-723">Create a 200GB test file called iobw.tst on the CacheReads and NoCacheWrites volumes.</span></span>

<span data-ttu-id="5a457-724">*액세스 사양*</span><span class="sxs-lookup"><span data-stu-id="5a457-724">*Access Specifications*</span></span>  
<span data-ttu-id="5a457-725">요청 IO 크기, % 읽기/쓰기, % 임의/순차 사양은 Iometer의 “액세스 사양” 탭을 사용하여 구성됩니다.</span><span class="sxs-lookup"><span data-stu-id="5a457-725">The specifications, request IO size, % read/write, % random/sequential are configured using the "Access Specifications" tab in Iometer.</span></span> <span data-ttu-id="5a457-726">아래에 설명된 각 시나리오에 대한 액세스 사양을 만듭니다.</span><span class="sxs-lookup"><span data-stu-id="5a457-726">Create an access specification for each of the scenarios described below.</span></span> <span data-ttu-id="5a457-727">액세스 사양을 만들고 RandomWrites\_8K, RandomReads\_8K와 같은 적절한 이름으로 “저장”합니다.</span><span class="sxs-lookup"><span data-stu-id="5a457-727">Create the access specifications and "Save" with an appropriate name like – RandomWrites\_8K, RandomReads\_8K.</span></span> <span data-ttu-id="5a457-728">테스트 시나리오를 실행할 때 해당 사양을 선택합니다.</span><span class="sxs-lookup"><span data-stu-id="5a457-728">Select the corresponding specification when running the test scenario.</span></span>

<span data-ttu-id="5a457-729">최대 쓰기 IOPS 시나리오에 대한 액세스 사양의 예는 아래와 같습니다.</span><span class="sxs-lookup"><span data-stu-id="5a457-729">An example of access specifications for maximum Write IOPS scenario is shown below,</span></span>  
    ![](media/storage-premium-storage-performance/image8.png)

<span data-ttu-id="5a457-730">*최대 IOPS 테스트 사양*</span><span class="sxs-lookup"><span data-stu-id="5a457-730">*Maximum IOPS Test Specifications*</span></span>  
<span data-ttu-id="5a457-731">최대 IOP를 보여주기 위해 작은 요청 크기를 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="5a457-731">To demonstrate maximum IOPs, use smaller request size.</span></span> <span data-ttu-id="5a457-732">8K 요청 크기를 사용하고 임의 쓰기 및 읽기에 대한 사양을 만듭니다.</span><span class="sxs-lookup"><span data-stu-id="5a457-732">Use 8K request size and create specifications for Random Writes and Reads.</span></span>

| <span data-ttu-id="5a457-733">액세스 사양</span><span class="sxs-lookup"><span data-stu-id="5a457-733">Access Specification</span></span> | <span data-ttu-id="5a457-734">요청 크기</span><span class="sxs-lookup"><span data-stu-id="5a457-734">Request size</span></span> | <span data-ttu-id="5a457-735">임의 %</span><span class="sxs-lookup"><span data-stu-id="5a457-735">Random %</span></span> | <span data-ttu-id="5a457-736">읽기 %</span><span class="sxs-lookup"><span data-stu-id="5a457-736">Read %</span></span> |
| --- | --- | --- | --- |
| <span data-ttu-id="5a457-737">RandomWrites\_8K</span><span class="sxs-lookup"><span data-stu-id="5a457-737">RandomWrites\_8K</span></span> |<span data-ttu-id="5a457-738">8K</span><span class="sxs-lookup"><span data-stu-id="5a457-738">8K</span></span> |<span data-ttu-id="5a457-739">100</span><span class="sxs-lookup"><span data-stu-id="5a457-739">100</span></span> |<span data-ttu-id="5a457-740">0</span><span class="sxs-lookup"><span data-stu-id="5a457-740">0</span></span> |
| <span data-ttu-id="5a457-741">RandomReads\_8K</span><span class="sxs-lookup"><span data-stu-id="5a457-741">RandomReads\_8K</span></span> |<span data-ttu-id="5a457-742">8K</span><span class="sxs-lookup"><span data-stu-id="5a457-742">8K</span></span> |<span data-ttu-id="5a457-743">100</span><span class="sxs-lookup"><span data-stu-id="5a457-743">100</span></span> |<span data-ttu-id="5a457-744">100</span><span class="sxs-lookup"><span data-stu-id="5a457-744">100</span></span> |

<span data-ttu-id="5a457-745">*최대 처리량 테스트 사양*</span><span class="sxs-lookup"><span data-stu-id="5a457-745">*Maximum Throughput Test Specifications*</span></span>  
<span data-ttu-id="5a457-746">최대 처리량을 보여주기 위해 더 큰 요청 크기를 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="5a457-746">To demonstrate maximum Throughput, use larger request size.</span></span> <span data-ttu-id="5a457-747">64K 요청 크기를 사용하여 임의 쓰기 및 읽기에 대한 사양을 만듭니다.</span><span class="sxs-lookup"><span data-stu-id="5a457-747">Use 64K request size and create specifications for Random Writes and Reads.</span></span>

| <span data-ttu-id="5a457-748">액세스 사양</span><span class="sxs-lookup"><span data-stu-id="5a457-748">Access Specification</span></span> | <span data-ttu-id="5a457-749">요청 크기</span><span class="sxs-lookup"><span data-stu-id="5a457-749">Request size</span></span> | <span data-ttu-id="5a457-750">임의 %</span><span class="sxs-lookup"><span data-stu-id="5a457-750">Random %</span></span> | <span data-ttu-id="5a457-751">읽기 %</span><span class="sxs-lookup"><span data-stu-id="5a457-751">Read %</span></span> |
| --- | --- | --- | --- |
| <span data-ttu-id="5a457-752">RandomWrites\_64K</span><span class="sxs-lookup"><span data-stu-id="5a457-752">RandomWrites\_64K</span></span> |<span data-ttu-id="5a457-753">64K</span><span class="sxs-lookup"><span data-stu-id="5a457-753">64K</span></span> |<span data-ttu-id="5a457-754">100</span><span class="sxs-lookup"><span data-stu-id="5a457-754">100</span></span> |<span data-ttu-id="5a457-755">0</span><span class="sxs-lookup"><span data-stu-id="5a457-755">0</span></span> |
| <span data-ttu-id="5a457-756">RandomReads\_64K</span><span class="sxs-lookup"><span data-stu-id="5a457-756">RandomReads\_64K</span></span> |<span data-ttu-id="5a457-757">64K</span><span class="sxs-lookup"><span data-stu-id="5a457-757">64K</span></span> |<span data-ttu-id="5a457-758">100</span><span class="sxs-lookup"><span data-stu-id="5a457-758">100</span></span> |<span data-ttu-id="5a457-759">100</span><span class="sxs-lookup"><span data-stu-id="5a457-759">100</span></span> |

<span data-ttu-id="5a457-760">*Iometer 테스트 실행*</span><span class="sxs-lookup"><span data-stu-id="5a457-760">*Running the Iometer Test*</span></span>  
<span data-ttu-id="5a457-761">아래 단계를 수행하여 캐시를 준비합니다.</span><span class="sxs-lookup"><span data-stu-id="5a457-761">Perform the steps below to warm up cache</span></span>

1. <span data-ttu-id="5a457-762">아래에 표시된 값으로 두 액세스 사양을 만듭니다.</span><span class="sxs-lookup"><span data-stu-id="5a457-762">Create two access specifications with values shown below,</span></span>

   | <span data-ttu-id="5a457-763">이름</span><span class="sxs-lookup"><span data-stu-id="5a457-763">Name</span></span> | <span data-ttu-id="5a457-764">요청 크기</span><span class="sxs-lookup"><span data-stu-id="5a457-764">Request size</span></span> | <span data-ttu-id="5a457-765">임의 %</span><span class="sxs-lookup"><span data-stu-id="5a457-765">Random %</span></span> | <span data-ttu-id="5a457-766">읽기 %</span><span class="sxs-lookup"><span data-stu-id="5a457-766">Read %</span></span> |
   | --- | --- | --- | --- |
   | <span data-ttu-id="5a457-767">RandomWrites\_1MB</span><span class="sxs-lookup"><span data-stu-id="5a457-767">RandomWrites\_1MB</span></span> |<span data-ttu-id="5a457-768">1MB</span><span class="sxs-lookup"><span data-stu-id="5a457-768">1MB</span></span> |<span data-ttu-id="5a457-769">100</span><span class="sxs-lookup"><span data-stu-id="5a457-769">100</span></span> |<span data-ttu-id="5a457-770">0</span><span class="sxs-lookup"><span data-stu-id="5a457-770">0</span></span> |
   | <span data-ttu-id="5a457-771">RandomReads\_1MB</span><span class="sxs-lookup"><span data-stu-id="5a457-771">RandomReads\_1MB</span></span> |<span data-ttu-id="5a457-772">1MB</span><span class="sxs-lookup"><span data-stu-id="5a457-772">1MB</span></span> |<span data-ttu-id="5a457-773">100</span><span class="sxs-lookup"><span data-stu-id="5a457-773">100</span></span> |<span data-ttu-id="5a457-774">100</span><span class="sxs-lookup"><span data-stu-id="5a457-774">100</span></span> |
2. <span data-ttu-id="5a457-775">다음 매개 변수로 캐시 디스크 초기화를 위한 Iometer 테스트를 실행합니다.</span><span class="sxs-lookup"><span data-stu-id="5a457-775">Run the Iometer test for initializing cache disk with following parameters.</span></span> <span data-ttu-id="5a457-776">대상 볼륨에 대해 3개의 작업자 스레드 및 128의 큐 크기를 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="5a457-776">Use three worker threads for the target volume and a queue depth of 128.</span></span> <span data-ttu-id="5a457-777">테스트의 “실행 시간” 기간을 “테스트 설정” 탭에서 2hrs로 설정합니다.</span><span class="sxs-lookup"><span data-stu-id="5a457-777">Set the "Run time" duration of the test to 2hrs on the "Test Setup" tab.</span></span>

   | <span data-ttu-id="5a457-778">시나리오</span><span class="sxs-lookup"><span data-stu-id="5a457-778">Scenario</span></span> | <span data-ttu-id="5a457-779">대상 볼륨</span><span class="sxs-lookup"><span data-stu-id="5a457-779">Target Volume</span></span> | <span data-ttu-id="5a457-780">이름</span><span class="sxs-lookup"><span data-stu-id="5a457-780">Name</span></span> | <span data-ttu-id="5a457-781">기간</span><span class="sxs-lookup"><span data-stu-id="5a457-781">Duration</span></span> |
   | --- | --- | --- | --- |
   | <span data-ttu-id="5a457-782">디스크 캐시 초기화</span><span class="sxs-lookup"><span data-stu-id="5a457-782">Initialize Cache Disk</span></span> |<span data-ttu-id="5a457-783">CacheReads</span><span class="sxs-lookup"><span data-stu-id="5a457-783">CacheReads</span></span> |<span data-ttu-id="5a457-784">RandomWrites\_1MB</span><span class="sxs-lookup"><span data-stu-id="5a457-784">RandomWrites\_1MB</span></span> |<span data-ttu-id="5a457-785">2hrs</span><span class="sxs-lookup"><span data-stu-id="5a457-785">2hrs</span></span> |
3. <span data-ttu-id="5a457-786">다음 매개 변수로 캐시 디스크 준비를 위한 Iometer 테스트를 실행합니다.</span><span class="sxs-lookup"><span data-stu-id="5a457-786">Run the Iometer test for warming up cache disk with following parameters.</span></span> <span data-ttu-id="5a457-787">대상 볼륨에 대해 3개의 작업자 스레드 및 128의 큐 크기를 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="5a457-787">Use three worker threads for the target volume and a queue depth of 128.</span></span> <span data-ttu-id="5a457-788">테스트의 “실행 시간” 기간을 “테스트 설정” 탭에서 2hrs로 설정합니다.</span><span class="sxs-lookup"><span data-stu-id="5a457-788">Set the "Run time" duration of the test to 2hrs on the "Test Setup" tab.</span></span>

   | <span data-ttu-id="5a457-789">시나리오</span><span class="sxs-lookup"><span data-stu-id="5a457-789">Scenario</span></span> | <span data-ttu-id="5a457-790">대상 볼륨</span><span class="sxs-lookup"><span data-stu-id="5a457-790">Target Volume</span></span> | <span data-ttu-id="5a457-791">이름</span><span class="sxs-lookup"><span data-stu-id="5a457-791">Name</span></span> | <span data-ttu-id="5a457-792">기간</span><span class="sxs-lookup"><span data-stu-id="5a457-792">Duration</span></span> |
   | --- | --- | --- | --- |
   | <span data-ttu-id="5a457-793">캐시 디스크 준비</span><span class="sxs-lookup"><span data-stu-id="5a457-793">Warm up Cache Disk</span></span> |<span data-ttu-id="5a457-794">CacheReads</span><span class="sxs-lookup"><span data-stu-id="5a457-794">CacheReads</span></span> |<span data-ttu-id="5a457-795">RandomReads\_1MB</span><span class="sxs-lookup"><span data-stu-id="5a457-795">RandomReads\_1MB</span></span> |<span data-ttu-id="5a457-796">2hrs</span><span class="sxs-lookup"><span data-stu-id="5a457-796">2hrs</span></span> |

<span data-ttu-id="5a457-797">캐시 디스크를 준비한 후 아래에 나열된 테스트 시나리오를 계속합니다.</span><span class="sxs-lookup"><span data-stu-id="5a457-797">After cache disk is warmed up, proceed with the test scenarios listed below.</span></span> <span data-ttu-id="5a457-798">Iometer 테스트를 실행하려면 **각** 대상 볼륨에 대해 최소 세 개의 작업자 스레드를 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="5a457-798">To run the Iometer test, use at least three worker threads for **each** target volume.</span></span> <span data-ttu-id="5a457-799">각 작업자 스레드의 경우 해당 테스트 시나리오를 실행하도록 아래 표에 표시된 것처럼 대상 볼륨을 선택하고 큐 크기를 설정하고 저장된 테스트 사양 중 하나를 선택합니다.</span><span class="sxs-lookup"><span data-stu-id="5a457-799">For each worker thread, select the target volume, set queue depth and select one of the saved test specifications, as shown in the table below, to run the corresponding test scenario.</span></span> <span data-ttu-id="5a457-800">또한 표는 이러한 테스트를 실행할 때 IOPS 및 처리량에 대한 예상된 결과를 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="5a457-800">The table also shows expected results for IOPS and Throughput when running these tests.</span></span> <span data-ttu-id="5a457-801">모든 시나리오의 경우 8KB의 작은 IO 크기 및 128의 높은 큐 크기가 사용됩니다.</span><span class="sxs-lookup"><span data-stu-id="5a457-801">For all scenarios, a small IO size of 8KB and a high queue depth of 128 is used.</span></span>

| <span data-ttu-id="5a457-802">테스트 시나리오</span><span class="sxs-lookup"><span data-stu-id="5a457-802">Test Scenario</span></span> | <span data-ttu-id="5a457-803">대상 볼륨</span><span class="sxs-lookup"><span data-stu-id="5a457-803">Target Volume</span></span> | <span data-ttu-id="5a457-804">이름</span><span class="sxs-lookup"><span data-stu-id="5a457-804">Name</span></span> | <span data-ttu-id="5a457-805">결과</span><span class="sxs-lookup"><span data-stu-id="5a457-805">Result</span></span> |
| --- | --- | --- | --- |
| <span data-ttu-id="5a457-806">최대</span><span class="sxs-lookup"><span data-stu-id="5a457-806">Max.</span></span> <span data-ttu-id="5a457-807">읽기 IOPS</span><span class="sxs-lookup"><span data-stu-id="5a457-807">Read IOPS</span></span> |<span data-ttu-id="5a457-808">CacheReads</span><span class="sxs-lookup"><span data-stu-id="5a457-808">CacheReads</span></span> |<span data-ttu-id="5a457-809">RandomWrites\_8K</span><span class="sxs-lookup"><span data-stu-id="5a457-809">RandomWrites\_8K</span></span> |<span data-ttu-id="5a457-810">50,000 IOPS </span><span class="sxs-lookup"><span data-stu-id="5a457-810">50,000 IOPS</span></span> |
| <span data-ttu-id="5a457-811">최대</span><span class="sxs-lookup"><span data-stu-id="5a457-811">Max.</span></span> <span data-ttu-id="5a457-812">쓰기 IOPS</span><span class="sxs-lookup"><span data-stu-id="5a457-812">Write IOPS</span></span> |<span data-ttu-id="5a457-813">NoCacheWrites</span><span class="sxs-lookup"><span data-stu-id="5a457-813">NoCacheWrites</span></span> |<span data-ttu-id="5a457-814">RandomReads\_8K</span><span class="sxs-lookup"><span data-stu-id="5a457-814">RandomReads\_8K</span></span> |<span data-ttu-id="5a457-815">64,000 IOPS</span><span class="sxs-lookup"><span data-stu-id="5a457-815">64,000 IOPS</span></span> |
| <span data-ttu-id="5a457-816">최대</span><span class="sxs-lookup"><span data-stu-id="5a457-816">Max.</span></span> <span data-ttu-id="5a457-817">결합된 IOPS</span><span class="sxs-lookup"><span data-stu-id="5a457-817">Combined IOPS</span></span> |<span data-ttu-id="5a457-818">CacheReads</span><span class="sxs-lookup"><span data-stu-id="5a457-818">CacheReads</span></span> |<span data-ttu-id="5a457-819">RandomWrites\_8K</span><span class="sxs-lookup"><span data-stu-id="5a457-819">RandomWrites\_8K</span></span> |<span data-ttu-id="5a457-820">100,000 IOPS</span><span class="sxs-lookup"><span data-stu-id="5a457-820">100,000 IOPS</span></span> |
| <span data-ttu-id="5a457-821">NoCacheWrites</span><span class="sxs-lookup"><span data-stu-id="5a457-821">NoCacheWrites</span></span> |<span data-ttu-id="5a457-822">RandomReads\_8K</span><span class="sxs-lookup"><span data-stu-id="5a457-822">RandomReads\_8K</span></span> | &nbsp; | &nbsp; |
| <span data-ttu-id="5a457-823">최대</span><span class="sxs-lookup"><span data-stu-id="5a457-823">Max.</span></span> <span data-ttu-id="5a457-824">읽기 MB/초</span><span class="sxs-lookup"><span data-stu-id="5a457-824">Read MB/sec</span></span> |<span data-ttu-id="5a457-825">CacheReads</span><span class="sxs-lookup"><span data-stu-id="5a457-825">CacheReads</span></span> |<span data-ttu-id="5a457-826">RandomWrites\_64K</span><span class="sxs-lookup"><span data-stu-id="5a457-826">RandomWrites\_64K</span></span> |<span data-ttu-id="5a457-827">524MB/초</span><span class="sxs-lookup"><span data-stu-id="5a457-827">524 MB/sec</span></span> |
| <span data-ttu-id="5a457-828">최대</span><span class="sxs-lookup"><span data-stu-id="5a457-828">Max.</span></span> <span data-ttu-id="5a457-829">쓰기 MB/초</span><span class="sxs-lookup"><span data-stu-id="5a457-829">Write MB/sec</span></span> |<span data-ttu-id="5a457-830">NoCacheWrites</span><span class="sxs-lookup"><span data-stu-id="5a457-830">NoCacheWrites</span></span> |<span data-ttu-id="5a457-831">RandomReads\_64K</span><span class="sxs-lookup"><span data-stu-id="5a457-831">RandomReads\_64K</span></span> |<span data-ttu-id="5a457-832">524MB/초</span><span class="sxs-lookup"><span data-stu-id="5a457-832">524 MB/sec</span></span> |
| <span data-ttu-id="5a457-833">결합된 MB/초</span><span class="sxs-lookup"><span data-stu-id="5a457-833">Combined MB/sec</span></span> |<span data-ttu-id="5a457-834">CacheReads</span><span class="sxs-lookup"><span data-stu-id="5a457-834">CacheReads</span></span> |<span data-ttu-id="5a457-835">RandomWrites\_64K</span><span class="sxs-lookup"><span data-stu-id="5a457-835">RandomWrites\_64K</span></span> |<span data-ttu-id="5a457-836">1000MB/초</span><span class="sxs-lookup"><span data-stu-id="5a457-836">1000 MB/sec</span></span> |
| <span data-ttu-id="5a457-837">NoCacheWrites</span><span class="sxs-lookup"><span data-stu-id="5a457-837">NoCacheWrites</span></span> |<span data-ttu-id="5a457-838">RandomReads\_64K</span><span class="sxs-lookup"><span data-stu-id="5a457-838">RandomReads\_64K</span></span> | &nbsp; | &nbsp; |

<span data-ttu-id="5a457-839">아래는 결합된 IOPS 및 처리량 시나리오에 대한 Iometer 테스트 결과의 스크린샷입니다.</span><span class="sxs-lookup"><span data-stu-id="5a457-839">Below are screenshots of the Iometer test results for combined IOPS and Throughput scenarios.</span></span>

<span data-ttu-id="5a457-840">*읽기 및 쓰기 최대 IOPS를 결합*</span><span class="sxs-lookup"><span data-stu-id="5a457-840">*Combined Reads and Writes Maximum IOPS*</span></span>  
![](media/storage-premium-storage-performance/image9.png)

<span data-ttu-id="5a457-841">*읽기 및 쓰기 최대 처리량을 결합*</span><span class="sxs-lookup"><span data-stu-id="5a457-841">*Combined Reads and Writes Maximum Throughput*</span></span>  
![](media/storage-premium-storage-performance/image10.png)

### <a name="fio"></a><span data-ttu-id="5a457-842">FIO</span><span class="sxs-lookup"><span data-stu-id="5a457-842">FIO</span></span>
<span data-ttu-id="5a457-843">FIO는 Linux VM의 벤치마크 저장소에 널리 사용되는 도구입니다.</span><span class="sxs-lookup"><span data-stu-id="5a457-843">FIO is a popular tool to benchmark storage on the Linux VMs.</span></span> <span data-ttu-id="5a457-844">다른 IO 크기, 순차 또는 임의 읽기 및 쓰기를 선택하는 유연성을 가집니다.</span><span class="sxs-lookup"><span data-stu-id="5a457-844">It has the flexibility to select different IO sizes, sequential or random reads and writes.</span></span> <span data-ttu-id="5a457-845">지정된 I/O 작업을 수행하는 작업자 스레드 또는 프로세스를 생성합니다.</span><span class="sxs-lookup"><span data-stu-id="5a457-845">It spawns worker threads or processes to perform the specified I/O operations.</span></span> <span data-ttu-id="5a457-846">각 작업자 스레드가 작업 파일을 사용하여 수행해야 하는 I/O 작업의 유형을 지정할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="5a457-846">You can specify the type of I/O operations each worker thread must perform using job files.</span></span> <span data-ttu-id="5a457-847">아래 예에 나와 있는 시나리오 당 하나의 작업 파일을 만들었습니다.</span><span class="sxs-lookup"><span data-stu-id="5a457-847">We created one job file per scenario illustrated in the examples below.</span></span> <span data-ttu-id="5a457-848">프리미엄 저장소에서 실행되는 다른 작업을 벤치마크하도록 이러한 작업 파일의 사양을 변경할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="5a457-848">You can change the specifications in these job files to benchmark different workloads running on Premium Storage.</span></span> <span data-ttu-id="5a457-849">예제에서 **Ubuntu**를 실행하는 Standard DS 14 VM을 사용하고 있습니다.</span><span class="sxs-lookup"><span data-stu-id="5a457-849">In the examples, we are using a Standard DS 14 VM running **Ubuntu**.</span></span> <span data-ttu-id="5a457-850">[벤치마킹 섹션](#Benchmarking) 의 시작 부분에서 설명한 동일한 설치를 사용하고 벤치마킹 테스트를 실행하기 전에 캐시를 준비합니다.</span><span class="sxs-lookup"><span data-stu-id="5a457-850">Use the same setup described in the beginning of the [Benchmarking section](#Benchmarking) and warm up the cache before running the benchmarking tests.</span></span>

<span data-ttu-id="5a457-851">시작하기 전에 [FIO를 다운로드](https://github.com/axboe/fio) 하고 가상 컴퓨터에 설치합니다.</span><span class="sxs-lookup"><span data-stu-id="5a457-851">Before you begin, [download FIO](https://github.com/axboe/fio) and install it on your virtual machine.</span></span>

<span data-ttu-id="5a457-852">Ubuntu에 대해 다음 명령을 실행합니다.</span><span class="sxs-lookup"><span data-stu-id="5a457-852">Run the following command for Ubuntu,</span></span>

```
apt-get install fio
```

<span data-ttu-id="5a457-853">디스크에서 쓰기 작업 구동에 대해 4개의 작업자 스레드를 읽기 작업 구동에 대해 4개의 작업자 스레드를 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="5a457-853">We will use four worker threads for driving Write operations and four worker threads for driving Read operations on the disks.</span></span> <span data-ttu-id="5a457-854">쓰기 작업자는 “None”으로 설정된 캐시와 10개의 디스크가 있는 “nocache” 볼륨의 트래픽으로 구동됩니다.</span><span class="sxs-lookup"><span data-stu-id="5a457-854">The Write workers will be driving traffic on the "nocache" volume, which has 10 disks with cache set to "None".</span></span> <span data-ttu-id="5a457-855">쓰기 작업자는 “ReadOnly”로 설정된 캐시와 1개의 디스크가 있는 “readcache” 볼륨의 트래픽으로 구동됩니다.</span><span class="sxs-lookup"><span data-stu-id="5a457-855">The Read workers will be driving traffic on the "readcache" volume, which has 1 disk with cache set to "ReadOnly".</span></span>

<span data-ttu-id="5a457-856">*최대 쓰기 IOPS*</span><span class="sxs-lookup"><span data-stu-id="5a457-856">*Maximum Write IOPS*</span></span>  
<span data-ttu-id="5a457-857">최대 쓰기 IOPS를 얻으려면 다음 사양을 가진 작업 파일을 만듭니다.</span><span class="sxs-lookup"><span data-stu-id="5a457-857">Create the job file with following specifications to get maximum Write IOPS.</span></span> <span data-ttu-id="5a457-858">“fiowrite.ini”로 이름을 지정합니다.</span><span class="sxs-lookup"><span data-stu-id="5a457-858">Name it "fiowrite.ini".</span></span>

```
[global]
size=30g
direct=1
iodepth=256
ioengine=libaio
bs=8k

[writer1]
rw=randwrite
directory=/mnt/nocache
[writer2]
rw=randwrite
directory=/mnt/nocache
[writer3]
rw=randwrite
directory=/mnt/nocache
[writer4]
rw=randwrite
directory=/mnt/nocache
```

<span data-ttu-id="5a457-859">이전 섹션에서 설명한 설계 지침을 따라 핵심 사항을 기록해 둡니다.</span><span class="sxs-lookup"><span data-stu-id="5a457-859">Note the follow key things that are in line with the design guidelines discussed in previous sections.</span></span> <span data-ttu-id="5a457-860">이러한 사양은 최대 IOPS 구동에 필수적입니다.</span><span class="sxs-lookup"><span data-stu-id="5a457-860">These specifications are essential to drive maximum IOPS,</span></span>  

* <span data-ttu-id="5a457-861">256의 높은 큐 크기.</span><span class="sxs-lookup"><span data-stu-id="5a457-861">A high queue depth of 256.</span></span>  
* <span data-ttu-id="5a457-862">8KB의 작은 블록 크기.</span><span class="sxs-lookup"><span data-stu-id="5a457-862">A small block size of 8KB.</span></span>  
* <span data-ttu-id="5a457-863">임의 쓰기를 수행하는 다중 스레드.</span><span class="sxs-lookup"><span data-stu-id="5a457-863">Multiple threads performing random writes.</span></span>

<span data-ttu-id="5a457-864">다음 명령을 실행하여 30초 동안 FIO 테스트를 시작합니다.</span><span class="sxs-lookup"><span data-stu-id="5a457-864">Run the following command to kick off the FIO test for 30 seconds,</span></span>  

```
sudo fio --runtime 30 fiowrite.ini
```

<span data-ttu-id="5a457-865">테스트가 실행되는 동안 VM 및 프리미엄 디스크가 제공하는 쓰기 IOPS 수를 볼 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="5a457-865">While the test runs, you will be able to see the number of write IOPS the VM and Premium disks are delivering.</span></span> <span data-ttu-id="5a457-866">아래 예제처럼 DS14 VM은 50,000 IOPS의 해당 최대 쓰기 IOPS 제한을 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="5a457-866">As shown in the sample below, the DS14 VM is delivering its maximum write IOPS limit of 50,000 IOPS.</span></span>  
    ![](media/storage-premium-storage-performance/image11.png)

<span data-ttu-id="5a457-867">*최대 읽기 IOPS*</span><span class="sxs-lookup"><span data-stu-id="5a457-867">*Maximum Read IOPS*</span></span>  
<span data-ttu-id="5a457-868">최대 읽기 IOPS를 얻으려면 다음 사양을 가진 작업 파일을 만듭니다.</span><span class="sxs-lookup"><span data-stu-id="5a457-868">Create the job file with following specifications to get maximum Read IOPS.</span></span> <span data-ttu-id="5a457-869">"fioread.ini"로 이름을 지정합니다.</span><span class="sxs-lookup"><span data-stu-id="5a457-869">Name it "fioread.ini".</span></span>

```
[global]
size=30g
direct=1
iodepth=256
ioengine=libaio
bs=8k

[reader1]
rw=randread
directory=/mnt/readcache
[reader2]
rw=randread
directory=/mnt/readcache
[reader3]
rw=randread
directory=/mnt/readcache
[reader4]
rw=randread
directory=/mnt/readcache
```

<span data-ttu-id="5a457-870">이전 섹션에서 설명한 설계 지침을 따라 핵심 사항을 기록해 둡니다.</span><span class="sxs-lookup"><span data-stu-id="5a457-870">Note the follow key things that are in line with the design guidelines discussed in previous sections.</span></span> <span data-ttu-id="5a457-871">이러한 사양은 최대 IOPS 구동에 필수적입니다.</span><span class="sxs-lookup"><span data-stu-id="5a457-871">These specifications are essential to drive maximum IOPS,</span></span>

* <span data-ttu-id="5a457-872">256의 높은 큐 크기.</span><span class="sxs-lookup"><span data-stu-id="5a457-872">A high queue depth of 256.</span></span>  
* <span data-ttu-id="5a457-873">8KB의 작은 블록 크기.</span><span class="sxs-lookup"><span data-stu-id="5a457-873">A small block size of 8KB.</span></span>  
* <span data-ttu-id="5a457-874">임의 쓰기를 수행하는 다중 스레드.</span><span class="sxs-lookup"><span data-stu-id="5a457-874">Multiple threads performing random writes.</span></span>

<span data-ttu-id="5a457-875">다음 명령을 실행하여 30초 동안 FIO 테스트를 시작합니다.</span><span class="sxs-lookup"><span data-stu-id="5a457-875">Run the following command to kick off the FIO test for 30 seconds,</span></span>

```
sudo fio --runtime 30 fioread.ini
```

<span data-ttu-id="5a457-876">테스트가 실행되는 동안 VM 및 프리미엄 디스크가 제공하는 읽기 IOPS 수를 볼 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="5a457-876">While the test runs, you will be able to see the number of read IOPS the VM and Premium disks are delivering.</span></span> <span data-ttu-id="5a457-877">아래 예제처럼 DS14 VM은 64,000 읽기 IOPS보다 많이 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="5a457-877">As shown in the sample below, the DS14 VM is delivering more than 64,000 Read IOPS.</span></span> <span data-ttu-id="5a457-878">이는 디스크와 캐시 성능의 조합입니다.</span><span class="sxs-lookup"><span data-stu-id="5a457-878">This is a combination of the disk and the cache performance.</span></span>  
    ![](media/storage-premium-storage-performance/image12.png)

<span data-ttu-id="5a457-879">*최대 읽기 및 쓰기 IOPS*</span><span class="sxs-lookup"><span data-stu-id="5a457-879">*Maximum Read and Write IOPS*</span></span>  
<span data-ttu-id="5a457-880">결합된 최대 읽기 및 쓰기 IOPS를 얻으려면 다음과 같은 사양의 작업 파일을 만듭니다.</span><span class="sxs-lookup"><span data-stu-id="5a457-880">Create the job file with following specifications to get maximum combined Read and Write IOPS.</span></span> <span data-ttu-id="5a457-881">"fioreadwrite.ini"로 이름을 지정합니다.</span><span class="sxs-lookup"><span data-stu-id="5a457-881">Name it "fioreadwrite.ini".</span></span>

```
[global]
size=30g
direct=1
iodepth=128
ioengine=libaio
bs=4k

[reader1]
rw=randread
directory=/mnt/readcache
[reader2]
rw=randread
directory=/mnt/readcache
[reader3]
rw=randread
directory=/mnt/readcache
[reader4]
rw=randread
directory=/mnt/readcache

[writer1]
rw=randwrite
directory=/mnt/nocache
rate_iops=12500
[writer2]
rw=randwrite
directory=/mnt/nocache
rate_iops=12500
[writer3]
rw=randwrite
directory=/mnt/nocache
rate_iops=12500
[writer4]
rw=randwrite
directory=/mnt/nocache
rate_iops=12500
```

<span data-ttu-id="5a457-882">이전 섹션에서 설명한 설계 지침을 따라 핵심 사항을 기록해 둡니다.</span><span class="sxs-lookup"><span data-stu-id="5a457-882">Note the follow key things that are in line with the design guidelines discussed in previous sections.</span></span> <span data-ttu-id="5a457-883">이러한 사양은 최대 IOPS 구동에 필수적입니다.</span><span class="sxs-lookup"><span data-stu-id="5a457-883">These specifications are essential to drive maximum IOPS,</span></span>

* <span data-ttu-id="5a457-884">128의 높은 큐 크기</span><span class="sxs-lookup"><span data-stu-id="5a457-884">A high queue depth of 128.</span></span>  
* <span data-ttu-id="5a457-885">4KB의 작은 블록 크기</span><span class="sxs-lookup"><span data-stu-id="5a457-885">A small block size of 4KB.</span></span>  
* <span data-ttu-id="5a457-886">임의 읽기 및 쓰기를 수행하는 다중 스레드</span><span class="sxs-lookup"><span data-stu-id="5a457-886">Multiple threads performing random reads and writes.</span></span>

<span data-ttu-id="5a457-887">다음 명령을 실행하여 30초 동안 FIO 테스트를 시작합니다.</span><span class="sxs-lookup"><span data-stu-id="5a457-887">Run the following command to kick off the FIO test for 30 seconds,</span></span>

```
sudo fio --runtime 30 fioreadwrite.ini
```

<span data-ttu-id="5a457-888">테스트가 실행되는 동안 VM 및 프리미엄 디스크가 제공하는 결합된 읽기 및 쓰기 IOPS 수를 볼 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="5a457-888">While the test runs, you will be able to see the number of combined read and write IOPS the VM and Premium disks are delivering.</span></span> <span data-ttu-id="5a457-889">아래 예제처럼 DS14 VM은 결합된 읽기 및 쓰기 IOPS를 100,000 보다 많이 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="5a457-889">As shown in the sample below, the DS14 VM is delivering more than 100,000 combined Read and Write IOPS.</span></span> <span data-ttu-id="5a457-890">이는 디스크와 캐시 성능의 조합입니다.</span><span class="sxs-lookup"><span data-stu-id="5a457-890">This is a combination of the disk and the cache performance.</span></span>  
    ![](media/storage-premium-storage-performance/image13.png)

<span data-ttu-id="5a457-891">*결합된 최대 처리량*</span><span class="sxs-lookup"><span data-stu-id="5a457-891">*Maximum Combined Throughput*</span></span>  
<span data-ttu-id="5a457-892">결합된 최대 읽기 및 쓰기 처리량을 얻으려면 읽기 및 쓰기를 수행하는 다중 스레드로 더 큰 블록 크기 및 큰 큐 크기를 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="5a457-892">To get the maximum combined Read and Write Throughput, use a larger block size and large queue depth with multiple threads performing reads and writes.</span></span> <span data-ttu-id="5a457-893">64KB의 블록 크기와 128의 큐 크기를 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="5a457-893">You can use a block size of 64KB and queue depth of 128.</span></span>

## <a name="next-steps"></a><span data-ttu-id="5a457-894">다음 단계</span><span class="sxs-lookup"><span data-stu-id="5a457-894">Next Steps</span></span>
<span data-ttu-id="5a457-895">Azure 프리미엄 저장소에 대한 자세한 정보</span><span class="sxs-lookup"><span data-stu-id="5a457-895">Learn more about Azure Premium Storage:</span></span>

* [<span data-ttu-id="5a457-896">프리미엄 저장소: Azure 가상 컴퓨터 워크로드를 위한 고성능 저장소</span><span class="sxs-lookup"><span data-stu-id="5a457-896">Premium Storage: High-Performance Storage for Azure Virtual Machine Workloads</span></span>](storage-premium-storage.md)  

<span data-ttu-id="5a457-897">SQL Server 사용자의 경우 SQL Server에 대한 성능 모범 사례의 문서를 읽으세요.</span><span class="sxs-lookup"><span data-stu-id="5a457-897">For SQL Server users, read articles on Performance Best Practices for SQL Server:</span></span>

* [<span data-ttu-id="5a457-898">Azure 가상 컴퓨터의 SQL Server에 대한 성능 모범 사례</span><span class="sxs-lookup"><span data-stu-id="5a457-898">Performance Best Practices for SQL Server in Azure Virtual Machines</span></span>](../virtual-machines/windows/sql/virtual-machines-windows-sql-performance.md)
* [<span data-ttu-id="5a457-899">Azure 프리미엄 저장소는 Azure VM의 SQL Server에 대해 가장 높은 성능을 제공합니다</span><span class="sxs-lookup"><span data-stu-id="5a457-899">Azure Premium Storage provides highest performance for SQL Server in Azure VM</span></span>](http://blogs.technet.com/b/dataplatforminsider/archive/2015/04/23/azure-premium-storage-provides-highest-performance-for-sql-server-in-azure-vm.aspx)
