---
title: "Azure에서 Linux와 함께 Cassandra aaaRun | Microsoft Docs"
description: "Node.js 응용 프로그램에서 Azure 가상 컴퓨터의 linux 클러스터는 Cassandra toorun 방법"
services: virtual-machines-linux
documentationcenter: nodejs
author: tomarcher
manager: routlaw
editor: 
tags: azure-service-management
ms.assetid: 30de1f29-e97d-492f-ae34-41ec83488de0
ms.service: virtual-machines-linux
ms.workload: infrastructure-services
ms.tgt_pltfrm: vm-linux
ms.devlang: na
ms.topic: article
ms.date: 08/17/2017
ms.author: tarcher
ms.openlocfilehash: 381ca301bbe88d3740cf182f9c44fada5b9ba7cc
ms.sourcegitcommit: 523283cc1b3c37c428e77850964dc1c33742c5f0
ms.translationtype: MT
ms.contentlocale: ko-KR
ms.lasthandoff: 10/06/2017
---
# <a name="running-cassandra-with-linux-on-azure-and-accessing-it-from-nodejs"></a><span data-ttu-id="3186f-103">Azure에서 Linux 환경의 Cassandra 실행 및 Node.js에서 Cassandra에 액세스</span><span class="sxs-lookup"><span data-stu-id="3186f-103">Running Cassandra with Linux on Azure and Accessing it from Node.js</span></span>
> [!IMPORTANT] 
> <span data-ttu-id="3186f-104">Azure에는 리소스를 만들고 작업하기 위한 [리소스 관리자 및 클래식](../../../resource-manager-deployment-model.md)라는 두 가지 배포 모델이 있습니다.</span><span class="sxs-lookup"><span data-stu-id="3186f-104">Azure has two different deployment models for creating and working with resources: [Resource Manager and Classic](../../../resource-manager-deployment-model.md).</span></span> <span data-ttu-id="3186f-105">이 문서에서는 hello 클래식 배포 모델을 사용 하 여 설명 합니다.</span><span class="sxs-lookup"><span data-stu-id="3186f-105">This article covers using hello Classic deployment model.</span></span> <span data-ttu-id="3186f-106">대부분의 새로운 배포 hello 리소스 관리자 모델을 사용 하는 것이 좋습니다.</span><span class="sxs-lookup"><span data-stu-id="3186f-106">Microsoft recommends that most new deployments use hello Resource Manager model.</span></span> <span data-ttu-id="3186f-107">[Datastax Enterprise](https://azure.microsoft.com/documentation/templates/datastax) 및 [CentOS의 Spark 클러스터 및 Cassandra](https://azure.microsoft.com/documentation/templates/spark-and-cassandra-on-centos/)는 Resource Manager 템플릿을 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="3186f-107">See Resource Manager templates for [Datastax Enterprise](https://azure.microsoft.com/documentation/templates/datastax) and [Spark cluster and Cassandra on CentOS](https://azure.microsoft.com/documentation/templates/spark-and-cassandra-on-centos/).</span></span>

## <a name="overview"></a><span data-ttu-id="3186f-108">개요</span><span class="sxs-lookup"><span data-stu-id="3186f-108">Overview</span></span>
<span data-ttu-id="3186f-109">Microsoft Azure는 운영 체제, 응용 프로그램 서버, 메시징 미들웨어뿐 아니라 상용 및 오픈 소스 모델의 SQL 및 NoSQL 데이터베이스를 포함하는 Microsoft 및 타사 소프트웨어를 실행하는 개방형 클라우드 플랫폼입니다.</span><span class="sxs-lookup"><span data-stu-id="3186f-109">Microsoft Azure is an open cloud platform that runs both Microsoft as well as non-Microsoft software which  includes operating systems, application servers, messaging middleware as well as SQL and NoSQL databases from both commercial and open source models.</span></span> <span data-ttu-id="3186f-110">Azure를 비롯한 공용 클라우드에 복원 서비스를 빌드하려면 응용 프로그램 서버 및 저장소 계층 둘 다의 신중한 계획과 세밀한 아키텍처가 필요합니다.</span><span class="sxs-lookup"><span data-stu-id="3186f-110">Building resilient services on public clouds including Azure requires careful planning and deliberate architecture for both applications servers as well storage layers.</span></span> <span data-ttu-id="3186f-111">Cassandra의 분산 저장소 아키텍처는 클러스터 오류에 대한 내결함성이 있는 고가용성 시스템 빌드에 도움이 됩니다.</span><span class="sxs-lookup"><span data-stu-id="3186f-111">Cassandra’s distributed storage architecture naturally helps in building highly available systems that are fault tolerant for cluster failures.</span></span> <span data-ttu-id="3186f-112">Cassandra는 cassandra.apache.org에서 Apache Software Foundation에 의해 유지 관리되는 클라우드 규모의 NoSQL 데이터베이스입니다. Cassandra는 Java로 작성되었으므로 Windows 및 Linux 플랫폼에서 모두 실행됩니다.</span><span class="sxs-lookup"><span data-stu-id="3186f-112">Cassandra is a cloud scale NoSQL database maintained by Apache Software Foundation at cassandra.apache.org; Cassandra is written in Java and hence runs on both on Windows as well as Linux platforms.</span></span>

<span data-ttu-id="3186f-113">hello이이 문서는 Microsoft Azure 가상 컴퓨터와 가상 네트워크를 활용 하는 단일 및 다중 데이터 센터 클러스터로 ubuntu tooshow Cassandra 배포.</span><span class="sxs-lookup"><span data-stu-id="3186f-113">hello focus of this article is tooshow Cassandra deployment on Ubuntu as a single and multi-data center cluster leveraging Microsoft Azure Virtual Machines and Virtual Networks.</span></span> <span data-ttu-id="3186f-114">hello 클러스터 배포에 최적화 된 프로덕션 작업에는이 문서의 범위를 벗어났습니다 다중 디스크 노드 구성 해야 하므로, 적절 한 링 토폴로지 디자인 및 데이터 모델링 toosupport hello 필요한 복제, 데이터 일관성, 처리량 및 고가용성 요구 사항입니다.</span><span class="sxs-lookup"><span data-stu-id="3186f-114">hello cluster deployment for production optimized workloads is out of scope of this article as it requires multi-disk node configuration, appropriate ring topology design and data modeling toosupport hello needed replication, data consistency, throughput and high availability requirements.</span></span>

<span data-ttu-id="3186f-115">Docker, Chef 또는 puppet과 인프라 배포를 더 쉽게 많은 hello을 만들 수 있는 작업과 관련 된 사항을 건물 hello Cassandra 클러스터 기본 접근 방식을 tooshow 비교를 수행 하는 문서입니다.</span><span class="sxs-lookup"><span data-stu-id="3186f-115">This article takes a fundamental approach tooshow what is involved in building hello Cassandra cluster compared Docker, Chef or Puppet which can make hello infrastructure deployment a lot easier.</span></span>  

## <a name="hello-deployment-models"></a><span data-ttu-id="3186f-116">hello 배포 모델</span><span class="sxs-lookup"><span data-stu-id="3186f-116">hello Deployment Models</span></span>
<span data-ttu-id="3186f-117">Microsoft Azure 네트워킹을 통해 hello 배포의 격리 된 개인 클러스터는 hello 액세스 제한 tooattain 세밀 하 게 세분화 된 네트워크 보안을 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="3186f-117">Microsoft Azure networking allows hello deployment of isolated private clusters, hello access of which can be restricted tooattain fine grained network security.</span></span>  <span data-ttu-id="3186f-118">이 문서는 기본적인 수준 hello Cassandra 배포를 보여 주는 하는 방법에 대 한 이므로 하지 살펴볼 것에서 hello 일관성 수준 및 처리량에 대 한 hello 최적의 저장소 디자인입니다.</span><span class="sxs-lookup"><span data-stu-id="3186f-118">Since this article is about showing hello Cassandra deployment at a fundamental level, we will not focus on hello consistency level and hello optimal storage design for throughput.</span></span> <span data-ttu-id="3186f-119">Hello 우리의 가상 클러스터에 대 한 네트워킹 요구 사항 목록은 다음과 같습니다.</span><span class="sxs-lookup"><span data-stu-id="3186f-119">Here is hello list of networking requirements for our hypothetical cluster:</span></span>

* <span data-ttu-id="3186f-120">외부 시스템은 Azure 내부나 외부에서 Cassandra 데이터베이스에 액세스할 수 없어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="3186f-120">External systems can’t access Cassandra database from within or outside Azure</span></span>
* <span data-ttu-id="3186f-121">Cassandra 클러스터 toobe thrift 트래픽에 대 한 부하 분산 장치 뒤에</span><span class="sxs-lookup"><span data-stu-id="3186f-121">Cassandra cluster has toobe behind a load balancer for thrift traffic</span></span>
* <span data-ttu-id="3186f-122">클러스터 가용성 향상을 위해 각 데이터 센터의 두 그룹에 Cassandra 노드를 배포해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="3186f-122">Deploy Cassandra nodes in two groups in each data center for an enhanced cluster availability</span></span>
* <span data-ttu-id="3186f-123">잠글 hello 클러스터 하므로 하는 서버 팜의 응용 프로그램에 직접 액세스 toohello 데이터베이스가</span><span class="sxs-lookup"><span data-stu-id="3186f-123">Lock down hello cluster so that only application server farm has access toohello database directly</span></span>
* <span data-ttu-id="3186f-124">SSH 이외의 공용 네트워킹 끝점이 없어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="3186f-124">No public networking endpoints other than SSH</span></span>
* <span data-ttu-id="3186f-125">각 Cassandra 노드에 고정된 내부 IP 주소가 필요합니다.</span><span class="sxs-lookup"><span data-stu-id="3186f-125">Each Cassandra node needs a fixed internal IP address</span></span>

<span data-ttu-id="3186f-126">배포 된 tooa 단일 Azure 지역 또는 hello 작업 부하의 distributed hello 특성에 따라 toomultiple 영역의 Cassandra 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="3186f-126">Cassandra can be deployed tooa single Azure region or toomultiple regions based on hello distributed nature of hello workload.</span></span> <span data-ttu-id="3186f-127">다중 지역 배포 모델 사용된 tooserve 최종 사용자가 더 가깝기 때문 tooa 특정 지리 hello 통해 수 동일한 Cassandra 인프라입니다.</span><span class="sxs-lookup"><span data-stu-id="3186f-127">Multi-region deployment model can be leveraged tooserve end users closer tooa particular geography through hello same Cassandra infrastructure.</span></span> <span data-ttu-id="3186f-128">여러 데이터 센터에서 시작 된 쓰고 hello 데이터 tooapplications의 일관 된 뷰를 제공 하는 다중 마스터의 hello 동기화의 Cassandra의 기본 제공 노드 복제는 주의 합니다.</span><span class="sxs-lookup"><span data-stu-id="3186f-128">Cassandra’s built-in node replication takes care of hello synchronization of multi-master writes originating from multiple data centers and presents a consistent view of hello data tooapplications.</span></span> <span data-ttu-id="3186f-129">다중 지역 배포는 hello 보다 광범위 한 Azure 서비스 중단의 위험 완화 hello와 유용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="3186f-129">Multi-region deployment can also help with hello risk mitigation of hello broader Azure service outages.</span></span> <span data-ttu-id="3186f-130">Cassandra의 조정 가능한 일관성 및 복제 토폴로지는 응용 프로그램의 다양한 RPO 요구를 충족하는 데 유용합니다.</span><span class="sxs-lookup"><span data-stu-id="3186f-130">Cassandra’s tunable consistency and replication topology will help in meeting diverse RPO needs of applications.</span></span>

### <a name="single-region-deployment"></a><span data-ttu-id="3186f-131">단일 지역 배포</span><span class="sxs-lookup"><span data-stu-id="3186f-131">Single Region Deployment</span></span>
<span data-ttu-id="3186f-132">단일 지역 배포 및 9 월 hello 배우게 되는 다중 지역 모델을 만드는 것부터 시작 합니다.</span><span class="sxs-lookup"><span data-stu-id="3186f-132">We will start with a single region deployment and harvest hello learnings in creating a multi-region model.</span></span> <span data-ttu-id="3186f-133">위에서 언급 한 hello 네트워크 보안 요구를 충족 될 수 있도록 azure 가상 네트워크 격리 사용된 toocreate 서브넷 됩니다.</span><span class="sxs-lookup"><span data-stu-id="3186f-133">Azure virtual networking will be used toocreate isolated subnets so that hello network security requirements mentioned above can be met.</span></span>  <span data-ttu-id="3186f-134">Ubuntu 14.04 LTS 및 Cassandra 2.08; hello 단일 지역 배포 만들기에 설명 된 hello 프로세스 사용 그러나 hello 프로세스 수 채택된 되 toohello 다른 Linux 변형 됩니다.</span><span class="sxs-lookup"><span data-stu-id="3186f-134">hello process described in creating hello single region deployment uses Ubuntu 14.04 LTS and Cassandra 2.08; however, hello process can easily be adopted toohello other Linux variants.</span></span> <span data-ttu-id="3186f-135">hello 단일 지역 배포의 시스템 특성 hello hello 다음과가 같습니다.</span><span class="sxs-lookup"><span data-stu-id="3186f-135">hello following are some of hello systemic characteristics of hello single region deployment.</span></span>  

<span data-ttu-id="3186f-136">**고가용성:** hello Cassandra 노드 tootwo 가용성 집합 hello 노드는 고가용성을 위해 여러 오류 도메인 간에 분산 되어 있도록 그림 1에 배포 된 hello에 표시 된 것입니다.</span><span class="sxs-lookup"><span data-stu-id="3186f-136">**High Availability:** hello Cassandra nodes shown in hello Figure 1 are deployed tootwo availability sets so that hello nodes are spread between multiple fault domains for high availability.</span></span> <span data-ttu-id="3186f-137">각 가용성 집합으로 주석이 달려 있어야 하는 Vm은 매핑된 too2 오류 도메인입니다.</span><span class="sxs-lookup"><span data-stu-id="3186f-137">VMs annotated with each availability set is mapped too2 fault domains.</span></span>  <span data-ttu-id="3186f-138">작동 중단 시간 (예:: 하드웨어나 소프트웨어 장애) hello 개념의 업그레이드 도메인 (예: 호스트 또는 게스트 OS 패치/업그레이드, 응용 프로그램 업그레이드) 하는 동안 계획 되지 않은 오류 도메인 toomanage의 Microsoft Azure 사용 하 여 hello 개념 작동 중단 시간에 예약 된 관리에 사용 됩니다.</span><span class="sxs-lookup"><span data-stu-id="3186f-138">Microsoft Azure uses hello concept of fault domain toomanage unplanned down time (e.g. hardware or software failures) while hello concept of upgrade domain (e.g. host or guest OS patching/upgrades, application upgrades) is used for managing scheduled down time.</span></span> <span data-ttu-id="3186f-139">참조 하십시오 [Azure 응용 프로그램에 대 한 고가용성 및 재해 복구](http://msdn.microsoft.com/library/dn251004.aspx) 높은 가용성을 계산 하기에 있는 오류 및 업그레이드 도메인의 hello 역할에 대 한 합니다.</span><span class="sxs-lookup"><span data-stu-id="3186f-139">Please see [Disaster Recovery and High Availability for Azure Applications](http://msdn.microsoft.com/library/dn251004.aspx) for hello role of fault and upgrade domains in attaining high availability.</span></span>

![단일 지역 배포](./media/cassandra-nodejs/cassandra-linux1.png)

<span data-ttu-id="3186f-141">그림 1: 단일 지역 배포</span><span class="sxs-lookup"><span data-stu-id="3186f-141">Figure 1: Single region deployment</span></span>

<span data-ttu-id="3186f-142">참고는이 문서 작성 hello 시 Azure 허용 하지 않습니다 hello Vm tooa 특정 장애 도메인; 그룹의 명시적 매핑 따라서 그림 1에 표시 된 hello 배포 모델을 사용 하더라도 것이 통계적으로 할 모든 hello 가상 컴퓨터 4 개가 아니라 매핑된 tootwo 오류 도메인을 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="3186f-142">Note that at hello time of this writing, Azure doesn’t allow hello explicit mapping of a group of VMs tooa specific fault domain; consequently, even with hello deployment model shown in Figure 1, it is statistically probable that all hello virtual machines may be mapped tootwo fault domains instead of four.</span></span>

<span data-ttu-id="3186f-143">**로드 균형 조정 Thrift 트래픽:** hello 웹 서버가 안쪽 Thrift 클라이언트 라이브러리는 내부 부하 분산 장치를 통해 toohello 클러스터에 연결 합니다.</span><span class="sxs-lookup"><span data-stu-id="3186f-143">**Load Balancing Thrift Traffic:** Thrift client libraries inside hello web server connect toohello cluster through an internal load balancer.</span></span> <span data-ttu-id="3186f-144">이 위해서는 hello 내부 부하 분산 장치 toohello "데이터" 서브넷을 추가 하는 hello 프로세스 (그림 1 참조) hello Cassandra 클러스터를 호스팅하는 hello 클라우드 서비스의 hello 컨텍스트에서 합니다.</span><span class="sxs-lookup"><span data-stu-id="3186f-144">This requires hello process of adding hello internal load balancer toohello “data” subnet (refer Figure 1) in hello context of hello cloud service hosting hello Cassandra cluster.</span></span> <span data-ttu-id="3186f-145">Hello 내부 부하 분산 장치에서 정의 되 면 각 노드는 hello 부하 분산 된 끝점 toobe 정의 된 부하 분산 장치 이름이 이전 부하 분산 된 집합의 hello 주석으로 추가 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="3186f-145">Once hello internal load balancer is defined, each node requires hello load balanced endpoint toobe added with hello annotations of a load balanced set with previously defined load balancer name.</span></span> <span data-ttu-id="3186f-146">자세한 내용은 [Azure 내부 부하 분산 ](../../../load-balancer/load-balancer-internal-overview.md)을 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="3186f-146">See [Azure Internal Load Balancing ](../../../load-balancer/load-balancer-internal-overview.md)for more details.</span></span>

<span data-ttu-id="3186f-147">**클러스터 시드:** tooselect hello 클러스터의 시드 노드 toodiscover hello 토폴로지 통신할 초기값으로 새 노드를 hello에 대 한 대부분의 항상 사용 가능한 노드에 hello 고려해 야 합니다.</span><span class="sxs-lookup"><span data-stu-id="3186f-147">**Cluster Seeds:** It is important tooselect hello most highly available nodes for seeds as hello new nodes will communicate with seed nodes toodiscover hello topology of hello cluster.</span></span> <span data-ttu-id="3186f-148">각 가용성 집합에서 한 노드 시드 노드 tooavoid 단일 오류 지점으로 지정 됩니다.</span><span class="sxs-lookup"><span data-stu-id="3186f-148">One node from each availability set is designated as seed nodes tooavoid single point of failure.</span></span>

<span data-ttu-id="3186f-149">**복제 요소와 일관성 수준을:** Cassandra의 기본 제공 고가용성 및 데이터 지 속성의 특징은 hello 복제 요소 (RF-hello 클러스터에 저장 된 각 행의 복사본 개수) 및 일관성 수준 (개수 복제본 toobe hello 결과 toohello 호출자에 게 반환 하기 전에 읽기/쓰기).</span><span class="sxs-lookup"><span data-stu-id="3186f-149">**Replication Factor and Consistency Level:** Cassandra’s build-in high-availability and data durability is characterized by hello Replication Factor (RF - number of copies of each row stored on hello cluster) and Consistency Level (number of replicas toobe read/written before returning hello result toohello caller).</span></span> <span data-ttu-id="3186f-150">복제 요소 hello 일관성 수준이 hello CRUD 쿼리를 실행 하는 동안 지정 된 반면 hello 있어 실제로 (유사한 tooa 관계형 데이터베이스) 생성 하는 동안 지정 됩니다.</span><span class="sxs-lookup"><span data-stu-id="3186f-150">Replication factor is specified during hello KEYSPACE (similar tooa relational database) creation whereas hello consistency level is specified while issuing hello CRUD query.</span></span> <span data-ttu-id="3186f-151">Cassandra 설명서를 참조 [일관성에 대 한 구성](http://www.datastax.com/documentation/cassandra/2.0/cassandra/dml/dml_config_consistency_c.html) 일관성 세부 정보 및 쿼럼 계산에 대 한 hello 수식에 대 한 합니다.</span><span class="sxs-lookup"><span data-stu-id="3186f-151">See Cassandra documentation at [Configuring for Consistency](http://www.datastax.com/documentation/cassandra/2.0/cassandra/dml/dml_config_consistency_c.html) for consistency details and hello formula for quorum computation.</span></span>

<span data-ttu-id="3186f-152">Cassandra 두 가지 유형의 일관성 및 결과적 일관성; – 데이터 무결성 모델 지원 hello 복제 요소와 일관성 수준이 경우 hello 데이터 일관성이 됩니다 즉시 쓰기 작업이 완료 되는 것은 결국 일관 된 결정 함께 합니다.</span><span class="sxs-lookup"><span data-stu-id="3186f-152">Cassandra supports two types of data integrity models – Consistency and Eventual Consistency; hello Replication Factor and Consistency Level will together determine if hello data will be consistent as soon as a write operation is complete or it will be eventually consistent.</span></span> <span data-ttu-id="3186f-153">예를 들어 지정 하면 쿼럼 hello 수가 필요한 tooattain로 작성 된 복제본 toobe 아래의 모든 일관성 수준 하는 동안 데이터 일관성을 보장 하는 hello 일관성 수준이 항상 (예: 1 개) 쿼럼 발생 결국 일관성이 데이터입니다.</span><span class="sxs-lookup"><span data-stu-id="3186f-153">For example, specifying QUORUM as hello Consistency Level will always ensures data Consistency while any consistency level, below hello number of replicas toobe written as needed tooattain QUORUM (e.g. ONE) results in data being eventually consistent.</span></span>

<span data-ttu-id="3186f-154">3, 쿼럼 복제 요소와 위에 표시 된 hello 8 개 노드 클러스터 (2 노드는 읽기 또는 쓰기 일관성을 위해) 읽기/쓰기 일관성 수준이, hello 복제 당 1 노드는 최대 hello 응용 프로그램 시작 하기 전에 그룹에서 hello 이론적 손실이 감당할 수 있는 hello 오류를 검색 합니다.</span><span class="sxs-lookup"><span data-stu-id="3186f-154">hello 8-node cluster shown above, with a replication factor of 3 and QUORUM (2 nodes are read or written for consistency) read/write consistency level, can survive hello theoretical loss of at hello most 1 node per replication group before hello application start noticing hello failure.</span></span> <span data-ttu-id="3186f-155">이 모든 hello 키 공간 읽기/쓰기 요청을 분산도 가정 합니다.</span><span class="sxs-lookup"><span data-stu-id="3186f-155">This assumes that all hello key spaces have well balanced read/write requests.</span></span>  <span data-ttu-id="3186f-156">hello 다음은 배포 된 hello 클러스터를 사용 하는 hello 매개 변수입니다.</span><span class="sxs-lookup"><span data-stu-id="3186f-156">hello following are hello parameters we will use for hello deployed cluster:</span></span>

<span data-ttu-id="3186f-157">단일 지역 Cassandra 클러스터 구성:</span><span class="sxs-lookup"><span data-stu-id="3186f-157">Single region Cassandra cluster configuration:</span></span>

| <span data-ttu-id="3186f-158">클러스터 매개 변수</span><span class="sxs-lookup"><span data-stu-id="3186f-158">Cluster Parameter</span></span> | <span data-ttu-id="3186f-159">값</span><span class="sxs-lookup"><span data-stu-id="3186f-159">Value</span></span> | <span data-ttu-id="3186f-160">설명</span><span class="sxs-lookup"><span data-stu-id="3186f-160">Remarks</span></span> |
| --- | --- | --- |
| <span data-ttu-id="3186f-161">노드 수(N)</span><span class="sxs-lookup"><span data-stu-id="3186f-161">Number of Nodes (N)</span></span> |<span data-ttu-id="3186f-162">8</span><span class="sxs-lookup"><span data-stu-id="3186f-162">8</span></span> |<span data-ttu-id="3186f-163">총 hello 클러스터의 노드 수</span><span class="sxs-lookup"><span data-stu-id="3186f-163">Total number of nodes in hello cluster</span></span> |
| <span data-ttu-id="3186f-164">복제 계수(RF)</span><span class="sxs-lookup"><span data-stu-id="3186f-164">Replication Factor (RF)</span></span> |<span data-ttu-id="3186f-165">3</span><span class="sxs-lookup"><span data-stu-id="3186f-165">3</span></span> |<span data-ttu-id="3186f-166">지정된 행의 복제본 수</span><span class="sxs-lookup"><span data-stu-id="3186f-166">Number of replicas of a given row</span></span> |
| <span data-ttu-id="3186f-167">일관성 수준(쓰기)</span><span class="sxs-lookup"><span data-stu-id="3186f-167">Consistency Level (Write)</span></span> |<span data-ttu-id="3186f-168">QUORUM[(RF/2) +1) = 2] hello 결과 수식을 내림 hello의</span><span class="sxs-lookup"><span data-stu-id="3186f-168">QUORUM[(RF/2) +1) = 2] hello result of hello formula is rounded down</span></span> |<span data-ttu-id="3186f-169">에 작성 hello 대부분 복제본 2 개 hello 응답 toohello 호출자를 전송 하기 전에 3 번째 복제본 결국 일관 된 방식으로 기록 됩니다.</span><span class="sxs-lookup"><span data-stu-id="3186f-169">Writes at hello most 2 replicas before hello response is sent toohello caller; 3rd replica is written in an eventually consistent manner.</span></span> |
| <span data-ttu-id="3186f-170">일관성 수준(읽기)</span><span class="sxs-lookup"><span data-stu-id="3186f-170">Consistency Level (Read)</span></span> |<span data-ttu-id="3186f-171">쿼럼 [(RF/2) + 1 = 2] hello 수식의 hello 결과 내림</span><span class="sxs-lookup"><span data-stu-id="3186f-171">QUORUM [(RF/2) +1= 2] hello result of hello formula is rounded down</span></span> |<span data-ttu-id="3186f-172">응답 toohello 호출자에 게 보내기 전에 복제본 2 개를 읽습니다.</span><span class="sxs-lookup"><span data-stu-id="3186f-172">Reads 2 replicas before sending response toohello caller.</span></span> |
| <span data-ttu-id="3186f-173">복제 전략</span><span class="sxs-lookup"><span data-stu-id="3186f-173">Replication Strategy</span></span> |<span data-ttu-id="3186f-174">NetworkTopologyStrategy자세한 내용은 Cassandra 설명서의 [데이터 복제](http://www.datastax.com/documentation/cassandra/2.0/cassandra/architecture/architectureDataDistributeReplication_c.html) 참조</span><span class="sxs-lookup"><span data-stu-id="3186f-174">NetworkTopologyStrategy see [Data Replication](http://www.datastax.com/documentation/cassandra/2.0/cassandra/architecture/architectureDataDistributeReplication_c.html) in Cassandra documentation for more information</span></span> |<span data-ttu-id="3186f-175">Hello 배포 토폴로지를 이해 하 고 모든 hello 복제 하지 않는에서 중단 될 hello 동일한 복제본 노드에 배치 랙</span><span class="sxs-lookup"><span data-stu-id="3186f-175">Understands hello deployment topology and places replicas on nodes so that all hello replicas don’t end up on hello same rack</span></span> |
| <span data-ttu-id="3186f-176">Snitch</span><span class="sxs-lookup"><span data-stu-id="3186f-176">Snitch</span></span> |<span data-ttu-id="3186f-177">GossipingPropertyFileSnitch 자세한 내용은 Cassandra 설명서의 [Snitches](http://www.datastax.com/documentation/cassandra/2.0/cassandra/architecture/architectureSnitchesAbout_c.html) 를 참조</span><span class="sxs-lookup"><span data-stu-id="3186f-177">GossipingPropertyFileSnitch see [Snitches](http://www.datastax.com/documentation/cassandra/2.0/cassandra/architecture/architectureSnitchesAbout_c.html) in Cassandra documentation for more information</span></span> |<span data-ttu-id="3186f-178">NetworkTopologyStrategy는 경찰관 toounderstand hello 토폴로지의 개념을 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="3186f-178">NetworkTopologyStrategy uses a concept of snitch toounderstand hello topology.</span></span> <span data-ttu-id="3186f-179">GossipingPropertyFileSnitch 각 노드 toodata 중심과 랙 매핑에 효율적으로 제어를 제공 합니다.</span><span class="sxs-lookup"><span data-stu-id="3186f-179">GossipingPropertyFileSnitch gives better control in mapping each node toodata center and rack.</span></span> <span data-ttu-id="3186f-180">hello 클러스터는 다음 여러 toopropagate이이 정보가 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="3186f-180">hello cluster then uses gossip toopropagate this information.</span></span> <span data-ttu-id="3186f-181">동적 IP 설정 상대 tooPropertyFileSnitch에 훨씬 더 간단입니다.</span><span class="sxs-lookup"><span data-stu-id="3186f-181">This is much simpler in dynamic IP setting relative tooPropertyFileSnitch</span></span> |

<span data-ttu-id="3186f-182">**Cassandra 클러스터에 대한 Azure 고려 사항:** Microsoft Azure Virtual Machines 기능은 디스크 지속성을 위해 Azure Blob Storage를 사용합니다. Azure Storage는 높은 내구성을 위해 각 디스크의 복제본을 3개 저장합니다.</span><span class="sxs-lookup"><span data-stu-id="3186f-182">**Azure Considerations for Cassandra Cluster:** Microsoft Azure Virtual Machines capability uses Azure Blob storage for disk persistence; Azure Storage saves 3 replicas of each disk for high durability.</span></span> <span data-ttu-id="3186f-183">즉, Cassandra 테이블에 삽입 된 데이터의 각 행은 이미 복제본 3 개에 저장 하 고 따라서 데이터 일관성 이미 안전 하다는 1 hello 복제 비율 (RF) 하는 경우에 합니다.</span><span class="sxs-lookup"><span data-stu-id="3186f-183">That means each row of data inserted into a Cassandra table is already stored in 3 replicas and hence data consistency is already taken care of even if hello Replication Factor (RF) is 1.</span></span> <span data-ttu-id="3186f-184">복제 비율로 1 hello 큰 문제는 hello 응용 프로그램에서 작동 중단이 발생 한 단일 Cassandra 노드가 실패 한 경우에입니다.</span><span class="sxs-lookup"><span data-stu-id="3186f-184">hello main problem with Replication Factor being 1 is that hello application will experience downtime even if a single Cassandra node fails.</span></span> <span data-ttu-id="3186f-185">그러나 Azure 패브릭 컨트롤러에 의해 인식 hello 문제 (예: 하드웨어, 소프트웨어 오류 시스템)에 대 한 노드가 다운 되는 경우 것은 프로 비전 사용 하 여 해당 위치에 새 노드는 동일한 저장소 드라이브 hello 합니다.</span><span class="sxs-lookup"><span data-stu-id="3186f-185">However, if a node is down for hello problems (e.g. hardware, system software failures) recognized by Azure Fabric Controller, it will provision a new node in its place using hello same storage drives.</span></span> <span data-ttu-id="3186f-186">새 노드 tooreplace hello 이전 몇 분 정도 걸릴 수 있습니다 하나를 프로 비전 합니다.</span><span class="sxs-lookup"><span data-stu-id="3186f-186">Provisioning a new node tooreplace hello old one may take a few minutes.</span></span>  <span data-ttu-id="3186f-187">마찬가지로 게스트 OS 변경 내용과 비슷한 계획 된 유지 관리 작업에 대 한 Cassandra 업그레이드 하 고 응용 프로그램을 변경 Azure 패브릭 컨트롤러 hello 클러스터에서 롤링 hello 노드의 업그레이드 수행 합니다.</span><span class="sxs-lookup"><span data-stu-id="3186f-187">Similarly for planned maintenance activities like guest OS changes, Cassandra upgrades and application changes Azure Fabric Controller performs rolling upgrades of hello nodes in hello cluster.</span></span>  <span data-ttu-id="3186f-188">Hello 클러스터 몇 가지 파티션에 대 한 짧은 가동 중지가 발생할 수 있으므로 및 롤링 업그레이드도 한 번에 몇 개 노드 아래로 걸릴 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="3186f-188">Rolling upgrades also may take down a few nodes at a time and hence hello cluster may experience brief downtime for a few partitions.</span></span> <span data-ttu-id="3186f-189">그러나 hello 데이터 toohello 기본 제공 Azure 저장소 중복 인해 손실 됩니다.</span><span class="sxs-lookup"><span data-stu-id="3186f-189">However, hello data will not be lost due toohello built-in Azure Storage redundancy.</span></span>  

<span data-ttu-id="3186f-190">시스템이 tooAzure 고가용성이 필요 하지 않은 배포에 대 한 (예: 99.9 약 변수인 해당 too8.76 시간/연도; 참조 [고가용성](http://en.wikipedia.org/wiki/High_availability) 대 한 자세한 내용은) 수 toorun RF 사용 될 수 있습니다 = 1 및 일관성 수준이 = 하나입니다.</span><span class="sxs-lookup"><span data-stu-id="3186f-190">For systems deployed tooAzure that doesn’t require high availability (e.g. around 99.9 which is equivalent too8.76 hrs/year; see [High Availability](http://en.wikipedia.org/wiki/High_availability) for details) you may be able toorun with RF=1 and Consistency Level=ONE.</span></span>  <span data-ttu-id="3186f-191">응용 프로그램의 가용성 요구 사항이, RF = 3, 일관성 수준이 = 쿼럼 hello hello 복제본 중 하나 hello 노드 중 하나의 작동 중단이 허용 됩니다.</span><span class="sxs-lookup"><span data-stu-id="3186f-191">For applications with high availability requirements, RF=3 and Consistency Level=QUORUM will tolerate hello down time of one of hello nodes one of hello replicas.</span></span> <span data-ttu-id="3186f-192">RF = 1 기존 배포에서 인해 디스크 오류와 같은 문제 로부터 toohello 가능한 데이터 손실 (예: 온-프레미스)를 사용할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="3186f-192">RF=1 in traditional deployments (e.g. on-premises) can’t be used due toohello possible data loss resulting from problems like disk failures.</span></span>   

## <a name="multi-region-deployment"></a><span data-ttu-id="3186f-193">다중 지역 배포</span><span class="sxs-lookup"><span data-stu-id="3186f-193">Multi-region Deployment</span></span>
<span data-ttu-id="3186f-194">Cassandra의 복제 데이터 센터 인식 및 일관성 모델 hello 없이 hello 초기 hello 다중 지역 배포와 함께 사용 하면 위에서 설명한 모든 외부 도구에 대 한 필요 합니다.</span><span class="sxs-lookup"><span data-stu-id="3186f-194">Cassandra’s data-center-aware replication and consistency model described above helps with hello multi-region deployment out of hello box without hello need for any external tooling.</span></span> <span data-ttu-id="3186f-195">이것이 hello 기존의 관계형 데이터베이스와에서 크게 다르게 다중 마스터 쓰기에 대 한 데이터베이스 미러링에 대 한 hello 설치 매우 복잡할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="3186f-195">This is quite different from hello traditional relational databases where hello setup for database mirroring for multi-master writes can be quite complex.</span></span> <span data-ttu-id="3186f-196">Cassandra 다중 지역 설정에 hello 다음을 비롯 한 hello 사용 시나리오에 도움이 될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="3186f-196">Cassandra in a multi-region set up can help with hello usage scenarios including hello following:</span></span>

<span data-ttu-id="3186f-197">**근접 기반 배포:** 테 넌 트 사용자의 명확한 매핑 사용 하 여 다중 테 넌 트 응용 프로그램-에-지역 hello 다중 지역 클러스터의 낮은 대기 시간이 있었습니다 될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="3186f-197">**Proximity based deployment:** Multi-tenant applications, with clear mapping of tenant users -to-region, can be benefited by hello multi-region cluster’s low latencies.</span></span> <span data-ttu-id="3186f-198">예를 들어 학습 관리 교육 기관에 대 한 시스템에서 미국 동부 및 미국 서 부 지역 tooserve hello 해당 캠퍼스에 대 한 분산된 클러스터를 배포할 수 분석 뿐만 아니라 트랜잭션.</span><span class="sxs-lookup"><span data-stu-id="3186f-198">For example a learning management systems for educational institutions can deploy a distributed cluster in East US and West US regions tooserve hello respective campuses for transactional as well as analytics.</span></span> <span data-ttu-id="3186f-199">hello 데이터 hello 시간 읽기 및 쓰기에 로컬로 일관 된 수 있으며 두 hello 영역 간에 결국 일치 될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="3186f-199">hello data can be locally consistent at hello time reads and writes and can be eventually consistent across both hello regions.</span></span> <span data-ttu-id="3186f-200">미디어 배포, 전자 상거래와 같은 다른 예제는 없으며, 지역 관련 사용자 기반을 제공하는 모든 것이 이 배포 모델에 대한 좋은 사용 사례입니다.</span><span class="sxs-lookup"><span data-stu-id="3186f-200">There are other examples like media distribution, e-commerce and anything and everything that serves geo concentrated user base is a good use case for this deployment model.</span></span>

<span data-ttu-id="3186f-201">**고가용성:** 중복성은 소프트웨어 및 하드웨어의 높은 가용성을 계산하는 핵심 요소이며 자세한 내용은 Microsoft Azure에서 신뢰할 수 있는 클라우드 시스템 구축을 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="3186f-201">**High Availability:** Redundancy is a key factor in attaining high availability of software and hardware; see Building Reliable Cloud Systems on Microsoft Azure for details.</span></span> <span data-ttu-id="3186f-202">Microsoft Azure에서 true 중복성을 얻기 위한 hello 신뢰할 수 있는 유일한 방법은 다중 지역 클러스터를 배포 하 여 것입니다.</span><span class="sxs-lookup"><span data-stu-id="3186f-202">On Microsoft Azure, hello only reliable way of achieving true redundancy is by deploying a multi-region cluster.</span></span> <span data-ttu-id="3186f-203">액티브-패시브 또는 액티브-액티브 모드에서 응용 프로그램을 배포할 수 있습니다 및 hello 지역 중 한 다운 된 경우 Azure 트래픽 관리자 트래픽 toohello 활성 영역을 리디렉션할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="3186f-203">Applications can be deployed in an active-active or active-passive mode and if one of hello regions is down, Azure Traffic Manager can redirect traffic toohello active region.</span></span>  <span data-ttu-id="3186f-204">Hello 단일 지역 배포 된 hello 가용성 99.9, 이면 두 지역 배포 일 수 99.9999 hello 수식으로 계산의 가용성: (1-(1-0.999) * (1-0.999)) * 100); 용지 대 한 자세한 내용은 위의 hello를 참조 하십시오.</span><span class="sxs-lookup"><span data-stu-id="3186f-204">With hello single region deployment, if hello availability is 99.9, a two-region deployment can attain an availability of 99.9999 computed by hello formula: (1-(1-0.999) * (1-0.999))*100); see hello above paper for details.</span></span>

<span data-ttu-id="3186f-205">**재해 복구:** 제대로 설계된 경우 다중 지역 Cassandra 클러스터는 치명적인 데이터 센터 중단을 견딜 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="3186f-205">**Disaster Recovery:** Multi-region Cassandra cluster, if properly designed, can withstand catastrophic data center outages.</span></span> <span data-ttu-id="3186f-206">하나의 영역 다운 되는 경우 hello 응용 프로그램을 배포 tooother 영역 hello 최종 사용자가 처리를 시작할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="3186f-206">If one region is down, hello application deployed tooother regions can start serving hello end users.</span></span> <span data-ttu-id="3186f-207">모든 다른 비즈니스 연속성 구현에서는 같은 hello 응용 프로그램 toobe hello 비동기 파이프라인의 hello 데이터에서 일부 데이터가 손실에 대 한 내결함성에 있습니다.</span><span class="sxs-lookup"><span data-stu-id="3186f-207">Like any other business continuity implementations, hello application has toobe tolerant for some data loss resulting from hello data in hello asynchronous pipeline.</span></span> <span data-ttu-id="3186f-208">그러나 Cassandra는 hello 복구 일반 데이터베이스 복구 프로세스에서 사용한 hello 시간 보다 훨씬 swifter.</span><span class="sxs-lookup"><span data-stu-id="3186f-208">However, Cassandra makes hello recovery much swifter than hello time taken by traditional database recovery processes.</span></span> <span data-ttu-id="3186f-209">그림 2는 각 지역에 8 개 노드가 포함 된 hello 일반적인 다중 지역 배포 모델을 보여줍니다.</span><span class="sxs-lookup"><span data-stu-id="3186f-209">Figure 2 shows hello typical multi-region deployment model with eight nodes in each region.</span></span> <span data-ttu-id="3186f-210">두 영역은 hello에 대 한 서로의 미러 이미지 대칭; 동일한 실제 디자인 hello 작업 유형 (트랜잭션 또는 분석 예:), RPO, RTO, 데이터 일관성 및 가용성 요구 사항에 따라 다릅니다.</span><span class="sxs-lookup"><span data-stu-id="3186f-210">Both regions are mirror images of each other for hello same of symmetry; real world designs depend on hello workload type (e.g. transactional or analytical), RPO, RTO, data consistency and availability requirements.</span></span>

![다중 지역 배포](./media/cassandra-nodejs/cassandra-linux2.png)

<span data-ttu-id="3186f-212">그림 2: 다중 지역 Cassandra 배포</span><span class="sxs-lookup"><span data-stu-id="3186f-212">Figure 2: Multi-region Cassandra deployment</span></span>

### <a name="network-integration"></a><span data-ttu-id="3186f-213">네트워크 통합</span><span class="sxs-lookup"><span data-stu-id="3186f-213">Network Integration</span></span>
<span data-ttu-id="3186f-214">VPN 터널을 사용 하 여 서로 통신 하는 두 지역에 있는 배포 된 tooprivate 네트워크는 가상 컴퓨터의 설정 합니다.</span><span class="sxs-lookup"><span data-stu-id="3186f-214">Sets of virtual machines deployed tooprivate networks located on two regions communicates with each other using a VPN tunnel.</span></span> <span data-ttu-id="3186f-215">hello VPN 터널 hello 네트워크 배포 프로세스 중 사용자를 프로 비전 하는 두 개의 소프트웨어 게이트웨이 연결 합니다.</span><span class="sxs-lookup"><span data-stu-id="3186f-215">hello VPN tunnel connects two software gateways provisioned during hello network deployment process.</span></span> <span data-ttu-id="3186f-216">두 지역에 "웹" 및 "데이터" 서브넷; 측면에서 비슷한 네트워크 아키텍처 Azure 네트워킹 hello 필요에 따라 많은 서브넷 만들기를 허용 하 고 네트워크 보안이 필요에 따라 Acl을 적용 합니다.</span><span class="sxs-lookup"><span data-stu-id="3186f-216">Both regions have similar network architecture in terms of “web” and “data” subnets; Azure networking allows hello creation of as many subnets as needed and apply ACLs as needed by network security.</span></span> <span data-ttu-id="3186f-217">Hello 클러스터 토폴로지를 디자인 하는 동안 간 데이터 센터 통신 대기 시간 및 hello 경제의 영향 hello 네트워크 트래픽이 필요 toobe 것으로 간주 합니다.</span><span class="sxs-lookup"><span data-stu-id="3186f-217">While designing hello cluster topology inter data center communication latency and hello economic impact of hello network traffic need toobe considered.</span></span>

### <a name="data-consistency-for-multi-data-center-deployment"></a><span data-ttu-id="3186f-218">다중 데이터 센터 배포에 대한 데이터 일관성</span><span class="sxs-lookup"><span data-stu-id="3186f-218">Data Consistency for Multi-Data Center Deployment</span></span>
<span data-ttu-id="3186f-219">배포 요구 toobe 처리량 및 가용성에 대 한 hello 클러스터 토폴로지 영향 인식 배포 됩니다.</span><span class="sxs-lookup"><span data-stu-id="3186f-219">Distributed deployments need toobe aware of hello cluster topology impact on throughput and high availability.</span></span> <span data-ttu-id="3186f-220">hello RF 및 일관성 수준이 필요 toobe 쿼럼 hello 방식에서 선택한 모든 hello 데이터 센터의 hello 가용성에 종속 되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="3186f-220">hello RF and Consistency Level need toobe selected in such way that hello quorum doesn’t depend on hello availability of all hello data centers.</span></span>
<span data-ttu-id="3186f-221">일관성 수준 (에 대 한 읽기 및 쓰기) 하면 해당 hello 로컬에 대 한 높은 일관성을는 LOCAL_QUORUM를 필요로 하는 시스템 읽기 및 쓰기 hello 로컬에서 충족 하는 노드 데이터는 비동기적으로 toohello 원격 데이터 센터 복제 합니다.</span><span class="sxs-lookup"><span data-stu-id="3186f-221">For a system that needs high consistency, a LOCAL_QUORUM for consistency level (for reads and writes) will make sure that hello local reads and writes are satisfied from hello local nodes while data is replicated asynchronously toohello remote data centers.</span></span>  <span data-ttu-id="3186f-222">표 2 hello의 뒷부분에서 설명 하는 hello 다중 지역 클러스터에 대 한 세부 정보를 작성 하는 hello 구성 요약 되어 있습니다.</span><span class="sxs-lookup"><span data-stu-id="3186f-222">Table 2 summarizes hello configuration details for hello multi-region cluster outlined later in hello write up.</span></span>

<span data-ttu-id="3186f-223">**두 지역 Cassandra 클러스터 구성**</span><span class="sxs-lookup"><span data-stu-id="3186f-223">**Two-region Cassandra cluster configuration**</span></span>

| <span data-ttu-id="3186f-224">클러스터 매개 변수</span><span class="sxs-lookup"><span data-stu-id="3186f-224">Cluster Parameter</span></span> | <span data-ttu-id="3186f-225">값</span><span class="sxs-lookup"><span data-stu-id="3186f-225">Value</span></span> | <span data-ttu-id="3186f-226">설명</span><span class="sxs-lookup"><span data-stu-id="3186f-226">Remarks</span></span> |
| --- | --- | --- |
| <span data-ttu-id="3186f-227">노드 수(N)</span><span class="sxs-lookup"><span data-stu-id="3186f-227">Number of Nodes (N)</span></span> |<span data-ttu-id="3186f-228">8 + 8</span><span class="sxs-lookup"><span data-stu-id="3186f-228">8 + 8</span></span> |<span data-ttu-id="3186f-229">총 hello 클러스터의 노드 수</span><span class="sxs-lookup"><span data-stu-id="3186f-229">Total number of nodes in hello cluster</span></span> |
| <span data-ttu-id="3186f-230">복제 계수(RF)</span><span class="sxs-lookup"><span data-stu-id="3186f-230">Replication Factor (RF)</span></span> |<span data-ttu-id="3186f-231">3</span><span class="sxs-lookup"><span data-stu-id="3186f-231">3</span></span> |<span data-ttu-id="3186f-232">지정된 행의 복제본 수</span><span class="sxs-lookup"><span data-stu-id="3186f-232">Number of replicas of a given row</span></span> |
| <span data-ttu-id="3186f-233">일관성 수준(쓰기)</span><span class="sxs-lookup"><span data-stu-id="3186f-233">Consistency Level (Write)</span></span> |<span data-ttu-id="3186f-234">LOCAL_QUORUM [(sum(RF)/2) +1) = 4] hello 수식의 hello 결과 내림</span><span class="sxs-lookup"><span data-stu-id="3186f-234">LOCAL_QUORUM [(sum(RF)/2) +1) = 4] hello result of hello formula is rounded down</span></span> |<span data-ttu-id="3186f-235">노드 2 개 쓸 toohello 첫 번째 데이터 센터 hello 추가 2 노드 쿼럼에 필요한 쓸 비동기적으로 toohello 보조 데이터 센터입니다.</span><span class="sxs-lookup"><span data-stu-id="3186f-235">2 nodes will be written toohello first data center synchronously; hello additional 2 nodes needed for quorum will be written asynchronously toohello 2nd data center.</span></span> |
| <span data-ttu-id="3186f-236">일관성 수준(읽기)</span><span class="sxs-lookup"><span data-stu-id="3186f-236">Consistency Level (Read)</span></span> |<span data-ttu-id="3186f-237">LOCAL_QUORUM ((RF/2) + 1) = 2 hello 수식의 hello 결과 내림</span><span class="sxs-lookup"><span data-stu-id="3186f-237">LOCAL_QUORUM ((RF/2) +1) = 2 hello result of hello formula is rounded down</span></span> |<span data-ttu-id="3186f-238">하나의 영역;에서 읽기 요청을 충족 시킬 노드 2 개 hello 응답 백 toohello 클라이언트를 전송 하기 전에 읽습니다.</span><span class="sxs-lookup"><span data-stu-id="3186f-238">Read requests are satisfied from only one region; 2 nodes are read before hello response is sent back toohello client.</span></span> |
| <span data-ttu-id="3186f-239">복제 전략</span><span class="sxs-lookup"><span data-stu-id="3186f-239">Replication Strategy</span></span> |<span data-ttu-id="3186f-240">NetworkTopologyStrategy자세한 내용은 Cassandra 설명서의 [데이터 복제](http://www.datastax.com/documentation/cassandra/2.0/cassandra/architecture/architectureDataDistributeReplication_c.html) 참조</span><span class="sxs-lookup"><span data-stu-id="3186f-240">NetworkTopologyStrategy see [Data Replication](http://www.datastax.com/documentation/cassandra/2.0/cassandra/architecture/architectureDataDistributeReplication_c.html) in Cassandra documentation for more information</span></span> |<span data-ttu-id="3186f-241">Hello 배포 토폴로지를 이해 하 고 모든 hello 복제 하지 않는에서 중단 될 hello 동일한 복제본 노드에 배치 랙</span><span class="sxs-lookup"><span data-stu-id="3186f-241">Understands hello deployment topology and places replicas on nodes so that all hello replicas don’t end up on hello same rack</span></span> |
| <span data-ttu-id="3186f-242">Snitch</span><span class="sxs-lookup"><span data-stu-id="3186f-242">Snitch</span></span> |<span data-ttu-id="3186f-243">GossipingPropertyFileSnitch 자세한 내용은 Cassandra 설명서의 [Snitches](http://www.datastax.com/documentation/cassandra/2.0/cassandra/architecture/architectureSnitchesAbout_c.html) 를 참조</span><span class="sxs-lookup"><span data-stu-id="3186f-243">GossipingPropertyFileSnitch see [Snitches](http://www.datastax.com/documentation/cassandra/2.0/cassandra/architecture/architectureSnitchesAbout_c.html) in Cassandra documentation for more information</span></span> |<span data-ttu-id="3186f-244">NetworkTopologyStrategy는 경찰관 toounderstand hello 토폴로지의 개념을 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="3186f-244">NetworkTopologyStrategy uses a concept of snitch toounderstand hello topology.</span></span> <span data-ttu-id="3186f-245">GossipingPropertyFileSnitch 각 노드 toodata 중심과 랙 매핑에 효율적으로 제어를 제공 합니다.</span><span class="sxs-lookup"><span data-stu-id="3186f-245">GossipingPropertyFileSnitch gives better control in mapping each node toodata center and rack.</span></span> <span data-ttu-id="3186f-246">hello 클러스터는 다음 여러 toopropagate이이 정보가 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="3186f-246">hello cluster then uses gossip toopropagate this information.</span></span> <span data-ttu-id="3186f-247">동적 IP 설정 상대 tooPropertyFileSnitch에 훨씬 더 간단입니다.</span><span class="sxs-lookup"><span data-stu-id="3186f-247">This is much simpler in dynamic IP setting relative tooPropertyFileSnitch</span></span> |

## <a name="hello-software-configuration"></a><span data-ttu-id="3186f-248">hello 소프트웨어 구성</span><span class="sxs-lookup"><span data-stu-id="3186f-248">hello SOFTWARE CONFIGURATION</span></span>
<span data-ttu-id="3186f-249">다음 소프트웨어 버전 hello hello 배포 하는 동안 사용 됩니다.</span><span class="sxs-lookup"><span data-stu-id="3186f-249">hello following software versions are used during hello deployment:</span></span>

<table>
<tr><th><span data-ttu-id="3186f-250">소프트웨어</span><span class="sxs-lookup"><span data-stu-id="3186f-250">Software</span></span></th><th><span data-ttu-id="3186f-251">원본</span><span class="sxs-lookup"><span data-stu-id="3186f-251">Source</span></span></th><th><span data-ttu-id="3186f-252">버전</span><span class="sxs-lookup"><span data-stu-id="3186f-252">Version</span></span></th></tr>
<tr><td><span data-ttu-id="3186f-253">JRE</span><span class="sxs-lookup"><span data-stu-id="3186f-253">JRE</span></span>    </td><td><span data-ttu-id="3186f-254">[JRE 8](http://www.oracle.com/technetwork/java/javase/downloads/server-jre8-downloads-2133154.html) </span><span class="sxs-lookup"><span data-stu-id="3186f-254">[JRE 8](http://www.oracle.com/technetwork/java/javase/downloads/server-jre8-downloads-2133154.html) </span></span></td><td><span data-ttu-id="3186f-255">8U5</span><span class="sxs-lookup"><span data-stu-id="3186f-255">8U5</span></span></td></tr>
<tr><td><span data-ttu-id="3186f-256">JNA</span><span class="sxs-lookup"><span data-stu-id="3186f-256">JNA</span></span>    </td><td><span data-ttu-id="3186f-257">[JNA](https://github.com/twall/jna) </span><span class="sxs-lookup"><span data-stu-id="3186f-257">[JNA](https://github.com/twall/jna) </span></span></td><td> <span data-ttu-id="3186f-258">3.2.7</span><span class="sxs-lookup"><span data-stu-id="3186f-258">3.2.7</span></span></td></tr>
<tr><td><span data-ttu-id="3186f-259">Cassandra</span><span class="sxs-lookup"><span data-stu-id="3186f-259">Cassandra</span></span></td><td>[<span data-ttu-id="3186f-260">Apache Cassandra 2.0.8</span><span class="sxs-lookup"><span data-stu-id="3186f-260">Apache Cassandra 2.0.8</span></span>](http://www.apache.org/dist/cassandra/2.0.8/apache-cassandra-2.0.8-bin.tar.gz)</td><td> <span data-ttu-id="3186f-261">2.0.8</span><span class="sxs-lookup"><span data-stu-id="3186f-261">2.0.8</span></span></td></tr>
<tr><td><span data-ttu-id="3186f-262">Ubuntu</span><span class="sxs-lookup"><span data-stu-id="3186f-262">Ubuntu</span></span>    </td><td><span data-ttu-id="3186f-263">[Microsoft Azure](https://azure.microsoft.com/) </span><span class="sxs-lookup"><span data-stu-id="3186f-263">[Microsoft Azure](https://azure.microsoft.com/) </span></span></td><td><span data-ttu-id="3186f-264">14.04 LTS</span><span class="sxs-lookup"><span data-stu-id="3186f-264">14.04 LTS</span></span></td></tr>
</table>

<span data-ttu-id="3186f-265">이후 Oracle 라이선스, toosimplify hello 배포, 다운로드를 수행 하려면 먼저 toohello 클러스터 만드는데 hello Ubuntu 템플릿 이미지를 나중에 업로드 하기 위한 필수 소프트웨어 toohello 데스크톱 hello 모든 수동 승인의 JRE 다운로드. 배포 합니다.</span><span class="sxs-lookup"><span data-stu-id="3186f-265">Since downloading of JRE requires manual acceptance of Oracle license, toosimplify hello deployment, download all hello required software toohello desktop for later uploading into hello Ubuntu template image we will be creating as a precursor toohello cluster deployment.</span></span>

<span data-ttu-id="3186f-266">Hello 로컬 컴퓨터에 다운로드 잘 알려진 디렉터리 (예: Windows에서 %TEMP%/downloads 또는 대부분의 Linux 배포판 또는 Mac에서 ~/Downloads)에 소프트웨어 위에 hello를 다운로드 합니다.</span><span class="sxs-lookup"><span data-stu-id="3186f-266">Download hello above software into a well-known download directory (e.g. %TEMP%/downloads on Windows or ~/Downloads on most Linux distributions or Mac) on hello local computer.</span></span>

### <a name="create-ubuntu-vm"></a><span data-ttu-id="3186f-267">UBUNTU VM 만들기</span><span class="sxs-lookup"><span data-stu-id="3186f-267">CREATE UBUNTU VM</span></span>
<span data-ttu-id="3186f-268">Hello 프로세스의이 단계에서를 만듭니다 Ubuntu 이미지 hello 필수 구성 요소 소프트웨어와 함께 hello 이미지 재사용 몇 개의 Cassandra 노드를 프로 비전에 있도록.</span><span class="sxs-lookup"><span data-stu-id="3186f-268">In this step of hello process we will create Ubuntu image with hello pre-requisite software so that hello image can be reused for provisioning several Cassandra nodes.</span></span>  

#### <a name="step-1-generate-ssh-key-pair"></a><span data-ttu-id="3186f-269">1단계: SSH 키 쌍 생성</span><span class="sxs-lookup"><span data-stu-id="3186f-269">STEP 1: Generate SSH key pair</span></span>
<span data-ttu-id="3186f-270">Azure는 DER 또는 PEM 공개 키 시간을 프로 비전 하는 hello로 인코딩된 X509 필요 합니다.</span><span class="sxs-lookup"><span data-stu-id="3186f-270">Azure needs an X509 public key that is either PEM or DER encoded at hello provisioning time.</span></span> <span data-ttu-id="3186f-271">방법에 있는 hello 지침을 사용 하 여 공개/개인 키 쌍을 생성 된 Azure에서 Linux에 SSH tooUse 합니다.</span><span class="sxs-lookup"><span data-stu-id="3186f-271">Generate a public/private key pair using hello instructions located at How tooUse SSH with Linux on Azure.</span></span> <span data-ttu-id="3186f-272">Toouse putty.exe Windows 또는 Linux에 SSH 클라이언트를 계획 해야 tooconvert hello PEM 인코딩된 puttygen.exe;를 사용 하 여 RSA 개인 키 tooPPK 형식 이 대 한 hello 지침 hello 웹 페이지의 위쪽에 있습니다.</span><span class="sxs-lookup"><span data-stu-id="3186f-272">If you plan toouse putty.exe as an SSH client either on Windows or Linux, you have tooconvert hello PEM encoded RSA private key tooPPK format using puttygen.exe; hello instructions for this can be found in hello above web page.</span></span>

#### <a name="step-2-create-ubuntu-template-vm"></a><span data-ttu-id="3186f-273">2단계: Ubuntu 템플릿 VM 만들기</span><span class="sxs-lookup"><span data-stu-id="3186f-273">STEP 2: Create Ubuntu template VM</span></span>
<span data-ttu-id="3186f-274">toocreate hello 템플릿, VM에 로그인 할 hello 순서에 따라 Azure 클래식 포털을 사용 하 여 hello: 새로 만들기, 계산, 가상 컴퓨터, 갤러리, UBUNTU, Ubuntu Server 14.04 LTS를 클릭 한 다음 hello 오른쪽 화살표를 클릭 합니다.</span><span class="sxs-lookup"><span data-stu-id="3186f-274">toocreate hello template VM, log into hello Azure classic portal and use hello following sequence: Click NEW, COMPUTE, VIRTUAL MACHINE, FROM GALLERY, UBUNTU, Ubuntu Server 14.04 LTS, and then click hello right arrow.</span></span> <span data-ttu-id="3186f-275">Linux VM을 확인 하는 toocreate 방법에 대해 설명 하는 자습서는 Linux 가상 컴퓨터 실행을 만듭니다.</span><span class="sxs-lookup"><span data-stu-id="3186f-275">For a tutorial that describes how toocreate a Linux VM, see Create a Virtual Machine Running Linux.</span></span>

<span data-ttu-id="3186f-276">Hello #1 "가상 컴퓨터 구성" hello 화면에 다음 정보를 입력 합니다.</span><span class="sxs-lookup"><span data-stu-id="3186f-276">Enter hello following information on hello “Virtual machine configuration” screen #1:</span></span>

<table>
<tr><th><span data-ttu-id="3186f-277">필드 이름</span><span class="sxs-lookup"><span data-stu-id="3186f-277">FIELD NAME</span></span>              </td><td>       <span data-ttu-id="3186f-278">필드 값</span><span class="sxs-lookup"><span data-stu-id="3186f-278">FIELD VALUE</span></span>               </td><td>         <span data-ttu-id="3186f-279">설명</span><span class="sxs-lookup"><span data-stu-id="3186f-279">REMARKS</span></span>                </td><tr>
<tr><td><span data-ttu-id="3186f-280">버전 릴리스 날짜</span><span class="sxs-lookup"><span data-stu-id="3186f-280">VERSION RELEASE DATE</span></span>    </td><td> <span data-ttu-id="3186f-281">Hello 드롭다운 목록에서 날짜 선택</span><span class="sxs-lookup"><span data-stu-id="3186f-281">Select a date from hello drop down</span></span></td><td></td><tr>
<tr><td><span data-ttu-id="3186f-282">가상 컴퓨터 이름</span><span class="sxs-lookup"><span data-stu-id="3186f-282">VIRTUAL MACHINE NAME</span></span>    </td><td> <span data-ttu-id="3186f-283">cass-template</span><span class="sxs-lookup"><span data-stu-id="3186f-283">cass-template</span></span>                   </td><td> <span data-ttu-id="3186f-284">이 hello VM의 hello 호스트 이름</span><span class="sxs-lookup"><span data-stu-id="3186f-284">This is hello hostname of hello VM</span></span> </td><tr>
<tr><td><span data-ttu-id="3186f-285">계층</span><span class="sxs-lookup"><span data-stu-id="3186f-285">TIER</span></span>                     </td><td> <span data-ttu-id="3186f-286">표준</span><span class="sxs-lookup"><span data-stu-id="3186f-286">STANDARD</span></span>                           </td><td> <span data-ttu-id="3186f-287">Hello 기본값을 사용</span><span class="sxs-lookup"><span data-stu-id="3186f-287">Leave hello default</span></span>              </td><tr>
<tr><td><span data-ttu-id="3186f-288">크기</span><span class="sxs-lookup"><span data-stu-id="3186f-288">SIZE</span></span>                     </td><td> <span data-ttu-id="3186f-289">A1</span><span class="sxs-lookup"><span data-stu-id="3186f-289">A1</span></span>                              </td><td><span data-ttu-id="3186f-290">Hello IO 기준으로 VM 선택 hello 요구를 이 목적 hello 기본값을 그대로 둡니다.</span><span class="sxs-lookup"><span data-stu-id="3186f-290">Select hello VM based on hello IO needs; for this purpose leave hello default</span></span> </td><tr>
<tr><td> <span data-ttu-id="3186f-291">새 사용자 이름</span><span class="sxs-lookup"><span data-stu-id="3186f-291">NEW USER NAME</span></span>             </td><td> <span data-ttu-id="3186f-292">localadmin</span><span class="sxs-lookup"><span data-stu-id="3186f-292">localadmin</span></span>                       </td><td> <span data-ttu-id="3186f-293">"admin"은 Ubuntu 12.xx 이상에서 예약된 사용자 이름입니다.</span><span class="sxs-lookup"><span data-stu-id="3186f-293">"admin" is a reserved user name in Ubuntu 12.xx and after</span></span></td><tr>
<tr><td> <span data-ttu-id="3186f-294">인증</span><span class="sxs-lookup"><span data-stu-id="3186f-294">AUTHENTICATION</span></span>         </td><td> <span data-ttu-id="3186f-295">확인란을 클릭합니다.</span><span class="sxs-lookup"><span data-stu-id="3186f-295">Click check box</span></span>                 </td><td><span data-ttu-id="3186f-296">SSH 키를 가진 toosecure 원하면 선택</span><span class="sxs-lookup"><span data-stu-id="3186f-296">Check if you want toosecure with an SSH key</span></span> </td><tr>
<tr><td> <span data-ttu-id="3186f-297">인증서</span><span class="sxs-lookup"><span data-stu-id="3186f-297">CERTIFICATE</span></span>             </td><td> <span data-ttu-id="3186f-298">hello 공개 키 인증서의 파일 이름</span><span class="sxs-lookup"><span data-stu-id="3186f-298">file name of hello public key certificate</span></span> </td><td> <span data-ttu-id="3186f-299">이전에 생성 된 hello 공개 키를 사용 하 여</span><span class="sxs-lookup"><span data-stu-id="3186f-299">Use hello public key generated previously</span></span></td><tr>
<tr><td> <span data-ttu-id="3186f-300">새 암호</span><span class="sxs-lookup"><span data-stu-id="3186f-300">New Password</span></span>    </td><td> <span data-ttu-id="3186f-301">강력한 암호</span><span class="sxs-lookup"><span data-stu-id="3186f-301">strong password</span></span> </td><td> </td><tr>
<tr><td> <span data-ttu-id="3186f-302">암호 확인</span><span class="sxs-lookup"><span data-stu-id="3186f-302">Confirm Password</span></span>    </td><td> <span data-ttu-id="3186f-303">강력한 암호</span><span class="sxs-lookup"><span data-stu-id="3186f-303">strong password</span></span> </td><td></td><tr>
</table>

<span data-ttu-id="3186f-304">Hello "가상 컴퓨터 구성" hello 화면 # 2에서 다음 정보를 입력 합니다.</span><span class="sxs-lookup"><span data-stu-id="3186f-304">Enter hello following information on hello “Virtual machine configuration” screen #2:</span></span>

<table>
<tr><th><span data-ttu-id="3186f-305">필드 이름</span><span class="sxs-lookup"><span data-stu-id="3186f-305">FIELD NAME</span></span>             </th><th> <span data-ttu-id="3186f-306">필드 값</span><span class="sxs-lookup"><span data-stu-id="3186f-306">FIELD VALUE</span></span>                       </th><th> <span data-ttu-id="3186f-307">설명</span><span class="sxs-lookup"><span data-stu-id="3186f-307">REMARKS</span></span>                                 </th></tr>
<tr><td> <span data-ttu-id="3186f-308">클라우드 서비스</span><span class="sxs-lookup"><span data-stu-id="3186f-308">CLOUD SERVICE</span></span>    </td><td> <span data-ttu-id="3186f-309">새 클라우드 서비스 만들기</span><span class="sxs-lookup"><span data-stu-id="3186f-309">Create a new cloud service</span></span>    </td><td><span data-ttu-id="3186f-310">클라우드 서비스는 가상 컴퓨터와 같은 계산 리소스의 컨테이너입니다.</span><span class="sxs-lookup"><span data-stu-id="3186f-310">Cloud service is a container compute resources like virtual machines</span></span></td></tr>
<tr><td> <span data-ttu-id="3186f-311">클라우드 서비스 DNS 이름</span><span class="sxs-lookup"><span data-stu-id="3186f-311">CLOUD SERVICE DNS NAME</span></span>    </td><td><span data-ttu-id="3186f-312">ubuntu-template.cloudapp.net</span><span class="sxs-lookup"><span data-stu-id="3186f-312">ubuntu-template.cloudapp.net</span></span>    </td><td><span data-ttu-id="3186f-313">컴퓨터에 알 수 없는 부하 분산 장치 이름을 지정합니다.</span><span class="sxs-lookup"><span data-stu-id="3186f-313">Give a machine agnostic load balancer name</span></span></td></tr>
<tr><td> <span data-ttu-id="3186f-314">지역/선호도 그룹/가상 네트워크</span><span class="sxs-lookup"><span data-stu-id="3186f-314">REGION/AFFINITY GROUP/VIRTUAL NETWORK</span></span> </td><td>    <span data-ttu-id="3186f-315">미국 서부</span><span class="sxs-lookup"><span data-stu-id="3186f-315">West US</span></span>    </td><td> <span data-ttu-id="3186f-316">웹 응용 프로그램 올 hello Cassandra 클러스터에 액세스 한 지역을 선택합니다</span><span class="sxs-lookup"><span data-stu-id="3186f-316">Select a region from which your web applications access hello Cassandra cluster</span></span></td></tr>
<tr><td><span data-ttu-id="3186f-317">저장소 계정</span><span class="sxs-lookup"><span data-stu-id="3186f-317">STORAGE ACCOUNT</span></span> </td><td>    <span data-ttu-id="3186f-318">기본값 사용</span><span class="sxs-lookup"><span data-stu-id="3186f-318">Use default</span></span>    </td><td><span data-ttu-id="3186f-319">사용 하 여 hello 기본 저장소 계정 또는 특정 지역에서 미리 생성된 된 저장소 계정</span><span class="sxs-lookup"><span data-stu-id="3186f-319">Use hello default storage account  or a pre-created storage account in a particular region</span></span></td></tr>
<tr><td><span data-ttu-id="3186f-320">가용성 집합</span><span class="sxs-lookup"><span data-stu-id="3186f-320">AVAILABILITY SET</span></span> </td><td>    <span data-ttu-id="3186f-321">없음</span><span class="sxs-lookup"><span data-stu-id="3186f-321">None</span></span> </td><td>    <span data-ttu-id="3186f-322">비워 둡니다.</span><span class="sxs-lookup"><span data-stu-id="3186f-322">Leave it blank</span></span></td></tr>
<tr><td><span data-ttu-id="3186f-323">끝점</span><span class="sxs-lookup"><span data-stu-id="3186f-323">ENDPOINTS</span></span>    </td><td><span data-ttu-id="3186f-324">기본값 사용</span><span class="sxs-lookup"><span data-stu-id="3186f-324">Use default</span></span> </td><td>    <span data-ttu-id="3186f-325">Hello 기본 SSH 구성 사용</span><span class="sxs-lookup"><span data-stu-id="3186f-325">Use hello default SSH configuration</span></span> </td></tr>
</table>

<span data-ttu-id="3186f-326">오른쪽 화살표를 클릭 하 고 hello 화면 # 3에서 hello 기본값을 그대로 두고 hello "확인" 단추 toocomplete hello VM 프로 비전 프로세스를 클릭 합니다.</span><span class="sxs-lookup"><span data-stu-id="3186f-326">Click right arrow, leave hello defaults on hello screen #3 and click hello “check” button toocomplete hello VM provisioning process.</span></span> <span data-ttu-id="3186f-327">몇 분 후 VM 템플릿을 사용 하 여 hello 이름"ubuntu-" hello "실행 중" 상태에 있어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="3186f-327">After a few minutes, hello VM with hello name “ubuntu-template” should be in a “running” status.</span></span>

### <a name="install-hello-necessary-software"></a><span data-ttu-id="3186f-328">Hello 필요한 소프트웨어를 설치 합니다.</span><span class="sxs-lookup"><span data-stu-id="3186f-328">INSTALL hello NECESSARY SOFTWARE</span></span>
#### <a name="step-1-upload-tarballs"></a><span data-ttu-id="3186f-329">1단계: tarball 업로드</span><span class="sxs-lookup"><span data-stu-id="3186f-329">STEP 1: Upload tarballs</span></span>
<span data-ttu-id="3186f-330">Scp 또는 pscp를 사용 하 여 복사 hello 이전에 다운로드 한 소프트웨어 너무 ~ 다운로드 디렉터리 명령 형식에 따라 hello를 사용 하 여:</span><span class="sxs-lookup"><span data-stu-id="3186f-330">Using scp or pscp, copy hello previously downloaded software too~/downloads directory using hello following command format:</span></span>

##### <a name="pscp-server-jre-8u5-linux-x64targz-localadminhk-cas-templatecloudappnethomelocaladmindownloadsserver-jre-8u5-linux-x64targz"></a><span data-ttu-id="3186f-331">pscp server-jre-8u5-linux-x64.tar.gz localadmin@hk-cas-template.cloudapp.net:/home/localadmin/downloads/server-jre-8u5-linux-x64.tar.gz</span><span class="sxs-lookup"><span data-stu-id="3186f-331">pscp server-jre-8u5-linux-x64.tar.gz localadmin@hk-cas-template.cloudapp.net:/home/localadmin/downloads/server-jre-8u5-linux-x64.tar.gz</span></span>
<span data-ttu-id="3186f-332">Hello Cassandra 비트의 경우와 명령 위에 hello JRE도 반복 합니다.</span><span class="sxs-lookup"><span data-stu-id="3186f-332">Repeat hello above command for JRE as well as for hello Cassandra bits.</span></span>

#### <a name="step-2-prepare-hello-directory-structure-and-extract-hello-archives"></a><span data-ttu-id="3186f-333">2 단계: hello 디렉터리 구조를 준비 하 고 hello 아카이브를 추출 합니다.</span><span class="sxs-lookup"><span data-stu-id="3186f-333">STEP 2: Prepare hello directory structure and extract hello archives</span></span>
<span data-ttu-id="3186f-334">VM hello를 로그인 하 고 hello 디렉터리 구조를 만드는 하 고 소프트웨어 아래의 hello bash 스크립트를 사용 하는 슈퍼 사용자로 추출:</span><span class="sxs-lookup"><span data-stu-id="3186f-334">Log into hello VM and create hello directory structure and extract software as a super user using hello bash script below:</span></span>

    #!/bin/bash
    CASS_INSTALL_DIR="/opt/cassandra"
    JRE_INSTALL_DIR="/opt/java"
    CASS_DATA_DIR="/var/lib/cassandra"
    CASS_LOG_DIR="/var/log/cassandra"
    DOWNLOADS_DIR="~/downloads"
    JRE_TARBALL="server-jre-8u5-linux-x64.tar.gz"
    CASS_TARBALL="apache-cassandra-2.0.8-bin.tar.gz"
    SVC_USER="localadmin"

    RESET_ERROR=1
    MKDIR_ERROR=2

    reset_installation ()
    {
       rm -rf $CASS_INSTALL_DIR 2> /dev/null
       rm -rf $JRE_INSTALL_DIR 2> /dev/null
       rm -rf $CASS_DATA_DIR 2> /dev/null
       rm -rf $CASS_LOG_DIR 2> /dev/null
    }
    make_dir ()
    {
       if [ -z "$1" ]
       then
          echo "make_dir: invalid directory name"
          exit $MKDIR_ERROR
       fi

       if [ -d "$1" ]
       then
          echo "make_dir: directory already exists"
          exit $MKDIR_ERROR
       fi

       mkdir $1 2>/dev/null
       if [ $? != 0 ]
       then
          echo "directory creation failed"
          exit $MKDIR_ERROR
       fi
    }

    unzip()
    {
       if [ $# == 2 ]
       then
          tar xzf $1 -C $2
       else
          echo "archive error"
       fi

    }

    if [ -n "$1" ]
    then
       SVC_USER=$1
    fi

    reset_installation
    make_dir $CASS_INSTALL_DIR
    make_dir $JRE_INSTALL_DIR
    make_dir $CASS_DATA_DIR
    make_dir $CASS_LOG_DIR

    #unzip JRE and Cassandra
    unzip $HOME/downloads/$JRE_TARBALL $JRE_INSTALL_DIR
    unzip $HOME/downloads/$CASS_TARBALL $CASS_INSTALL_DIR

    #Change hello ownership toohello service credentials

    chown -R $SVC_USER:$GROUP $CASS_DATA_DIR
    chown -R $SVC_USER:$GROUP $CASS_LOG_DIR
    echo "edit /etc/profile tooadd JRE toohello PATH"
    echo "installation is complete"


<span data-ttu-id="3186f-335">Vim 창에이 스크립트를 붙여 확인 되었는지 tooremove hello 캐리지 반환 ('\r ") hello 다음 명령을 사용 하 여:</span><span class="sxs-lookup"><span data-stu-id="3186f-335">If you paste this script into vim window, make sure tooremove hello carriage return (‘\r”) using hello following command:</span></span>

    tr -d '\r' <infile.sh >outfile.sh

#### <a name="step-3-edit-etcprofile"></a><span data-ttu-id="3186f-336">3단계: etc/profile 편집</span><span class="sxs-lookup"><span data-stu-id="3186f-336">Step 3: Edit etc/profile</span></span>
<span data-ttu-id="3186f-337">Hello 다음 hello 끝에 추가 합니다.</span><span class="sxs-lookup"><span data-stu-id="3186f-337">Append hello following at hello end:</span></span>

    JAVA_HOME=/opt/java/jdk1.8.0_05
    CASS_HOME= /opt/cassandra/apache-cassandra-2.0.8
    PATH=$PATH:$HOME/bin:$JAVA_HOME/bin:$CASS_HOME/bin
    export JAVA_HOME
    export CASS_HOME
    export PATH

#### <a name="step-4-install-jna-for-production-systems"></a><span data-ttu-id="3186f-338">4단계: 프로덕션 시스템용 JNA 설치</span><span class="sxs-lookup"><span data-stu-id="3186f-338">Step 4: Install JNA for production systems</span></span>
<span data-ttu-id="3186f-339">사용 하 여 hello 다음 시퀀스 명령은: hello 다음 명령은 설치 jna 3.2.7.jar 및 jna-플랫폼-3.2.7.jar too/usr/share.java 디렉터리 sudo apt-get libjna-java 설치 합니다</span><span class="sxs-lookup"><span data-stu-id="3186f-339">Use hello following command sequence: hello following command will install jna-3.2.7.jar and jna-platform-3.2.7.jar too/usr/share.java directory sudo apt-get install libjna-java</span></span>

<span data-ttu-id="3186f-340">Cassandra 시작 스크립트에서 이러한 jar을 찾을 수 있도록 $CASS_HOME/lib 디렉터리에 바로 가기 링크를 만듭니다.</span><span class="sxs-lookup"><span data-stu-id="3186f-340">Create symbolic links in $CASS_HOME/lib directory so that Cassandra startup script can find these jars:</span></span>

    ln -s /usr/share/java/jna-3.2.7.jar $CASS_HOME/lib/jna.jar

    ln -s /usr/share/java/jna-platform-3.2.7.jar $CASS_HOME/lib/jna-platform.jar

#### <a name="step-5-configure-cassandrayaml"></a><span data-ttu-id="3186f-341">5단계: cassandra.yaml 구성</span><span class="sxs-lookup"><span data-stu-id="3186f-341">Step 5: Configure cassandra.yaml</span></span>
<span data-ttu-id="3186f-342">[우리는 조정이 hello 실제 프로 비전 하는 동안] 모든 hello 가상 컴퓨터에 필요한 각 VM tooreflect 구성에서 cassandra.yaml를 편집 합니다.</span><span class="sxs-lookup"><span data-stu-id="3186f-342">Edit cassandra.yaml on each VM tooreflect configuration needed by all hello virtual machines [we will tweak this during hello actual provisioning]:</span></span>

<table>
<tr><th><span data-ttu-id="3186f-343">필드 이름</span><span class="sxs-lookup"><span data-stu-id="3186f-343">Field Name</span></span>   </th><th> <span data-ttu-id="3186f-344">값</span><span class="sxs-lookup"><span data-stu-id="3186f-344">Value</span></span>  </th><th>    <span data-ttu-id="3186f-345">설명</span><span class="sxs-lookup"><span data-stu-id="3186f-345">Remarks</span></span> </th></tr>
<tr><td><span data-ttu-id="3186f-346">cluster_name</span><span class="sxs-lookup"><span data-stu-id="3186f-346">cluster_name</span></span> </td><td>    <span data-ttu-id="3186f-347">"CustomerService"</span><span class="sxs-lookup"><span data-stu-id="3186f-347">“CustomerService”</span></span>    </td><td> <span data-ttu-id="3186f-348">배포를 반영 하는 hello 이름 사용</span><span class="sxs-lookup"><span data-stu-id="3186f-348">Use hello name that reflects your deployment</span></span></td></tr>
<tr><td><span data-ttu-id="3186f-349">listen_address</span><span class="sxs-lookup"><span data-stu-id="3186f-349">listen_address</span></span>    </td><td><span data-ttu-id="3186f-350">[비워 둠]</span><span class="sxs-lookup"><span data-stu-id="3186f-350">[leave it blank]</span></span>    </td><td> <span data-ttu-id="3186f-351">"localhost"를 삭제합니다.</span><span class="sxs-lookup"><span data-stu-id="3186f-351">Delete “localhost”</span></span> </td></tr>
<tr><td><span data-ttu-id="3186f-352">rpc_addres</span><span class="sxs-lookup"><span data-stu-id="3186f-352">rpc_addres</span></span>   </td><td><span data-ttu-id="3186f-353">[비워 둠]</span><span class="sxs-lookup"><span data-stu-id="3186f-353">[leave it blank]</span></span>    </td><td> <span data-ttu-id="3186f-354">"localhost"를 삭제합니다.</span><span class="sxs-lookup"><span data-stu-id="3186f-354">Delete “localhost”</span></span> </td></tr>
<tr><td><span data-ttu-id="3186f-355">seeds</span><span class="sxs-lookup"><span data-stu-id="3186f-355">seeds</span></span>    </td><td><span data-ttu-id="3186f-356">"10.1.2.4, 10.1.2.6, 10.1.2.8"</span><span class="sxs-lookup"><span data-stu-id="3186f-356">"10.1.2.4, 10.1.2.6, 10.1.2.8"</span></span>    </td><td><span data-ttu-id="3186f-357">초기값으로 지정 된 모든 hello IP 주소 목록입니다.</span><span class="sxs-lookup"><span data-stu-id="3186f-357">List of  all hello IP addresses which are designated as seeds.</span></span></td></tr>
<tr><td><span data-ttu-id="3186f-358">endpoint_snitch</span><span class="sxs-lookup"><span data-stu-id="3186f-358">endpoint_snitch</span></span> </td><td> <span data-ttu-id="3186f-359">org.apache.cassandra.locator.GossipingPropertyFileSnitch</span><span class="sxs-lookup"><span data-stu-id="3186f-359">org.apache.cassandra.locator.GossipingPropertyFileSnitch</span></span> </td><td> <span data-ttu-id="3186f-360">이 사용 됩니다 hello NetworkTopologyStrateg 유추 hello 데이터 센터 및 hello VM의 hello 랙</span><span class="sxs-lookup"><span data-stu-id="3186f-360">This is used by hello NetworkTopologyStrateg for inferring hello data center and hello rack of hello VM</span></span></td></tr>
</table>

#### <a name="step-6-capture-hello-vm-image"></a><span data-ttu-id="3186f-361">6 단계: hello VM 이미지 캡처</span><span class="sxs-lookup"><span data-stu-id="3186f-361">Step 6: Capture hello VM image</span></span>
<span data-ttu-id="3186f-362">Hello 호스트 이름 (hk cas template.cloudapp.net) 및 이전에 만든 hello SSH 개인 키를 사용 하 여 hello 가상 컴퓨터에 로그인 합니다.</span><span class="sxs-lookup"><span data-stu-id="3186f-362">Log into hello virtual machine using hello hostname (hk-cas-template.cloudapp.net) and hello SSH private key previously created.</span></span> <span data-ttu-id="3186f-363">참조 방식을 사용 하 여 toolog hello 명령 ssh 또는 putty.exe tooUse SSH에 대 한 Azure에서 Linux와 함께 자세히 설명 하는 방법입니다.</span><span class="sxs-lookup"><span data-stu-id="3186f-363">See How tooUse SSH with Linux on Azure for details on how toolog in using hello command ssh or putty.exe.</span></span>

<span data-ttu-id="3186f-364">Hello toocapture hello 이미지 작업의 시퀀스를 따라를 실행 합니다.</span><span class="sxs-lookup"><span data-stu-id="3186f-364">Execute hello following sequence of actions toocapture hello image:</span></span>

##### <a name="1-deprovision"></a><span data-ttu-id="3186f-365">1. 프로비전 해제</span><span class="sxs-lookup"><span data-stu-id="3186f-365">1. Deprovision</span></span>
<span data-ttu-id="3186f-366">Hello 명령을 사용 하 여 "sudo waagent-deprovision + 사용자" tooremove 가상 컴퓨터 인스턴스 관련 정보입니다.</span><span class="sxs-lookup"><span data-stu-id="3186f-366">Use hello command “sudo waagent –deprovision+user” tooremove Virtual Machine instance specific information.</span></span> <span data-ttu-id="3186f-367">에 대 한 참조 [어떻게 tooCapture Linux 가상 컴퓨터를](capture-image.md) 템플릿으로 tooUse hello 이미지 캡처 프로세스에서 더 자세히 설명 합니다.</span><span class="sxs-lookup"><span data-stu-id="3186f-367">See for [How tooCapture a Linux Virtual Machine](capture-image.md) tooUse as a Template more details on hello image capture process.</span></span>

##### <a name="2-shutdown-hello-vm"></a><span data-ttu-id="3186f-368">2: 종료 hello VM</span><span class="sxs-lookup"><span data-stu-id="3186f-368">2: Shutdown hello VM</span></span>
<span data-ttu-id="3186f-369">Hello 가상 컴퓨터 선택 되었는지 확인 하 고 hello 맨 아래 명령 모음에서 hello 종료 링크를 클릭 합니다.</span><span class="sxs-lookup"><span data-stu-id="3186f-369">Make sure that hello virtual machine is highlighted and click hello SHUTDOWN link from hello bottom command bar.</span></span>

##### <a name="3-capture-hello-image"></a><span data-ttu-id="3186f-370">3: hello 이미지 캡처</span><span class="sxs-lookup"><span data-stu-id="3186f-370">3: Capture hello image</span></span>
<span data-ttu-id="3186f-371">Hello 가상 컴퓨터 선택 되었는지 확인 하 고 hello 맨 아래 명령 모음에서 hello 캡처 링크를 클릭 합니다.</span><span class="sxs-lookup"><span data-stu-id="3186f-371">Make sure that hello virtual machine is highlighted and click hello CAPTURE link from hello bottom command bar.</span></span> <span data-ttu-id="3186f-372">Hello 다음 화면 (예: hk-cas-2-08-ub-14-04-2014071) 이미지 이름을 지정 하 고 이미지 설명 적절 한 hello "검사" 표시 toofinish hello 캡처 프로세스를 클릭 합니다.</span><span class="sxs-lookup"><span data-stu-id="3186f-372">In hello next screen, give an IMAGE NAME (e.g. hk-cas-2-08-ub-14-04-2014071), appropriate IMAGE DESCRIPTION, and click hello “check” mark toofinish hello CAPTURE process.</span></span>

<span data-ttu-id="3186f-373">몇 초 정도 걸립니다 및 hello 이미지 hello 이미지 갤러리의 이미지 내 이미지 섹션에서 사용할 수 있어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="3186f-373">This will take a few seconds and hello image should be available in MY IMAGES section of hello image gallery.</span></span> <span data-ttu-id="3186f-374">hello 이미지는 성공적으로 캡처되면 hello 원본 VM을 자동으로 삭제 됩니다.</span><span class="sxs-lookup"><span data-stu-id="3186f-374">hello source VM will be automatically deleted after hello image is successfully captured.</span></span> 

## <a name="single-region-deployment-process"></a><span data-ttu-id="3186f-375">단일 지역 배포 프로세스</span><span class="sxs-lookup"><span data-stu-id="3186f-375">Single Region Deployment Process</span></span>
<span data-ttu-id="3186f-376">**1 단계: hello 가상 네트워크 만들기** Azure 포털 hello에 로그인 하 고 가상 네트워크 만들기 (클래식) hello 특성으로 다음 표에 hello에 표시 된 것입니다.</span><span class="sxs-lookup"><span data-stu-id="3186f-376">**Step 1: Create hello Virtual Network** Log into hello Azure portal and create a virtual network (classic) with hello attributes shown in hello following table.</span></span> <span data-ttu-id="3186f-377">참조 [hello Azure 포털을 사용 하 여 가상 네트워크 (클래식) 만들기](../../../virtual-network/virtual-networks-create-vnet-classic-pportal.md) hello 프로세스의 자세한 단계입니다.</span><span class="sxs-lookup"><span data-stu-id="3186f-377">See [Create a virtual network (classic) using hello Azure portal](../../../virtual-network/virtual-networks-create-vnet-classic-pportal.md) for detailed steps of hello process.</span></span>      

<table>
<tr><th><span data-ttu-id="3186f-378">VM 특성 이름</span><span class="sxs-lookup"><span data-stu-id="3186f-378">VM Attribute Name</span></span></th><th><span data-ttu-id="3186f-379">값</span><span class="sxs-lookup"><span data-stu-id="3186f-379">Value</span></span></th><th><span data-ttu-id="3186f-380">설명</span><span class="sxs-lookup"><span data-stu-id="3186f-380">Remarks</span></span></th></tr>
<tr><td><span data-ttu-id="3186f-381">이름</span><span class="sxs-lookup"><span data-stu-id="3186f-381">Name</span></span></td><td><span data-ttu-id="3186f-382">vnet-cass-west-us</span><span class="sxs-lookup"><span data-stu-id="3186f-382">vnet-cass-west-us</span></span></td><td></td></tr>
<tr><td><span data-ttu-id="3186f-383">지역</span><span class="sxs-lookup"><span data-stu-id="3186f-383">Region</span></span></td><td><span data-ttu-id="3186f-384">미국 서부</span><span class="sxs-lookup"><span data-stu-id="3186f-384">West US</span></span></td><td></td></tr>
<tr><td><span data-ttu-id="3186f-385">DNS 서버</span><span class="sxs-lookup"><span data-stu-id="3186f-385">DNS Servers</span></span></td><td><span data-ttu-id="3186f-386">없음</span><span class="sxs-lookup"><span data-stu-id="3186f-386">None</span></span></td><td><span data-ttu-id="3186f-387">DNS 서버를 사용하지 않으므로 이 특성을 무시합니다.</span><span class="sxs-lookup"><span data-stu-id="3186f-387">Ignore this as we are not using a DNS Server</span></span></td></tr>
<tr><td><span data-ttu-id="3186f-388">주소 공간</span><span class="sxs-lookup"><span data-stu-id="3186f-388">Address Space</span></span></td><td><span data-ttu-id="3186f-389">10.1.0.0/16</span><span class="sxs-lookup"><span data-stu-id="3186f-389">10.1.0.0/16</span></span></td><td></td></tr>    
<tr><td><span data-ttu-id="3186f-390">시작 IP</span><span class="sxs-lookup"><span data-stu-id="3186f-390">Starting IP</span></span></td><td><span data-ttu-id="3186f-391">10.1.0.0</span><span class="sxs-lookup"><span data-stu-id="3186f-391">10.1.0.0</span></span></td><td></td></tr>    
<tr><td><span data-ttu-id="3186f-392">CIDR</span><span class="sxs-lookup"><span data-stu-id="3186f-392">CIDR</span></span> </td><td><span data-ttu-id="3186f-393">/16 (65531)</span><span class="sxs-lookup"><span data-stu-id="3186f-393">/16 (65531)</span></span></td><td></td></tr>
</table>

<span data-ttu-id="3186f-394">Hello 다음 서브넷을 추가 합니다.</span><span class="sxs-lookup"><span data-stu-id="3186f-394">Add hello following subnets:</span></span>

<table>
<tr><th><span data-ttu-id="3186f-395">이름</span><span class="sxs-lookup"><span data-stu-id="3186f-395">Name</span></span></th><th><span data-ttu-id="3186f-396">시작 IP</span><span class="sxs-lookup"><span data-stu-id="3186f-396">Starting IP</span></span></th><th><span data-ttu-id="3186f-397">CIDR</span><span class="sxs-lookup"><span data-stu-id="3186f-397">CIDR</span></span></th><th><span data-ttu-id="3186f-398">설명</span><span class="sxs-lookup"><span data-stu-id="3186f-398">Remarks</span></span></th></tr>
<tr><td><span data-ttu-id="3186f-399">web</span><span class="sxs-lookup"><span data-stu-id="3186f-399">web</span></span></td><td><span data-ttu-id="3186f-400">10.1.1.0</span><span class="sxs-lookup"><span data-stu-id="3186f-400">10.1.1.0</span></span></td><td><span data-ttu-id="3186f-401">/24 (251)</span><span class="sxs-lookup"><span data-stu-id="3186f-401">/24 (251)</span></span></td><td><span data-ttu-id="3186f-402">Hello 웹 팜에 대 한 서브넷</span><span class="sxs-lookup"><span data-stu-id="3186f-402">Subnet for hello web farm</span></span></td></tr>
<tr><td><span data-ttu-id="3186f-403">데이터</span><span class="sxs-lookup"><span data-stu-id="3186f-403">data</span></span></td><td><span data-ttu-id="3186f-404">10.1.2.0</span><span class="sxs-lookup"><span data-stu-id="3186f-404">10.1.2.0</span></span></td><td><span data-ttu-id="3186f-405">/24 (251)</span><span class="sxs-lookup"><span data-stu-id="3186f-405">/24 (251)</span></span></td><td><span data-ttu-id="3186f-406">데이터베이스 노드 hello에 대 한 서브넷</span><span class="sxs-lookup"><span data-stu-id="3186f-406">Subnet for hello database nodes</span></span></td></tr>
</table>

<span data-ttu-id="3186f-407">데이터 및 웹 서브넷 보호할 수 있습니다 네트워크 보안 그룹을 통해 hello 검사는이 문서에 대 한 범위를 벗어났습니다.</span><span class="sxs-lookup"><span data-stu-id="3186f-407">Data and Web subnets can be protected through network security groups hello coverage of which is out of scope for this article.</span></span>  

<span data-ttu-id="3186f-408">**가상 컴퓨터를 프로 비전 하는 2 단계:** 이전에 만든 hello 이미지를 사용 하 여 hello 클라우드의 가상 컴퓨터를 다음 hello 서버 "hk-c-svc-서" 만들어져 아래와 같이 toohello 해당 하는 서브넷 바인딩합니다.</span><span class="sxs-lookup"><span data-stu-id="3186f-408">**Step 2: Provision Virtual Machines** Using hello image created previously, we will create hello following virtual machines in hello cloud server “hk-c-svc-west” and bind them toohello respective subnets as shown below:</span></span>

<table>
<tr><th><span data-ttu-id="3186f-409">컴퓨터 이름</span><span class="sxs-lookup"><span data-stu-id="3186f-409">Machine Name</span></span>    </th><th><span data-ttu-id="3186f-410">서브넷</span><span class="sxs-lookup"><span data-stu-id="3186f-410">Subnet</span></span>    </th><th><span data-ttu-id="3186f-411">IP 주소</span><span class="sxs-lookup"><span data-stu-id="3186f-411">IP Address</span></span>    </th><th><span data-ttu-id="3186f-412">가용성 집합</span><span class="sxs-lookup"><span data-stu-id="3186f-412">Availability set</span></span></th><th><span data-ttu-id="3186f-413">DC/랙</span><span class="sxs-lookup"><span data-stu-id="3186f-413">DC/Rack</span></span></th><th><span data-ttu-id="3186f-414">시드 여부</span><span class="sxs-lookup"><span data-stu-id="3186f-414">Seed?</span></span></th></tr>
<tr><td><span data-ttu-id="3186f-415">hk-c1-west-us</span><span class="sxs-lookup"><span data-stu-id="3186f-415">hk-c1-west-us</span></span>    </td><td><span data-ttu-id="3186f-416">데이터</span><span class="sxs-lookup"><span data-stu-id="3186f-416">data</span></span>    </td><td><span data-ttu-id="3186f-417">10.1.2.4</span><span class="sxs-lookup"><span data-stu-id="3186f-417">10.1.2.4</span></span>    </td><td><span data-ttu-id="3186f-418">hk-c-aset-1</span><span class="sxs-lookup"><span data-stu-id="3186f-418">hk-c-aset-1</span></span>    </td><td><span data-ttu-id="3186f-419">dc =WESTUS rack =rack1</span><span class="sxs-lookup"><span data-stu-id="3186f-419">dc =WESTUS rack =rack1</span></span> </td><td><span data-ttu-id="3186f-420">예</span><span class="sxs-lookup"><span data-stu-id="3186f-420">Yes</span></span></td></tr>
<tr><td><span data-ttu-id="3186f-421">hk-c2-west-us</span><span class="sxs-lookup"><span data-stu-id="3186f-421">hk-c2-west-us</span></span>    </td><td><span data-ttu-id="3186f-422">데이터</span><span class="sxs-lookup"><span data-stu-id="3186f-422">data</span></span>    </td><td><span data-ttu-id="3186f-423">10.1.2.5</span><span class="sxs-lookup"><span data-stu-id="3186f-423">10.1.2.5</span></span>    </td><td><span data-ttu-id="3186f-424">hk-c-aset-1</span><span class="sxs-lookup"><span data-stu-id="3186f-424">hk-c-aset-1</span></span>    </td><td><span data-ttu-id="3186f-425">dc =WESTUS rack =rack1</span><span class="sxs-lookup"><span data-stu-id="3186f-425">dc =WESTUS rack =rack1</span></span>    </td><td><span data-ttu-id="3186f-426">아니요</span><span class="sxs-lookup"><span data-stu-id="3186f-426">No</span></span> </td></tr>
<tr><td><span data-ttu-id="3186f-427">hk-c3-west-us</span><span class="sxs-lookup"><span data-stu-id="3186f-427">hk-c3-west-us</span></span>    </td><td><span data-ttu-id="3186f-428">데이터</span><span class="sxs-lookup"><span data-stu-id="3186f-428">data</span></span>    </td><td><span data-ttu-id="3186f-429">10.1.2.6</span><span class="sxs-lookup"><span data-stu-id="3186f-429">10.1.2.6</span></span>    </td><td><span data-ttu-id="3186f-430">hk-c-aset-1</span><span class="sxs-lookup"><span data-stu-id="3186f-430">hk-c-aset-1</span></span>    </td><td><span data-ttu-id="3186f-431">dc =WESTUS rack =rack2</span><span class="sxs-lookup"><span data-stu-id="3186f-431">dc =WESTUS rack =rack2</span></span>    </td><td><span data-ttu-id="3186f-432">예</span><span class="sxs-lookup"><span data-stu-id="3186f-432">Yes</span></span></td></tr>
<tr><td><span data-ttu-id="3186f-433">hk-c4-west-us</span><span class="sxs-lookup"><span data-stu-id="3186f-433">hk-c4-west-us</span></span>    </td><td><span data-ttu-id="3186f-434">데이터</span><span class="sxs-lookup"><span data-stu-id="3186f-434">data</span></span>    </td><td><span data-ttu-id="3186f-435">10.1.2.7</span><span class="sxs-lookup"><span data-stu-id="3186f-435">10.1.2.7</span></span>    </td><td><span data-ttu-id="3186f-436">hk-c-aset-1</span><span class="sxs-lookup"><span data-stu-id="3186f-436">hk-c-aset-1</span></span>    </td><td><span data-ttu-id="3186f-437">dc =WESTUS rack =rack2</span><span class="sxs-lookup"><span data-stu-id="3186f-437">dc =WESTUS rack =rack2</span></span>    </td><td><span data-ttu-id="3186f-438">아니요</span><span class="sxs-lookup"><span data-stu-id="3186f-438">No</span></span> </td></tr>
<tr><td><span data-ttu-id="3186f-439">hk-c5-west-us</span><span class="sxs-lookup"><span data-stu-id="3186f-439">hk-c5-west-us</span></span>    </td><td><span data-ttu-id="3186f-440">데이터</span><span class="sxs-lookup"><span data-stu-id="3186f-440">data</span></span>    </td><td><span data-ttu-id="3186f-441">10.1.2.8</span><span class="sxs-lookup"><span data-stu-id="3186f-441">10.1.2.8</span></span>    </td><td><span data-ttu-id="3186f-442">hk-c-aset-2</span><span class="sxs-lookup"><span data-stu-id="3186f-442">hk-c-aset-2</span></span>    </td><td><span data-ttu-id="3186f-443">dc =WESTUS rack =rack3</span><span class="sxs-lookup"><span data-stu-id="3186f-443">dc =WESTUS rack =rack3</span></span>    </td><td><span data-ttu-id="3186f-444">예</span><span class="sxs-lookup"><span data-stu-id="3186f-444">Yes</span></span></td></tr>
<tr><td><span data-ttu-id="3186f-445">hk-c6-west-us</span><span class="sxs-lookup"><span data-stu-id="3186f-445">hk-c6-west-us</span></span>    </td><td><span data-ttu-id="3186f-446">데이터</span><span class="sxs-lookup"><span data-stu-id="3186f-446">data</span></span>    </td><td><span data-ttu-id="3186f-447">10.1.2.9</span><span class="sxs-lookup"><span data-stu-id="3186f-447">10.1.2.9</span></span>    </td><td><span data-ttu-id="3186f-448">hk-c-aset-2</span><span class="sxs-lookup"><span data-stu-id="3186f-448">hk-c-aset-2</span></span>    </td><td><span data-ttu-id="3186f-449">dc =WESTUS rack =rack3</span><span class="sxs-lookup"><span data-stu-id="3186f-449">dc =WESTUS rack =rack3</span></span>    </td><td><span data-ttu-id="3186f-450">아니요</span><span class="sxs-lookup"><span data-stu-id="3186f-450">No</span></span> </td></tr>
<tr><td><span data-ttu-id="3186f-451">hk-c7-west-us</span><span class="sxs-lookup"><span data-stu-id="3186f-451">hk-c7-west-us</span></span>    </td><td><span data-ttu-id="3186f-452">데이터</span><span class="sxs-lookup"><span data-stu-id="3186f-452">data</span></span>    </td><td><span data-ttu-id="3186f-453">10.1.2.10</span><span class="sxs-lookup"><span data-stu-id="3186f-453">10.1.2.10</span></span>    </td><td><span data-ttu-id="3186f-454">hk-c-aset-2</span><span class="sxs-lookup"><span data-stu-id="3186f-454">hk-c-aset-2</span></span>    </td><td><span data-ttu-id="3186f-455">dc =WESTUS rack =rack4</span><span class="sxs-lookup"><span data-stu-id="3186f-455">dc =WESTUS rack =rack4</span></span>    </td><td><span data-ttu-id="3186f-456">예</span><span class="sxs-lookup"><span data-stu-id="3186f-456">Yes</span></span></td></tr>
<tr><td><span data-ttu-id="3186f-457">hk-c8-west-us</span><span class="sxs-lookup"><span data-stu-id="3186f-457">hk-c8-west-us</span></span>    </td><td><span data-ttu-id="3186f-458">데이터</span><span class="sxs-lookup"><span data-stu-id="3186f-458">data</span></span>    </td><td><span data-ttu-id="3186f-459">10.1.2.11</span><span class="sxs-lookup"><span data-stu-id="3186f-459">10.1.2.11</span></span>    </td><td><span data-ttu-id="3186f-460">hk-c-aset-2</span><span class="sxs-lookup"><span data-stu-id="3186f-460">hk-c-aset-2</span></span>    </td><td><span data-ttu-id="3186f-461">dc =WESTUS rack =rack4</span><span class="sxs-lookup"><span data-stu-id="3186f-461">dc =WESTUS rack =rack4</span></span>    </td><td><span data-ttu-id="3186f-462">아니요</span><span class="sxs-lookup"><span data-stu-id="3186f-462">No</span></span> </td></tr>
<tr><td><span data-ttu-id="3186f-463">hk-w1-west-us</span><span class="sxs-lookup"><span data-stu-id="3186f-463">hk-w1-west-us</span></span>    </td><td><span data-ttu-id="3186f-464">web</span><span class="sxs-lookup"><span data-stu-id="3186f-464">web</span></span>    </td><td><span data-ttu-id="3186f-465">10.1.1.4</span><span class="sxs-lookup"><span data-stu-id="3186f-465">10.1.1.4</span></span>    </td><td><span data-ttu-id="3186f-466">hk-w-aset-1</span><span class="sxs-lookup"><span data-stu-id="3186f-466">hk-w-aset-1</span></span>    </td><td>                       </td><td><span data-ttu-id="3186f-467">해당 없음</span><span class="sxs-lookup"><span data-stu-id="3186f-467">N/A</span></span></td></tr>
<tr><td><span data-ttu-id="3186f-468">hk-w2-west-us</span><span class="sxs-lookup"><span data-stu-id="3186f-468">hk-w2-west-us</span></span>    </td><td><span data-ttu-id="3186f-469">web</span><span class="sxs-lookup"><span data-stu-id="3186f-469">web</span></span>    </td><td><span data-ttu-id="3186f-470">10.1.1.5</span><span class="sxs-lookup"><span data-stu-id="3186f-470">10.1.1.5</span></span>    </td><td><span data-ttu-id="3186f-471">hk-w-aset-1</span><span class="sxs-lookup"><span data-stu-id="3186f-471">hk-w-aset-1</span></span>    </td><td>                       </td><td><span data-ttu-id="3186f-472">해당 없음</span><span class="sxs-lookup"><span data-stu-id="3186f-472">N/A</span></span></td></tr>
</table>

<span data-ttu-id="3186f-473">Vm의 목록 위의 hello 만들기 프로세스를 수행 하는 hello이 필요 합니다.</span><span class="sxs-lookup"><span data-stu-id="3186f-473">Creation of hello above list of VMs requires hello following process:</span></span>

1. <span data-ttu-id="3186f-474">특정 지역에 빈 클라우드 서비스를 만듭니다.</span><span class="sxs-lookup"><span data-stu-id="3186f-474">Create an empty cloud service in a particular region</span></span>
2. <span data-ttu-id="3186f-475">Hello 이전에 캡처된 이미지에서 VM을 만들고; 이전에 만든 toohello 가상 네트워크 연결 모든 hello Vm에 대해이 단계를 반복합니다</span><span class="sxs-lookup"><span data-stu-id="3186f-475">Create a VM from hello previously captured image and attach it toohello virtual network created previously; repeat this for all hello VMs</span></span>
3. <span data-ttu-id="3186f-476">내부 부하 분산 장치 toohello 클라우드 서비스를 추가 하 고 "데이터" toohello 서브넷 연결</span><span class="sxs-lookup"><span data-stu-id="3186f-476">Add an internal load balancer toohello cloud service and attach it toohello “data” subnet</span></span>
4. <span data-ttu-id="3186f-477">이전에 만든 각 VM에 대 한 부하 분산 된 집합을 연결 된 이전에 만든 toohello 내부 부하 분산 장치를 통해 thrift 트래픽에 대 한 부하 분산 된 끝점 추가</span><span class="sxs-lookup"><span data-stu-id="3186f-477">For each VM created previously, add a load balanced endpoint for thrift traffic through a load balanced set connected toohello previously created internal load balancer</span></span>

<span data-ttu-id="3186f-478">Azure 클래식 포털;를 사용 하 여 hello 위의 프로세스를 실행할 수 있습니다. Windows 컴퓨터 (액세스 tooa Windows 컴퓨터에 없는 경우 Azure에서 VM 사용)를 사용 하 여 자동으로 다음 PowerShell 스크립트 tooprovision hello 8 모든 Vm을 사용 합니다.</span><span class="sxs-lookup"><span data-stu-id="3186f-478">hello above process can be executed using Azure classic portal; use a Windows machine (use a VM on Azure if you don't have access tooa Windows machine), use hello following PowerShell script tooprovision all 8 VMs automatically.</span></span>

<span data-ttu-id="3186f-479">**목록 1: 가상 컴퓨터 프로비전을 위한 PowerShell 스크립트**</span><span class="sxs-lookup"><span data-stu-id="3186f-479">**List 1: PowerShell script for provisioning virtual machines**</span></span>

        #Tested with Azure Powershell - November 2014
        #This powershell script deployes a number of VMs from an existing image inside an Azure region
        #Import your Azure subscription into hello current Powershell session before proceeding
        #hello process: 1. create Azure Storage account, 2. create virtual network, 3.create hello VM template, 2. crate a list of VMs from hello template

        #fundamental variables - change these tooreflect your subscription
        $country="us"; $region="west"; $vnetName = "your_vnet_name";$storageAccount="your_storage_account"
        $numVMs=8;$prefix = "hk-cass";$ilbIP="your_ilb_ip"
        $subscriptionName = "Azure_subscription_name";
        $vmSize="ExtraSmall"; $imageName="your_linux_image_name"
        $ilbName="ThriftInternalLB"; $thriftEndPoint="ThriftEndPoint"

        #generated variables
        $serviceName = "$prefix-svc-$region-$country"; $azureRegion = "$region $country"

        $vmNames = @()
        for ($i=0; $i -lt $numVMs; $i++)
        {
           $vmNames+=("$prefix-vm"+($i+1) + "-$region-$country" );
        }

        #select an Azure subscription already imported into Powershell session
        Select-AzureSubscription -SubscriptionName $subscriptionName -Current
        Set-AzureSubscription -SubscriptionName $subscriptionName -CurrentStorageAccountName $storageAccount

        #create an empty cloud service
        New-AzureService -ServiceName $serviceName -Label "hkcass$region" -Location $azureRegion
        Write-Host "Created $serviceName"

        $VMList= @()   # stores hello list of azure vm configuration objects
        #create hello list of VMs
        foreach($vmName in $vmNames)
        {
           $VMList += New-AzureVMConfig -Name $vmName -InstanceSize ExtraSmall -ImageName $imageName |
           Add-AzureProvisioningConfig -Linux -LinuxUser "localadmin" -Password "Local123" |
           Set-AzureSubnet "data"
        }

        New-AzureVM -ServiceName $serviceName -VNetName $vnetName -VMs $VMList

        #Create internal load balancer
        Add-AzureInternalLoadBalancer -ServiceName $serviceName -InternalLoadBalancerName $ilbName -SubnetName "data" -StaticVNetIPAddress "$ilbIP"
        Write-Host "Created $ilbName"
        #Add add hello thrift endpoint toohello internal load balancer for all hello VMs
        foreach($vmName in $vmNames)
        {
            Get-AzureVM -ServiceName $serviceName -Name $vmName |
                Add-AzureEndpoint -Name $thriftEndPoint -LBSetName "ThriftLBSet" -Protocol tcp -LocalPort 9160 -PublicPort 9160 -ProbePort 9160 -ProbeProtocol tcp -ProbeIntervalInSeconds 10 -InternalLoadBalancerName $ilbName |
                Update-AzureVM

            Write-Host "created $vmName"     
        }

<span data-ttu-id="3186f-480">**3단계: 각 VM에서 Cassandra 구성**</span><span class="sxs-lookup"><span data-stu-id="3186f-480">**Step 3: Configure Cassandra on each VM**</span></span>

<span data-ttu-id="3186f-481">Hello VM에 로그인 한를 hello 다음을 수행 합니다.</span><span class="sxs-lookup"><span data-stu-id="3186f-481">Log into hello VM and perform hello following:</span></span>

* <span data-ttu-id="3186f-482">$CASS_HOME/conf/cassandra-rackdc.properties는 toospecify hello 데이터 센터와 랙 속성을 편집 합니다.</span><span class="sxs-lookup"><span data-stu-id="3186f-482">Edit $CASS_HOME/conf/cassandra-rackdc.properties toospecify hello data center and rack properties:</span></span>
  
       dc =EASTUS, rack =rack1
* <span data-ttu-id="3186f-483">아래와 같이 cassandra.yaml tooconfigure 시드 노드를 편집 합니다.</span><span class="sxs-lookup"><span data-stu-id="3186f-483">Edit cassandra.yaml tooconfigure seed nodes as below:</span></span>
  
       Seeds: "10.1.2.4,10.1.2.6,10.1.2.8,10.1.2.10"

<span data-ttu-id="3186f-484">**4 단계: hello Vm을 시작 하 고 hello 클러스터 테스트**</span><span class="sxs-lookup"><span data-stu-id="3186f-484">**Step 4: Start hello VMs and test hello cluster**</span></span>

<span data-ttu-id="3186f-485">(예: 홍콩-c1-서쪽-us) hello 노드 중 하나에 로그인 실행된 hello hello 클러스터의 명령 toosee hello 상태에 따라:</span><span class="sxs-lookup"><span data-stu-id="3186f-485">Log into one of hello nodes (e.g. hk-c1-west-us) and run hello following command toosee hello status of hello cluster:</span></span>

       nodetool –h 10.1.2.4 –p 7199 status

<span data-ttu-id="3186f-486">Hello 디스플레이 비슷한 toohello 하나 아래의 8 개 노드 클러스터에 대 한 표시 되어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="3186f-486">You should see hello display similar toohello one below for an 8-node cluster:</span></span>

<table>
<tr><th><span data-ttu-id="3186f-487">가동 상태</span><span class="sxs-lookup"><span data-stu-id="3186f-487">Status</span></span></th><th><span data-ttu-id="3186f-488">주소</span><span class="sxs-lookup"><span data-stu-id="3186f-488">Address</span></span>    </th><th><span data-ttu-id="3186f-489">로드</span><span class="sxs-lookup"><span data-stu-id="3186f-489">Load</span></span>    </th><th><span data-ttu-id="3186f-490">토큰</span><span class="sxs-lookup"><span data-stu-id="3186f-490">Tokens</span></span>    </th><th><span data-ttu-id="3186f-491">소유 비율</span><span class="sxs-lookup"><span data-stu-id="3186f-491">Owns</span></span> </th><th><span data-ttu-id="3186f-492">호스트 ID</span><span class="sxs-lookup"><span data-stu-id="3186f-492">Host ID</span></span>    </th><th><span data-ttu-id="3186f-493">랙</span><span class="sxs-lookup"><span data-stu-id="3186f-493">Rack</span></span></th></tr>
<tr><th><span data-ttu-id="3186f-494">UN</span><span class="sxs-lookup"><span data-stu-id="3186f-494">UN</span></span>    </td><td><span data-ttu-id="3186f-495">10.1.2.4</span><span class="sxs-lookup"><span data-stu-id="3186f-495">10.1.2.4</span></span>     </td><td><span data-ttu-id="3186f-496">87.81 KB</span><span class="sxs-lookup"><span data-stu-id="3186f-496">87.81 KB</span></span>    </td><td><span data-ttu-id="3186f-497">256</span><span class="sxs-lookup"><span data-stu-id="3186f-497">256</span></span>    </td><td><span data-ttu-id="3186f-498">38.0%</span><span class="sxs-lookup"><span data-stu-id="3186f-498">38.0%</span></span>    </td><td><span data-ttu-id="3186f-499">Guid(제거됨)</span><span class="sxs-lookup"><span data-stu-id="3186f-499">Guid (removed)</span></span></td><td><span data-ttu-id="3186f-500">rack1</span><span class="sxs-lookup"><span data-stu-id="3186f-500">rack1</span></span></td></tr>
<tr><th><span data-ttu-id="3186f-501">UN</span><span class="sxs-lookup"><span data-stu-id="3186f-501">UN</span></span>    </td><td><span data-ttu-id="3186f-502">10.1.2.5</span><span class="sxs-lookup"><span data-stu-id="3186f-502">10.1.2.5</span></span>     </td><td><span data-ttu-id="3186f-503">41.08 KB</span><span class="sxs-lookup"><span data-stu-id="3186f-503">41.08 KB</span></span>    </td><td><span data-ttu-id="3186f-504">256</span><span class="sxs-lookup"><span data-stu-id="3186f-504">256</span></span>    </td><td><span data-ttu-id="3186f-505">68.9%</span><span class="sxs-lookup"><span data-stu-id="3186f-505">68.9%</span></span>    </td><td><span data-ttu-id="3186f-506">Guid(제거됨)</span><span class="sxs-lookup"><span data-stu-id="3186f-506">Guid (removed)</span></span></td><td><span data-ttu-id="3186f-507">rack1</span><span class="sxs-lookup"><span data-stu-id="3186f-507">rack1</span></span></td></tr>
<tr><th><span data-ttu-id="3186f-508">UN</span><span class="sxs-lookup"><span data-stu-id="3186f-508">UN</span></span>    </td><td><span data-ttu-id="3186f-509">10.1.2.6</span><span class="sxs-lookup"><span data-stu-id="3186f-509">10.1.2.6</span></span>     </td><td><span data-ttu-id="3186f-510">55.29 KB</span><span class="sxs-lookup"><span data-stu-id="3186f-510">55.29 KB</span></span>    </td><td><span data-ttu-id="3186f-511">256</span><span class="sxs-lookup"><span data-stu-id="3186f-511">256</span></span>    </td><td><span data-ttu-id="3186f-512">68.8%</span><span class="sxs-lookup"><span data-stu-id="3186f-512">68.8%</span></span>    </td><td><span data-ttu-id="3186f-513">Guid(제거됨)</span><span class="sxs-lookup"><span data-stu-id="3186f-513">Guid (removed)</span></span></td><td><span data-ttu-id="3186f-514">rack2</span><span class="sxs-lookup"><span data-stu-id="3186f-514">rack2</span></span></td></tr>
<tr><th><span data-ttu-id="3186f-515">UN</span><span class="sxs-lookup"><span data-stu-id="3186f-515">UN</span></span>    </td><td><span data-ttu-id="3186f-516">10.1.2.7</span><span class="sxs-lookup"><span data-stu-id="3186f-516">10.1.2.7</span></span>     </td><td><span data-ttu-id="3186f-517">55.29 KB</span><span class="sxs-lookup"><span data-stu-id="3186f-517">55.29 KB</span></span>    </td><td><span data-ttu-id="3186f-518">256</span><span class="sxs-lookup"><span data-stu-id="3186f-518">256</span></span>    </td><td><span data-ttu-id="3186f-519">68.8%</span><span class="sxs-lookup"><span data-stu-id="3186f-519">68.8%</span></span>    </td><td><span data-ttu-id="3186f-520">Guid(제거됨)</span><span class="sxs-lookup"><span data-stu-id="3186f-520">Guid (removed)</span></span></td><td><span data-ttu-id="3186f-521">rack2</span><span class="sxs-lookup"><span data-stu-id="3186f-521">rack2</span></span></td></tr>
<tr><th><span data-ttu-id="3186f-522">UN</span><span class="sxs-lookup"><span data-stu-id="3186f-522">UN</span></span>    </td><td><span data-ttu-id="3186f-523">10.1.2.8</span><span class="sxs-lookup"><span data-stu-id="3186f-523">10.1.2.8</span></span>     </td><td><span data-ttu-id="3186f-524">55.29 KB</span><span class="sxs-lookup"><span data-stu-id="3186f-524">55.29 KB</span></span>    </td><td><span data-ttu-id="3186f-525">256</span><span class="sxs-lookup"><span data-stu-id="3186f-525">256</span></span>    </td><td><span data-ttu-id="3186f-526">68.8%</span><span class="sxs-lookup"><span data-stu-id="3186f-526">68.8%</span></span>    </td><td><span data-ttu-id="3186f-527">Guid(제거됨)</span><span class="sxs-lookup"><span data-stu-id="3186f-527">Guid (removed)</span></span></td><td><span data-ttu-id="3186f-528">rack3</span><span class="sxs-lookup"><span data-stu-id="3186f-528">rack3</span></span></td></tr>
<tr><th><span data-ttu-id="3186f-529">UN</span><span class="sxs-lookup"><span data-stu-id="3186f-529">UN</span></span>    </td><td><span data-ttu-id="3186f-530">10.1.2.9</span><span class="sxs-lookup"><span data-stu-id="3186f-530">10.1.2.9</span></span>     </td><td><span data-ttu-id="3186f-531">55.29 KB</span><span class="sxs-lookup"><span data-stu-id="3186f-531">55.29 KB</span></span>    </td><td><span data-ttu-id="3186f-532">256</span><span class="sxs-lookup"><span data-stu-id="3186f-532">256</span></span>    </td><td><span data-ttu-id="3186f-533">68.8%</span><span class="sxs-lookup"><span data-stu-id="3186f-533">68.8%</span></span>    </td><td><span data-ttu-id="3186f-534">Guid(제거됨)</span><span class="sxs-lookup"><span data-stu-id="3186f-534">Guid (removed)</span></span></td><td><span data-ttu-id="3186f-535">rack3</span><span class="sxs-lookup"><span data-stu-id="3186f-535">rack3</span></span></td></tr>
<tr><th><span data-ttu-id="3186f-536">UN</span><span class="sxs-lookup"><span data-stu-id="3186f-536">UN</span></span>    </td><td><span data-ttu-id="3186f-537">10.1.2.10</span><span class="sxs-lookup"><span data-stu-id="3186f-537">10.1.2.10</span></span>     </td><td><span data-ttu-id="3186f-538">55.29 KB</span><span class="sxs-lookup"><span data-stu-id="3186f-538">55.29 KB</span></span>    </td><td><span data-ttu-id="3186f-539">256</span><span class="sxs-lookup"><span data-stu-id="3186f-539">256</span></span>    </td><td><span data-ttu-id="3186f-540">68.8%</span><span class="sxs-lookup"><span data-stu-id="3186f-540">68.8%</span></span>    </td><td><span data-ttu-id="3186f-541">Guid(제거됨)</span><span class="sxs-lookup"><span data-stu-id="3186f-541">Guid (removed)</span></span></td><td><span data-ttu-id="3186f-542">rack4</span><span class="sxs-lookup"><span data-stu-id="3186f-542">rack4</span></span></td></tr>
<tr><th><span data-ttu-id="3186f-543">UN</span><span class="sxs-lookup"><span data-stu-id="3186f-543">UN</span></span>    </td><td><span data-ttu-id="3186f-544">10.1.2.11</span><span class="sxs-lookup"><span data-stu-id="3186f-544">10.1.2.11</span></span>     </td><td><span data-ttu-id="3186f-545">55.29 KB</span><span class="sxs-lookup"><span data-stu-id="3186f-545">55.29 KB</span></span>    </td><td><span data-ttu-id="3186f-546">256</span><span class="sxs-lookup"><span data-stu-id="3186f-546">256</span></span>    </td><td><span data-ttu-id="3186f-547">68.8%</span><span class="sxs-lookup"><span data-stu-id="3186f-547">68.8%</span></span>    </td><td><span data-ttu-id="3186f-548">Guid(제거됨)</span><span class="sxs-lookup"><span data-stu-id="3186f-548">Guid (removed)</span></span></td><td><span data-ttu-id="3186f-549">rack4</span><span class="sxs-lookup"><span data-stu-id="3186f-549">rack4</span></span></td></tr>
</table>

## <a name="test-hello-single-region-cluster"></a><span data-ttu-id="3186f-550">테스트 hello 단일 지역 클러스터</span><span class="sxs-lookup"><span data-stu-id="3186f-550">Test hello Single Region Cluster</span></span>
<span data-ttu-id="3186f-551">다음 단계 tootest hello 클러스터 hello를 사용 합니다.</span><span class="sxs-lookup"><span data-stu-id="3186f-551">Use hello following steps tootest hello cluster:</span></span>

1. <span data-ttu-id="3186f-552">Hello Powershell 명령 가져오기 AzureInternalLoadbalancer commandlet을 사용 (예: hello 내부 부하 분산 장치의 IP 주소 hello 가져올  10.1.2.101)입니다.</span><span class="sxs-lookup"><span data-stu-id="3186f-552">Using hello Powershell command Get-AzureInternalLoadbalancer commandlet, obtain hello IP address of hello internal load balancer (e.g.  10.1.2.101).</span></span> <span data-ttu-id="3186f-553">hello 명령의 hello 구문은 다음과 같습니다: AzureLoadbalancer Get-ServiceName "hk-c-svc-서쪽-us" [hello 내부 부하 분산 장치 IP 주소와 함께 hello 세부 정보가 표시 됩니다.]</span><span class="sxs-lookup"><span data-stu-id="3186f-553">hello syntax of hello command is shown below: Get-AzureLoadbalancer –ServiceName "hk-c-svc-west-us” [displays hello details of hello internal load balancer along with its IP address]</span></span>
2. <span data-ttu-id="3186f-554">Hello 웹 팜 (예: 홍콩-w1-서쪽-us) VM에 로그인 Putty를 사용 하 여 또는 ssh</span><span class="sxs-lookup"><span data-stu-id="3186f-554">Log into hello web farm VM (e.g. hk-w1-west-us) using Putty or ssh</span></span>
3. <span data-ttu-id="3186f-555">$CASS_HOME/bin/cqlsh 10.1.2.101 9160을 실행합니다.</span><span class="sxs-lookup"><span data-stu-id="3186f-555">Execute $CASS_HOME/bin/cqlsh 10.1.2.101 9160</span></span>
4. <span data-ttu-id="3186f-556">Hello CQL 명령을 tooverify hello 클러스터가 작동 하는 경우 다음을 사용 합니다.</span><span class="sxs-lookup"><span data-stu-id="3186f-556">Use hello following CQL commands tooverify if hello cluster is working:</span></span>
   
     <span data-ttu-id="3186f-557">CREATE KEYSPACE customers_ks WITH REPLICATION = { 'class' : 'SimpleStrategy', 'replication_factor' : 3 };   USE customers_ks;   CREATE TABLE Customers(customer_id int PRIMARY KEY, firstname text, lastname text);   INSERT INTO Customers(customer_id, firstname, lastname) VALUES(1, 'John', 'Doe');   INSERT INTO Customers(customer_id, firstname, lastname) VALUES (2, 'Jane', 'Doe');</span><span class="sxs-lookup"><span data-stu-id="3186f-557">CREATE KEYSPACE customers_ks WITH REPLICATION = { 'class' : 'SimpleStrategy', 'replication_factor' : 3 };   USE customers_ks;   CREATE TABLE Customers(customer_id int PRIMARY KEY, firstname text, lastname text);   INSERT INTO Customers(customer_id, firstname, lastname) VALUES(1, 'John', 'Doe');   INSERT INTO Customers(customer_id, firstname, lastname) VALUES (2, 'Jane', 'Doe');</span></span>
   
     <span data-ttu-id="3186f-558">SELECT * FROM Customers;</span><span class="sxs-lookup"><span data-stu-id="3186f-558">SELECT * FROM Customers;</span></span>

<span data-ttu-id="3186f-559">Hello 하나 아래와 같은 표시를 나타나야 합니다.</span><span class="sxs-lookup"><span data-stu-id="3186f-559">You should see a display like hello one below:</span></span>

<table>
  <tr><th> <span data-ttu-id="3186f-560">customer_id</span><span class="sxs-lookup"><span data-stu-id="3186f-560">customer_id</span></span> </th><th> <span data-ttu-id="3186f-561">firstname</span><span class="sxs-lookup"><span data-stu-id="3186f-561">firstname</span></span> </th><th> <span data-ttu-id="3186f-562">Lastname</span><span class="sxs-lookup"><span data-stu-id="3186f-562">lastname</span></span> </th></tr>
  <tr><td> <span data-ttu-id="3186f-563">1</span><span class="sxs-lookup"><span data-stu-id="3186f-563">1</span></span> </td><td> <span data-ttu-id="3186f-564">John</span><span class="sxs-lookup"><span data-stu-id="3186f-564">John</span></span> </td><td> <span data-ttu-id="3186f-565">Doe</span><span class="sxs-lookup"><span data-stu-id="3186f-565">Doe</span></span> </td></tr>
  <tr><td> <span data-ttu-id="3186f-566">2</span><span class="sxs-lookup"><span data-stu-id="3186f-566">2</span></span> </td><td> <span data-ttu-id="3186f-567">Jane</span><span class="sxs-lookup"><span data-stu-id="3186f-567">Jane</span></span> </td><td> <span data-ttu-id="3186f-568">Doe</span><span class="sxs-lookup"><span data-stu-id="3186f-568">Doe</span></span> </td></tr>
</table>

<span data-ttu-id="3186f-569">4 단계에서 만든 해당 hello 키 스페이스 SimpleStrategy를 사용 하 여 3 replication_factor와 note 하십시오.</span><span class="sxs-lookup"><span data-stu-id="3186f-569">Please note that hello keyspace created in step 4 uses SimpleStrategy with a  replication_factor of 3.</span></span> <span data-ttu-id="3186f-570">SimpleStrategy는 단일 데이터 세터 배포에 권장되고 NetworkTopologyStrategy는 다중 데이터 세터 배포에 권장됩니다.</span><span class="sxs-lookup"><span data-stu-id="3186f-570">SimpleStrategy is recommended for single data center deployments whereas NetworkTopologyStrategy for multi-data center deployments.</span></span> <span data-ttu-id="3186f-571">replication_factor가 3이면 노드 오류에 대한 내결함성이 제공됩니다.</span><span class="sxs-lookup"><span data-stu-id="3186f-571">A replication_factor of 3 will give tolerance for node failures.</span></span>

## <span data-ttu-id="3186f-572"><a id="tworegion"> </a>다중 지역 배포 프로세스</span><span class="sxs-lookup"><span data-stu-id="3186f-572"><a id="tworegion"> </a>Multi-Region Deployment Process</span></span>
<span data-ttu-id="3186f-573">완료 하는 hello 단일 지역 배포를 활용 하 고 hello 두 번째 영역을 설치 하기 위한 hello 동일한 프로세스를 반복 합니다.</span><span class="sxs-lookup"><span data-stu-id="3186f-573">Will leverage hello single region deployment completed and repeat hello same process for installing hello second region.</span></span> <span data-ttu-id="3186f-574">hello 주요한 차이점 hello 단일 및 다중 지역 배포는 지역 간 통신용; hello VPN 터널 설정 hello 네트워크를 통해 설치를 시작, hello Vm을 프로 비전 하 고 Cassandra를 구성 합니다.</span><span class="sxs-lookup"><span data-stu-id="3186f-574">hello key difference between hello single and multiple region deployment is hello VPN tunnel setup for inter-region communication; we will start with hello network installation, provision hello VMs and configure Cassandra.</span></span>

### <a name="step-1-create-hello-virtual-network-at-hello-2nd-region"></a><span data-ttu-id="3186f-575">1 단계: hello에 hello 가상 네트워크 만들기 2 일 영역</span><span class="sxs-lookup"><span data-stu-id="3186f-575">Step 1: Create hello Virtual Network at hello 2nd Region</span></span>
<span data-ttu-id="3186f-576">Azure 클래식 포털 hello를 로그인 하 고 hello 표에 hello 특성 표시 된 가상 네트워크를 만듭니다.</span><span class="sxs-lookup"><span data-stu-id="3186f-576">Log into hello Azure classic portal and create a Virtual Network with hello attributes show in hello table.</span></span> <span data-ttu-id="3186f-577">참조 [hello Azure 클래식 포털에서에서 클라우드 전용 가상 네트워크 구성](../../../virtual-network/virtual-networks-create-vnet-classic-pportal.md) hello 프로세스의 자세한 단계입니다.</span><span class="sxs-lookup"><span data-stu-id="3186f-577">See [Configure a Cloud-Only Virtual Network in hello Azure classic portal](../../../virtual-network/virtual-networks-create-vnet-classic-pportal.md) for detailed steps of hello process.</span></span>      

<table>
<tr><th><span data-ttu-id="3186f-578">특성 이름</span><span class="sxs-lookup"><span data-stu-id="3186f-578">Attribute Name</span></span>    </th><th><span data-ttu-id="3186f-579">값</span><span class="sxs-lookup"><span data-stu-id="3186f-579">Value</span></span>    </th><th><span data-ttu-id="3186f-580">설명</span><span class="sxs-lookup"><span data-stu-id="3186f-580">Remarks</span></span></th></tr>
<tr><td><span data-ttu-id="3186f-581">Name</span><span class="sxs-lookup"><span data-stu-id="3186f-581">Name</span></span>    </td><td><span data-ttu-id="3186f-582">vnet-cass-east-us</span><span class="sxs-lookup"><span data-stu-id="3186f-582">vnet-cass-east-us</span></span></td><td></td></tr>
<tr><td><span data-ttu-id="3186f-583">지역</span><span class="sxs-lookup"><span data-stu-id="3186f-583">Region</span></span>    </td><td><span data-ttu-id="3186f-584">미국 동부</span><span class="sxs-lookup"><span data-stu-id="3186f-584">East US</span></span></td><td></td></tr>
<tr><td><span data-ttu-id="3186f-585">DNS 서버</span><span class="sxs-lookup"><span data-stu-id="3186f-585">DNS Servers</span></span>        </td><td></td><td><span data-ttu-id="3186f-586">DNS 서버를 사용하지 않으므로 이 특성을 무시합니다.</span><span class="sxs-lookup"><span data-stu-id="3186f-586">Ignore this as we are not using a DNS Server</span></span></td></tr>
<tr><td><span data-ttu-id="3186f-587">지점 및 사이트 간 VPN 구성</span><span class="sxs-lookup"><span data-stu-id="3186f-587">Configure a point-to-site VPN</span></span></td><td></td><td>        <span data-ttu-id="3186f-588">이 특성을 무시합니다.</span><span class="sxs-lookup"><span data-stu-id="3186f-588">Ignore this</span></span></td></tr>
<tr><td><span data-ttu-id="3186f-589">사이트 간 VPN 구성</span><span class="sxs-lookup"><span data-stu-id="3186f-589">Configure a site-to-site VPN</span></span></td><td></td><td>        <span data-ttu-id="3186f-590">이 특성을 무시합니다.</span><span class="sxs-lookup"><span data-stu-id="3186f-590">Ignore this</span></span></td></tr>
<tr><td><span data-ttu-id="3186f-591">주소 공간</span><span class="sxs-lookup"><span data-stu-id="3186f-591">Address Space</span></span>    </td><td><span data-ttu-id="3186f-592">10.2.0.0/16</span><span class="sxs-lookup"><span data-stu-id="3186f-592">10.2.0.0/16</span></span></td><td></td></tr>
<tr><td><span data-ttu-id="3186f-593">시작 IP</span><span class="sxs-lookup"><span data-stu-id="3186f-593">Starting IP</span></span>    </td><td><span data-ttu-id="3186f-594">10.2.0.0</span><span class="sxs-lookup"><span data-stu-id="3186f-594">10.2.0.0</span></span>    </td><td></td></tr>
<tr><td><span data-ttu-id="3186f-595">CIDR</span><span class="sxs-lookup"><span data-stu-id="3186f-595">CIDR</span></span>    </td><td><span data-ttu-id="3186f-596">/16 (65531)</span><span class="sxs-lookup"><span data-stu-id="3186f-596">/16 (65531)</span></span></td><td></td></tr>
</table>

<span data-ttu-id="3186f-597">Hello 다음 서브넷을 추가 합니다.</span><span class="sxs-lookup"><span data-stu-id="3186f-597">Add hello following subnets:</span></span>

<table>
<tr><th><span data-ttu-id="3186f-598">이름</span><span class="sxs-lookup"><span data-stu-id="3186f-598">Name</span></span>    </th><th><span data-ttu-id="3186f-599">시작 IP</span><span class="sxs-lookup"><span data-stu-id="3186f-599">Starting IP</span></span>    </th><th><span data-ttu-id="3186f-600">CIDR</span><span class="sxs-lookup"><span data-stu-id="3186f-600">CIDR</span></span>    </th><th><span data-ttu-id="3186f-601">설명</span><span class="sxs-lookup"><span data-stu-id="3186f-601">Remarks</span></span></th></tr>
<tr><td><span data-ttu-id="3186f-602">web</span><span class="sxs-lookup"><span data-stu-id="3186f-602">web</span></span>    </td><td><span data-ttu-id="3186f-603">10.2.1.0</span><span class="sxs-lookup"><span data-stu-id="3186f-603">10.2.1.0</span></span>    </td><td><span data-ttu-id="3186f-604">/24 (251)</span><span class="sxs-lookup"><span data-stu-id="3186f-604">/24 (251)</span></span>    </td><td><span data-ttu-id="3186f-605">Hello 웹 팜에 대 한 서브넷</span><span class="sxs-lookup"><span data-stu-id="3186f-605">Subnet for hello web farm</span></span></td></tr>
<tr><td><span data-ttu-id="3186f-606">데이터</span><span class="sxs-lookup"><span data-stu-id="3186f-606">data</span></span>    </td><td><span data-ttu-id="3186f-607">10.2.2.0</span><span class="sxs-lookup"><span data-stu-id="3186f-607">10.2.2.0</span></span>    </td><td><span data-ttu-id="3186f-608">/24 (251)</span><span class="sxs-lookup"><span data-stu-id="3186f-608">/24 (251)</span></span>    </td><td><span data-ttu-id="3186f-609">데이터베이스 노드 hello에 대 한 서브넷</span><span class="sxs-lookup"><span data-stu-id="3186f-609">Subnet for hello database nodes</span></span></td></tr>
</table>


### <a name="step-2-create-local-networks"></a><span data-ttu-id="3186f-610">2단계: 로컬 네트워크 만들기</span><span class="sxs-lookup"><span data-stu-id="3186f-610">Step 2: Create Local Networks</span></span>
<span data-ttu-id="3186f-611">Azure 가상 네트워킹에는 로컬 네트워크는 사설 클라우드 또는 다른 Azure 영역을 포함 하 여 tooa 원격 사이트에 매핑되는 프록시 주소 공간입니다.</span><span class="sxs-lookup"><span data-stu-id="3186f-611">A Local Network in Azure virtual networking is a proxy address space that maps tooa remote site including a private cloud or another Azure region.</span></span> <span data-ttu-id="3186f-612">이 프록시 주소 공간은 라우팅 네트워크 toohello 오른쪽 대상 네트워킹에 대 한 원격 게이트웨이 바인딩된 tooa입니다.</span><span class="sxs-lookup"><span data-stu-id="3186f-612">This proxy address space is bound tooa remote gateway for routing network toohello right networking destinations.</span></span> <span data-ttu-id="3186f-613">참조 [VNet tooVNet 연결 구성](../../../vpn-gateway/virtual-networks-configure-vnet-to-vnet-connection.md) hello에 대 한 지침은 VNET 대 VNET 연결을 설정 합니다.</span><span class="sxs-lookup"><span data-stu-id="3186f-613">See [Configure a VNet tooVNet Connection](../../../vpn-gateway/virtual-networks-configure-vnet-to-vnet-connection.md) for hello instructions on establishing VNET-to-VNET connection.</span></span>

<span data-ttu-id="3186f-614">다음 세부 정보는 hello 당 두 개의 로컬 네트워크를 만듭니다.</span><span class="sxs-lookup"><span data-stu-id="3186f-614">Create two local networks per hello following details:</span></span>

| <span data-ttu-id="3186f-615">네트워크 이름</span><span class="sxs-lookup"><span data-stu-id="3186f-615">Network Name</span></span> | <span data-ttu-id="3186f-616">VPN 게이트웨이 주소</span><span class="sxs-lookup"><span data-stu-id="3186f-616">VPN Gateway Address</span></span> | <span data-ttu-id="3186f-617">주소 공간</span><span class="sxs-lookup"><span data-stu-id="3186f-617">Address Space</span></span> | <span data-ttu-id="3186f-618">설명</span><span class="sxs-lookup"><span data-stu-id="3186f-618">Remarks</span></span> |
| --- | --- | --- | --- |
| <span data-ttu-id="3186f-619">hk-lnet-map-to-east-us</span><span class="sxs-lookup"><span data-stu-id="3186f-619">hk-lnet-map-to-east-us</span></span> |<span data-ttu-id="3186f-620">23.1.1.1</span><span class="sxs-lookup"><span data-stu-id="3186f-620">23.1.1.1</span></span> |<span data-ttu-id="3186f-621">10.2.0.0/16</span><span class="sxs-lookup"><span data-stu-id="3186f-621">10.2.0.0/16</span></span> |<span data-ttu-id="3186f-622">Hello 로컬 네트워크를 만드는 동안 자리 표시자 게이트웨이 주소를 제공 합니다.</span><span class="sxs-lookup"><span data-stu-id="3186f-622">While creating hello Local Network give a placeholder gateway address.</span></span> <span data-ttu-id="3186f-623">hello 실제 게이트웨이 주소는 hello 게이트웨이가 생성 된 후에 채워집니다.</span><span class="sxs-lookup"><span data-stu-id="3186f-623">hello real gateway address is filled once hello gateway is created.</span></span> <span data-ttu-id="3186f-624">Hello는 주소 공간 있는지와 정확히 일치 hello 해당 원격 VNET; 이 경우 hello VNET에서에서 만든 hello 미국 동부 지역입니다.</span><span class="sxs-lookup"><span data-stu-id="3186f-624">Make sure hello address space exactly matches hello respective remote VNET; in this case hello VNET created in hello East US region.</span></span> |
| <span data-ttu-id="3186f-625">hk-lnet-map-to-west-us</span><span class="sxs-lookup"><span data-stu-id="3186f-625">hk-lnet-map-to-west-us</span></span> |<span data-ttu-id="3186f-626">23.2.2.2</span><span class="sxs-lookup"><span data-stu-id="3186f-626">23.2.2.2</span></span> |<span data-ttu-id="3186f-627">10.1.0.0/16</span><span class="sxs-lookup"><span data-stu-id="3186f-627">10.1.0.0/16</span></span> |<span data-ttu-id="3186f-628">Hello 로컬 네트워크를 만드는 동안 자리 표시자 게이트웨이 주소를 제공 합니다.</span><span class="sxs-lookup"><span data-stu-id="3186f-628">While creating hello Local Network give a placeholder gateway address.</span></span> <span data-ttu-id="3186f-629">hello 실제 게이트웨이 주소는 hello 게이트웨이가 생성 된 후에 채워집니다.</span><span class="sxs-lookup"><span data-stu-id="3186f-629">hello real gateway address is filled once hello gateway is created.</span></span> <span data-ttu-id="3186f-630">Hello는 주소 공간 있는지와 정확히 일치 hello 해당 원격 VNET; 이 경우 hello VNET에서에서 만든 hello 미국 서 부 지역입니다.</span><span class="sxs-lookup"><span data-stu-id="3186f-630">Make sure hello address space exactly matches hello respective remote VNET; in this case hello VNET created in hello West US region.</span></span> |

### <a name="step-3-map-local-network-toohello-respective-vnets"></a><span data-ttu-id="3186f-631">3 단계: 맵 "Local" 네트워크 toohello 각 Vnet</span><span class="sxs-lookup"><span data-stu-id="3186f-631">Step 3: Map “Local” network toohello respective VNETs</span></span>
<span data-ttu-id="3186f-632">Hello Azure 클래식 포털에서에서 각 vnet 선택를 클릭 "구성", "Connect toohello 로컬 네트워크" 확인 하 고 다음 세부 정보는 hello 당 hello 로컬 네트워크:</span><span class="sxs-lookup"><span data-stu-id="3186f-632">From hello Azure classic portal, select each vnet, click “Configure”, check “Connect toohello local network”, and select hello Local Networks per hello following details:</span></span>

| <span data-ttu-id="3186f-633">가상 네트워크</span><span class="sxs-lookup"><span data-stu-id="3186f-633">Virtual Network</span></span> | <span data-ttu-id="3186f-634">로컬 네트워크</span><span class="sxs-lookup"><span data-stu-id="3186f-634">Local Network</span></span> |
| --- | --- |
| <span data-ttu-id="3186f-635">hk-vnet-west-us</span><span class="sxs-lookup"><span data-stu-id="3186f-635">hk-vnet-west-us</span></span> |<span data-ttu-id="3186f-636">hk-lnet-map-to-east-us</span><span class="sxs-lookup"><span data-stu-id="3186f-636">hk-lnet-map-to-east-us</span></span> |
| <span data-ttu-id="3186f-637">hk-vnet-east-us</span><span class="sxs-lookup"><span data-stu-id="3186f-637">hk-vnet-east-us</span></span> |<span data-ttu-id="3186f-638">hk-lnet-map-to-west-us</span><span class="sxs-lookup"><span data-stu-id="3186f-638">hk-lnet-map-to-west-us</span></span> |

### <a name="step-4-create-gateways-on-vnet1-and-vnet2"></a><span data-ttu-id="3186f-639">4단계: VNET1 및 VNET2에 게이트웨이 만들기</span><span class="sxs-lookup"><span data-stu-id="3186f-639">Step 4: Create Gateways on VNET1 and VNET2</span></span>
<span data-ttu-id="3186f-640">두 hello 가상 네트워크의 hello 대시보드에서 hello VPN 게이트웨이 프로 비전 프로세스 트리거되고 게이트웨이 만들기를 클릭 합니다.</span><span class="sxs-lookup"><span data-stu-id="3186f-640">From hello dashboard of both hello virtual networks, click CREATE GATEWAY which will trigger hello VPN gateway provisioning process.</span></span> <span data-ttu-id="3186f-641">잠시 후에는 각 가상 네트워크의 대시보드 hello 후 hello 실제 게이트웨이 주소가 표시 되어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="3186f-641">After a few minutes hello dashboard of each virtual network should display hello actual gateway address.</span></span>

### <a name="step-5-update-local-networks-with-hello-respective-gateway-addresses"></a><span data-ttu-id="3186f-642">Hello 각각 "게이트웨이" 주소와 5 단계: 업데이트 "Local" 네트워크</span><span class="sxs-lookup"><span data-stu-id="3186f-642">Step 5: Update “Local” networks with hello respective “Gateway” addresses</span></span>
<span data-ttu-id="3186f-643">두 hello 로컬 네트워크 tooreplace hello 자리 표시자 게이트웨이 IP 주소 프로 비전의 정당한 hello hello 실제 IP 주소와 게이트웨이 편집 합니다.</span><span class="sxs-lookup"><span data-stu-id="3186f-643">Edit both hello local networks tooreplace hello placeholder gateway IP address with hello real IP address of hello just provisioned gateways.</span></span> <span data-ttu-id="3186f-644">다음 매핑 hello를 사용 합니다.</span><span class="sxs-lookup"><span data-stu-id="3186f-644">Use hello following mapping:</span></span>

<table>
<tr><th><span data-ttu-id="3186f-645">로컬 네트워크</span><span class="sxs-lookup"><span data-stu-id="3186f-645">Local Network</span></span>    </th><th><span data-ttu-id="3186f-646">가상 네트워크 게이트웨이</span><span class="sxs-lookup"><span data-stu-id="3186f-646">Virtual Network Gateway</span></span></th></tr>
<tr><td><span data-ttu-id="3186f-647">hk-lnet-map-to-east-us</span><span class="sxs-lookup"><span data-stu-id="3186f-647">hk-lnet-map-to-east-us</span></span> </td><td><span data-ttu-id="3186f-648">hk-vnet-west-us의 게이트웨이</span><span class="sxs-lookup"><span data-stu-id="3186f-648">Gateway of hk-vnet-west-us</span></span></td></tr>
<tr><td><span data-ttu-id="3186f-649">hk-lnet-map-to-west-us</span><span class="sxs-lookup"><span data-stu-id="3186f-649">hk-lnet-map-to-west-us</span></span> </td><td><span data-ttu-id="3186f-650">hk-vnet-east-us의 게이트웨이</span><span class="sxs-lookup"><span data-stu-id="3186f-650">Gateway of hk-vnet-east-us</span></span></td></tr>
</table>

### <a name="step-6-update-hello-shared-key"></a><span data-ttu-id="3186f-651">6 단계: hello 공유 키를 업데이트 합니다.</span><span class="sxs-lookup"><span data-stu-id="3186f-651">Step 6: Update hello shared key</span></span>
<span data-ttu-id="3186f-652">다음 Powershell 스크립트 tooupdate hello IPSec 키 [모두 hello 게이트웨이에 사용 하 여 hello 찾았 키] 각 VPN 게이트웨이의 사용 하 여 hello: 집합 AzureVNetGatewayKey VNetName hk-vnet-동부-미국-LocalNetworkSiteName hk-lnet-map-to-west-us-에서 SharedKey D9E76BKK 집합 AzureVNetGatewayKey-VNetName hk-vnet-서쪽-미국-LocalNetworkSiteName hk-lnet-map-to-east-us-에서 SharedKey D9E76BKK</span><span class="sxs-lookup"><span data-stu-id="3186f-652">Use hello following Powershell script tooupdate hello IPSec key of each VPN gateway [use hello sake key for both hello gateways]: Set-AzureVNetGatewayKey -VNetName hk-vnet-east-us -LocalNetworkSiteName hk-lnet-map-to-west-us -SharedKey D9E76BKK Set-AzureVNetGatewayKey -VNetName hk-vnet-west-us -LocalNetworkSiteName hk-lnet-map-to-east-us -SharedKey D9E76BKK</span></span>

### <a name="step-7-establish-hello-vnet-to-vnet-connection"></a><span data-ttu-id="3186f-653">7 단계: hello VNET 대 VNET 연결 설정</span><span class="sxs-lookup"><span data-stu-id="3186f-653">Step 7: Establish hello VNET-to-VNET connection</span></span>
<span data-ttu-id="3186f-654">Hello Azure 클래식 포털에서에서 모두 hello tooestablish 가상 네트워크 게이트웨이 투 게이트웨이 연결의 "대시보드" 메뉴 hello를 사용 합니다.</span><span class="sxs-lookup"><span data-stu-id="3186f-654">From hello Azure classic portal, use hello “DASHBOARD” menu of both hello virtual networks tooestablish gateway-to-gateway connection.</span></span> <span data-ttu-id="3186f-655">Hello 아래쪽 도구 모음에서 hello "연결" 메뉴 항목을 사용 합니다.</span><span class="sxs-lookup"><span data-stu-id="3186f-655">Use hello “CONNECT” menu items in hello bottom toolbar.</span></span> <span data-ttu-id="3186f-656">몇 분 후 hello 대시보드에서 hello 연결 세부 정보를 그래픽으로 표시 되어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="3186f-656">After a few minutes hello dashboard should display hello connection details graphically.</span></span>

### <a name="step-8-create-hello-virtual-machines-in-region-2"></a><span data-ttu-id="3186f-657">8 단계: 영역 # 2에에서 hello 가상 컴퓨터 만들기</span><span class="sxs-lookup"><span data-stu-id="3186f-657">Step 8: Create hello virtual machines in region #2</span></span>
<span data-ttu-id="3186f-658">다음 hello 단계 같거나 hello 이미지 VHD 파일 toohello Azure 저장소 계정이 지역 # 2에 복사 하 여 지역 #1 배포에 설명 된 대로 hello Ubuntu 이미지를 만들고 hello 이미지를 만듭니다.</span><span class="sxs-lookup"><span data-stu-id="3186f-658">Create hello Ubuntu image as described in region #1 deployment by following hello same steps or copy hello image VHD file toohello Azure storage account located in region #2 and create hello image.</span></span> <span data-ttu-id="3186f-659">이 이미지를 사용 하 고 hello hk-c-svc-동부-us를 새 클라우드 서비스에 가상 컴퓨터의 목록을 다음을 만듭니다.</span><span class="sxs-lookup"><span data-stu-id="3186f-659">Use this image and create hello following list of virtual machines into a new cloud service hk-c-svc-east-us:</span></span>

| <span data-ttu-id="3186f-660">컴퓨터 이름</span><span class="sxs-lookup"><span data-stu-id="3186f-660">Machine Name</span></span> | <span data-ttu-id="3186f-661">서브넷</span><span class="sxs-lookup"><span data-stu-id="3186f-661">Subnet</span></span> | <span data-ttu-id="3186f-662">IP 주소</span><span class="sxs-lookup"><span data-stu-id="3186f-662">IP Address</span></span> | <span data-ttu-id="3186f-663">가용성 집합</span><span class="sxs-lookup"><span data-stu-id="3186f-663">Availability set</span></span> | <span data-ttu-id="3186f-664">DC/랙</span><span class="sxs-lookup"><span data-stu-id="3186f-664">DC/Rack</span></span> | <span data-ttu-id="3186f-665">시드 여부</span><span class="sxs-lookup"><span data-stu-id="3186f-665">Seed?</span></span> |
| --- | --- | --- | --- | --- | --- |
| <span data-ttu-id="3186f-666">hk-c1-east-us</span><span class="sxs-lookup"><span data-stu-id="3186f-666">hk-c1-east-us</span></span> |<span data-ttu-id="3186f-667">데이터</span><span class="sxs-lookup"><span data-stu-id="3186f-667">data</span></span> |<span data-ttu-id="3186f-668">10.2.2.4</span><span class="sxs-lookup"><span data-stu-id="3186f-668">10.2.2.4</span></span> |<span data-ttu-id="3186f-669">hk-c-aset-1</span><span class="sxs-lookup"><span data-stu-id="3186f-669">hk-c-aset-1</span></span> |<span data-ttu-id="3186f-670">dc =EASTUS rack =rack1</span><span class="sxs-lookup"><span data-stu-id="3186f-670">dc =EASTUS rack =rack1</span></span> |<span data-ttu-id="3186f-671">예</span><span class="sxs-lookup"><span data-stu-id="3186f-671">Yes</span></span> |
| <span data-ttu-id="3186f-672">hk-c2-east-us</span><span class="sxs-lookup"><span data-stu-id="3186f-672">hk-c2-east-us</span></span> |<span data-ttu-id="3186f-673">데이터</span><span class="sxs-lookup"><span data-stu-id="3186f-673">data</span></span> |<span data-ttu-id="3186f-674">10.2.2.5</span><span class="sxs-lookup"><span data-stu-id="3186f-674">10.2.2.5</span></span> |<span data-ttu-id="3186f-675">hk-c-aset-1</span><span class="sxs-lookup"><span data-stu-id="3186f-675">hk-c-aset-1</span></span> |<span data-ttu-id="3186f-676">dc =EASTUS rack =rack1</span><span class="sxs-lookup"><span data-stu-id="3186f-676">dc =EASTUS rack =rack1</span></span> |<span data-ttu-id="3186f-677">아니요</span><span class="sxs-lookup"><span data-stu-id="3186f-677">No</span></span> |
| <span data-ttu-id="3186f-678">hk-c3-east-us</span><span class="sxs-lookup"><span data-stu-id="3186f-678">hk-c3-east-us</span></span> |<span data-ttu-id="3186f-679">데이터</span><span class="sxs-lookup"><span data-stu-id="3186f-679">data</span></span> |<span data-ttu-id="3186f-680">10.2.2.6</span><span class="sxs-lookup"><span data-stu-id="3186f-680">10.2.2.6</span></span> |<span data-ttu-id="3186f-681">hk-c-aset-1</span><span class="sxs-lookup"><span data-stu-id="3186f-681">hk-c-aset-1</span></span> |<span data-ttu-id="3186f-682">dc =EASTUS rack =rack2</span><span class="sxs-lookup"><span data-stu-id="3186f-682">dc =EASTUS rack =rack2</span></span> |<span data-ttu-id="3186f-683">예</span><span class="sxs-lookup"><span data-stu-id="3186f-683">Yes</span></span> |
| <span data-ttu-id="3186f-684">hk-c5-east-us</span><span class="sxs-lookup"><span data-stu-id="3186f-684">hk-c5-east-us</span></span> |<span data-ttu-id="3186f-685">데이터</span><span class="sxs-lookup"><span data-stu-id="3186f-685">data</span></span> |<span data-ttu-id="3186f-686">10.2.2.8</span><span class="sxs-lookup"><span data-stu-id="3186f-686">10.2.2.8</span></span> |<span data-ttu-id="3186f-687">hk-c-aset-2</span><span class="sxs-lookup"><span data-stu-id="3186f-687">hk-c-aset-2</span></span> |<span data-ttu-id="3186f-688">dc =EASTUS rack =rack3</span><span class="sxs-lookup"><span data-stu-id="3186f-688">dc =EASTUS rack =rack3</span></span> |<span data-ttu-id="3186f-689">예</span><span class="sxs-lookup"><span data-stu-id="3186f-689">Yes</span></span> |
| <span data-ttu-id="3186f-690">hk-c6-east-us</span><span class="sxs-lookup"><span data-stu-id="3186f-690">hk-c6-east-us</span></span> |<span data-ttu-id="3186f-691">데이터</span><span class="sxs-lookup"><span data-stu-id="3186f-691">data</span></span> |<span data-ttu-id="3186f-692">10.2.2.9</span><span class="sxs-lookup"><span data-stu-id="3186f-692">10.2.2.9</span></span> |<span data-ttu-id="3186f-693">hk-c-aset-2</span><span class="sxs-lookup"><span data-stu-id="3186f-693">hk-c-aset-2</span></span> |<span data-ttu-id="3186f-694">dc =EASTUS rack =rack3</span><span class="sxs-lookup"><span data-stu-id="3186f-694">dc =EASTUS rack =rack3</span></span> |<span data-ttu-id="3186f-695">아니요</span><span class="sxs-lookup"><span data-stu-id="3186f-695">No</span></span> |
| <span data-ttu-id="3186f-696">hk-c7-east-us</span><span class="sxs-lookup"><span data-stu-id="3186f-696">hk-c7-east-us</span></span> |<span data-ttu-id="3186f-697">데이터</span><span class="sxs-lookup"><span data-stu-id="3186f-697">data</span></span> |<span data-ttu-id="3186f-698">10.2.2.10</span><span class="sxs-lookup"><span data-stu-id="3186f-698">10.2.2.10</span></span> |<span data-ttu-id="3186f-699">hk-c-aset-2</span><span class="sxs-lookup"><span data-stu-id="3186f-699">hk-c-aset-2</span></span> |<span data-ttu-id="3186f-700">dc =EASTUS rack =rack4</span><span class="sxs-lookup"><span data-stu-id="3186f-700">dc =EASTUS rack =rack4</span></span> |<span data-ttu-id="3186f-701">예</span><span class="sxs-lookup"><span data-stu-id="3186f-701">Yes</span></span> |
| <span data-ttu-id="3186f-702">hk-c8-east-us</span><span class="sxs-lookup"><span data-stu-id="3186f-702">hk-c8-east-us</span></span> |<span data-ttu-id="3186f-703">데이터</span><span class="sxs-lookup"><span data-stu-id="3186f-703">data</span></span> |<span data-ttu-id="3186f-704">10.2.2.11</span><span class="sxs-lookup"><span data-stu-id="3186f-704">10.2.2.11</span></span> |<span data-ttu-id="3186f-705">hk-c-aset-2</span><span class="sxs-lookup"><span data-stu-id="3186f-705">hk-c-aset-2</span></span> |<span data-ttu-id="3186f-706">dc =EASTUS rack =rack4</span><span class="sxs-lookup"><span data-stu-id="3186f-706">dc =EASTUS rack =rack4</span></span> |<span data-ttu-id="3186f-707">아니요</span><span class="sxs-lookup"><span data-stu-id="3186f-707">No</span></span> |
| <span data-ttu-id="3186f-708">hk-w1-east-us</span><span class="sxs-lookup"><span data-stu-id="3186f-708">hk-w1-east-us</span></span> |<span data-ttu-id="3186f-709">web</span><span class="sxs-lookup"><span data-stu-id="3186f-709">web</span></span> |<span data-ttu-id="3186f-710">10.2.1.4</span><span class="sxs-lookup"><span data-stu-id="3186f-710">10.2.1.4</span></span> |<span data-ttu-id="3186f-711">hk-w-aset-1</span><span class="sxs-lookup"><span data-stu-id="3186f-711">hk-w-aset-1</span></span> |<span data-ttu-id="3186f-712">해당 없음</span><span class="sxs-lookup"><span data-stu-id="3186f-712">N/A</span></span> |<span data-ttu-id="3186f-713">해당 없음</span><span class="sxs-lookup"><span data-stu-id="3186f-713">N/A</span></span> |
| <span data-ttu-id="3186f-714">hk-w2-east-us</span><span class="sxs-lookup"><span data-stu-id="3186f-714">hk-w2-east-us</span></span> |<span data-ttu-id="3186f-715">web</span><span class="sxs-lookup"><span data-stu-id="3186f-715">web</span></span> |<span data-ttu-id="3186f-716">10.2.1.5</span><span class="sxs-lookup"><span data-stu-id="3186f-716">10.2.1.5</span></span> |<span data-ttu-id="3186f-717">hk-w-aset-1</span><span class="sxs-lookup"><span data-stu-id="3186f-717">hk-w-aset-1</span></span> |<span data-ttu-id="3186f-718">해당 없음</span><span class="sxs-lookup"><span data-stu-id="3186f-718">N/A</span></span> |<span data-ttu-id="3186f-719">해당 없음</span><span class="sxs-lookup"><span data-stu-id="3186f-719">N/A</span></span> |

<span data-ttu-id="3186f-720">다음과 같은 hello 지역 #1 지침 하지만 10.2.xxx.xxx 주소 공간을 사용 합니다.</span><span class="sxs-lookup"><span data-stu-id="3186f-720">Follow hello same instructions as region #1 but use 10.2.xxx.xxx address space.</span></span>

### <a name="step-9-configure-cassandra-on-each-vm"></a><span data-ttu-id="3186f-721">9단계: 각 VM에서 Cassandra 구성</span><span class="sxs-lookup"><span data-stu-id="3186f-721">Step 9: Configure Cassandra on each VM</span></span>
<span data-ttu-id="3186f-722">Hello VM에 로그인 한를 hello 다음을 수행 합니다.</span><span class="sxs-lookup"><span data-stu-id="3186f-722">Log into hello VM and perform hello following:</span></span>

1. <span data-ttu-id="3186f-723">속성을 편집 $CASS_HOME/conf/cassandra-rackdc.properties toospecify hello 데이터 센터와 랙 hello 형태로 표시: dc = EASTUS 랙 rack1 =</span><span class="sxs-lookup"><span data-stu-id="3186f-723">Edit $CASS_HOME/conf/cassandra-rackdc.properties toospecify hello data center and rack properties in hello format:  dc =EASTUS  rack =rack1</span></span>
2. <span data-ttu-id="3186f-724">Cassandra.yaml tooconfigure 시드 노드를 편집: 초기값: "10.1.2.4,10.1.2.6,10.1.2.8,10.1.2.10,10.2.2.4,10.2.2.6,10.2.2.8,10.2.2.10"</span><span class="sxs-lookup"><span data-stu-id="3186f-724">Edit cassandra.yaml tooconfigure seed nodes:  Seeds: "10.1.2.4,10.1.2.6,10.1.2.8,10.1.2.10,10.2.2.4,10.2.2.6,10.2.2.8,10.2.2.10"</span></span>

### <a name="step-10-start-cassandra"></a><span data-ttu-id="3186f-725">10단계: Cassandra 시작</span><span class="sxs-lookup"><span data-stu-id="3186f-725">Step 10: Start Cassandra</span></span>
<span data-ttu-id="3186f-726">각 VM에 로그인 하 고 hello 다음 명령을 실행 하 여 Cassandra hello 백그라운드에서 시작: $CASS_HOME/bin/cassandra</span><span class="sxs-lookup"><span data-stu-id="3186f-726">Log into each VM and start Cassandra in hello background by running hello following command: $CASS_HOME/bin/cassandra</span></span>

## <a name="test-hello-multi-region-cluster"></a><span data-ttu-id="3186f-727">테스트 hello 다중 지역 클러스터</span><span class="sxs-lookup"><span data-stu-id="3186f-727">Test hello Multi-Region Cluster</span></span>
<span data-ttu-id="3186f-728">지금까지 Cassandra 각 Azure 영역의 8 개의 노드로 구성 된 배포 된 too16 노드 되었습니다.</span><span class="sxs-lookup"><span data-stu-id="3186f-728">By now Cassandra has been deployed too16 nodes with 8 nodes in each Azure region.</span></span> <span data-ttu-id="3186f-729">이러한 노드는 hello 일반 클러스터 이름 및 hello 시드 노드 구성으로 인해 클러스터 동일 hello입니다.</span><span class="sxs-lookup"><span data-stu-id="3186f-729">These nodes are in hello same cluster by virtue of hello common cluster name and hello seed node configuration.</span></span> <span data-ttu-id="3186f-730">다음 프로세스 tootest hello 클러스터 hello를 사용 합니다.</span><span class="sxs-lookup"><span data-stu-id="3186f-730">Use hello following process tootest hello cluster:</span></span>

### <a name="step-1-get-hello-internal-load-balancer-ip-for-both-hello-regions-using-powershell"></a><span data-ttu-id="3186f-731">1 단계: PowerShell을 사용 하 여 두 hello 영역에 대 한 hello 내부 부하 분산 장치 IP 가져오기</span><span class="sxs-lookup"><span data-stu-id="3186f-731">Step 1: Get hello internal load balancer IP for both hello regions using PowerShell</span></span>
* <span data-ttu-id="3186f-732">Get-AzureInternalLoadbalancer -ServiceName "hk-c-svc-west-us"</span><span class="sxs-lookup"><span data-stu-id="3186f-732">Get-AzureInternalLoadbalancer -ServiceName "hk-c-svc-west-us"</span></span>
* <span data-ttu-id="3186f-733">Get-AzureInternalLoadbalancer -ServiceName "hk-c-svc-east-us"</span><span class="sxs-lookup"><span data-stu-id="3186f-733">Get-AzureInternalLoadbalancer -ServiceName "hk-c-svc-east-us"</span></span>  
  
    <span data-ttu-id="3186f-734">Hello IP 주소를 기록해 둡니다 (예:-10.1.2.101, 동-서 10.2.2.101) 표시 합니다.</span><span class="sxs-lookup"><span data-stu-id="3186f-734">Note hello IP addresses (e.g. west - 10.1.2.101, east - 10.2.2.101) displayed.</span></span>

### <a name="step-2-execute-hello-following-in-hello-west-region-after-logging-into-hk-w1-west-us"></a><span data-ttu-id="3186f-735">2 단계: hello 서 부 지역에 hello 다음 hk-w1-서쪽-미국에 로그인 한 후 실행</span><span class="sxs-lookup"><span data-stu-id="3186f-735">Step 2: Execute hello following in hello west region after logging into hk-w1-west-us</span></span>
1. <span data-ttu-id="3186f-736">$CASS_HOME/bin/cqlsh 10.1.2.101 9160을 실행합니다.</span><span class="sxs-lookup"><span data-stu-id="3186f-736">Execute $CASS_HOME/bin/cqlsh 10.1.2.101 9160</span></span>
2. <span data-ttu-id="3186f-737">Hello 다음 CQL 명령을 실행 합니다.</span><span class="sxs-lookup"><span data-stu-id="3186f-737">Execute hello following CQL commands:</span></span>
   
     <span data-ttu-id="3186f-738">CREATE KEYSPACE customers_ks   WITH REPLICATION = { 'class' : 'NetworkToplogyStrategy', 'WESTUS' : 3, 'EASTUS' : 3};   USE customers_ks;   CREATE TABLE Customers(customer_id int PRIMARY KEY, firstname text, lastname text);   INSERT INTO Customers(customer_id, firstname, lastname) VALUES(1, 'John', 'Doe');   INSERT INTO Customers(customer_id, firstname, lastname) VALUES (2, 'Jane', 'Doe');   SELECT * FROM Customers;</span><span class="sxs-lookup"><span data-stu-id="3186f-738">CREATE KEYSPACE customers_ks   WITH REPLICATION = { 'class' : 'NetworkToplogyStrategy', 'WESTUS' : 3, 'EASTUS' : 3};   USE customers_ks;   CREATE TABLE Customers(customer_id int PRIMARY KEY, firstname text, lastname text);   INSERT INTO Customers(customer_id, firstname, lastname) VALUES(1, 'John', 'Doe');   INSERT INTO Customers(customer_id, firstname, lastname) VALUES (2, 'Jane', 'Doe');   SELECT * FROM Customers;</span></span>

<span data-ttu-id="3186f-739">Hello 하나 아래와 같은 표시를 나타나야 합니다.</span><span class="sxs-lookup"><span data-stu-id="3186f-739">You should see a display like hello one below:</span></span>

| <span data-ttu-id="3186f-740">customer_id</span><span class="sxs-lookup"><span data-stu-id="3186f-740">customer_id</span></span> | <span data-ttu-id="3186f-741">firstname</span><span class="sxs-lookup"><span data-stu-id="3186f-741">firstname</span></span> | <span data-ttu-id="3186f-742">Lastname</span><span class="sxs-lookup"><span data-stu-id="3186f-742">Lastname</span></span> |
| --- | --- | --- |
| <span data-ttu-id="3186f-743">1</span><span class="sxs-lookup"><span data-stu-id="3186f-743">1</span></span> |<span data-ttu-id="3186f-744">John</span><span class="sxs-lookup"><span data-stu-id="3186f-744">John</span></span> |<span data-ttu-id="3186f-745">Doe</span><span class="sxs-lookup"><span data-stu-id="3186f-745">Doe</span></span> |
| <span data-ttu-id="3186f-746">2</span><span class="sxs-lookup"><span data-stu-id="3186f-746">2</span></span> |<span data-ttu-id="3186f-747">Jane</span><span class="sxs-lookup"><span data-stu-id="3186f-747">Jane</span></span> |<span data-ttu-id="3186f-748">Doe</span><span class="sxs-lookup"><span data-stu-id="3186f-748">Doe</span></span> |

### <a name="step-3-execute-hello-following-in-hello-east-region-after-logging-into-hk-w1-east-us"></a><span data-ttu-id="3186f-749">3 단계 hello 동부 지역 hello 다음 hk-w1-동부-미국에 로그인 한 후 실행 합니다.:</span><span class="sxs-lookup"><span data-stu-id="3186f-749">Step 3: Execute hello following in hello east region after logging into hk-w1-east-us:</span></span>
1. <span data-ttu-id="3186f-750">$CASS_HOME/bin/cqlsh 10.2.2.101 9160 실행</span><span class="sxs-lookup"><span data-stu-id="3186f-750">Execute $CASS_HOME/bin/cqlsh 10.2.2.101 9160</span></span>
2. <span data-ttu-id="3186f-751">Hello 다음 CQL 명령을 실행 합니다.</span><span class="sxs-lookup"><span data-stu-id="3186f-751">Execute hello following CQL commands:</span></span>
   
     <span data-ttu-id="3186f-752">USE customers_ks;   CREATE TABLE Customers(customer_id int PRIMARY KEY, firstname text, lastname text);   INSERT INTO Customers(customer_id, firstname, lastname) VALUES(1, 'John', 'Doe');   INSERT INTO Customers(customer_id, firstname, lastname) VALUES (2, 'Jane', 'Doe');   SELECT * FROM Customers;</span><span class="sxs-lookup"><span data-stu-id="3186f-752">USE customers_ks;   CREATE TABLE Customers(customer_id int PRIMARY KEY, firstname text, lastname text);   INSERT INTO Customers(customer_id, firstname, lastname) VALUES(1, 'John', 'Doe');   INSERT INTO Customers(customer_id, firstname, lastname) VALUES (2, 'Jane', 'Doe');   SELECT * FROM Customers;</span></span>

<span data-ttu-id="3186f-753">Hello 서 부 지역에 대해 표시 되는 디스플레이 동일 hello를 표시 되어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="3186f-753">You should see hello same display as seen for hello West region:</span></span>

| <span data-ttu-id="3186f-754">customer_id</span><span class="sxs-lookup"><span data-stu-id="3186f-754">customer_id</span></span> | <span data-ttu-id="3186f-755">firstname</span><span class="sxs-lookup"><span data-stu-id="3186f-755">firstname</span></span> | <span data-ttu-id="3186f-756">Lastname</span><span class="sxs-lookup"><span data-stu-id="3186f-756">Lastname</span></span> |
| --- | --- | --- |
| <span data-ttu-id="3186f-757">1</span><span class="sxs-lookup"><span data-stu-id="3186f-757">1</span></span> |<span data-ttu-id="3186f-758">John</span><span class="sxs-lookup"><span data-stu-id="3186f-758">John</span></span> |<span data-ttu-id="3186f-759">Doe</span><span class="sxs-lookup"><span data-stu-id="3186f-759">Doe</span></span> |
| <span data-ttu-id="3186f-760">2</span><span class="sxs-lookup"><span data-stu-id="3186f-760">2</span></span> |<span data-ttu-id="3186f-761">Jane</span><span class="sxs-lookup"><span data-stu-id="3186f-761">Jane</span></span> |<span data-ttu-id="3186f-762">Doe</span><span class="sxs-lookup"><span data-stu-id="3186f-762">Doe</span></span> |

<span data-ttu-id="3186f-763">몇 가지 더 많은 삽입을 실행 하 고 복제 된 toowest를 구하십시오 것-hello 클러스터의 일부로 주세요.</span><span class="sxs-lookup"><span data-stu-id="3186f-763">Execute a few more inserts and see that those get replicated toowest-us part of hello cluster.</span></span>

## <a name="test-cassandra-cluster-from-nodejs"></a><span data-ttu-id="3186f-764">Node.js에서 Cassandra 클러스터 테스트</span><span class="sxs-lookup"><span data-stu-id="3186f-764">Test Cassandra Cluster from Node.js</span></span>
<span data-ttu-id="3186f-765">Hello "웹" 계층에서 이전에 만든 hello Linux Vm 중 하나를 사용 하 여, 이전 실행될지 간단한 Node.js 스크립트 tooread hello 앞서 삽입 한 데이터</span><span class="sxs-lookup"><span data-stu-id="3186f-765">Using one of hello Linux VMs crated in hello "web" tier previously, we will execute a simple Node.js script tooread hello previously inserted data</span></span>

<span data-ttu-id="3186f-766">**1단계: Node.js 및 Cassandra 클라이언트 설치**</span><span class="sxs-lookup"><span data-stu-id="3186f-766">**Step 1: Install Node.js and Cassandra Client**</span></span>

1. <span data-ttu-id="3186f-767">Node.js 및 npm을 설치합니다.</span><span class="sxs-lookup"><span data-stu-id="3186f-767">Install Node.js and npm</span></span>
2. <span data-ttu-id="3186f-768">npm을 사용하여 노드 패키지 "cassandra-client"를 설치합니다.</span><span class="sxs-lookup"><span data-stu-id="3186f-768">Install node package "cassandra-client" using npm</span></span>
3. <span data-ttu-id="3186f-769">Hello 스크립트 hello 검색 데이터의 json 문자열 hello를 표시 하는 hello 셸 프롬프트에서 다음을 실행 합니다.</span><span class="sxs-lookup"><span data-stu-id="3186f-769">Execute hello following script at hello shell prompt which displays hello json string of hello retrieved data:</span></span>
   
        var pooledCon = require('cassandra-client').PooledConnection;
        var ksName = "custsupport_ks";
        var cfName = "customers_cf";
        var hostList = ['internal_loadbalancer_ip:9160'];
        var ksConOptions = { hosts: hostList,
                             keyspace: ksName, use_bigints: false };
   
        function createKeyspace(callback){
           var cql = 'CREATE KEYSPACE ' + ksName + ' WITH strategy_class=SimpleStrategy AND strategy_options:replication_factor=1';
           var sysConOptions = { hosts: hostList,  
                                 keyspace: 'system', use_bigints: false };
           var con = new pooledCon(sysConOptions);
           con.execute(cql,[],function(err) {
           if (err) {
             console.log("Failed toocreate Keyspace: " + ksName);
             console.log(err);
           }
           else {
             console.log("Created Keyspace: " + ksName);
             callback(ksConOptions, populateCustomerData);
           }
           });
           con.shutdown();
        }
   
        function createColumnFamily(ksConOptions, callback){
          var params = ['customers_cf','custid','varint','custname',
                        'text','custaddress','text'];
          var cql = 'CREATE COLUMNFAMILY ? (? ? PRIMARY KEY,? ?, ? ?)';
        var con =  new pooledCon(ksConOptions);
          con.execute(cql,params,function(err) {
              if (err) {
                 console.log("Failed toocreate column family: " + params[0]);
                 console.log(err);
              }
              else {
                 console.log("Created column family: " + params[0]);
                 callback();
              }
          });
          con.shutdown();
        }
   
        //populate Data
        function populateCustomerData() {
           var params = ['John','Infinity Dr, TX', 1];
           updateCustomer(ksConOptions,params);
   
           params = ['Tom','Fermat Ln, WA', 2];
           updateCustomer(ksConOptions,params);
        }
   
        //update will also insert hello record if none exists
        function updateCustomer(ksConOptions,params)
        {
          var cql = 'UPDATE customers_cf SET custname=?,custaddress=? where custid=?';
          var con = new pooledCon(ksConOptions);
          con.execute(cql,params,function(err) {
              if (err) console.log(err);
              else console.log("Inserted customer : " + params[0]);
          });
          con.shutdown();
        }
   
        //read hello two rows inserted above
        function readCustomer(ksConOptions)
        {
          var cql = 'SELECT * FROM customers_cf WHERE custid IN (1,2)';
          var con = new pooledCon(ksConOptions);
          con.execute(cql,[],function(err,rows) {
              if (err)
                 console.log(err);
              else
                 for (var i=0; i<rows.length; i++)
                    console.log(JSON.stringify(rows[i]));
            });
           con.shutdown();
        }
   
        //exectue hello code
        createKeyspace(createColumnFamily);
        readCustomer(ksConOptions)

## <a name="conclusion"></a><span data-ttu-id="3186f-770">결론</span><span class="sxs-lookup"><span data-stu-id="3186f-770">Conclusion</span></span>
<span data-ttu-id="3186f-771">Microsoft Azure는이 연습에서 설명으로 Microsoft 오픈 소스 소프트웨어 hello 실행 수 있도록 허용 하는 유동적인 플랫폼입니다.</span><span class="sxs-lookup"><span data-stu-id="3186f-771">Microsoft Azure is a flexible platform that allows hello running of both Microsoft as well as open source software as demonstrated by this exercise.</span></span> <span data-ttu-id="3186f-772">항상 사용 가능한 Cassandra 클러스터 hello를 분배 hello 클러스터 노드의 여러 오류 도메인을 통해 단일 데이터 센터에 배포할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="3186f-772">Highly available Cassandra clusters can be deployed on a single data center through hello spreading of hello cluster nodes across multiple fault domains.</span></span> <span data-ttu-id="3186f-773">재해 증명 시스템을 위해 지역적으로 떨어진 여러 Azure 지역에 Cassandra 클러스터를 배포할 수도 있습니다.</span><span class="sxs-lookup"><span data-stu-id="3186f-773">Cassandra clusters can also be deployed across multiple geographically distant Azure regions for disaster proof systems.</span></span> <span data-ttu-id="3186f-774">Azure와 함께 사용 하면 Cassandra hello 확장성이 높은, 항상 사용 가능한의 생성 및 재해 복구 가능한 클라우드 서비스 필요한 현재의 인터넷에서 서비스를 크기입니다.</span><span class="sxs-lookup"><span data-stu-id="3186f-774">Azure and Cassandra together enables hello construction of highly scalable, highly available and disaster recoverable cloud services needed by today's internet scale services.</span></span>  

## <a name="references"></a><span data-ttu-id="3186f-775">참조</span><span class="sxs-lookup"><span data-stu-id="3186f-775">References</span></span>
* [<span data-ttu-id="3186f-776">http://cassandra.apache.org</span><span class="sxs-lookup"><span data-stu-id="3186f-776">http://cassandra.apache.org</span></span>](http://cassandra.apache.org)
* [<span data-ttu-id="3186f-777">http://www.datastax.com</span><span class="sxs-lookup"><span data-stu-id="3186f-777">http://www.datastax.com</span></span>](http://www.datastax.com)
* [<span data-ttu-id="3186f-778">http://www.nodejs.org</span><span class="sxs-lookup"><span data-stu-id="3186f-778">http://www.nodejs.org</span></span>](http://www.nodejs.org)

